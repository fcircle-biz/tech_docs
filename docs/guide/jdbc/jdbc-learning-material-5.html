<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JDBC初心者向け学習教材 - 第5章：高度なJDBC機能</title>
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        .navbar {
            background-color: #1565c0;
        }
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        .chapter-title {
            color: #1565c0;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #1565c0;
            padding-bottom: 0.5rem;
        }
        .section-title {
            color: #1976d2;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        code {
            display: block;
            background-color: #f5f5f5;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            white-space: pre;
            overflow-x: auto;
        }
        .quiz-container {
            background-color: #e3f2fd;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }
        .quiz-question {
            font-weight: 500;
            margin-bottom: 1rem;
        }
        .diagram {
            max-width: 100%;
            height: auto;
            margin: 1.5rem 0;
            text-align: center;
        }
        .exercise {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        .note {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        #table-of-contents .list-group-item {
            border: none;
            padding: 0.5rem 1rem;
        }
        #table-of-contents .list-group-item-action {
            color: #1976d2;
        }
        /* 選択された目次項目のスタイル */
        #table-of-contents .list-group-item-action.active,
        .list-group-item.active {
            color: white !important; /* テキストを白色にして青い背景に対してコントラストをつける */
            background-color: #1976d2;
            border-color: #1976d2;
        }
        .section-nav {
            padding-left: 1rem;
        }
        .inline-code {
            background-color: #f5f5f5;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            display: inline;
        }
        footer {
            background-color: #1565c0;
            color: white;
            padding: 1rem 0;
            margin-top: 3rem;
        }
        .table-example {
            width: 100%;
            margin-bottom: 1rem;
            border-collapse: collapse;
        }
        .table-example th {
            background-color: #e3f2fd;
            border: 1px solid #b3e5fc;
            padding: 0.5rem;
            text-align: center;
        }
        .table-example td {
            border: 1px solid #b3e5fc;
            padding: 0.5rem;
            text-align: center;
        }
        .example-result {
            background-color: #f1f8e9;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
        }
        .warning {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 1rem;
            margin: 1.5rem 0;
        }
    </style>
</head>
<body data-bs-spy="scroll" data-bs-target="#tableOfContents">
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="#">JDBC初心者向け学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="#introduction">はじめに</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#chapter5">第5章: 高度なJDBC機能</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container my-4">
        <div class="row">
            <!-- Sidebar - Table of Contents -->
            <div class="col-lg-3">
                <div class="sidebar">
                    <div class="card">
                        <div class="card-header bg-primary text-white">
                            <h5 class="mb-0">目次</h5>
                        </div>
                        <div id="table-of-contents" class="list-group list-group-flush">
                            <a href="#introduction" class="list-group-item list-group-item-action">はじめに</a>
                            <a href="#chapter5" class="list-group-item list-group-item-action">第5章: 高度なJDBC機能</a>
                            <div class="section-nav">
                                <a href="#batch-processing" class="list-group-item list-group-item-action">5.1 バッチ処理によるパフォーマンス最適化</a>
                                <a href="#transaction-management" class="list-group-item list-group-item-action">5.2 トランザクション管理（commit, rollback）</a>
                                <a href="#stored-procedures" class="list-group-item list-group-item-action">5.3 ストアドプロシージャとファンクションの呼び出し</a>
                                <a href="#practical-exercise" class="list-group-item list-group-item-action">5.4 在庫管理システムのトランザクション処理（実習）</a>
                                <a href="#chapter5-quiz" class="list-group-item list-group-item-action">5.5 理解度確認テスト</a>
                            </div>
                            <a href="#next-steps" class="list-group-item list-group-item-action">次のステップ</a>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Main Content -->
            <div class="col-lg-9">
                <section id="introduction">
                    <h1 class="display-5 mb-4">JDBC初心者向け学習教材</h1>
                    <p class="lead">この第5章では、JDBCの高度な機能について学習します。バッチ処理、トランザクション管理、ストアドプロシージャの呼び出しなど、実践的なアプリケーション開発に不可欠な機能を理解し、在庫管理システムを例にトランザクション処理の実装を行います。</p>

                    <div class="note">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>バッチ処理によるデータベース操作の効率化</li>
                            <li>トランザクション管理の基本と実装方法</li>
                            <li>PostgreSQLのストアドプロシージャとファンクションの使用方法</li>
                            <li>在庫管理システムを例にしたトランザクション処理の実装</li>
                            <li>JDBCを用いた実践的なデータベースアプリケーション開発のベストプラクティス</li>
                        </ul>
                    </div>
                </section>

                <section id="chapter5">
                    <h2 class="chapter-title">第5章：高度なJDBC機能</h2>
                    <p>これまでの章では、JDBCの基本的な使い方と基本的なデータベース操作について学んできました。この章では、より高度なJDBC機能について学習し、実際のアプリケーション開発で直面する様々な要件に対応する方法を習得します。</p>

                    <section id="batch-processing">
                        <h3 class="section-title">5.1 バッチ処理によるパフォーマンス最適化</h3>
                        <p>大量のデータを挿入、更新、または削除する場合、一つずつSQL文を実行すると、パフォーマンスが低下します。JDBCのバッチ処理機能を使用することで、複数のSQL文をグループ化して一括実行し、データベースとの通信回数を削減してパフォーマンスを向上させることができます。</p>

                        <h4>バッチ処理の基本概念</h4>
                        <p>バッチ処理では、以下のようなステップで操作を行います：</p>
                        <ol>
                            <li>複数のSQL文をバッチに追加（<code>addBatch()</code>メソッド）</li>
                            <li>バッチをデータベースに一括実行（<code>executeBatch()</code>メソッド）</li>
                            <li>結果を受け取る（各文の更新件数の配列）</li>
                        </ol>

                        <h4>Statement を使用したバッチ処理</h4>
                        <p>複数の異なるSQL文をバッチ処理する場合は、<code>Statement</code>オブジェクトを使用します：</p>

                        <code>// Statementを使用したバッチ処理の例
import java.sql.*;

public class StatementBatchExample {
    public static void main(String[] args) {
        String url = "jdbc:postgresql://localhost:5432/testdb";
        String user = "postgres";
        String password = "password";
        
        try (Connection conn = DriverManager.getConnection(url, user, password);
             Statement stmt = conn.createStatement()) {
            
            // 自動コミットをオフにする（バッチ処理ではトランザクション管理が重要）
            conn.setAutoCommit(false);
            
            // バッチにSQL文を追加
            stmt.addBatch("INSERT INTO products (name, price) VALUES ('ノートPC', 98000)");
            stmt.addBatch("INSERT INTO products (name, price) VALUES ('タブレット', 45000)");
            stmt.addBatch("UPDATE categories SET category_name = 'デジタル機器' WHERE id = 1");
            stmt.addBatch("DELETE FROM discontinued_products WHERE last_sold < '2024-01-01'");
            
            // バッチを実行して結果を取得
            int[] updateCounts = stmt.executeBatch();
            
            // 変更をコミット
            conn.commit();
            
            // 結果の表示
            System.out.println("バッチ処理の結果:");
            for (int i = 0; i < updateCounts.length; i++) {
                System.out.println("クエリ " + (i + 1) + ": " + updateCounts[i] + "行が更新されました");
            }
            
        } catch (BatchUpdateException e) {
            System.err.println("バッチ処理中にエラーが発生しました: " + e.getMessage());
            int[] counts = e.getUpdateCounts();
            System.err.println("成功したアップデート数: " + counts.length);
            // ここでロールバック処理を行う
        } catch (SQLException e) {
            System.err.println("データベースエラー: " + e.getMessage());
        }
    }
}</code>

                        <h4>PreparedStatement を使用したバッチ処理</h4>
                        <p>同じSQL文で異なるパラメータ値を使用する場合は、<code>PreparedStatement</code>を使用したバッチ処理が効率的です：</p>

                        <code>// PreparedStatementを使用したバッチ処理の例
import java.sql.*;

public class PreparedStatementBatchExample {
    public static void main(String[] args) {
        String url = "jdbc:postgresql://localhost:5432/testdb";
        String user = "postgres";
        String password = "password";
        
        try (Connection conn = DriverManager.getConnection(url, user, password)) {
            // 自動コミットをオフにする
            conn.setAutoCommit(false);
            
            // 大量のユーザーデータを挿入するPreparedStatement
            String sql = "INSERT INTO users (name, email, age) VALUES (?, ?, ?)";
            
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                // 複数のレコードをバッチに追加
                // ユーザー1
                pstmt.setString(1, "山本雄太");
                pstmt.setString(2, "yamamoto@example.com");
                pstmt.setInt(3, 28);
                pstmt.addBatch();
                
                // ユーザー2
                pstmt.setString(1, "佐々木美咲");
                pstmt.setString(2, "sasaki@example.com");
                pstmt.setInt(3, 32);
                pstmt.addBatch();
                
                // ユーザー3
                pstmt.setString(1, "中村健太");
                pstmt.setString(2, "nakamura@example.com");
                pstmt.setInt(3, 45);
                pstmt.addBatch();
                
                // バッチを実行
                int[] updateCounts = pstmt.executeBatch();
                
                // 変更をコミット
                conn.commit();
                
                // 結果の表示
                System.out.println("バッチ処理の結果:");
                int totalUpdates = 0;
                for (int count : updateCounts) {
                    totalUpdates += count;
                }
                System.out.println("合計 " + totalUpdates + " 件のレコードが挿入されました");
            }
            
        } catch (BatchUpdateException e) {
            System.err.println("バッチ処理中にエラーが発生しました: " + e.getMessage());
            // ロールバックの処理
        } catch (SQLException e) {
            System.err.println("データベースエラー: " + e.getMessage());
        }
    }
}</code>

                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 300" width="600" height="300">
                                <!-- 通常の処理 -->
                                <rect x="50" y="20" width="500" height="100" fill="#f5f5f5" stroke="#9e9e9e" stroke-width="2" rx="5" />
                                <text x="300" y="45" text-anchor="middle" font-size="16" font-weight="bold">通常の処理（一つずつ実行）</text>
                                
                                <rect x="80" y="60" width="90" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="3" />
                                <text x="125" y="85" text-anchor="middle" font-size="14">SQL文1</text>
                                
                                <rect x="200" y="60" width="90" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="3" />
                                <text x="245" y="85" text-anchor="middle" font-size="14">SQL文2</text>
                                
                                <rect x="320" y="60" width="90" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="3" />
                                <text x="365" y="85" text-anchor="middle" font-size="14">SQL文3</text>
                                
                                <rect x="440" y="60" width="90" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="3" />
                                <text x="485" y="85" text-anchor="middle" font-size="14">SQL文4</text>
                                
                                <!-- 各文と実行の矢印 -->
                                <line x1="125" y1="100" x2="125" y2="140" stroke="#d32f2f" stroke-width="2" stroke-dasharray="5,5" marker-end="url(#arrow)" />
                                <line x1="245" y1="100" x2="245" y2="140" stroke="#d32f2f" stroke-width="2" stroke-dasharray="5,5" marker-end="url(#arrow)" />
                                <line x1="365" y1="100" x2="365" y2="140" stroke="#d32f2f" stroke-width="2" stroke-dasharray="5,5" marker-end="url(#arrow)" />
                                <line x1="485" y1="100" x2="485" y2="140" stroke="#d32f2f" stroke-width="2" stroke-dasharray="5,5" marker-end="url(#arrow)" />
                                
                                <!-- バッチ処理 -->
                                <rect x="50" y="160" width="500" height="120" fill="#f5f5f5" stroke="#9e9e9e" stroke-width="2" rx="5" />
                                <text x="300" y="185" text-anchor="middle" font-size="16" font-weight="bold">バッチ処理（まとめて実行）</text>
                                
                                <rect x="80" y="200" width="350" height="60" fill="#c8e6c9" stroke="#388e3c" stroke-width="1" rx="3" />
                                <text x="255" y="225" text-anchor="middle" font-size="14">バッチ（複数のSQL文をグループ化）</text>
                                
                                <rect x="100" y="215" width="70" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="3" />
                                <text x="135" y="235" text-anchor="middle" font-size="12">SQL文1</text>
                                
                                <rect x="180" y="215" width="70" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="3" />
                                <text x="215" y="235" text-anchor="middle" font-size="12">SQL文2</text>
                                
                                <rect x="260" y="215" width="70" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="3" />
                                <text x="295" y="235" text-anchor="middle" font-size="12">SQL文3</text>
                                
                                <rect x="340" y="215" width="70" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="3" />
                                <text x="375" y="235" text-anchor="middle" font-size="12">SQL文4</text>
                                
                                <!-- バッチと実行の矢印 -->
                                <line x1="255" y1="260" x2="255" y2="290" stroke="#388e3c" stroke-width="3" marker-end="url(#arrow)" />
                                
                                <!-- データベース -->
                                <rect x="200" y="140" width="200" height="20" fill="#ffecb3" stroke="#ffa000" stroke-width="2" rx="3" />
                                <text x="300" y="155" text-anchor="middle" font-size="14">データベース</text>
                                
                                <rect x="200" y="290" width="200" height="20" fill="#ffecb3" stroke="#ffa000" stroke-width="2" rx="3" />
                                <text x="300" y="305" text-anchor="middle" font-size="14">データベース</text>
                                
                                <defs>
                                    <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                        <path d="M0,0 L0,6 L9,3 z" fill="#000" />
                                    </marker>
                                </defs>
                            </svg>
                            <p class="text-center">図5.1: 通常の処理とバッチ処理の比較</p>
                        </div>

                        <h4>バッチ処理のパフォーマンス比較</h4>
                        <p>バッチ処理のパフォーマンス向上を確認するための例を見てみましょう：</p>

                        <code>// バッチ処理とシングル実行のパフォーマンス比較
import java.sql.*;

public class BatchPerformanceComparison {
    private static final int RECORD_COUNT = 10000;
    private static final String URL = "jdbc:postgresql://localhost:5432/testdb";
    private static final String USER = "postgres";
    private static final String PASSWORD = "password";
    
    public static void main(String[] args) throws SQLException {
        // テストテーブルを作成
        createTable();
        
        // 通常の処理（1つずつSQL実行）
        long startTime = System.currentTimeMillis();
        insertOneByOne();
        long endTime = System.currentTimeMillis();
        System.out.println("通常処理の実行時間: " + (endTime - startTime) + "ms");
        
        // テーブルをクリア
        clearTable();
        
        // バッチ処理
        startTime = System.currentTimeMillis();
        insertWithBatch();
        endTime = System.currentTimeMillis();
        System.out.println("バッチ処理の実行時間: " + (endTime - startTime) + "ms");
    }
    
    private static void createTable() throws SQLException {
        try (Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);
             Statement stmt = conn.createStatement()) {
            // 既存のテーブルを削除（存在する場合）
            stmt.execute("DROP TABLE IF EXISTS batch_test");
            // 新しいテーブルを作成
            stmt.execute("CREATE TABLE batch_test (id SERIAL PRIMARY KEY, name VARCHAR(100), value INT)");
        }
    }
    
    private static void clearTable() throws SQLException {
        try (Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);
             Statement stmt = conn.createStatement()) {
            stmt.execute("DELETE FROM batch_test");
        }
    }
    
    private static void insertOneByOne() throws SQLException {
        try (Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);
             PreparedStatement pstmt = conn.prepareStatement(
                "INSERT INTO batch_test (name, value) VALUES (?, ?)")) {
            
            for (int i = 0; i < RECORD_COUNT; i++) {
                pstmt.setString(1, "名前" + i);
                pstmt.setInt(2, i);
                pstmt.executeUpdate();
            }
        }
    }
    
    private static void insertWithBatch() throws SQLException {
        try (Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);
             PreparedStatement pstmt = conn.prepareStatement(
                "INSERT INTO batch_test (name, value) VALUES (?, ?)")) {
            
            conn.setAutoCommit(false);
            
            for (int i = 0; i < RECORD_COUNT; i++) {
                pstmt.setString(1, "名前" + i);
                pstmt.setInt(2, i);
                pstmt.addBatch();
                
                // バッチサイズを制限（メモリ使用量を抑制）
                if (i % 1000 == 0) {
                    pstmt.executeBatch();
                }
            }
            
            // 残りのバッチを実行
            pstmt.executeBatch();
            
            // コミット
            conn.commit();
        }
    }
}</code>

                        <div class="example-result">
                            <pre>通常処理の実行時間: 9524ms
バッチ処理の実行時間: 785ms</pre>
                        </div>

                        <div class="note">
                            <h5>バッチ処理のベストプラクティス</h5>
                            <ul>
                                <li><strong>適切なバッチサイズを選択する</strong>：バッチサイズが大きすぎるとメモリ使用量が増加し、小さすぎるとパフォーマンス向上が限定的になります。一般的には1,000〜10,000の範囲が推奨されます。</li>
                                <li><strong>トランザクション管理を併用する</strong>：バッチ処理とトランザクション管理を組み合わせることで、エラーが発生した場合にも一貫性を保つことができます。</li>
                                <li><strong>例外処理を適切に行う</strong>：<code>BatchUpdateException</code>を捕捉し、部分的に成功した更新情報を取得して適切に対応します。</li>
                                <li><strong>リターンジェネレーテッドキーに注意</strong>：バッチ挿入で生成されたキーを取得する場合は、データベースとJDBCドライバの対応状況を確認してください。</li>
                            </ul>
                        </div>

                        <div class="exercise">
                            <h5>練習問題 5.1.1: バッチ処理の実装</h5>
                            <p>次の要件を満たすJavaプログラムを作成してください：</p>
                            <ol>
                                <li>products_batchというテーブルを作成する（id, name, price, stock_quantity）</li>
                                <li>PreparedStatementとバッチ処理を使用して、100件の製品データを一括挿入する</li>
                                <li>各製品の名前は「製品XX」、価格は1000〜10000のランダムな値、在庫数は10〜100のランダムな値とする</li>
                                <li>挿入後、「価格が5000円以上の製品の平均価格」と「在庫数が50以下の製品数」を表示する</li>
                            </ol>
                        </div>
                    </section>

                    <section id="transaction-management">
                        <h3 class="section-title">5.2 トランザクション管理（commit, rollback）</h3>
                        <p>トランザクションは、一連のデータベース操作を単一の論理的な作業単位としてまとめるものです。トランザクションは、ACID特性（原子性、一貫性、独立性、耐久性）を保証し、データの整合性を維持するために重要な役割を果たします。</p>

                        <h4>トランザクションの基本概念</h4>
                        <p>トランザクションの基本的な操作は以下の通りです：</p>
                        <ul>
                            <li><strong>トランザクション開始</strong>：自動コミットモードをオフにする（<code>setAutoCommit(false)</code>）</li>
                            <li><strong>コミット</strong>：トランザクション内のすべての変更を確定する（<code>commit()</code>）</li>
                            <li><strong>ロールバック</strong>：トランザクション内のすべての変更を取り消す（<code>rollback()</code>）</li>
                            <li><strong>セーブポイント</strong>：トランザクション内の特定のポイントを設定し、そこまで部分的にロールバックできるようにする（<code>setSavepoint()</code>）</li>
                        </ul>

                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 250" width="600" height="250">
                                <!-- トランザクションの図 -->
                                <rect x="75" y="20" width="450" height="200" fill="#f5f5f5" stroke="#9e9e9e" stroke-width="2" rx="5" />
                                <text x="300" y="45" text-anchor="middle" font-size="16" font-weight="bold">トランザクション</text>
                                
                                <!-- トランザクション開始 -->
                                <rect x="100" y="60" width="150" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="1" rx="3" />
                                <text x="175" y="85" text-anchor="middle" font-size="14">setAutoCommit(false)</text>
                                
                                <!-- 操作1 -->
                                <rect x="100" y="110" width="150" height="40" fill="#c8e6c9" stroke="#388e3c" stroke-width="1" rx="3" />
                                <text x="175" y="135" text-anchor="middle" font-size="14">操作1: INSERT文</text>
                                
                                <!-- 操作2 -->
                                <rect x="100" y="160" width="150" height="40" fill="#c8e6c9" stroke="#388e3c" stroke-width="1" rx="3" />
                                <text x="175" y="185" text-anchor="middle" font-size="14">操作2: UPDATE文</text>
                                
                                <!-- 成功パス -->
                                <rect x="350" y="110" width="150" height="40" fill="#a5d6a7" stroke="#388e3c" stroke-width="2" rx="3" />
                                <text x="425" y="135" text-anchor="middle" font-size="14">commit()</text>
                                
                                <!-- 失敗パス -->
                                <rect x="350" y="160" width="150" height="40" fill="#ef9a9a" stroke="#d32f2f" stroke-width="2" rx="3" />
                                <text x="425" y="185" text-anchor="middle" font-size="14">rollback()</text>
                                
                                <!-- 矢印 -->
                                <line x1="250" y1="130" x2="350" y2="130" stroke="#388e3c" stroke-width="2" marker-end="url(#arrow)" />
                                <text x="300" y="120" text-anchor="middle" font-size="14">成功</text>
                                
                                <line x1="250" y1="180" x2="350" y2="180" stroke="#d32f2f" stroke-width="2" marker-end="url(#arrow)" />
                                <text x="300" y="170" text-anchor="middle" font-size="14">エラー発生</text>
                                
                                <defs>
                                    <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                        <path d="M0,0 L0,6 L9,3 z" fill="#000" />
                                    </marker>
                                </defs>
                            </svg>
                            <p class="text-center">図5.2: トランザクション処理の基本フロー</p>
                        </div>

                        <h4>基本的なトランザクション管理</h4>
                        <p>以下に、銀行口座間の送金処理を例にしたトランザクション管理の例を示します：</p>

                        <code>// 基本的なトランザクション管理の例
import java.sql.*;

public class TransactionExample {
    public static void main(String[] args) {
        String url = "jdbc:postgresql://localhost:5432/bankdb";
        String user = "postgres";
        String password = "password";
        
        // 送金情報
        int fromAccountId = 101;
        int toAccountId = 202;
        double transferAmount = 5000.0;
        
        Connection conn = null;
        
        try {
            // データベース接続
            conn = DriverManager.getConnection(url, user, password);
            
            // 自動コミットモードをオフにしてトランザクション開始
            conn.setAutoCommit(false);
            
            // 1. 送金元口座から金額を引き出す
            String debitSql = "UPDATE accounts SET balance = balance - ? WHERE account_id = ? AND balance >= ?";
            try (PreparedStatement pstmt = conn.prepareStatement(debitSql)) {
                pstmt.setDouble(1, transferAmount);
                pstmt.setInt(2, fromAccountId);
                pstmt.setDouble(3, transferAmount); // 残高が不足していないか確認
                
                int rowsAffected = pstmt.executeUpdate();
                if (rowsAffected == 0) {
                    // 残高不足または口座が見つからない場合
                    throw new SQLException("送金元口座の残高が不足しているか、口座が見つかりません");
                }
            }
            
            // 2. 送金先口座に金額を入金する
            String creditSql = "UPDATE accounts SET balance = balance + ? WHERE account_id = ?";
            try (PreparedStatement pstmt = conn.prepareStatement(creditSql)) {
                pstmt.setDouble(1, transferAmount);
                pstmt.setInt(2, toAccountId);
                
                int rowsAffected = pstmt.executeUpdate();
                if (rowsAffected == 0) {
                    // 送金先口座が見つからない場合
                    throw new SQLException("送金先口座が見つかりません");
                }
            }
            
            // 3. 取引履歴に記録
            String logSql = "INSERT INTO transaction_history (from_account, to_account, amount, transaction_date) VALUES (?, ?, ?, CURRENT_TIMESTAMP)";
            try (PreparedStatement pstmt = conn.prepareStatement(logSql)) {
                pstmt.setInt(1, fromAccountId);
                pstmt.setInt(2, toAccountId);
                pstmt.setDouble(3, transferAmount);
                pstmt.executeUpdate();
            }
            
            // すべての操作が成功したらコミット
            conn.commit();
            System.out.println("送金処理が正常に完了しました。金額: " + transferAmount);
            
        } catch (SQLException e) {
            // エラーが発生した場合はロールバック
            System.err.println("エラーが発生しました: " + e.getMessage());
            
            if (conn != null) {
                try {
                    conn.rollback();
                    System.err.println("トランザクションをロールバックしました");
                } catch (SQLException ex) {
                    System.err.println("ロールバック中にエラーが発生しました: " + ex.getMessage());
                }
            }
        } finally {
            // 接続をクローズ（自動コミットモードを元に戻す）
            if (conn != null) {
                try {
                    conn.setAutoCommit(true);
                    conn.close();
                } catch (SQLException e) {
                    System.err.println("接続クローズ中にエラーが発生しました: " + e.getMessage());
                }
            }
        }
    }
}</code>

                        <h4>セーブポイントを使用したトランザクション管理</h4>
                        <p>セーブポイントを使用すると、トランザクション内の特定のポイントまで部分的にロールバックすることができます：</p>

                        <code>// セーブポイントを使用したトランザクション管理の例
import java.sql.*;

public class SavepointExample {
    public static void main(String[] args) {
        String url = "jdbc:postgresql://localhost:5432/inventorydb";
        String user = "postgres";
        String password = "password";
        
        Connection conn = null;
        Savepoint stockUpdateSavepoint = null;
        
        try {
            // データベース接続
            conn = DriverManager.getConnection(url, user, password);
            
            // 自動コミットモードをオフにしてトランザクション開始
            conn.setAutoCommit(false);
            
            // 1. 新しい注文レコードを作成
            String orderSql = "INSERT INTO orders (customer_id, order_date, total_amount) VALUES (?, CURRENT_DATE, ?) RETURNING order_id";
            int orderId;
            double totalAmount = 12500.0;
            
            try (PreparedStatement pstmt = conn.prepareStatement(orderSql)) {
                pstmt.setInt(1, 1001);  // 顧客ID
                pstmt.setDouble(2, totalAmount);
                ResultSet rs = pstmt.executeQuery();
                
                if (rs.next()) {
                    orderId = rs.getInt("order_id");
                    System.out.println("新しい注文ID: " + orderId);
                } else {
                    throw new SQLException("注文IDの取得に失敗しました");
                }
            }
            
            // ここでセーブポイントを設定（注文作成後、在庫更新前）
            stockUpdateSavepoint = conn.setSavepoint("STOCK_UPDATE");
            
            // 2. 注文明細アイテムを追加し、在庫を更新
            String[] orderItems = {"在庫更新成功アイテム", "在庫不足アイテム"};
            int[] productIds = {101, 102};
            int[] quantities = {5, 3};
            double[] prices = {1500.0, 2500.0};
            
            for (int i = 0; i < orderItems.length; i++) {
                // 注文明細を追加
                String itemSql = "INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (?, ?, ?, ?)";
                try (PreparedStatement pstmt = conn.prepareStatement(itemSql)) {
                    pstmt.setInt(1, orderId);
                    pstmt.setInt(2, productIds[i]);
                    pstmt.setInt(3, quantities[i]);
                    pstmt.setDouble(4, prices[i]);
                    pstmt.executeUpdate();
                }
                
                // 在庫数を更新
                String stockSql = "UPDATE products SET stock_quantity = stock_quantity - ? WHERE product_id = ? AND stock_quantity >= ?";
                try (PreparedStatement pstmt = conn.prepareStatement(stockSql)) {
                    pstmt.setInt(1, quantities[i]);
                    pstmt.setInt(2, productIds[i]);
                    pstmt.setInt(3, quantities[i]);
                    
                    int rowsAffected = pstmt.executeUpdate();
                    if (rowsAffected == 0) {
                        throw new SQLException("製品ID " + productIds[i] + " の在庫が不足しています");
                    }
                }
                
                System.out.println("製品ID " + productIds[i] + " の在庫を更新しました");
            }
            
            // すべての操作が成功したらコミット
            conn.commit();
            System.out.println("注文処理が正常に完了しました");
            
        } catch (SQLException e) {
            System.err.println("エラーが発生しました: " + e.getMessage());
            
            if (conn != null) {
                try {
                    if (stockUpdateSavepoint != null) {
                        // 在庫更新のセーブポイントまでロールバック（注文自体は保持）
                        conn.rollback(stockUpdateSavepoint);
                        System.err.println("在庫更新をロールバックしました（注文は保持）");
                        
                        // 注文ステータスを「在庫待ち」などに更新できる
                        String updateSql = "UPDATE orders SET status = 'PENDING_STOCK' WHERE order_id = ?";
                        try (PreparedStatement pstmt = conn.prepareStatement(updateSql)) {
                            // orderId変数がスコープ内にない可能性があるため、実際のコードでは適切に処理する必要がある
                            // pstmt.setInt(1, orderId);
                            // pstmt.executeUpdate();
                        }
                        
                        // 部分的な変更をコミット
                        conn.commit();
                    } else {
                        // 完全にロールバック
                        conn.rollback();
                        System.err.println("トランザクション全体をロールバックしました");
                    }
                } catch (SQLException ex) {
                    System.err.println("ロールバック中にエラーが発生しました: " + ex.getMessage());
                }
            }
        } finally {
            // 接続をクローズ（自動コミットモードを元に戻す）
            if (conn != null) {
                try {
                    conn.setAutoCommit(true);
                    conn.close();
                } catch (SQLException e) {
                    System.err.println("接続クローズ中にエラーが発生しました: " + e.getMessage());
                }
            }
        }
    }
}</code>

                        <h4>トランザクション分離レベル</h4>
                        <p>JDBCでは、トランザクションの分離レベルを設定することができます。分離レベルによって、同時に実行される複数のトランザクション間での相互作用のルールが定義されます：</p>

                        <div class="table-responsive">
                            <table class="table-example">
                                <tr>
                                    <th>分離レベル</th>
                                    <th>定数</th>
                                    <th>ダーティリード</th>
                                    <th>ノンリピータブルリード</th>
                                    <th>ファントムリード</th>
                                    <th>説明</th>
                                </tr>
                                <tr>
                                    <td>READ UNCOMMITTED</td>
                                    <td>Connection.TRANSACTION_READ_UNCOMMITTED</td>
                                    <td>可能</td>
                                    <td>可能</td>
                                    <td>可能</td>
                                    <td>コミットされていない変更も読み取り可能</td>
                                </tr>
                                <tr>
                                    <td>READ COMMITTED</td>
                                    <td>Connection.TRANSACTION_READ_COMMITTED</td>
                                    <td>防止</td>
                                    <td>可能</td>
                                    <td>可能</td>
                                    <td>コミットされた変更のみ読み取り可能</td>
                                </tr>
                                <tr>
                                    <td>REPEATABLE READ</td>
                                    <td>Connection.TRANSACTION_REPEATABLE_READ</td>
                                    <td>防止</td>
                                    <td>防止</td>
                                    <td>可能</td>
                                    <td>同じクエリを再実行しても同じ結果を保証</td>
                                </tr>
                                <tr>
                                    <td>SERIALIZABLE</td>
                                    <td>Connection.TRANSACTION_SERIALIZABLE</td>
                                    <td>防止</td>
                                    <td>防止</td>
                                    <td>防止</td>
                                    <td>トランザクションを完全に分離</td>
                                </tr>
                            </table>
                        </div>

                        <p>分離レベルの設定例：</p>

                        <code>// トランザクション分離レベルの設定例
Connection conn = DriverManager.getConnection(url, user, password);

// 現在の分離レベルを確認
int currentLevel = conn.getTransactionIsolation();
System.out.println("現在の分離レベル: " + getIsolationLevelName(currentLevel));

// 分離レベルを変更
conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
System.out.println("変更後の分離レベル: " + getIsolationLevelName(conn.getTransactionIsolation()));

// ...トランザクション処理...

// 分離レベル名を取得するヘルパーメソッド
private static String getIsolationLevelName(int level) {
    switch (level) {
        case Connection.TRANSACTION_NONE:
            return "TRANSACTION_NONE";
        case Connection.TRANSACTION_READ_UNCOMMITTED:
            return "READ_UNCOMMITTED";
        case Connection.TRANSACTION_READ_COMMITTED:
            return "READ_COMMITTED";
        case Connection.TRANSACTION_REPEATABLE_READ:
            return "REPEATABLE_READ";
        case Connection.TRANSACTION_SERIALIZABLE:
            return "SERIALIZABLE";
        default:
            return "UNKNOWN";
    }
}</code>

                        <div class="note">
                            <h5>トランザクション管理のベストプラクティス</h5>
                            <ul>
                                <li><strong>トランザクションの範囲を適切に設定する</strong>：トランザクションは必要な操作のみを含め、できるだけ短時間で完了するようにします。</li>
                                <li><strong>try-with-resourcesを使用する</strong>：Java 7以降では、try-with-resourcesを使用してリソースを自動的にクローズし、接続管理をシンプルにします。</li>
                                <li><strong>適切な分離レベルを選択する</strong>：アプリケーションの要件に基づいて適切な分離レベルを選択します。高い分離レベルはデータの一貫性を向上させますが、パフォーマンスが低下する可能性があります。</li>
                                <li><strong>例外処理を正確に行う</strong>：トランザクション中にエラーが発生した場合は、適切にロールバックし、例外情報をログに記録します。</li>
                                <li><strong>デッドロックを回避する</strong>：複数のトランザクションが同じリソースにアクセスする場合は、一貫した順序でロックを取得するようにします。</li>
                            </ul>
                        </div>

                        <div class="exercise">
                            <h5>練習問題 5.2.1: トランザクション管理の実装</h5>
                            <p>以下のシナリオに基づいて、トランザクション管理を使用したプログラムを実装してください：</p>
                            <ol>
                                <li>次のテーブルを持つデータベースを作成します：
                                    <ul>
                                        <li>products（id, name, price, stock）</li>
                                        <li>customer_orders（id, customer_name, order_date, total_amount）</li>
                                        <li>order_items（id, order_id, product_id, quantity, price）</li>
                                    </ul>
                                </li>
                                <li>顧客の注文を処理するプログラムを作成します：
                                    <ul>
                                        <li>顧客情報と注文商品（商品ID、数量）のリストを受け取る</li>
                                        <li>トランザクション内で以下の処理を行う：
                                            <ol>
                                                <li>顧客の注文レコードを作成する</li>
                                                <li>各注文商品の明細を作成する</li>
                                                <li>各商品の在庫を減らす（在庫が不足している場合はエラー）</li>
                                            </ol>
                                        </li>
                                        <li>すべての処理が成功した場合のみコミットし、エラーが発生した場合はロールバックする</li>
                                    </ul>
                                </li>
                                <li>セーブポイントを使用して、一部の商品が在庫不足の場合でも、利用可能な商品については注文を確定できるように拡張する</li>
                            </ol>
                        </div>
                    </section>

                    <section id="stored-procedures">
                        <h3 class="section-title">5.3 ストアドプロシージャとファンクションの呼び出し</h3>
                        <p>ストアドプロシージャとファンクションは、データベースサーバー上に保存された再利用可能なSQL文のセットです。これらをJDBCから呼び出すことで、複雑なデータベース操作をカプセル化し、パフォーマンスを向上させることができます。</p>

                        <h4>PostgreSQLにおけるストアドプロシージャとファンクション</h4>
                        <p>PostgreSQLでは、ストアドプロシージャとファンクションは主にPL/pgSQLという手続き型言語で記述されます。基本的な違いは以下の通りです：</p>
                        <ul>
                            <li><strong>ファンクション（関数）</strong>：値を返すことができ、SQLクエリの一部として使用可能</li>
                            <li><strong>ストアドプロシージャ</strong>：PostgreSQL 11以降で導入された機能で、戻り値を持たず、トランザクション制御を含むことができる</li>
                        </ul>

                        <p>PostgreSQLでのストアドプロシージャとファンクションの作成例：</p>

                        <code>-- ファンクション（関数）の作成例
CREATE OR REPLACE FUNCTION calculate_order_total(p_order_id INTEGER)
RETURNS NUMERIC AS $$
DECLARE
    v_total NUMERIC;
BEGIN
    SELECT SUM(quantity * price)
    INTO v_total
    FROM order_items
    WHERE order_id = p_order_id;
    
    RETURN COALESCE(v_total, 0);
END;
$$ LANGUAGE plpgsql;

-- ストアドプロシージャの作成例（PostgreSQL 11以降）
CREATE OR REPLACE PROCEDURE process_order(
    p_customer_id INTEGER,
    p_product_id INTEGER,
    p_quantity INTEGER
)
AS $$
DECLARE
    v_product_price NUMERIC;
    v_current_stock INTEGER;
    v_order_id INTEGER;
BEGIN
    -- 商品の価格と在庫を取得
    SELECT price, stock INTO v_product_price, v_current_stock
    FROM products
    WHERE id = p_product_id;
    
    -- 在庫チェック
    IF v_current_stock < p_quantity THEN
        RAISE EXCEPTION '在庫不足です（利用可能: %, 要求: %）', v_current_stock, p_quantity;
    END IF;
    
    -- 注文作成
    INSERT INTO customer_orders (customer_id, order_date, total_amount)
    VALUES (p_customer_id, CURRENT_DATE, v_product_price * p_quantity)
    RETURNING id INTO v_order_id;
    
    -- 注文明細作成
    INSERT INTO order_items (order_id, product_id, quantity, price)
    VALUES (v_order_id, p_product_id, p_quantity, v_product_price);
    
    -- 在庫更新
    UPDATE products
    SET stock = stock - p_quantity
    WHERE id = p_product_id;
    
    COMMIT;
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
$$ LANGUAGE plpgsql;</code>

                        <h4>JDBCからのファンクション呼び出し</h4>
                        <p>PostgreSQLのファンクションは、通常のSQLクエリの一部として呼び出すことができます：</p>

                        <code>// ファンクションの呼び出し例
import java.sql.*;

public class FunctionCallExample {
    public static void main(String[] args) {
        String url = "jdbc:postgresql://localhost:5432/testdb";
        String user = "postgres";
        String password = "password";
        
        try (Connection conn = DriverManager.getConnection(url, user, password);
             PreparedStatement pstmt = conn.prepareStatement(
                "SELECT calculate_order_total(?)")) {
            
            int orderId = 1001;
            pstmt.setInt(1, orderId);
            
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    double total = rs.getDouble(1);
                    System.out.println("注文ID " + orderId + " の合計金額: " + total);
                }
            }
            
        } catch (SQLException e) {
            System.err.println("エラーが発生しました: " + e.getMessage());
        }
    }
}</code>

                        <h4>JDBCからのストアドプロシージャ呼び出し</h4>
                        <p>JDBCでは、<code>CallableStatement</code>を使用してストアドプロシージャを呼び出します：</p>

                        <code>// ストアドプロシージャの呼び出し例
import java.sql.*;

public class StoredProcedureCallExample {
    public static void main(String[] args) {
        String url = "jdbc:postgresql://localhost:5432/testdb";
        String user = "postgres";
        String password = "password";
        
        try (Connection conn = DriverManager.getConnection(url, user, password);
             CallableStatement cstmt = conn.prepareCall(
                "CALL process_order(?, ?, ?)")) {
            
            int customerId = 1001;
            int productId = 101;
            int quantity = 5;
            
            cstmt.setInt(1, customerId);
            cstmt.setInt(2, productId);
            cstmt.setInt(3, quantity);
            
            cstmt.execute();
            System.out.println("注文処理が正常に完了しました");
            
        } catch (SQLException e) {
            System.err.println("エラーが発生しました: " + e.getMessage());
        }
    }
}</code>

                        <h4>ファンクションの出力パラメータの処理</h4>
                        <p>複数の出力パラメータを持つファンクションを呼び出す例：</p>

                        <code>-- 複数の出力パラメータを持つファンクション
CREATE OR REPLACE FUNCTION get_product_info(
    p_product_id INTEGER,
    OUT p_name VARCHAR,
    OUT p_price NUMERIC,
    OUT p_stock INTEGER
)
AS $$
BEGIN
    SELECT name, price, stock
    INTO p_name, p_price, p_stock
    FROM products
    WHERE id = p_product_id;
END;
$$ LANGUAGE plpgsql;

-- JDBCからの呼び出し
import java.sql.*;

public class OutputParametersExample {
    public static void main(String[] args) {
        String url = "jdbc:postgresql://localhost:5432/testdb";
        String user = "postgres";
        String password = "password";
        
        try (Connection conn = DriverManager.getConnection(url, user, password);
             PreparedStatement pstmt = conn.prepareStatement(
                "SELECT * FROM get_product_info(?)")) {
            
            int productId = 101;
            pstmt.setInt(1, productId);
            
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    String name = rs.getString("p_name");
                    double price = rs.getDouble("p_price");
                    int stock = rs.getInt("p_stock");
                    
                    System.out.println("商品情報:");
                    System.out.println("名前: " + name);
                    System.out.println("価格: " + price);
                    System.out.println("在庫: " + stock);
                } else {
                    System.out.println("商品が見つかりません");
                }
            }
            
        } catch (SQLException e) {
            System.err.println("エラーが発生しました: " + e.getMessage());
        }
    }
}</code>

                        <h4>テーブル値を返すファンクションの処理</h4>
                        <p>テーブル値を返すファンクションも簡単に呼び出すことができます：</p>

                        <code>-- テーブル値を返すファンクション
CREATE OR REPLACE FUNCTION get_orders_by_customer(p_customer_id INTEGER)
RETURNS TABLE (
    order_id INTEGER,
    order_date DATE,
    total_amount NUMERIC,
    item_count INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        o.id,
        o.order_date,
        o.total_amount,
        COUNT(oi.id)::INTEGER AS item_count
    FROM
        customer_orders o
    JOIN
        order_items oi ON o.id = oi.order_id
    WHERE
        o.customer_id = p_customer_id
    GROUP BY
        o.id, o.order_date, o.total_amount;
END;
$$ LANGUAGE plpgsql;

-- JDBCからの呼び出し
import java.sql.*;

public class TableFunctionExample {
    public static void main(String[] args) {
        String url = "jdbc:postgresql://localhost:5432/testdb";
        String user = "postgres";
        String password = "password";
        
        try (Connection conn = DriverManager.getConnection(url, user, password);
             PreparedStatement pstmt = conn.prepareStatement(
                "SELECT * FROM get_orders_by_customer(?)")) {
            
            int customerId = 1001;
            pstmt.setInt(1, customerId);
            
            try (ResultSet rs = pstmt.executeQuery()) {
                System.out.println("顧客ID " + customerId + " の注文一覧:");
                
                boolean hasOrders = false;
                while (rs.next()) {
                    hasOrders = true;
                    int orderId = rs.getInt("order_id");
                    Date orderDate = rs.getDate("order_date");
                    double totalAmount = rs.getDouble("total_amount");
                    int itemCount = rs.getInt("item_count");
                    
                    System.out.printf("注文ID: %d, 日付: %s, 合計金額: %.2f, 商品数: %d%n",
                                     orderId, orderDate, totalAmount, itemCount);
                }
                
                if (!hasOrders) {
                    System.out.println("注文が見つかりません");
                }
            }
            
        } catch (SQLException e) {
            System.err.println("エラーが発生しました: " + e.getMessage());
        }
    }
}</code>

                        <div class="note">
                            <h5>ストアドプロシージャとファンクションの利点</h5>
                            <ul>
                                <li><strong>パフォーマンスの向上</strong>：ネットワーク通信が減少し、SQLの実行計画をキャッシュできる</li>
                                <li><strong>セキュリティの強化</strong>：テーブルへの直接アクセスを制限し、ストアドプロシージャを通じてのみデータにアクセスできるようにする</li>
                                <li><strong>コードの再利用</strong>：複雑なロジックをデータベース側でカプセル化し、複数のアプリケーションで再利用できる</li>
                                <li><strong>トランザクション管理の簡素化</strong>：複数のSQL操作をデータベース側で単一のトランザクションとして処理できる</li>
                                <li><strong>保守性の向上</strong>：データベースロジックの変更がクライアントアプリケーションに影響を与えない</li>
                            </ul>
                        </div>

                        <div class="warning">
                            <h5>ストアドプロシージャ使用時の注意点</h5>
                            <p>ストアドプロシージャとファンクションを使用する際には、以下の点に注意してください：</p>
                            <ul>
                                <li><strong>データベース依存性</strong>：ストアドプロシージャはデータベース固有の言語で書かれることが多く、データベース間の移植性が低下する可能性があります。</li>
                                <li><strong>デバッグの難しさ</strong>：データベース側のロジックは、クライアントアプリケーションと比較してデバッグが難しい場合があります。</li>
                                <li><strong>バージョン管理</strong>：ストアドプロシージャの変更管理とバージョン管理には、追加のツールが必要になることがあります。</li>
                                <li><strong>テストの複雑さ</strong>：データベースロジックのテストは、アプリケーションコードよりも複雑になる可能性があります。</li>
                            </ul>
                        </div>

                        <div class="exercise">
                            <h5>練習問題 5.3.1: ストアドプロシージャとファンクションの実装</h5>
                            <p>以下の要件に基づいて、PostgreSQLのストアドプロシージャとファンクションを作成し、JDBCから呼び出すプログラムを実装してください：</p>
                            <ol>
                                <li>次のファンクションを作成：
                                    <ul>
                                        <li>商品IDを受け取り、過去3か月間の当該商品の月次売上金額と販売数を月別に返すファンクション</li>
                                        <li>顧客IDを受け取り、その顧客の合計購入金額、平均注文金額、最終注文日を返すファンクション</li>
                                    </ul>
                                </li>
                                <li>次のストアドプロシージャを作成：
                                    <ul>
                                        <li>商品IDと値引き率（%）を受け取り、商品価格を更新し、値引き履歴テーブルに記録するプロシージャ</li>
                                        <li>注文IDを受け取り、注文のキャンセル処理を行うプロシージャ（商品の在庫を戻し、注文ステータスを「キャンセル」に更新）</li>
                                    </ul>
                                </li>
                                <li>JDBCを使用して、上記のファンクションとストアドプロシージャを呼び出す統合プログラムを実装
                                    <ul>
                                        <li>コンソールメニューを表示し、ユーザーの選択に応じて各機能を実行する</li>
                                        <li>結果を適切にフォーマットして表示する</li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </section>

                    <section id="practical-exercise">
                        <h3 class="section-title">5.4 在庫管理システムのトランザクション処理（実習）</h3>
                        <p>この実習では、これまで学んだバッチ処理、トランザクション管理、ストアドプロシージャを組み合わせて、シンプルな在庫管理システムを実装します。このシステムでは、商品の入出庫管理、注文処理、在庫集計などの機能を提供します。</p>

                        <h4>システム要件</h4>
                        <p>在庫管理システムの主な要件は以下の通りです：</p>
                        <ul>
                            <li><strong>商品マスタ管理</strong>：商品の登録、更新、検索</li>
                            <li><strong>在庫トランザクション</strong>：入庫、出庫、在庫調整</li>
                            <li><strong>注文処理</strong>：注文入力、出荷処理</li>
                            <li><strong>レポート生成</strong>：在庫状況、商品別販売実績</li>
                        </ul>

                        <h4>データベーススキーマ設計</h4>
                        <p>以下のテーブルを作成します：</p>

                        <code>-- データベース作成
CREATE DATABASE inventory_management;

-- テーブル作成
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT
);

CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    category_id INTEGER REFERENCES categories(category_id),
    code VARCHAR(20) UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    unit_price NUMERIC(10, 2) NOT NULL,
    stock_quantity INTEGER NOT NULL DEFAULT 0,
    reorder_level INTEGER NOT NULL DEFAULT 10,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE inventory_transactions (
    transaction_id SERIAL PRIMARY KEY,
    product_id INTEGER REFERENCES products(product_id),
    transaction_type CHAR(1) NOT NULL, -- 'I'=入庫, 'O'=出庫, 'A'=調整
    quantity INTEGER NOT NULL,
    transaction_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    reference_id INTEGER, -- 関連する注文ID or 入荷IDなど
    notes TEXT
);

CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20),
    address TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER REFERENCES customers(customer_id),
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'PENDING', -- 'PENDING', 'SHIPPED', 'COMPLETED', 'CANCELED'
    total_amount NUMERIC(12, 2) NOT NULL,
    shipping_address TEXT,
    notes TEXT
);

CREATE TABLE order_items (
    item_id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(order_id),
    product_id INTEGER REFERENCES products(product_id),
    quantity INTEGER NOT NULL,
    unit_price NUMERIC(10, 2) NOT NULL,
    subtotal NUMERIC(12, 2) NOT NULL
);

-- トリガー用の関数
CREATE OR REPLACE FUNCTION update_product_stock()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.transaction_type = 'I' THEN
        -- 入庫
        UPDATE products SET 
            stock_quantity = stock_quantity + NEW.quantity,
            updated_at = CURRENT_TIMESTAMP
        WHERE product_id = NEW.product_id;
    ELSIF NEW.transaction_type = 'O' THEN
        -- 出庫
        UPDATE products SET 
            stock_quantity = stock_quantity - NEW.quantity,
            updated_at = CURRENT_TIMESTAMP
        WHERE product_id = NEW.product_id;
    ELSIF NEW.transaction_type = 'A' THEN
        -- 調整（絶対数）
        UPDATE products SET 
            stock_quantity = NEW.quantity,
            updated_at = CURRENT_TIMESTAMP
        WHERE product_id = NEW.product_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- トリガーの作成
CREATE TRIGGER after_inventory_transaction
AFTER INSERT ON inventory_transactions
FOR EACH ROW
EXECUTE FUNCTION update_product_stock();</code>

                        <h4>ストアドプロシージャとファンクションの作成</h4>
                        <p>システムで使用するストアドプロシージャとファンクションを作成します：</p>

                        <code>-- 製品情報を取得するファンクション
CREATE OR REPLACE FUNCTION get_product_details(p_product_id INTEGER)
RETURNS TABLE (
    product_id INTEGER,
    category_name VARCHAR,
    code VARCHAR,
    name VARCHAR,
    description TEXT,
    unit_price NUMERIC,
    stock_quantity INTEGER,
    reorder_level INTEGER,
    needs_reorder BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.product_id,
        c.name AS category_name,
        p.code,
        p.name,
        p.description,
        p.unit_price,
        p.stock_quantity,
        p.reorder_level,
        (p.stock_quantity <= p.reorder_level) AS needs_reorder
    FROM
        products p
    JOIN
        categories c ON p.category_id = c.category_id
    WHERE
        p.product_id = p_product_id;
END;
$$ LANGUAGE plpgsql;

-- 在庫が少ない製品を取得するファンクション
CREATE OR REPLACE FUNCTION get_low_stock_products()
RETURNS TABLE (
    product_id INTEGER,
    code VARCHAR,
    name VARCHAR,
    category_name VARCHAR,
    stock_quantity INTEGER,
    reorder_level INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.product_id,
        p.code,
        p.name,
        c.name AS category_name,
        p.stock_quantity,
        p.reorder_level
    FROM
        products p
    JOIN
        categories c ON p.category_id = c.category_id
    WHERE
        p.stock_quantity <= p.reorder_level
    ORDER BY
        (p.stock_quantity::FLOAT / p.reorder_level) ASC;
END;
$$ LANGUAGE plpgsql;

-- 注文処理プロシージャ
CREATE OR REPLACE PROCEDURE process_order(
    p_customer_id INTEGER,
    p_shipping_address TEXT,
    p_notes TEXT
)
AS $$
DECLARE
    v_order_id INTEGER;
    v_total_amount NUMERIC := 0;
BEGIN
    -- 一時テーブルが存在する必要があります（クライアントが事前に作成）
    -- temp_order_items (product_id INTEGER, quantity INTEGER)
    
    -- 在庫チェック
    IF EXISTS (
        SELECT 1
        FROM temp_order_items t
        JOIN products p ON t.product_id = p.product_id
        WHERE p.stock_quantity < t.quantity
    ) THEN
        RAISE EXCEPTION '一部の商品の在庫が不足しています';
    END IF;
    
    -- 注文合計金額の計算
    SELECT SUM(p.unit_price * t.quantity)
    INTO v_total_amount
    FROM temp_order_items t
    JOIN products p ON t.product_id = p.product_id;
    
    -- 注文レコードの作成
    INSERT INTO orders (customer_id, status, total_amount, shipping_address, notes)
    VALUES (p_customer_id, 'PENDING', v_total_amount, p_shipping_address, p_notes)
    RETURNING order_id INTO v_order_id;
    
    -- 注文明細の作成とインベントリトランザクションの記録
    INSERT INTO order_items (order_id, product_id, quantity, unit_price, subtotal)
    SELECT
        v_order_id,
        t.product_id,
        t.quantity,
        p.unit_price,
        p.unit_price * t.quantity
    FROM
        temp_order_items t
    JOIN
        products p ON t.product_id = p.product_id;
    
    -- 在庫トランザクションの記録
    INSERT INTO inventory_transactions (product_id, transaction_type, quantity, reference_id, notes)
    SELECT
        t.product_id,
        'O',  -- 出庫
        t.quantity,
        v_order_id,
        '注文ID: ' || v_order_id
    FROM
        temp_order_items t;
    
    -- 成功メッセージ
    RAISE NOTICE '注文ID % が正常に処理されました。合計金額: %', v_order_id, v_total_amount;
    
EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
$$ LANGUAGE plpgsql;</code>

                        <h4>JDBCでの実装：在庫管理システムのコア機能</h4>
                        <p>以下のJavaクラスを実装します：</p>

                        <code>// 製品マネージャークラス
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class ProductManager {
    private Connection conn;
    
    public ProductManager(Connection conn) {
        this.conn = conn;
    }
    
    // 製品の追加
    public int addProduct(int categoryId, String code, String name, 
                         String description, double unitPrice, int reorderLevel) throws SQLException {
        String sql = "INSERT INTO products (category_id, code, name, description, unit_price, reorder_level) " +
                     "VALUES (?, ?, ?, ?, ?, ?) RETURNING product_id";
        
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, categoryId);
            pstmt.setString(2, code);
            pstmt.setString(3, name);
            pstmt.setString(4, description);
            pstmt.setDouble(5, unitPrice);
            pstmt.setInt(6, reorderLevel);
            
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt("product_id");
            } else {
                throw new SQLException("製品の追加に失敗しました");
            }
        }
    }
    
    // 製品の情報を取得
    public Product getProductDetails(int productId) throws SQLException {
        String sql = "SELECT * FROM get_product_details(?)";
        
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, productId);
            
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                Product product = new Product();
                product.setProductId(rs.getInt("product_id"));
                product.setCategoryName(rs.getString("category_name"));
                product.setCode(rs.getString("code"));
                product.setName(rs.getString("name"));
                product.setDescription(rs.getString("description"));
                product.setUnitPrice(rs.getDouble("unit_price"));
                product.setStockQuantity(rs.getInt("stock_quantity"));
                product.setReorderLevel(rs.getInt("reorder_level"));
                product.setNeedsReorder(rs.getBoolean("needs_reorder"));
                
                return product;
            } else {
                return null;
            }
        }
    }
    
    // 在庫が少ない製品のリストを取得
    public List<Product> getLowStockProducts() throws SQLException {
        List&lt;Object&gt; params = new ArrayList&lt;&gt;();
        String sql = "SELECT * FROM get_low_stock_products()";
        
        try (Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                Product product = new Product();
                product.setProductId(rs.getInt("product_id"));
                product.setCode(rs.getString("code"));
                product.setName(rs.getString("name"));
                product.setCategoryName(rs.getString("category_name"));
                product.setStockQuantity(rs.getInt("stock_quantity"));
                product.setReorderLevel(rs.getInt("reorder_level"));
                products.add(product);
            }
        }
        
        return products;
    }
    
    // バッチ処理で複数製品の在庫を更新
    public int[] updateStockBatch(List<StockUpdate> updates) throws SQLException {
        String sql = "INSERT INTO inventory_transactions (product_id, transaction_type, quantity, notes) " +
                     "VALUES (?, ?, ?, ?)";
        
        conn.setAutoCommit(false);
        
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            for (StockUpdate update : updates) {
                pstmt.setInt(1, update.getProductId());
                pstmt.setString(2, update.getTransactionType());
                pstmt.setInt(3, update.getQuantity());
                pstmt.setString(4, update.getNotes());
                pstmt.addBatch();
            }
            
            int[] results = pstmt.executeBatch();
            conn.commit();
            
            return results;
        } catch (BatchUpdateException e) {
            conn.rollback();
            throw e;
        } finally {
            conn.setAutoCommit(true);
        }
    }
}

// 注文マネージャークラス
import java.sql.*;
import java.util.List;

public class OrderManager {
    private Connection conn;
    
    public OrderManager(Connection conn) {
        this.conn = conn;
    }
    
    // 注文処理
    public int processOrder(int customerId, List<OrderItem> items, 
                           String shippingAddress, String notes) throws SQLException {
        // 一時テーブルを作成
        createTempOrderItemsTable();
        
        // 一時テーブルにアイテムを挿入
        populateTempOrderItems(items);
        
        // トランザクション開始
        conn.setAutoCommit(false);
        
        try {
            // ストアドプロシージャ呼び出し
            CallableStatement cstmt = conn.prepareCall("CALL process_order(?, ?, ?)");
            cstmt.setInt(1, customerId);
            cstmt.setString(2, shippingAddress);
            cstmt.setString(3, notes);
            cstmt.execute();
            
            // 注文IDを取得
            int orderId = getLastOrderId();
            
            // コミット
            conn.commit();
            
            return orderId;
        } catch (SQLException e) {
            // ロールバック
            conn.rollback();
            throw e;
        } finally {
            // 一時テーブルを削除
            dropTempOrderItemsTable();
            conn.setAutoCommit(true);
        }
    }
    
    // 一時テーブルの作成
    private void createTempOrderItemsTable() throws SQLException {
        try (Statement stmt = conn.createStatement()) {
            stmt.execute("DROP TABLE IF EXISTS temp_order_items");
            stmt.execute("CREATE TEMPORARY TABLE temp_order_items " +
                         "(product_id INTEGER, quantity INTEGER)");
        }
    }
    
    // 一時テーブルへのデータ挿入
    private void populateTempOrderItems(List<OrderItem> items) throws SQLException {
        String sql = "INSERT INTO temp_order_items (product_id, quantity) VALUES (?, ?)";
        
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            for (OrderItem item : items) {
                pstmt.setInt(1, item.getProductId());
                pstmt.setInt(2, item.getQuantity());
                pstmt.executeUpdate();
            }
        }
    }
    
    // 一時テーブルの削除
    private void dropTempOrderItemsTable() throws SQLException {
        try (Statement stmt = conn.createStatement()) {
            stmt.execute("DROP TABLE IF EXISTS temp_order_items");
        }
    }
    
    // 最後に作成された注文IDを取得
    private int getLastOrderId() throws SQLException {
        try (Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery("SELECT MAX(order_id) AS last_id FROM orders")) {
            
            if (rs.next()) {
                return rs.getInt("last_id");
            } else {
                throw new SQLException("注文IDの取得に失敗しました");
            }
        }
    }
    
    // 注文ステータスの更新
    public boolean updateOrderStatus(int orderId, String newStatus) throws SQLException {
        String sql = "UPDATE orders SET status = ? WHERE order_id = ?";
        
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, newStatus);
            pstmt.setInt(2, orderId);
            
            int affectedRows = pstmt.executeUpdate();
            return affectedRows > 0;
        }
    }
}

// メインアプリケーションクラス
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class InventoryManagementApp {
    private static final String URL = "jdbc:postgresql://localhost:5432/inventory_management";
    private static final String USER = "postgres";
    private static final String PASSWORD = "password";
    
    private Connection conn;
    private ProductManager productManager;
    private OrderManager orderManager;
    private Scanner scanner;
    
    public InventoryManagementApp() {
        try {
            conn = DriverManager.getConnection(URL, USER, PASSWORD);
            productManager = new ProductManager(conn);
            orderManager = new OrderManager(conn);
            scanner = new Scanner(System.in);
        } catch (SQLException e) {
            System.err.println("データベース接続エラー: " + e.getMessage());
            System.exit(1);
        }
    }
    
    public void start() {
        boolean running = true;
        
        while (running) {
            displayMainMenu();
            int choice = getIntInput("選択してください: ");
            
            try {
                switch (choice) {
                    case 1:
                        productManagementMenu();
                        break;
                    case 2:
                        inventoryTransactionMenu();
                        break;
                    case 3:
                        orderProcessingMenu();
                        break;
                    case 4:
                        reportMenu();
                        break;
                    case 0:
                        running = false;
                        break;
                    default:
                        System.out.println("無効な選択です。再試行してください。");
                }
            } catch (SQLException e) {
                System.err.println("エラーが発生しました: " + e.getMessage());
            }
        }
        
        // リソースのクローズ
        try {
            if (conn != null) conn.close();
            if (scanner != null) scanner.close();
        } catch (SQLException e) {
            System.err.println("接続クローズ中にエラーが発生しました: " + e.getMessage());
        }
        
        System.out.println("アプリケーションを終了しました。");
    }
    
    private void displayMainMenu() {
        System.out.println("\n===== 在庫管理システム =====");
        System.out.println("1. 製品管理");
        System.out.println("2. 在庫トランザクション");
        System.out.println("3. 注文処理");
        System.out.println("4. レポート");
        System.out.println("0. 終了");
    }
    
    private void productManagementMenu() throws SQLException {
        // 実装省略（製品の追加、更新、検索などのメニュー）
    }
    
    private void inventoryTransactionMenu() throws SQLException {
        // 実装省略（入庫、出庫、在庫調整などのメニュー）
    }
    
    private void orderProcessingMenu() throws SQLException {
        // 実装省略（注文入力、出荷処理などのメニュー）
    }
    
    private void reportMenu() throws SQLException {
        System.out.println("\n===== レポート =====");
        System.out.println("1. 在庫不足の製品リスト");
        System.out.println("2. 製品詳細情報");
        System.out.println("0. 戻る");
        
        int choice = getIntInput("選択してください: ");
        
        switch (choice) {
            case 1:
                displayLowStockProducts();
                break;
            case 2:
                int productId = getIntInput("製品IDを入力してください: ");
                displayProductDetails(productId);
                break;
        }
    }
    
    private void displayLowStockProducts() throws SQLException {
        List<Product> products = productManager.getLowStockProducts();
        
        if (products.isEmpty()) {
            System.out.println("在庫不足の製品はありません。");
            return;
        }
        
        System.out.println("\n===== 在庫不足の製品リスト =====");
        System.out.printf("%-5s %-10s %-20s %-15s %-10s %-10s%n",
                         "ID", "コード", "製品名", "カテゴリ", "在庫数", "再注文点");
        System.out.println("-------------------------------------------------------------");
        
        for (Product product : products) {
            System.out.printf("%-5d %-10s %-20s %-15s %-10d %-10d%n",
                             product.getProductId(), 
                             product.getCode(),
                             product.getName(),
                             product.getCategoryName(),
                             product.getStockQuantity(),
                             product.getReorderLevel()
            );
        }
    }
    
    private void displayProductDetails(int productId) throws SQLException {
        Product product = productManager.getProductDetails(productId);
        
        if (product == null) {
            System.out.println("指定されたIDの製品は見つかりません。");
            return;
        }
        
        System.out.println("\n===== 製品詳細情報 =====");
        System.out.println("製品ID: " + product.getProductId());
        System.out.println("コード: " + product.getCode());
        System.out.println("製品名: " + product.getName());
        System.out.println("カテゴリ: " + product.getCategoryName());
        System.out.println("説明: " + product.getDescription());
        System.out.println("単価: " + product.getUnitPrice());
        System.out.println("在庫数: " + product.getStockQuantity());
        System.out.println("再注文点: " + product.getReorderLevel());
        System.out.println("在庫状態: " + (product.isNeedsReorder() ? "再注文が必要" : "十分"));
    }
    
    private int getIntInput(String prompt) {
        System.out.print(prompt);
        while (!scanner.hasNextInt()) {
            System.out.println("数値を入力してください。");
            scanner.next();
            System.out.print(prompt);
        }
        int value = scanner.nextInt();
        scanner.nextLine(); // バッファをクリア
        return value;
    }
    
    private String getStringInput(String prompt) {
        System.out.print(prompt);
        return scanner.nextLine();
    }
    
    public static void main(String[] args) {
        InventoryManagementApp app = new InventoryManagementApp();
        app.start();
    }
}

// 関連クラス
class Product {
    private int productId;
    private String categoryName;
    private String code;
    private String name;
    private String description;
    private double unitPrice;
    private int stockQuantity;
    private int reorderLevel;
    private boolean needsReorder;
    
    // getter/setterメソッド
    public int getProductId() { return productId; }
    public void setProductId(int productId) { this.productId = productId; }
    
    public String getCategoryName() { return categoryName; }
    public void setCategoryName(String categoryName) { this.categoryName = categoryName; }
    
    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public double getUnitPrice() { return unitPrice; }
    public void setUnitPrice(double unitPrice) { this.unitPrice = unitPrice; }
    
    public int getStockQuantity() { return stockQuantity; }
    public void setStockQuantity(int stockQuantity) { this.stockQuantity = stockQuantity; }
    
    public int getReorderLevel() { return reorderLevel; }
    public void setReorderLevel(int reorderLevel) { this.reorderLevel = reorderLevel; }
    
    public boolean isNeedsReorder() { return needsReorder; }
    public void setNeedsReorder(boolean needsReorder) { this.needsReorder = needsReorder; }
}

class OrderItem {
    private int productId;
    private int quantity;
    
    public OrderItem(int productId, int quantity) {
        this.productId = productId;
        this.quantity = quantity;
    }
    
    public int getProductId() { return productId; }
    public int getQuantity() { return quantity; }
}

class StockUpdate {
    private int productId;
    private String transactionType; // 'I'=入庫, 'O'=出庫, 'A'=調整
    private int quantity;
    private String notes;
    
    public StockUpdate(int productId, String transactionType, int quantity, String notes) {
        this.productId = productId;
        this.transactionType = transactionType;
        this.quantity = quantity;
        this.notes = notes;
    }
    
    public int getProductId() { return productId; }
    public String getTransactionType() { return transactionType; }
    public int getQuantity() { return quantity; }
    public String getNotes() { return notes; }
}

                        <div class="exercise">
                            <h5>実習課題 5.4.1: 在庫管理システムの拡張</h5>
                            <p>上記の在庫管理システムを以下の機能で拡張してください：</p>
                            <ol>
                                <li><strong>バッチ入荷処理</strong>：CSVファイルから複数製品の入荷情報を読み取り、バッチ処理で一括登録する機能</li>
                                <li><strong>商品検索機能</strong>：名前、コード、カテゴリによる商品検索機能</li>
                                <li><strong>在庫移動機能</strong>：倉庫間で在庫を移動する機能（トランザクション処理を適用）</li>
                                <li><strong>低在庫アラート</strong>：在庫が指定レベル以下になった商品を自動的に検出し、レポートを生成する機能</li>
                                <li><strong>注文履歴の表示</strong>：特定の顧客または製品に関連する注文履歴を表示する機能</li>
                            </ol>
                            <p>それぞれの機能実装にあたっては、適切なトランザクション管理を行い、例外処理を組み込んでください。また、バッチ処理やストアドプロシージャを効果的に活用してパフォーマンスを最適化してください。</p>
                        </div>
                    </section>

                    <section id="chapter5-quiz">
                        <h3 class="section-title">5.5 理解度確認テスト</h3>
                        <div class="quiz-container">
                            <h4>第5章の理解度チェック</h4>
                            <p>以下の問題に答えて、第5章の内容の理解度を確認しましょう。</p>
                            
                            <div class="quiz-question">
                                <p><strong>問題1:</strong> JDBCでバッチ処理を実行するメソッドとして正しいものはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1a" value="a">
                                    <label class="form-check-label" for="q1a">
                                        executeUpdateBatch()
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1b" value="b">
                                    <label class="form-check-label" for="q1b">
                                        executeBatch()
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1c" value="c">
                                        <label class="form-check-label" for="q1c">
                                        performBatch()
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1d" value="d">
                                        <label class="form-check-label" for="q1d">
                                        executeBulk()
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題2:</strong> トランザクション内で複数のSQL文を実行した後、すべての変更を確定するメソッドはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2a" value="a">
                                    <label class="form-check-label" for="q2a">
                                        finalize()
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2b" value="b">
                                    <label class="form-check-label" for="q2b">
                                        commit()
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2c" value="c">
                                        <label class="form-check-label" for="q2c">
                                        apply()
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2d" value="d">
                                        <label class="form-check-label" for="q2d">
                                        confirm()
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題3:</strong> トランザクション内の特定のポイントを設定し、そこまで部分的にロールバックできるようにする機能は何ですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3a" value="a">
                                    <label class="form-check-label" for="q3a">
                                        チェックポイント（Checkpoint）
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3b" value="b">
                                    <label class="form-check-label" for="q3b">
                                        マーカー（Marker）
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3c" value="c">
                                        <label class="form-check-label" for="q3c">
                                        セーブポイント（Savepoint）
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3d" value="d">
                                        <label class="form-check-label" for="q3d">
                                        スナップショット（Snapshot）
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題4:</strong> JDBCでストアドプロシージャを呼び出すために使用するステートメントの種類はどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4a" value="a">
                                    <label class="form-check-label" for="q4a">
                                        ProcedureStatement
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4b" value="b">
                                    <label class="form-check-label" for="q4b">
                                        StoredStatement
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4c" value="c">
                                        <label class="form-check-label" for="q4c">
                                        CallableStatement
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4d" value="d">
                                        <label class="form-check-label" for="q4d">
                                        ExecutableStatement
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題5:</strong> 次のコードの実行結果として最も可能性が高いものはどれですか？</p>
                                <code>try (Connection conn = DriverManager.getConnection(url, user, password)) {
    conn.setAutoCommit(false);
    
    try (Statement stmt = conn.createStatement()) {
        stmt.executeUpdate("UPDATE accounts SET balance = balance - 1000 WHERE account_id = 101");
        stmt.executeUpdate("UPDATE accounts SET balance = balance + 1000 WHERE account_id = 999");
    } catch (SQLException e) {
        conn.rollback();
        System.err.println("エラーが発生しました: " + e.getMessage());
    }
}</code>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5a" value="a">
                                    <label class="form-check-label" for="q5a">
                                        アカウント101から1000引かれ、アカウント999に1000追加される
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5b" value="b">
                                    <label class="form-check-label" for="q5b">
                                        アカウント101から1000引かれるが、アカウント999は存在しないのでエラーメッセージが表示され、両方の更新がロールバックされる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5c" value="c">
                                        <label class="form-check-label" for="q5c">
                                        アカウント101から1000引かれるが、アカウント999は存在しないため、アカウント101の残高変更だけが適用される
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5d" value="d">
                                        <label class="form-check-label" for="q5d">
                                        トランザクションが完了していないため、どちらの更新も適用されない
                                    </label>
                                </div>
                            </div>
                            
                            <button class="btn btn-primary mt-3" id="checkAnswers">回答を確認</button>
                            <div id="quizResults" class="mt-3 d-none">
                                <div class="alert alert-success">
                                    <h5>正解:</h5>
                                    <ol>
                                        <li>b（executeBatch()）</li>
                                        <li>b（commit()）</li>
                                        <li>c（セーブポイント（Savepoint））</li>
                                        <li>c（CallableStatement）</li>
                                        <li>d（トランザクションが完了していないため、どちらの更新も適用されない）</li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="next-steps">
                        <h3 class="section-title">次のステップ</h3>
                        <p>この章では、高度なJDBC機能について学習しました。バッチ処理、トランザクション管理、ストアドプロシージャの呼び出し、そして実際のアプリケーション（在庫管理システム）の実装を通じて、実践的なJDBCプログラミングのスキルを身につけることができました。</p>
                        <p>次のステップとして、以下のトピックについてさらに学習を深めることをお勧めします：</p>
                        <div class="note">
                            <h5>次のステップの学習項目</h5>
                            <ul>
                                <li><strong>コネクションプール</strong>：HikariCP、Apache DBCPなどのライブラリを使用したデータベース接続の効率的な管理</li>
                                <li><strong>ORマッピングフレームワーク</strong>：Hibernate、MyBatisなどのORマッピングフレームワークの利用</li>
                                <li><strong>Spring JDBCとSpring Data</strong>：Spring FrameworkのJDBCサポートとSpring Dataを使用した高度なデータアクセス</li>
                                <li><strong>NoSQLデータベース</strong>：MongoDB、Redis、Cassandraなどの非リレーショナルデータベースとの連携</li>
                                <li><strong>マイクロサービスアーキテクチャ</strong>：分散システムにおけるデータアクセスの設計とパターン</li>
                            </ul>
                        </div>
                        <p>JDBCの基本と高度な機能をマスターしたことで、Javaエコシステムにおけるデータアクセス技術の基盤を築くことができました。これからもJavaとデータベースに関する技術を学び続け、より高度なアプリケーション開発に挑戦してください。</p>
                    </section>
                </section>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="text-center py-4">
        <div class="container">
            <p class="mb-0">Copyright © 2025 F-Circle All rights reserved.</p>
        </div>
    </footer>

    <!-- Bootstrap JS and Popper.js -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 理解度テストの回答確認ボタンの処理
        document.getElementById('checkAnswers').addEventListener('click', function() {
            document.getElementById('quizResults').classList.remove('d-none');
        });
    </script>
</body>
</html>