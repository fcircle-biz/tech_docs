<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker学習教材 第1章 - Dockerとは何か</title>

    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">

    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>

    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
            line-height: 1.8;
        }

        /* ナビゲーション - Docker Blue */
        .navbar {
            background-color: #2496ED;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 1rem;
        }

        /* タイトル */
        .chapter-title {
            color: #2496ED;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 3px solid #2496ED;
            padding-bottom: 0.5rem;
            font-weight: bold;
        }

        .section-title {
            color: #1D63ED;
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e7f3ff;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #2496ED;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #fff9e6;
            border-radius: 8px;
            padding: 1.2rem;
            margin: 1.5rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            color: white;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #2496ED !important;
            color: white !important;
            border-radius: 5px;
        }

        .nav-link {
            color: #333;
            transition: all 0.3s;
        }

        .nav-link:hover {
            background-color: #e7f3ff;
            border-radius: 5px;
        }

        /* 表スタイル */
        .table-custom {
            background-color: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .table-custom th {
            background-color: #2496ED;
            color: white;
            font-weight: 600;
        }

        /* Mermaid図のスタイル */
        .mermaid {
            text-align: center;
            margin: 2rem 0;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">
                <i class="fab fa-docker"></i>
                <strong>Docker学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link active" href="docker-learning-material-01.html">
                                第1章: Dockerとは何か
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-02.html">
                                第2章: 環境構築と基本操作
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-03.html">
                                第3章: イメージの理解と管理
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-04.html">
                                第4章: Dockerfileによるイメージ作成
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-05.html">
                                第5章: Docker Compose
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-06.html">
                                第6章: ボリュームとデータ永続化
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-07.html">
                                第7章: ネットワークとコンテナ間通信
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-08.html">
                                第8章: マルチコンテナアプリケーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-09.html">
                                第9章: ベストプラクティスとセキュリティ
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-10.html">
                                第10章: 本番環境へのデプロイ
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第1章: Dockerとは何か - コンテナ技術の基礎理解</h1>
                </div>

                <div id="chapter1">
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5><i class="fas fa-lightbulb"></i> この章で学ぶこと</h5>
                        <ul>
                            <li>Dockerの基本概念と、従来の仮想マシン（VM）との根本的な違いを理解する</li>
                            <li>コンテナ技術がもたらすメリット（環境の一貫性、移植性、効率性）を学ぶ</li>
                            <li>Dockerの主要コンポーネント（Docker Engine、Docker CLI、Docker Desktop）の役割を把握する</li>
                            <li>Dockerのアーキテクチャ（クライアント・サーバモデル）を理解する</li>
                            <li>実際の開発現場でのDocker活用事例を知る</li>
                        </ul>
                    </div>

                    <!-- 1.1 Dockerとは -->
                    <h3 class="section-title">1.1 Dockerとは何か</h3>
                    <p>
                        <strong>Docker</strong>は、アプリケーションとその実行環境を<strong>コンテナ</strong>という軽量な単位でパッケージ化し、どこでも同じように動作させるためのプラットフォームです。2013年にDotCloud社（現Docker社）によって開発され、現在では世界中の開発者や企業に利用されています。
                    </p>
                    <p>
                        Dockerの最大の特徴は、<strong>「Build once, Run anywhere（一度ビルドすれば、どこでも実行できる）」</strong>という理念です。開発者のローカル環境、テスト環境、本番環境など、異なる環境間でも同じコンテナが動作するため、「私の環境では動くのに…」という問題を解決できます。
                    </p>

                    <!-- Dockerの位置づけ図 -->
                    <div class="mermaid">
                        flowchart TB
                            subgraph Traditional[従来の開発]
                                Dev1[開発環境] -.異なる構成.- Test1[テスト環境]
                                Test1 -.異なる構成.- Prod1[本番環境]
                            end

                            subgraph Docker[Dockerを使った開発]
                                Dev2[開発環境] -->|同じコンテナ| Test2[テスト環境]
                                Test2 -->|同じコンテナ| Prod2[本番環境]
                            end
                    </div>

                    <!-- 1.2 なぜDockerが必要なのか -->
                    <h3 class="section-title">1.2 なぜDockerが必要なのか - 解決する課題</h3>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.2.1 環境依存の問題</h4>
                    <p>
                        従来のソフトウェア開発では、開発者の環境によってアプリケーションの動作が異なる問題がよく発生していました。例えば：
                    </p>
                    <ul>
                        <li><strong>OS の違い</strong>: Windows、macOS、Linuxでパスの区切り文字やコマンドが異なる</li>
                        <li><strong>ライブラリのバージョン違い</strong>: Python 3.8と3.10でコードの動作が変わる</li>
                        <li><strong>環境変数の設定漏れ</strong>: 必要な設定が別の環境では定義されていない</li>
                        <li><strong>依存パッケージの競合</strong>: プロジェクトAとBで同じライブラリの異なるバージョンが必要</li>
                    </ul>

                    <p>
                        Dockerは、アプリケーションとその<strong>すべての依存関係</strong>（OSライブラリ、言語ランタイム、環境変数、設定ファイル等）をコンテナという一つのパッケージにまとめることで、この問題を根本的に解決します。
                    </p>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.2.2 環境構築の手間</h4>
                    <p>
                        新しいメンバーがプロジェクトに参加したとき、従来は数日かけて開発環境をセットアップする必要がありました：
                    </p>
                    <ol>
                        <li>データベースのインストールと設定</li>
                        <li>Webサーバーのインストールと設定</li>
                        <li>言語ランタイムの特定バージョンのインストール</li>
                        <li>各種ライブラリの依存関係解決</li>
                        <li>環境変数やパスの設定</li>
                    </ol>

                    <p>
                        Dockerを使えば、これらの手順が<strong>「docker-compose up」という1つのコマンド</strong>で完了します。新メンバーは数分で開発を開始できます。
                    </p>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.2.3 リソースの効率的な利用</h4>
                    <p>
                        後述する仮想マシン（VM）と比較して、Dockerコンテナは軽量で起動が速く、同じハードウェア上でより多くのアプリケーションを実行できます。これにより、開発時のストレスが減り、本番環境でのコスト削減も実現できます。
                    </p>

                    <!-- 1.3 仮想マシンとコンテナの違い -->
                    <h3 class="section-title">1.3 仮想マシン（VM）とコンテナの根本的な違い</h3>

                    <p>
                        Dockerを理解する上で最も重要なのが、従来の<strong>仮想マシン（Virtual Machine: VM）</strong>との違いです。どちらもアプリケーションを隔離して実行する技術ですが、その仕組みは大きく異なります。
                    </p>

                    <!-- VM vs Container 構造図 -->
                    <div class="mermaid">
                        flowchart TB
                            subgraph VM[仮想マシン方式]
                                direction TB
                                Hardware1[物理サーバー ハードウェア]
                                HostOS1[ホストOS]
                                Hypervisor[ハイパーバイザー 例: VMware, VirtualBox]
                                GuestOS1[ゲストOS 1]
                                GuestOS2[ゲストOS 2]
                                GuestOS3[ゲストOS 3]
                                App1[アプリA]
                                App2[アプリB]
                                App3[アプリC]

                                Hardware1 --> HostOS1
                                HostOS1 --> Hypervisor
                                Hypervisor --> GuestOS1
                                Hypervisor --> GuestOS2
                                Hypervisor --> GuestOS3
                                GuestOS1 --> App1
                                GuestOS2 --> App2
                                GuestOS3 --> App3
                            end

                            subgraph Container[コンテナ方式 - Docker]
                                direction TB
                                Hardware2[物理サーバー ハードウェア]
                                HostOS2[ホストOS]
                                DockerEngine[Docker Engine]
                                Container1[コンテナ1]
                                Container2[コンテナ2]
                                Container3[コンテナ3]
                                AppC1[アプリA + 依存]
                                AppC2[アプリB + 依存]
                                AppC3[アプリC + 依存]

                                Hardware2 --> HostOS2
                                HostOS2 --> DockerEngine
                                DockerEngine --> Container1
                                DockerEngine --> Container2
                                DockerEngine --> Container3
                                Container1 --> AppC1
                                Container2 --> AppC2
                                Container3 --> AppC3
                            end
                    </div>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.3.1 仮想マシン（VM）の仕組み</h4>
                    <p>
                        仮想マシンは、物理的なハードウェア上で<strong>ハイパーバイザー</strong>というソフトウェアを動かし、その上で複数の<strong>完全なOS（ゲストOS）</strong>を実行します。各仮想マシンは：
                    </p>
                    <ul>
                        <li>独自のOSカーネルを持つ（例: Ubuntu、CentOS、Windows Server）</li>
                        <li>OSの起動プロセスが必要（通常数分かかる）</li>
                        <li>各VMが数GBのディスク容量とGBオーダーのメモリを必要とする</li>
                        <li>完全に隔離されているため、セキュリティが高い</li>
                    </ul>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.3.2 コンテナ（Docker）の仕組み</h4>
                    <p>
                        コンテナは、ホストOSの<strong>カーネルを共有</strong>しながら、プロセスレベルで隔離を実現します。各コンテナは：
                    </p>
                    <ul>
                        <li>ホストOSのカーネルを使用（新しいOSを起動しない）</li>
                        <li>起動が数秒以内（プロセス起動とほぼ同じ速度）</li>
                        <li>必要な容量はアプリケーションサイズ + 依存ライブラリのみ（数十MB～数百MB）</li>
                        <li>軽量だが、カーネルレベルの隔離技術で安全性を確保</li>
                    </ul>

                    <!-- 比較表 -->
                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.3.3 比較表: 仮想マシン vs コンテナ</h4>
                    <table class="table table-custom table-hover">
                        <thead>
                            <tr>
                                <th>項目</th>
                                <th>仮想マシン（VM）</th>
                                <th>コンテナ（Docker）</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>起動時間</strong></td>
                                <td>数分（OS起動が必要）</td>
                                <td>数秒（プロセス起動のみ）</td>
                            </tr>
                            <tr>
                                <td><strong>サイズ</strong></td>
                                <td>数GB～数十GB</td>
                                <td>数十MB～数百MB</td>
                            </tr>
                            <tr>
                                <td><strong>リソース消費</strong></td>
                                <td>大きい（各VMが独自OS）</td>
                                <td>小さい（カーネル共有）</td>
                            </tr>
                            <tr>
                                <td><strong>隔離レベル</strong></td>
                                <td>完全隔離（ハードウェアレベル）</td>
                                <td>プロセスレベル隔離</td>
                            </tr>
                            <tr>
                                <td><strong>移植性</strong></td>
                                <td>中程度（VMイメージは大きい）</td>
                                <td>高い（軽量で配布しやすい）</td>
                            </tr>
                            <tr>
                                <td><strong>用途</strong></td>
                                <td>異なるOS実行、完全隔離が必要</td>
                                <td>アプリケーション配布、マイクロサービス</td>
                            </tr>
                        </tbody>
                    </table>

                    <!-- 1.4 Dockerのメリット -->
                    <h3 class="section-title">1.4 Dockerがもたらす具体的なメリット</h3>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.4.1 環境の一貫性</h4>
                    <p>
                        開発、テスト、本番のすべての環境で<strong>同じコンテナイメージ</strong>を使用するため、環境の違いによるバグを防げます。「開発環境では動くのに本番では動かない」という問題が激減します。
                    </p>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.4.2 高い移植性</h4>
                    <p>
                        Dockerコンテナは、Dockerが動作するあらゆる環境（Windows、macOS、Linux、クラウドサービス）で動作します。一度作成したコンテナは、インフラを問わず展開できます。
                    </p>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.4.3 迅速な開発サイクル</h4>
                    <p>
                        新しい環境の構築や破棄が簡単なため、実験やテストを気軽に行えます。「この設定を試してみたい」という時に、既存環境を壊すことなく新しいコンテナで試せます。
                    </p>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.4.4 効率的なリソース利用</h4>
                    <p>
                        VMと比べて軽量なため、1台のサーバー上で多くのコンテナを実行できます。これにより、クラウドコストの削減や、ローカルマシンでの複数サービスの同時実行が可能になります。
                    </p>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.4.5 マイクロサービスアーキテクチャへの適応</h4>
                    <p>
                        アプリケーションを小さな独立したサービスに分割する<strong>マイクロサービスアーキテクチャ</strong>において、Dockerコンテナは各サービスを独立して開発・デプロイする理想的な単位となります。
                    </p>

                    <!-- 1.5 Dockerの主要コンポーネント -->
                    <h3 class="section-title">1.5 Dockerの主要コンポーネント</h3>

                    <p>
                        Dockerは複数のコンポーネントから構成されています。それぞれの役割を理解することで、Dockerの全体像が見えてきます。
                    </p>

                    <!-- Docker構成図 -->
                    <div class="mermaid">
                        flowchart LR
                            Client[Docker CLI<br/>コマンドライン<br/>インターフェース]
                            Desktop[Docker Desktop<br/>GUIツール]

                            subgraph Engine[Docker Engine サーバー]
                                Daemon[Docker Daemon<br/>dockerd]
                                API[REST API]
                            end

                            subgraph Resources[リソース]
                                Images[イメージ]
                                Containers[コンテナ]
                                Networks[ネットワーク]
                                Volumes[ボリューム]
                            end

                            Client -->|コマンド送信| API
                            Desktop -->|操作| API
                            API -->|処理実行| Daemon
                            Daemon -->|管理| Images
                            Daemon -->|管理| Containers
                            Daemon -->|管理| Networks
                            Daemon -->|管理| Volumes
                    </div>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.5.1 Docker Engine（エンジン）</h4>
                    <p>
                        Dockerの<strong>中核となるサーバーソフトウェア</strong>です。コンテナの実行、イメージの管理、ネットワークやストレージの制御など、すべての処理を担当します。以下の要素で構成されます：
                    </p>
                    <ul>
                        <li><strong>Docker Daemon（dockerd）</strong>: バックグラウンドで動作し、実際の処理を行う常駐プログラム</li>
                        <li><strong>REST API</strong>: Docker Daemonと通信するためのインターフェース</li>
                        <li><strong>CLI（Command Line Interface）</strong>: ユーザーがコマンドを入力するツール</li>
                    </ul>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.5.2 Docker CLI（コマンドラインインターフェース）</h4>
                    <p>
                        <strong>docker</strong>コマンドを提供するツールです。開発者は<code>docker run</code>、<code>docker build</code>などのコマンドを実行して、Docker Engineに指示を出します。CLIは内部でREST APIを呼び出しています。
                    </p>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.5.3 Docker Desktop</h4>
                    <p>
                        WindowsとmacOS向けに提供される<strong>GUIアプリケーション</strong>です。以下の機能を含みます：
                    </p>
                    <ul>
                        <li>Docker Engineの簡単なインストールと管理</li>
                        <li>コンテナやイメージの視覚的な管理</li>
                        <li>Kubernetesの統合機能</li>
                        <li>リソース使用量の監視</li>
                    </ul>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.5.4 Docker Hub</h4>
                    <p>
                        Dockerイメージを保管・共有するための<strong>公式のオンラインレジストリ</strong>です。公式のイメージ（例: Nginx、MySQL、Python）や、コミュニティが作成したイメージをダウンロードできます。GitHub的な役割を果たします。
                    </p>

                    <!-- 1.6 Dockerのアーキテクチャ -->
                    <h3 class="section-title">1.6 Dockerのアーキテクチャ - クライアント・サーバモデル</h3>

                    <p>
                        Dockerは<strong>クライアント・サーバアーキテクチャ</strong>を採用しています。この設計により、コマンドを実行するクライアントと、実際の処理を行うサーバーが分離され、柔軟な運用が可能になります。
                    </p>

                    <!-- アーキテクチャ図 -->
                    <div class="mermaid">
                        sequenceDiagram
                            autonumber
                            participant User as 開発者
                            participant CLI as Docker CLI
                            participant API as REST API
                            participant Daemon as Docker Daemon
                            participant Hub as Docker Hub

                            User->>CLI: docker run nginx
                            CLI->>API: HTTPリクエスト送信
                            API->>Daemon: コンテナ作成命令
                            Daemon->>Hub: イメージ検索・ダウンロード
                            Hub-->>Daemon: イメージ返却
                            Daemon-->>API: コンテナ起動完了
                            API-->>CLI: 結果返却
                            CLI-->>User: 実行結果表示
                    </div>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.6.1 処理フロー</h4>
                    <ol>
                        <li><strong>開発者がコマンド入力</strong>: <code>docker run nginx</code>のようなコマンドをターミナルで実行</li>
                        <li><strong>CLIがAPIに送信</strong>: Docker CLIがコマンドをREST APIリクエストに変換</li>
                        <li><strong>DaemonがDocker Hubにアクセス</strong>: ローカルにイメージがない場合、自動的にDocker Hubからダウンロード</li>
                        <li><strong>コンテナ作成と起動</strong>: ダウンロードしたイメージからコンテナを作成し、起動</li>
                        <li><strong>結果を返却</strong>: 処理結果がユーザーに返される</li>
                    </ol>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.6.2 リモートDocker Engineへの接続</h4>
                    <p>
                        このアーキテクチャの利点の一つは、ローカルのDocker CLIから<strong>リモートサーバー上のDocker Engine</strong>に接続できることです。開発マシンからクラウド上のDockerサーバーを操作することも可能です。
                    </p>

                    <!-- 1.7 実際の活用事例 -->
                    <h3 class="section-title">1.7 実際の開発現場でのDocker活用事例</h3>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.7.1 開発環境の統一</h4>
                    <p>
                        チーム全員が同じDockerコンテナを使用することで、「私の環境では動く」問題を解消。新メンバーも数分で開発を開始できます。
                    </p>
                    <div class="highlight">
                        <strong>実例:</strong> あるWebアプリケーション開発チームでは、Node.js、MongoDB、Redisを使用していました。従来は各メンバーが個別にインストールしていましたが、Docker Composeを導入後は<code>docker-compose up</code>一つで環境構築が完了し、セットアップ時間が「3日から5分」に短縮されました。
                    </div>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.7.2 マイクロサービスの開発とデプロイ</h4>
                    <p>
                        各マイクロサービスを独立したコンテナとして開発・デプロイすることで、サービスごとに異なる言語やフレームワークを使用でき、更新も独立して行えます。
                    </p>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.7.3 CI/CDパイプラインの統合</h4>
                    <p>
                        GitHub ActionsやGitLab CIなどのCI/CDツールでDockerコンテナを使用することで、テスト環境と本番環境の一貫性を保ちながら、自動化されたビルド・テスト・デプロイを実現します。
                    </p>

                    <h4 style="color: #1D63ED; margin-top: 1.5rem;">1.7.4 レガシーアプリケーションの分離</h4>
                    <p>
                        古いバージョンのライブラリを必要とするアプリケーションを、他の環境に影響を与えずにコンテナ内で実行できます。
                    </p>

                    <!-- 実習コンテナ -->
                    <div class="exercise-container">
                        <h5><i class="fas fa-pencil-alt"></i> 理論演習 1-1: Dockerの理解を深める</h5>
                        <p>
                            この演習では、実際にコマンドを実行するのではなく、概念の理解を深めることに焦点を当てます。次の質問について考えてみましょう。
                        </p>
                        <h6>質問</h6>
                        <ol>
                            <li><strong>シナリオ1:</strong> あなたは3人のチームでWebアプリケーションを開発しています。一人はWindows、一人はmacOS、一人はUbuntuを使用しています。従来の開発方法とDockerを使った場合で、環境構築にどのような違いが生じるか説明してください。</li>
                            <li><strong>シナリオ2:</strong> 仮想マシンで5つの異なるアプリケーションを実行する場合と、Dockerコンテナで実行する場合で、リソース使用量（メモリ、ディスク、起動時間）にどのような違いがあるか比較してください。</li>
                            <li><strong>シナリオ3:</strong> あなたのアプリケーションが開発環境では正常に動作するのに、本番環境でエラーが出ました。Dockerを使用していた場合、この問題は防げた可能性がありますか？理由とともに答えてください。</li>
                        </ol>

                        <h6>考察のヒント</h6>
                        <ul>
                            <li>Docker を使用すると、OS の違いはどのように吸収されるか</li>
                            <li>コンテナはホストOSのカーネルを共有することによるメリット</li>
                            <li>「Build once, Run anywhere」の原則がどう機能するか</li>
                        </ul>
                    </div>

                    <!-- 理解度確認クイズ -->
                    <div class="quiz-container">
                        <h5><i class="fas fa-check-circle"></i> 理解度確認クイズ</h5>
                        <p>この章の内容を振り返り、以下の質問に答えてください。</p>
                        <ol>
                            <li>
                                <strong>Dockerの最大の特徴を表す理念は何ですか？</strong>
                                <ul style="list-style-type: none;">
                                    <li>A) Write once, Run anywhere</li>
                                    <li>B) Build once, Run anywhere</li>
                                    <li>C) Deploy once, Run anywhere</li>
                                    <li>D) Test once, Run anywhere</li>
                                </ul>
                            </li>
                            <li>
                                <strong>仮想マシンとコンテナの最も大きな違いは何ですか？</strong>
                                <ul style="list-style-type: none;">
                                    <li>A) コンテナは独自のOSカーネルを持つ</li>
                                    <li>B) コンテナはホストOSのカーネルを共有する</li>
                                    <li>C) 仮想マシンの方が起動が速い</li>
                                    <li>D) 仮想マシンの方がサイズが小さい</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Docker Engineの役割として正しいものはどれですか？</strong>
                                <ul style="list-style-type: none;">
                                    <li>A) コマンドラインインターフェースを提供する</li>
                                    <li>B) Dockerイメージを公開・共有する</li>
                                    <li>C) コンテナの実行とイメージの管理を担当する</li>
                                    <li>D) Dockerのグラフィカルな管理画面を提供する</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Dockerがもたらすメリットとして誤っているものはどれですか？</strong>
                                <ul style="list-style-type: none;">
                                    <li>A) 環境の一貫性</li>
                                    <li>B) 高い移植性</li>
                                    <li>C) 完全なハードウェアレベルの隔離</li>
                                    <li>D) 効率的なリソース利用</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Docker Hubの役割として正しいものはどれですか？</strong>
                                <ul style="list-style-type: none;">
                                    <li>A) Dockerコンテナを実行するためのサーバー</li>
                                    <li>B) Dockerイメージを保管・共有するレジストリ</li>
                                    <li>C) Dockerのコマンドを実行するためのツール</li>
                                    <li>D) Dockerのセキュリティを管理するサービス</li>
                                </ul>
                            </li>
                        </ol>
                        <details style="margin-top: 1rem;">
                            <summary style="cursor: pointer; color: #2496ED; font-weight: 600;">解答を見る</summary>
                            <div style="margin-top: 1rem; padding: 1rem; background-color: white; border-radius: 5px;">
                                <p><strong>1. B)</strong> Build once, Run anywhere - 一度ビルドすれば、どこでも実行できるという理念です。</p>
                                <p><strong>2. B)</strong> コンテナはホストOSのカーネルを共有します。これにより軽量で高速な起動が可能になります。</p>
                                <p><strong>3. C)</strong> Docker Engineはコンテナの実行とイメージの管理を担当する中核コンポーネントです。</p>
                                <p><strong>4. C)</strong> Dockerはプロセスレベルの隔離であり、完全なハードウェアレベルの隔離は仮想マシンの特徴です。</p>
                                <p><strong>5. B)</strong> Docker HubはDockerイメージを保管・共有するための公式レジストリです。</p>
                            </div>
                        </details>
                    </div>

                    <!-- まとめ -->
                    <h3 class="section-title">1.8 本章のまとめ</h3>
                    <div class="highlight">
                        <h5>重要ポイント</h5>
                        <ul>
                            <li><strong>Docker</strong>は、アプリケーションとその実行環境をコンテナとしてパッケージ化するプラットフォームです。</li>
                            <li><strong>コンテナ</strong>は仮想マシンよりも軽量で、起動が速く、リソース効率が高いという特徴があります。</li>
                            <li>Dockerは<strong>環境の一貫性</strong>を保証し、「私の環境では動く」問題を解決します。</li>
                            <li><strong>Docker Engine</strong>がコンテナ実行の中核であり、<strong>Docker CLI</strong>を通じて操作します。</li>
                            <li>Dockerのアーキテクチャは<strong>クライアント・サーバモデル</strong>を採用し、柔軟な運用を可能にしています。</li>
                            <li>実際の開発現場では、開発環境の統一、マイクロサービス、CI/CDなど様々な場面でDockerが活用されています。</li>
                        </ul>
                    </div>

                    <!-- 次章へのリンク -->
                    <div class="d-flex justify-content-between mt-5 mb-5">
                        <a href="../README.html" class="btn btn-secondary">← ガイドトップに戻る</a>
                        <a href="docker-learning-material-02.html" class="btn btn-primary">次の章: 環境構築と基本操作 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>

    <!-- Mermaid.js 初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>
