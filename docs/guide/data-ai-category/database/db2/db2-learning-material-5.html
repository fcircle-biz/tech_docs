<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DB2学習教材 第5章 - テーブル設計とインデックス基礎</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #003d73;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }

        /* タイトル */
        .chapter-title {
            color: #003d73;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #003d73;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #0062cc;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コード */
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }
        
        code {
            background-color: #f8f9fa;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            color: #d63384;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e6f1ff;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #003d73;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #003d73 !important;
            color: white !important;
        }

        .nav-link:hover {
            background-color: #0062cc !important;
            color: white !important;
        }

        /* テーブル */
        .table th {
            background-color: #f8f9fa;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">DB2学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../README.md">ガイドライン一覧</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav class="col-md-3 col-lg-2 d-md-block bg-light sidebar">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>目次</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="db2-learning-material-01.html">第1章: DB2の基本概念と環境構築</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="db2-learning-material-02.html">第2章: Docker環境でのDB2セットアップ</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="db2-learning-material-03.html">第3章: DB2クライアントツールの導入</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="db2-learning-material-04.html">第4章: DB2 SQLの基本</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="#chapter5">第5章: テーブル設計とインデックス基礎</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="db2-learning-material-06.html">第6章: DB2組み込み関数とストアドプロシージャ</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="db2-learning-material-07.html">第7章: ユーザー管理と基本的なセキュリティ</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="db2-learning-material-08.html">第8章: 基本的なデータベース管理操作</a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第5章: テーブル設計とインデックス基礎</h1>
                </div>

                <div id="chapter5">
                    <h2 class="chapter-title">テーブル設計とインデックス基礎</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>DB2でのテーブル設計の基本原則</li>
                            <li>テーブルスペースの概念と管理方法</li>
                            <li>インデックスの種類と作成方法</li>
                            <li>インデックス設計のベストプラクティス</li>
                            <li>基本的なパフォーマンス最適化のポイント</li>
                        </ul>
                    </div>

                    <!-- 5.1 DB2テーブル設計の原則 -->
                    <h3 class="section-title">5.1 DB2テーブル設計の原則</h3>
                    <p>効率的なDB2データベースの構築には、適切なテーブル設計が不可欠です。正規化、データ型選択、制約設計を通じて、データの整合性とパフォーマンスを両立させます。</p>

                    <h4>正規化の原則</h4>
                    <ul>
                        <li><strong>第1正規形（1NF）</strong>: 各列は原子的な値を持つ</li>
                        <li><strong>第2正規形（2NF）</strong>: 完全関数従属</li>
                        <li><strong>第3正規形（3NF）</strong>: 推移的関数従属の排除</li>
                        <li><strong>実践的な非正規化</strong>: パフォーマンスを考慮した適度な非正規化</li>
                    </ul>

                    <!-- 実習 5-1 -->
                    <div class="exercise-container">
                        <h5>実習 5-1: 正規化されたテーブル設計</h5>
                        <p>受注管理システムを例に、正規化されたテーブル構造を設計・実装します。</p>
                        
                        <h6>実行するSQL</h6>
                        <pre class="code-block"><code class="language-sql">-- カテゴリマスタテーブル
CREATE TABLE sales_dept.categories (
    category_id INTEGER NOT NULL PRIMARY KEY,
    category_name VARCHAR(50) NOT NULL UNIQUE,
    description VARCHAR(200)
);

-- 商品マスタテーブル
CREATE TABLE sales_dept.products_master (
    product_id INTEGER NOT NULL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    category_id INTEGER NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL CHECK (unit_price > 0),
    description VARCHAR(500),
    is_active CHAR(1) DEFAULT 'Y' CHECK (is_active IN ('Y', 'N')),
    created_date DATE DEFAULT CURRENT DATE,
    FOREIGN KEY (category_id) REFERENCES sales_dept.categories(category_id)
);

-- 顧客マスタテーブル
CREATE TABLE sales_dept.customers_master (
    customer_id INTEGER NOT NULL PRIMARY KEY,
    company_name VARCHAR(100) NOT NULL,
    contact_name VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    address VARCHAR(200),
    city VARCHAR(50),
    postal_code VARCHAR(10),
    created_date DATE DEFAULT CURRENT DATE
);

-- 受注ヘッダテーブル
CREATE TABLE sales_dept.order_headers (
    order_id INTEGER NOT NULL PRIMARY KEY,
    customer_id INTEGER NOT NULL,
    order_date DATE NOT NULL DEFAULT CURRENT DATE,
    delivery_date DATE,
    status VARCHAR(20) DEFAULT 'PENDING' 
        CHECK (status IN ('PENDING', 'CONFIRMED', 'SHIPPED', 'DELIVERED', 'CANCELLED')),
    total_amount DECIMAL(12,2),
    notes VARCHAR(500),
    FOREIGN KEY (customer_id) REFERENCES sales_dept.customers_master(customer_id)
);

-- 受注明細テーブル
CREATE TABLE sales_dept.order_details (
    order_id INTEGER NOT NULL,
    line_number INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    unit_price DECIMAL(10,2) NOT NULL CHECK (unit_price > 0),
    line_total DECIMAL(12,2) GENERATED ALWAYS AS (quantity * unit_price),
    PRIMARY KEY (order_id, line_number),
    FOREIGN KEY (order_id) REFERENCES sales_dept.order_headers(order_id),
    FOREIGN KEY (product_id) REFERENCES sales_dept.products_master(product_id)
);

-- サンプルデータの挿入
INSERT INTO sales_dept.categories VALUES 
(1, 'Electronics', 'Electronic devices and accessories'),
(2, 'Books', 'Physical and digital books'),
(3, 'Clothing', 'Apparel and accessories');

INSERT INTO sales_dept.products_master VALUES 
(101, 'Laptop Computer', 1, 999.99, 'High-performance laptop', 'Y', CURRENT DATE),
(102, 'Programming Book', 2, 49.99, 'Learn programming fundamentals', 'Y', CURRENT DATE),
(103, 'T-Shirt', 3, 19.99, 'Comfortable cotton t-shirt', 'Y', CURRENT DATE);

INSERT INTO sales_dept.customers_master VALUES 
(1001, 'Tech Solutions Inc.', 'John Smith', 'john@techsolutions.com', 
 '555-1234', '123 Business Ave', 'New York', '10001', CURRENT DATE);

-- 正規化の確認
SELECT 
    p.product_name,
    c.category_name,
    p.unit_price
FROM sales_dept.products_master p
JOIN sales_dept.categories c ON p.category_id = c.category_id;</code></pre>

                        <h6>設計のポイント</h6>
                        <ul>
                            <li>各テーブルが単一の責任を持つ</li>
                            <li>適切な外部キー制約によるデータ整合性</li>
                            <li>計算可能な列は生成列として定義</li>
                            <li>ビジネスルールをCHECK制約で実装</li>
                        </ul>
                    </div>

                    <!-- 5.2 テーブルスペースの理解と管理 -->
                    <h3 class="section-title">5.2 テーブルスペースの理解と管理</h3>
                    <p>テーブルスペースは、DB2における物理的なストレージの抽象化レイヤーです。適切なテーブルスペース設計により、パフォーマンスと管理性を向上させることができます。</p>

                    <!-- 実習 5-2 -->
                    <div class="exercise-container">
                        <h5>実習 5-2: テーブルスペースの作成と管理</h5>
                        <p>専用のテーブルスペースを作成し、テーブルを配置する方法を学習します。</p>
                        
                        <h6>実行するSQL</h6>
                        <pre class="code-block"><code class="language-sql">-- テーブルスペース情報の確認
SELECT 
    TBSPACE,
    TBSPACETYPE,
    DATATYPE,
    PAGESIZE,
    TOTALFRAMES,
    USABLEFRAMES
FROM SYSCAT.TABLESPACES;

-- 新しいテーブルスペースの作成
CREATE TABLESPACE sales_data
    MANAGED BY AUTOMATIC STORAGE
    USING STOGROUP IBMSTOGROUP
    INITIALSIZE 100M
    INCREASESIZE 50M
    MAXSIZE NONE;

-- テーブルスペースを指定したテーブル作成
CREATE TABLE sales_dept.large_orders (
    order_id BIGINT NOT NULL PRIMARY KEY,
    customer_id INTEGER NOT NULL,
    order_date DATE NOT NULL,
    total_amount DECIMAL(15,2),
    order_details CLOB(1M)
) IN sales_data;

-- テーブルスペースの使用状況確認
SELECT 
    TBSP_NAME,
    TBSP_TYPE,
    TBSP_TOTAL_SIZE_KB / 1024 as SIZE_MB,
    TBSP_USED_SIZE_KB / 1024 as USED_MB,
    TBSP_FREE_SIZE_KB / 1024 as FREE_MB,
    DECIMAL(FLOAT(TBSP_USED_SIZE_KB) / FLOAT(TBSP_TOTAL_SIZE_KB) * 100, 5, 2) as USAGE_PERCENT
FROM SYSIBMADM.TBSP_UTILIZATION
WHERE TBSP_NAME = 'SALES_DATA';

-- インデックス用テーブルスペースの作成
CREATE TABLESPACE sales_indexes
    MANAGED BY AUTOMATIC STORAGE
    USING STOGROUP IBMSTOGROUP
    INITIALSIZE 50M
    INCREASESIZE 25M;</code></pre>

                        <h6>テーブルスペースの種類</h6>
                        <ul>
                            <li><strong>Regular</strong>: 通常のテーブルとインデックス用</li>
                            <li><strong>Large</strong>: 大きなテーブル用（32KB以上のページサイズ）</li>
                            <li><strong>System Temporary</strong>: ソート操作用の一時領域</li>
                            <li><strong>User Temporary</strong>: ユーザー定義の一時テーブル用</li>
                        </ul>
                    </div>

                    <!-- 5.3 インデックスの基本概念 -->
                    <h3 class="section-title">5.3 インデックスの基本概念</h3>
                    <p>インデックスは、データの検索速度を向上させる重要な仕組みです。適切なインデックス設計により、クエリパフォーマンスを大幅に改善できます。</p>

                    <h4>DB2のインデックス種類</h4>
                    <div class="table-responsive">
                        <table class="table table-striped">
                            <thead>
                                <tr>
                                    <th>インデックス種類</th>
                                    <th>特徴</th>
                                    <th>用途</th>
                                    <th>パフォーマンス</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>B-Tree Index</td>
                                    <td>最も一般的</td>
                                    <td>等価検索、範囲検索</td>
                                    <td>高速</td>
                                </tr>
                                <tr>
                                    <td>Unique Index</td>
                                    <td>重複値を許可しない</td>
                                    <td>主キー、ユニーク制約</td>
                                    <td>高速</td>
                                </tr>
                                <tr>
                                    <td>Composite Index</td>
                                    <td>複数列を含む</td>
                                    <td>複合条件検索</td>
                                    <td>条件による</td>
                                </tr>
                                <tr>
                                    <td>Clustering Index</td>
                                    <td>物理的順序を決定</td>
                                    <td>範囲検索の最適化</td>
                                    <td>非常に高速</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- 実習 5-3 -->
                    <div class="exercise-container">
                        <h5>実習 5-3: 各種インデックスの作成と効果測定</h5>
                        <p>異なるタイプのインデックスを作成し、パフォーマンスへの影響を確認します。</p>
                        
                        <h6>実行するSQL</h6>
                        <pre class="code-block"><code class="language-sql">-- 大量データの準備
INSERT INTO sales_dept.order_headers (order_id, customer_id, order_date, status, total_amount)
SELECT 
    1000 + ROW_NUMBER() OVER(ORDER BY t1.column_1),
    1001,
    CURRENT DATE - (MOD(ROW_NUMBER() OVER(ORDER BY t1.column_1), 365)) DAYS,
    CASE MOD(ROW_NUMBER() OVER(ORDER BY t1.column_1), 4)
        WHEN 0 THEN 'PENDING'
        WHEN 1 THEN 'CONFIRMED'
        WHEN 2 THEN 'SHIPPED'
        ELSE 'DELIVERED'
    END,
    DECIMAL(RAND() * 1000 + 100, 10, 2)
FROM SYSIBM.SYSDUMMY1 t1,
     SYSIBM.SYSDUMMY1 t2,
     SYSIBM.SYSDUMMY1 t3,
     SYSIBM.SYSDUMMY1 t4;

-- インデックス作成前の実行計画確認
EXPLAIN PLAN FOR
SELECT * FROM sales_dept.order_headers 
WHERE order_date BETWEEN '2024-01-01' AND '2024-03-31';

-- 単一列インデックスの作成
CREATE INDEX sales_dept.idx_order_date 
ON sales_dept.order_headers(order_date) 
IN sales_indexes;

-- 複合インデックスの作成
CREATE INDEX sales_dept.idx_customer_date 
ON sales_dept.order_headers(customer_id, order_date) 
IN sales_indexes;

-- ユニークインデックスの作成
CREATE UNIQUE INDEX sales_dept.idx_order_id_unique 
ON sales_dept.order_headers(order_id) 
IN sales_indexes;

-- ステータス列のインデックス（カーディナリティが低い）
CREATE INDEX sales_dept.idx_status 
ON sales_dept.order_headers(status) 
INCLUDE (total_amount)
IN sales_indexes;

-- インデックス作成後の実行計画確認
EXPLAIN PLAN FOR
SELECT * FROM sales_dept.order_headers 
WHERE order_date BETWEEN '2024-01-01' AND '2024-03-31';

-- インデックス情報の確認
SELECT 
    INDSCHEMA,
    INDNAME,
    TABNAME,
    COLNAMES,
    UNIQUERULE,
    INDEXTYPE
FROM SYSCAT.INDEXES 
WHERE INDSCHEMA = 'SALES_DEPT'
ORDER BY TABNAME, INDNAME;

-- インデックス使用統計の確認
SELECT 
    TABSCHEMA,
    TABNAME,
    INDSCHEMA,
    INDNAME,
    NLEAF,
    NLEVELS,
    STATS_TIME
FROM SYSCAT.INDEXES 
WHERE INDSCHEMA = 'SALES_DEPT';</code></pre>

                        <h6>インデックス設計のポイント</h6>
                        <ul>
                            <li>WHERE句で頻繁に使用される列</li>
                            <li>JOIN条件で使用される列</li>
                            <li>ORDER BY句で使用される列</li>
                            <li>カーディナリティ（値の種類の多さ）を考慮</li>
                            <li>UPDATE/INSERTの頻度とのバランス</li>
                        </ul>
                    </div>

                    <!-- 5.4 インデックス設計のベストプラクティス -->
                    <h3 class="section-title">5.4 インデックス設計のベストプラクティス</h3>
                    <p>効果的なインデックス設計には、クエリパターンの分析、インデックスの選択性、メンテナンスコストの考慮が重要です。</p>

                    <!-- 実習 5-4 -->
                    <div class="exercise-container">
                        <h5>実習 5-4: インデックス最適化の実践</h5>
                        <p>実際のクエリパターンに基づいてインデックスを最適化する方法を学習します。</p>
                        
                        <h6>実行するSQL</h6>
                        <pre class="code-block"><code class="language-sql">-- クエリパターンの分析
-- パターン1: 顧客別の受注一覧
SELECT customer_id, COUNT(*) as order_count, SUM(total_amount) as total_sales
FROM sales_dept.order_headers 
WHERE customer_id = 1001
GROUP BY customer_id;

-- パターン2: 期間別受注検索
SELECT * FROM sales_dept.order_headers 
WHERE order_date BETWEEN '2024-01-01' AND '2024-03-31'
  AND status = 'DELIVERED';

-- パターン3: 高額受注の検索
SELECT order_id, customer_id, total_amount
FROM sales_dept.order_headers 
WHERE total_amount > 500.00
ORDER BY total_amount DESC;

-- 最適化されたインデックスの作成
-- パターン1用: 顧客ID -> インデックス既存なので OK

-- パターン2用: 複合インデックス（日付 + ステータス）
CREATE INDEX sales_dept.idx_date_status 
ON sales_dept.order_headers(order_date, status, total_amount) 
IN sales_indexes;

-- パターン3用: 金額での範囲検索用
CREATE INDEX sales_dept.idx_amount_desc 
ON sales_dept.order_headers(total_amount DESC) 
IN sales_indexes;

-- カバリングインデックスの例（INCLUDEカラムを使用）
CREATE INDEX sales_dept.idx_customer_covering 
ON sales_dept.order_headers(customer_id) 
INCLUDE (order_date, status, total_amount)
IN sales_indexes;

-- インデックス効果の測定
-- RUNSTATS実行（統計情報の更新）
RUNSTATS ON TABLE sales_dept.order_headers 
  WITH DISTRIBUTION AND DETAILED INDEXES ALL;

-- インデックス選択性の確認
SELECT 
    TABSCHEMA,
    TABNAME,
    COLNAME,
    COLCARD,
    HIGH2KEY,
    LOW2KEY
FROM SYSCAT.COLUMNS 
WHERE TABSCHEMA = 'SALES_DEPT' AND TABNAME = 'ORDER_HEADERS'
ORDER BY COLCARD DESC;

-- 使用されていないインデックスの確認（実際の運用では有用）
SELECT 
    TABSCHEMA,
    TABNAME,
    INDSCHEMA,
    INDNAME,
    STATS_TIME
FROM SYSCAT.INDEXES 
WHERE INDSCHEMA = 'SALES_DEPT'
  AND STATS_TIME IS NULL;</code></pre>

                        <h6>インデックス最適化の指針</h6>
                        <ul>
                            <li><strong>選択性の高い列</strong>: カーディナリティが高い列を優先</li>
                            <li><strong>複合インデックスの列順</strong>: 選択性の順に配置</li>
                            <li><strong>カバリングインデックス</strong>: INCLUDEを活用してテーブルアクセスを回避</li>
                            <li><strong>定期的な統計更新</strong>: RUNSTATSでオプティマイザーに最新情報を提供</li>
                        </ul>
                    </div>

                    <!-- 5.5 パフォーマンス監視と最適化 -->
                    <h3 class="section-title">5.5 パフォーマンス監視と最適化</h3>
                    <p>DB2の監視機能を使用して、テーブルとインデックスのパフォーマンスを継続的に改善します。</p>

                    <!-- 実習 5-5 -->
                    <div class="exercise-container">
                        <h5>実習 5-5: パフォーマンス監視の実践</h5>
                        <p>DB2の監視機能を使用して、データベースのパフォーマンスを分析します。</p>
                        
                        <h6>実行するSQL</h6>
                        <pre class="code-block"><code class="language-sql">-- テーブルアクセス統計の確認
SELECT 
    TABSCHEMA,
    TABNAME,
    ROWS_READ,
    ROWS_INSERTED,
    ROWS_UPDATED,
    ROWS_DELETED,
    OVERFLOW_ACCESSES,
    PAGE_REORGS
FROM SYSCAT.TABLES 
WHERE TABSCHEMA = 'SALES_DEPT'
ORDER BY ROWS_READ DESC;

-- インデックス使用統計
SELECT 
    INDSCHEMA,
    INDNAME,
    TABNAME,
    NLEAF,
    NLEVELS,
    SEQUENTIAL_PAGES,
    DENSITY
FROM SYSCAT.INDEXES 
WHERE INDSCHEMA = 'SALES_DEPT'
ORDER BY NLEAF DESC;

-- バッファープール使用状況
SELECT 
    BP_NAME,
    POOL_DATA_P_READS,
    POOL_DATA_L_READS,
    DECIMAL((1 - FLOAT(POOL_DATA_P_READS)/FLOAT(POOL_DATA_L_READS)) * 100, 5, 2) as HIT_RATIO,
    POOL_INDEX_P_READS,
    POOL_INDEX_L_READS
FROM SYSIBMADM.BP_HITRATIO;

-- 実行計画の分析
EXPLAIN PLAN FOR
SELECT 
    h.order_id,
    h.order_date,
    h.total_amount,
    c.company_name
FROM sales_dept.order_headers h
JOIN sales_dept.customers_master c ON h.customer_id = c.customer_id
WHERE h.order_date > '2024-01-01'
  AND h.total_amount > 100.00
ORDER BY h.total_amount DESC;

-- 実行計画の確認
SELECT 
    OPERATOR_TYPE,
    OBJECT_NAME,
    TOTAL_COST,
    CARDINALITY
FROM EXPLAIN_INSTANCE 
WHERE EXPLAIN_TIME = (SELECT MAX(EXPLAIN_TIME) FROM EXPLAIN_INSTANCE);

-- ロック待機状況の確認
SELECT 
    AGENT_ID,
    APPLICATION_HANDLE,
    LOCK_OBJECT_TYPE,
    LOCK_MODE,
    LOCK_STATUS,
    LOCK_WAIT_START_TIME
FROM SYSIBMADM.LOCKWAITS;

-- 長時間実行されているSQL文の確認
SELECT 
    APPLICATION_HANDLE,
    STMT_TEXT,
    TOTAL_EXEC_TIME,
    STMT_EXEC_TIME,
    ROWS_READ,
    ROWS_WRITTEN
FROM SYSIBMADM.LONG_RUNNING_SQL
WHERE STMT_EXEC_TIME > 1000;</code></pre>

                        <h6>パフォーマンス改善のアプローチ</h6>
                        <ul>
                            <li><strong>実行計画の分析</strong>: EXPLAIN機能でクエリの実行パスを確認</li>
                            <li><strong>統計情報の更新</strong>: 定期的なRUNSTATS実行</li>
                            <li><strong>インデックスの見直し</strong>: 使用頻度と効果の分析</li>
                            <li><strong>テーブル設計の最適化</strong>: 非正規化やパーティション化の検討</li>
                        </ul>
                    </div>

                    <!-- 5.6 設計時の考慮事項 -->
                    <h3 class="section-title">5.6 設計時の考慮事項</h3>
                    <p>実際のシステム開発では、理論的な設計に加えて、運用面や将来の拡張性も考慮する必要があります。</p>

                    <div class="highlight">
                        <h5>設計時のチェックリスト</h5>
                        <ul>
                            <li><strong>データ量の見積もり</strong>: 初期データ量と成長率の予測</li>
                            <li><strong>アクセスパターン</strong>: 読み取り中心か更新中心かの分析</li>
                            <li><strong>レスポンス要件</strong>: 許容可能な応答時間の設定</li>
                            <li><strong>可用性要件</strong>: バックアップとリカバリの要件</li>
                            <li><strong>セキュリティ要件</strong>: データ保護と監査の要件</li>
                            <li><strong>将来の拡張性</strong>: スケールアウトの計画</li>
                        </ul>
                    </div>

                    <div class="warning">
                        <h5>⚠️ よくある設計ミス</h5>
                        <ul>
                            <li>インデックスの過度な作成（更新性能の低下）</li>
                            <li>不適切なデータ型選択（ストレージの無駄遣い）</li>
                            <li>外部キー制約の不備（データ不整合）</li>
                            <li>テーブルスペース設計の軽視（I/Oボトルネック）</li>
                            <li>統計情報の更新忘れ（実行計画の劣化）</li>
                        </ul>
                    </div>

                    <!-- 理解度確認 -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li><strong>DB2でインデックスを特定のテーブルスペースに作成するSQL文の構文で正しいのはどれですか？</strong>
                                <ol type="a">
                                    <li>CREATE INDEX index_name ON table_name(column) TABLESPACE ts_name</li>
                                    <li>CREATE INDEX index_name ON table_name(column) IN ts_name</li>
                                    <li>CREATE INDEX index_name ON table_name(column) USING ts_name</li>
                                    <li>CREATE INDEX index_name ON table_name(column) TO ts_name</li>
                                </ol>
                            </li>
                            <li><strong>複合インデックスを作成する際の列の順序として最適なのはどれですか？</strong>
                                <ol type="a">
                                    <li>アルファベット順</li>
                                    <li>データサイズの小さい順</li>
                                    <li>選択性（カーディナリティ）の高い順</li>
                                    <li>使用頻度の低い順</li>
                                </ol>
                            </li>
                            <li><strong>DB2でテーブルとインデックスの統計情報を更新するコマンドはどれですか？</strong>
                                <ol type="a">
                                    <li>UPDATE STATISTICS</li>
                                    <li>ANALYZE TABLE</li>
                                    <li>RUNSTATS</li>
                                    <li>COMPUTE STATS</li>
                                </ol>
                            </li>
                            <li><strong>INCLUDEオプション付きインデックスの主な利点は何ですか？</strong>
                                <ol type="a">
                                    <li>インデックスサイズの削減</li>
                                    <li>更新性能の向上</li>
                                    <li>テーブルアクセスの回避（カバリング）</li>
                                    <li>メモリ使用量の削減</li>
                                </ol>
                            </li>
                        </ol>
                        
                        <details style="margin-top: 1rem;">
                            <summary>解答を見る</summary>
                            <div style="margin-top: 0.5rem;">
                                <p><strong>解答:</strong></p>
                                <ol>
                                    <li>b) CREATE INDEX index_name ON table_name(column) IN ts_name</li>
                                    <li>c) 選択性（カーディナリティ）の高い順</li>
                                    <li>c) RUNSTATS</li>
                                    <li>c) テーブルアクセスの回避（カバリング）</li>
                                </ol>
                            </div>
                        </details>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="db2-learning-material-04.html" class="btn btn-secondary">← 前の章</a>
                        <a href="db2-learning-material-06.html" class="btn btn-primary">次の章 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
</body>
</html>