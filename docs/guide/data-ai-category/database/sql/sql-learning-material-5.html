<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL学習教材 第5章 - 結合（JOIN）によるテーブル連携</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        
        .navbar {
            background-color: #1976d2;
        }
        
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        
        .chapter-title {
            color: #1976d2;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #1976d2;
            padding-bottom: 0.5rem;
        }
        
        .section-title {
            color: #42a5f5;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        
        .quiz-container {
            background-color: #e1f5fe;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #1976d2;
        }
        
        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }
        
        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }
        
        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }
        
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }
        
        .nav-link.active {
            background-color: #1976d2 !important;
            color: white !important;
        }
        
        .join-type {
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }
        
        .inner-join { background-color: #e8f5e8; border-left: 4px solid #4caf50; }
        .left-join { background-color: #e3f2fd; border-left: 4px solid #2196f3; }
        .right-join { background-color: #fff3e0; border-left: 4px solid #ff9800; }
        .full-join { background-color: #f3e5f5; border-left: 4px solid #9c27b0; }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">SQL学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="../../README.md">ガイドTOP</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
                <div class="position-sticky pt-3">
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="sql-learning-material-1.html">第1章: 基礎概念</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="sql-learning-material-2.html">第2章: データ型</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="sql-learning-material-3.html">第3章: CRUD操作</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="sql-learning-material-4.html">第4章: SELECT文の詳細</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="sql-learning-material-5.html">第5章: 結合（JOIN）</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="sql-learning-material-6.html">第6章: 集計とグループ化</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="sql-learning-material-7.html">第7章: サブクエリ</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="sql-learning-material-8.html">第8章: パフォーマンス</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="sql-learning-material-9.html">第9章: トランザクション</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="sql-learning-material-10.html">第10章: DB設計</a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第5章: 結合（JOIN）によるテーブル連携</h1>
                </div>

                <div id="chapter5">
                    <h2 class="chapter-title">結合（JOIN）によるテーブル連携</h2>
                    
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>JOINの基本概念と必要性の理解</li>
                            <li>INNER JOINによる内部結合</li>
                            <li>LEFT/RIGHT JOINによる外部結合</li>
                            <li>FULL OUTER JOINによる完全外部結合</li>
                            <li>複数テーブルの結合</li>
                            <li>自己結合（Self JOIN）の概念と活用</li>
                        </ul>
                    </div>

                    <h3 class="section-title">5.1 JOINとは何か</h3>
                    <p>
                        JOIN（結合）は、複数のテーブルから関連するデータを組み合わせて取得するSQL機能です。
                        リレーショナルデータベースの核心的な概念の一つです。
                    </p>

                    <div class="mermaid">
                        erDiagram
                            CATEGORIES {
                                int category_id PK
                                string category_name
                            }
                            PRODUCTS {
                                int product_id PK
                                string product_name
                                decimal price
                                int category_id FK
                            }
                            CUSTOMERS {
                                int customer_id PK
                                string name
                                string email
                            }
                            ORDERS {
                                int order_id PK
                                int customer_id FK
                                int product_id FK
                                int quantity
                                date order_date
                            }
                            
                            CATEGORIES ||--o{ PRODUCTS : "belongs to"
                            CUSTOMERS ||--o{ ORDERS : "places"
                            PRODUCTS ||--o{ ORDERS : "contains"
                    </div>

                    <h4>JOINが必要な理由</h4>
                    <ul>
                        <li><strong>正規化</strong>: データの重複を避けるため、関連データを別テーブルに分離</li>
                        <li><strong>データ整合性</strong>: 外部キー制約によりデータの一貫性を保持</li>
                        <li><strong>効率性</strong>: 必要な時だけ関連データを結合して取得</li>
                        <li><strong>柔軟性</strong>: 様々な組み合わせでデータを分析可能</li>
                    </ul>

                    <h3 class="section-title">5.2 INNER JOIN（内部結合）</h3>
                    <div class="inner-join">
                        <h6><strong>INNER JOIN</strong></h6>
                        <p>両方のテーブルに一致するレコードのみを取得します。最も基本的で使用頻度の高いJOINです。</p>
                    </div>

                    <div class="exercise-container">
                        <h5>実習 5-1: INNER JOINの基本</h5>
                        <p>商品とカテゴリのテーブルを結合して、商品情報にカテゴリ名を含めて表示します。</p>
                        <h6>実行例</h6>
                        <pre class="code-block"><code class="language-sql">-- 基本的なINNER JOIN
SELECT 
    p.product_name,
    p.price,
    c.category_name
FROM products p
INNER JOIN categories c ON p.category_id = c.category_id;

-- テーブルエイリアスを使わない場合（推奨されない）
SELECT 
    products.product_name,
    products.price,
    categories.category_name
FROM products
INNER JOIN categories ON products.category_id = categories.category_id;

-- WHERE句と組み合わせ
SELECT 
    p.product_name,
    p.price,
    c.category_name
FROM products p
INNER JOIN categories c ON p.category_id = c.category_id
WHERE p.price >= 2000
ORDER BY p.price DESC;</code></pre>
                    </div>

                    <div class="exercise-container">
                        <h5>実習 5-2: 注文情報の詳細表示</h5>
                        <p>注文、顧客、商品の3つのテーブルを結合して注文の詳細情報を表示します。</p>
                        <h6>実行例</h6>
                        <pre class="code-block"><code class="language-sql">-- 複数テーブルのINNER JOIN
SELECT 
    o.order_id,
    c.name AS customer_name,
    p.product_name,
    p.price,
    o.quantity,
    (p.price * o.quantity) AS total_amount,
    o.order_date
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id
INNER JOIN products p ON o.product_id = p.product_id
ORDER BY o.order_date DESC;

-- カテゴリ情報も含めた詳細表示
SELECT 
    o.order_id,
    c.name AS customer_name,
    c.email,
    p.product_name,
    cat.category_name,
    p.price,
    o.quantity,
    (p.price * o.quantity) AS total_amount,
    o.order_date,
    o.status
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id
INNER JOIN products p ON o.product_id = p.product_id
INNER JOIN categories cat ON p.category_id = cat.category_id
WHERE o.status = 'confirmed'
ORDER BY o.order_date DESC;</code></pre>
                    </div>

                    <h3 class="section-title">5.3 LEFT JOIN（左外部結合）</h3>
                    <div class="left-join">
                        <h6><strong>LEFT JOIN</strong></h6>
                        <p>左側テーブルの全レコードと、右側テーブルの一致するレコードを取得します。右側に一致するデータがない場合はNULLが表示されます。</p>
                    </div>

                    <div class="exercise-container">
                        <h5>実習 5-3: LEFT JOINの活用</h5>
                        <p>全ての顧客を表示し、注文履歴がある場合は注文情報も表示します。</p>
                        <h6>実行例</h6>
                        <pre class="code-block"><code class="language-sql">-- 全顧客と注文情報（注文がない顧客も表示）
SELECT 
    c.customer_id,
    c.name,
    c.email,
    o.order_id,
    o.order_date,
    o.status
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
ORDER BY c.name, o.order_date DESC;

-- 注文していない顧客のみを抽出
SELECT 
    c.customer_id,
    c.name,
    c.email,
    c.created_at
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
WHERE o.customer_id IS NULL
ORDER BY c.created_at DESC;

-- 全商品と売上情報（売上がない商品も表示）
SELECT 
    p.product_id,
    p.product_name,
    p.price,
    p.stock_quantity,
    COUNT(o.order_id) AS order_count,
    COALESCE(SUM(o.quantity), 0) AS total_sold
FROM products p
LEFT JOIN orders o ON p.product_id = o.product_id
GROUP BY p.product_id, p.product_name, p.price, p.stock_quantity
ORDER BY total_sold DESC;</code></pre>
                    </div>

                    <h3 class="section-title">5.4 RIGHT JOIN（右外部結合）</h3>
                    <div class="right-join">
                        <h6><strong>RIGHT JOIN</strong></h6>
                        <p>右側テーブルの全レコードと、左側テーブルの一致するレコードを取得します。LEFT JOINの逆の動作をします。</p>
                    </div>

                    <div class="exercise-container">
                        <h5>実習 5-4: RIGHT JOINの理解</h5>
                        <p>RIGHT JOINの動作をLEFT JOINと比較して理解します。</p>
                        <h6>実行例</h6>
                        <pre class="code-block"><code class="language-sql">-- RIGHT JOIN例（あまり使用されない）
SELECT 
    c.name,
    o.order_id,
    o.order_date
FROM orders o
RIGHT JOIN customers c ON o.customer_id = c.customer_id
ORDER BY c.name;

-- 上記と同じ結果をLEFT JOINで表現（推奨）
SELECT 
    c.name,
    o.order_id,
    o.order_date
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
ORDER BY c.name;</code></pre>
                        <h6>ポイント</h6>
                        <p>RIGHT JOINはLEFT JOINで書き換え可能で、LEFT JOINの方が理解しやすいため、実際の開発ではLEFT JOINが好まれます。</p>
                    </div>

                    <h3 class="section-title">5.5 FULL OUTER JOIN（完全外部結合）</h3>
                    <div class="full-join">
                        <h6><strong>FULL OUTER JOIN</strong></h6>
                        <p>両方のテーブルの全レコードを取得します。一致しないレコードはNULLで補完されます。</p>
                    </div>

                    <div class="exercise-container">
                        <h5>実習 5-5: FULL OUTER JOINの使用</h5>
                        <p>完全外部結合を使って、顧客と注文の完全な対応関係を確認します。</p>
                        <h6>実行例</h6>
                        <pre class="code-block"><code class="language-sql">-- FULL OUTER JOIN（PostgreSQL）
SELECT 
    COALESCE(c.name, 'Unknown Customer') AS customer_name,
    COALESCE(o.order_id::text, 'No Order') AS order_info,
    o.order_date
FROM customers c
FULL OUTER JOIN orders o ON c.customer_id = o.customer_id
ORDER BY c.name, o.order_date;

-- 実践的な使用例：データの整合性チェック
-- 孤立した注文データ（顧客情報が削除された注文）の検出
SELECT 
    'Orphaned Order' AS issue_type,
    o.order_id,
    o.customer_id,
    'Customer not found' AS description
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.customer_id
WHERE c.customer_id IS NULL
UNION
-- 孤立した商品データ（カテゴリが削除された商品）の検出
SELECT 
    'Orphaned Product' AS issue_type,
    p.product_id::text,
    p.category_id,
    'Category not found' AS description
FROM products p
LEFT JOIN categories cat ON p.category_id = cat.category_id
WHERE cat.category_id IS NULL;</code></pre>
                    </div>

                    <h3 class="section-title">5.6 自己結合（Self JOIN）</h3>
                    <p>
                        自己結合は、同じテーブルを自分自身と結合する技術です。
                        階層構造や関連データが同じテーブル内にある場合に使用します。
                    </p>

                    <div class="exercise-container">
                        <h5>実習 5-6: 自己結合の実践</h5>
                        <p>従業員と上司の関係を管理するテーブルを作成し、自己結合を実践します。</p>
                        <h6>準備</h6>
                        <pre class="code-block"><code class="language-sql">-- 従業員テーブル（上司情報を含む）
CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    position VARCHAR(50),
    manager_id INTEGER,
    salary DECIMAL(10,2),
    hire_date DATE,
    FOREIGN KEY (manager_id) REFERENCES employees(employee_id)
);

-- サンプルデータ挿入
INSERT INTO employees (name, position, manager_id, salary, hire_date) VALUES
    ('田中社長', '社長', NULL, 1000000, '2020-01-01'),
    ('佐藤部長', '部長', 1, 800000, '2020-04-01'),
    ('山田課長', '課長', 2, 600000, '2021-01-15'),
    ('鈴木主任', '主任', 3, 450000, '2021-06-01'),
    ('高橋員', '一般', 4, 350000, '2022-04-01'),
    ('伊藤員', '一般', 4, 340000, '2022-10-01');</code></pre>

                        <h6>自己結合の実行例</h6>
                        <pre class="code-block"><code class="language-sql">-- 従業員と上司の関係表示
SELECT 
    e.name AS employee_name,
    e.position,
    e.salary,
    m.name AS manager_name,
    m.position AS manager_position
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.employee_id
ORDER BY e.salary DESC;

-- 特定の上司の部下一覧
SELECT 
    m.name AS manager_name,
    e.name AS subordinate_name,
    e.position,
    e.salary
FROM employees e
INNER JOIN employees m ON e.manager_id = m.employee_id
WHERE m.name = '山田課長'
ORDER BY e.salary DESC;

-- 階層レベルの表示（2階層）
SELECT 
    gm.name AS grand_manager,
    m.name AS manager,
    e.name AS employee,
    e.position,
    e.salary
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.employee_id
LEFT JOIN employees gm ON m.manager_id = gm.employee_id
WHERE e.manager_id IS NOT NULL
ORDER BY gm.name, m.name, e.name;</code></pre>
                    </div>

                    <h3 class="section-title">5.7 JOINの最適化と注意点</h3>

                    <div class="warning">
                        <h6>JOINのパフォーマンス最適化</h6>
                        <ul>
                            <li><strong>適切なインデックス</strong>: JOIN条件で使用する列にはインデックスを設定</li>
                            <li><strong>WHERE句の配置</strong>: 結合前にデータを絞り込む</li>
                            <li><strong>必要な列のみ選択</strong>: SELECT * は避け、必要な列のみを指定</li>
                            <li><strong>結合順序</strong>: データ量の少ないテーブルから結合</li>
                        </ul>
                    </div>

                    <div class="exercise-container">
                        <h5>実習 5-7: 複雑なJOINクエリの最適化</h5>
                        <p>複数のテーブルを結合する複雑なクエリを作成し、最適化を実践します。</p>
                        <h6>実行例</h6>
                        <pre class="code-block"><code class="language-sql">-- 最適化前：非効率なクエリ
SELECT *
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id
INNER JOIN products p ON o.product_id = p.product_id
INNER JOIN categories cat ON p.category_id = cat.category_id;

-- 最適化後：必要な列のみ、条件で絞り込み
SELECT 
    o.order_id,
    c.name AS customer_name,
    p.product_name,
    cat.category_name,
    p.price,
    o.quantity,
    (p.price * o.quantity) AS total_amount,
    o.order_date
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id
INNER JOIN products p ON o.product_id = p.product_id  
INNER JOIN categories cat ON p.category_id = cat.category_id
WHERE o.order_date >= CURRENT_DATE - INTERVAL '30 days'  -- 直近30日
  AND o.status = 'confirmed'                              -- 確定済み注文のみ
ORDER BY o.order_date DESC
LIMIT 100;  -- 結果を制限

-- サブクエリとJOINの組み合わせ
SELECT 
    c.name,
    c.email,
    recent_orders.order_count,
    recent_orders.total_amount
FROM customers c
INNER JOIN (
    SELECT 
        customer_id,
        COUNT(*) AS order_count,
        SUM(p.price * o.quantity) AS total_amount
    FROM orders o
    INNER JOIN products p ON o.product_id = p.product_id
    WHERE o.order_date >= CURRENT_DATE - INTERVAL '30 days'
    GROUP BY customer_id
) recent_orders ON c.customer_id = recent_orders.customer_id
WHERE recent_orders.total_amount > 10000
ORDER BY recent_orders.total_amount DESC;</code></pre>
                    </div>

                    <!-- 理解度確認 -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <strong>問題1:</strong> INNER JOINとLEFT JOINの主な違いは何ですか？
                            </li>
                            <li>
                                <strong>問題2:</strong> 以下のクエリの結果は何件になりますか？
                                <pre class="code-block"><code class="language-sql">-- 顧客テーブル: 10件のレコード
-- 注文テーブル: 15件のレコード（一部の顧客は複数注文）
SELECT * FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id;</code></pre>
                            </li>
                            <li>
                                <strong>問題3:</strong> 自己結合が必要になる典型的なケースを2つ挙げてください。
                            </li>
                            <li>
                                <strong>問題4:</strong> 以下のクエリを最適化してください：
                                <pre class="code-block"><code class="language-sql">SELECT *
FROM products p, categories c
WHERE p.category_id = c.category_id;</code></pre>
                            </li>
                            <li>
                                <strong>問題5:</strong> LEFT JOINで「右側テーブルにデータがないレコードのみ」を取得するにはどうしますか？
                            </li>
                        </ol>
                        
                        <details class="mt-3">
                            <summary>解答を表示</summary>
                            <div class="mt-2">
                                <strong>解答:</strong>
                                <ol>
                                    <li>INNER JOINは両テーブルに一致するデータのみ、LEFT JOINは左テーブルのすべてのデータを取得（右に一致しない場合はNULL）</li>
                                    <li>15件（LEFT JOINは結合される側のレコード数以上になり、注文数分のレコードが生成される）</li>
                                    <li>組織の上下関係、製品のカテゴリ階層、地理的な階層構造、ユーザーの紹介関係など</li>
                                    <li><pre class="code-block"><code class="language-sql">SELECT p.product_name, c.category_name
FROM products p
INNER JOIN categories c ON p.category_id = c.category_id;</code></pre></li>
                                    <li>WHERE 右テーブルのキー IS NULL の条件を追加</li>
                                </ol>
                            </div>
                        </details>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="sql-learning-material-4.html" class="btn btn-secondary">← 前の章: SELECT文の詳細</a>
                        <a href="sql-learning-material-6.html" class="btn btn-primary">次の章: 集計とグループ化 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js 初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>