<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>アジャイル開発学習教材 第9章 - 継続的インテグレーション/デリバリー（CI/CD）</title>

    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">

    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>

    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #0d6efd;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 1rem;
        }

        /* タイトル */
        .chapter-title {
            color: #0d6efd;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #0d6efd;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #0dcaf0;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #cfe2ff;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #0d6efd;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            color: white;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #0d6efd !important;
            color: white !important;
        }

        /* テーブルスタイル */
        .comparison-table {
            margin: 1.5rem 0;
        }

        .comparison-table th {
            background-color: #0d6efd;
            color: white;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">
                <strong>アジャイル開発学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="agile-development-learning-material-01.html">
                                第1章: アジャイル開発の基礎と原則
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="agile-development-learning-material-02.html">
                                第2章: スクラムフレームワーク - 基礎編
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="agile-development-learning-material-03.html">
                                第3章: カンバン手法とビジュアルマネジメント
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="agile-development-learning-material-04.html">
                                第4章: ユーザーストーリーと要件定義
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="agile-development-learning-material-05.html">
                                第5章: スプリント計画と実行
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="agile-development-learning-material-06.html">
                                第6章: デイリースタンドアップとチームコミュニケーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="agile-development-learning-material-07.html">
                                第7章: レトロスペクティブと継続的改善
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="agile-development-learning-material-08.html">
                                第8章: テスト駆動開発（TDD）とアジャイルテスティング
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="agile-development-learning-material-09.html">
                                第9章: 継続的インテグレーション/デリバリー（CI/CD）
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="agile-development-learning-material-10.html">
                                第10章: アジャイルチームの運営と組織への導入
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第9章: 継続的インテグレーション/デリバリー（CI/CD）</h1>
                </div>

                <div id="chapter9">
                    <h2 class="chapter-title">自動化とデリバリーパイプライン</h2>

                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>継続的インテグレーション（CI）の原則と実践方法</li>
                            <li>継続的デリバリー（CD）と継続的デプロイメントの違い</li>
                            <li>ビルドパイプラインの構築と設計</li>
                            <li>自動化ビルドと自動化テストの実装</li>
                            <li>バージョン管理とブランチ戦略（トランクベース開発、GitFlow）</li>
                            <li>CI/CDツールの選択と使用方法</li>
                            <li>デプロイメントの自動化とロールバック戦略</li>
                            <li>インフラストラクチャーアズコード（IaC）の基礎</li>
                        </ul>
                    </div>

                    <h3 class="section-title">9.1 継続的インテグレーション（CI）とは</h3>
                    <p>
                        継続的インテグレーション（Continuous Integration, CI）は、開発者が頻繁にコードを共有リポジトリにマージし、その度に自動ビルドとテストを実行する開発プラクティスです。Martin Fowlerによって広められ、アジャイル開発の基盤となる重要な要素です。
                    </p>

                    <h4>CIの基本原則</h4>
                    <ul>
                        <li><strong>頻繁な統合</strong>: 少なくとも1日1回、可能であれば複数回コードをマージする</li>
                        <li><strong>自動ビルド</strong>: コミットごとに自動的にビルドが実行される</li>
                        <li><strong>自己テスト</strong>: ビルドプロセスに自動テストが含まれる</li>
                        <li><strong>高速フィードバック</strong>: ビルドとテストは10分以内に完了することが望ましい</li>
                        <li><strong>可視化</strong>: ビルドの成功・失敗状態がチーム全体に可視化される</li>
                        <li><strong>即座の修正</strong>: ビルドが壊れたら、最優先で修正する</li>
                    </ul>

                    <h4>CIのメリット</h4>
                    <ul>
                        <li><strong>統合問題の早期発見</strong>: 小さな変更を頻繁に統合するため、問題を早期に発見できる</li>
                        <li><strong>リスクの低減</strong>: 「統合地獄」を回避し、リリースリスクを最小化</li>
                        <li><strong>品質の向上</strong>: 自動テストにより、リグレッション（機能退行）を防ぐ</li>
                        <li><strong>開発速度の向上</strong>: 手動作業を削減し、開発者が本質的な作業に集中できる</li>
                        <li><strong>透明性</strong>: プロジェクトの健全性が可視化され、問題を隠せない</li>
                    </ul>

                    <div class="mermaid">
                        flowchart LR
                            A[開発者がコード変更] --> B[ローカルでテスト]
                            B --> C["リポジトリに<br/>コミット/プッシュ"]
                            C --> D["CIサーバーが<br/>変更を検知"]
                            D --> E[自動ビルド実行]
                            E --> F[自動テスト実行]
                            F --> G{成功?}
                            G -->|Yes| H["成果物を保存<br/>通知: 成功"]
                            G -->|No| I["通知: 失敗<br/>開発者が即座に修正"]
                            I --> A
                    </div>

                    <h3 class="section-title">9.2 継続的デリバリー（CD）と継続的デプロイメントの違い</h3>
                    <p>
                        継続的デリバリー（Continuous Delivery）と継続的デプロイメント（Continuous Deployment）は、CIを拡張した概念ですが、明確な違いがあります。
                    </p>

                    <h4>継続的デリバリー（Continuous Delivery）</h4>
                    <p>
                        コードの変更が常に本番環境にデプロイ可能な状態に保たれ、いつでも手動でリリースできる状態を維持する実践です。
                    </p>
                    <ul>
                        <li><strong>リリース判断</strong>: ビジネス判断により、手動でリリースボタンを押す</li>
                        <li><strong>本番デプロイの準備</strong>: すべてのテストが通り、本番環境にデプロイ可能な状態</li>
                        <li><strong>柔軟性</strong>: リリースタイミングをビジネス側がコントロールできる</li>
                    </ul>

                    <h4>継続的デプロイメント（Continuous Deployment）</h4>
                    <p>
                        コードの変更がすべてのテストを通過すると、自動的に本番環境にデプロイされる実践です。人間の介入なしに本番リリースが行われます。
                    </p>
                    <ul>
                        <li><strong>完全自動化</strong>: テストが成功すれば、自動的に本番環境へデプロイ</li>
                        <li><strong>最速のフィードバック</strong>: 変更が数時間以内にユーザーに届く</li>
                        <li><strong>高い自動化レベル</strong>: テスト、セキュリティスキャン、モニタリングがすべて自動化される</li>
                    </ul>

                    <table class="table table-bordered comparison-table">
                        <thead>
                            <tr>
                                <th>比較項目</th>
                                <th>継続的インテグレーション（CI）</th>
                                <th>継続的デリバリー（CD）</th>
                                <th>継続的デプロイメント</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>目的</strong></td>
                                <td>コードの統合を自動化</td>
                                <td>いつでもリリース可能な状態を維持</td>
                                <td>本番環境への自動デプロイ</td>
                            </tr>
                            <tr>
                                <td><strong>デプロイ先</strong></td>
                                <td>開発/テスト環境</td>
                                <td>ステージング環境まで</td>
                                <td>本番環境</td>
                            </tr>
                            <tr>
                                <td><strong>リリース判断</strong></td>
                                <td>N/A</td>
                                <td>手動（ビジネス判断）</td>
                                <td>自動（テスト成功時）</td>
                            </tr>
                            <tr>
                                <td><strong>リリース頻度</strong></td>
                                <td>N/A</td>
                                <td>週次〜月次</td>
                                <td>日次〜時間単位</td>
                            </tr>
                            <tr>
                                <td><strong>難易度</strong></td>
                                <td>低</td>
                                <td>中</td>
                                <td>高</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="mermaid">
                        flowchart TD
                            A[コードコミット] --> B["CI: ビルド＋<br/>単体テスト"]
                            B --> C{"テスト<br/>成功?"}
                            C -->|No| D[開発者へ通知]
                            C -->|Yes| E["CD: ステージング環境<br/>へデプロイ"]
                            E --> F["統合テスト<br/>E2Eテスト実行"]
                            F --> G{"テスト<br/>成功?"}
                            G -->|No| D
                            G -->|Yes| H{"デプロイ<br/>方式?"}
                            H -->|継続的デリバリー| I["手動承認<br/>待機"]
                            I --> J[本番環境へデプロイ]
                            H -->|継続的デプロイメント| J
                            J --> K[モニタリング]
                    </div>

                    <h3 class="section-title">9.3 ビルドパイプラインの構築</h3>
                    <p>
                        ビルドパイプライン（デプロイメントパイプライン）は、コードの変更から本番環境へのデプロイまでの自動化された一連のプロセスです。各ステージで品質ゲートを設け、段階的に品質を確認していきます。
                    </p>

                    <h4>典型的なパイプラインのステージ</h4>
                    <div class="mermaid">
                        flowchart LR
                            A["1. コミット<br/>ステージ"] --> B["2. 受け入れ<br/>テストステージ"]
                            B --> C["3. 性能<br/>テストステージ"]
                            C --> D["4. 手動<br/>検証ステージ"]
                            D --> E["5. 本番<br/>リリース"]
                            style A fill:#c8e6c9
                            style B fill:#fff9c4
                            style C fill:#ffcc80
                            style D fill:#ffab91
                            style E fill:#ef9a9a
                    </div>

                    <h4>各ステージの説明</h4>
                    <table class="table table-bordered comparison-table">
                        <thead>
                            <tr>
                                <th>ステージ</th>
                                <th>内容</th>
                                <th>実行時間</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>1. コミットステージ</strong></td>
                                <td>ビルド、単体テスト、静的解析、コード品質チェック</td>
                                <td>5〜10分</td>
                            </tr>
                            <tr>
                                <td><strong>2. 受け入れテストステージ</strong></td>
                                <td>機能テスト、統合テスト、E2Eテスト</td>
                                <td>30分〜2時間</td>
                            </tr>
                            <tr>
                                <td><strong>3. 性能テストステージ</strong></td>
                                <td>負荷テスト、ストレステスト、性能測定</td>
                                <td>1〜4時間</td>
                            </tr>
                            <tr>
                                <td><strong>4. 手動検証ステージ</strong></td>
                                <td>探索的テスト、ユーザビリティテスト</td>
                                <td>可変</td>
                            </tr>
                            <tr>
                                <td><strong>5. 本番リリース</strong></td>
                                <td>本番環境へのデプロイ、スモークテスト</td>
                                <td>5〜15分</td>
                            </tr>
                        </tbody>
                    </table>

                    <h4>パイプラインの設計原則</h4>
                    <ul>
                        <li><strong>高速なフィードバック</strong>: 早いステージほど高速に実行し、問題を早期発見</li>
                        <li><strong>並列実行</strong>: 独立したテストは並列実行して時間を短縮</li>
                        <li><strong>べき等性</strong>: 同じ入力に対して、何度実行しても同じ結果が得られる</li>
                        <li><strong>失敗時の停止</strong>: どこかのステージで失敗したら、後続のステージは実行しない</li>
                        <li><strong>可視化</strong>: パイプラインの状態がダッシュボードで確認できる</li>
                    </ul>

                    <div class="exercise-container">
                        <h5>演習 9-1: ビルドパイプラインの設計</h5>
                        <p><strong>目的:</strong> Webアプリケーションのビルドパイプラインを設計する</p>
                        <h6>シナリオ</h6>
                        <p>ReactフロントエンドとNode.js バックエンドで構成されるWebアプリケーションのCI/CDパイプラインを設計します。</p>

                        <h6>要件</h6>
                        <ul>
                            <li>コードがGitHubにプッシュされたらパイプラインが開始</li>
                            <li>フロントエンドとバックエンドのテストを並列実行</li>
                            <li>ステージング環境と本番環境へのデプロイ</li>
                            <li>本番デプロイは手動承認が必要</li>
                        </ul>

                        <h6>考えてみましょう</h6>
                        <ol>
                            <li>どのようなステージが必要ですか？順序を含めてリストアップしてください</li>
                            <li>各ステージでどのようなテストや検証を行いますか？</li>
                            <li>パイプラインが失敗した場合、どのように通知しますか？</li>
                            <li>ステージング環境と本番環境の違いをどう管理しますか？</li>
                        </ol>
                    </div>

                    <h3 class="section-title">9.4 バージョン管理とブランチ戦略</h3>
                    <p>
                        効果的なCI/CDには、適切なブランチ戦略が不可欠です。主要な戦略として、トランクベース開発とGitFlowがあります。
                    </p>

                    <h4>トランクベース開発（Trunk-Based Development）</h4>
                    <p>
                        開発者が全員、1つのメインブランチ（trunk/main）に頻繁に小さな変更をマージする手法です。長期的なフィーチャーブランチを作らないことが特徴です。
                    </p>

                    <div class="mermaid">
                        gitGraph
                            commit
                            commit
                            branch feature-1
                            checkout feature-1
                            commit
                            checkout main
                            merge feature-1
                            commit
                            branch feature-2
                            checkout feature-2
                            commit
                            checkout main
                            merge feature-2
                            commit
                    </div>

                    <h5>トランクベース開発の特徴</h5>
                    <ul>
                        <li><strong>短命なブランチ</strong>: フィーチャーブランチは1日以内にマージ</li>
                        <li><strong>フィーチャートグル</strong>: 未完成機能は機能フラグで隠す</li>
                        <li><strong>頻繁な統合</strong>: マージ地獄を避け、統合リスクを最小化</li>
                        <li><strong>高い自動化レベル</strong>: 頻繁なマージを支えるために、自動テストが必須</li>
                    </ul>

                    <h4>GitFlow</h4>
                    <p>
                        Vincent Driessenが提唱した、複数の長期ブランチを使用するブランチモデルです。リリース管理が明確で、従来型のリリースサイクルに適しています。
                    </p>

                    <div class="mermaid">
                        gitGraph
                            commit
                            branch develop
                            checkout develop
                            commit
                            branch feature
                            checkout feature
                            commit
                            commit
                            checkout develop
                            merge feature
                            branch release
                            checkout release
                            commit
                            checkout main
                            merge release tag: "v1.0"
                            checkout develop
                            merge release
                            commit
                    </div>

                    <h5>GitFlowの主要ブランチ</h5>
                    <ul>
                        <li><strong>main（master）</strong>: 本番環境のコード、リリース済みの安定版</li>
                        <li><strong>develop</strong>: 次のリリースに向けた開発の統合ブランチ</li>
                        <li><strong>feature/*</strong>: 個別機能の開発ブランチ（developから分岐）</li>
                        <li><strong>release/*</strong>: リリース準備ブランチ（developから分岐、mainにマージ）</li>
                        <li><strong>hotfix/*</strong>: 緊急修正ブランチ（mainから分岐、mainとdevelopにマージ）</li>
                    </ul>

                    <table class="table table-bordered comparison-table">
                        <thead>
                            <tr>
                                <th>比較項目</th>
                                <th>トランクベース開発</th>
                                <th>GitFlow</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>ブランチ数</strong></td>
                                <td>1つ（main）+ 短命なフィーチャーブランチ</td>
                                <td>複数の長期ブランチ</td>
                            </tr>
                            <tr>
                                <td><strong>マージ頻度</strong></td>
                                <td>非常に高い（1日複数回）</td>
                                <td>低〜中程度</td>
                            </tr>
                            <tr>
                                <td><strong>適したチーム</strong></td>
                                <td>小〜中規模、高度なスキル</td>
                                <td>中〜大規模、明確なリリース管理</td>
                            </tr>
                            <tr>
                                <td><strong>リリースサイクル</strong></td>
                                <td>継続的デプロイメント向き</td>
                                <td>計画的リリース向き</td>
                            </tr>
                            <tr>
                                <td><strong>複雑さ</strong></td>
                                <td>シンプル</td>
                                <td>やや複雑</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="highlight">
                        <h5>どちらを選ぶべきか？</h5>
                        <ul>
                            <li><strong>トランクベース開発</strong>: SaaS製品、Webアプリケーション、高頻度リリース</li>
                            <li><strong>GitFlow</strong>: パッケージソフト、モバイルアプリ、複数バージョンの並行サポート</li>
                        </ul>
                    </div>

                    <h3 class="section-title">9.5 CI/CDツールの選択</h3>
                    <p>
                        多様なCI/CDツールが存在し、それぞれ特徴があります。プロジェクトの要件に応じて適切なツールを選択することが重要です。
                    </p>

                    <h4>主要なCI/CDツール</h4>
                    <table class="table table-bordered comparison-table">
                        <thead>
                            <tr>
                                <th>ツール</th>
                                <th>タイプ</th>
                                <th>特徴</th>
                                <th>適したケース</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Jenkins</strong></td>
                                <td>オープンソース、セルフホスト</td>
                                <td>高度にカスタマイズ可能、プラグインが豊富</td>
                                <td>オンプレミス、複雑な要件</td>
                            </tr>
                            <tr>
                                <td><strong>GitHub Actions</strong></td>
                                <td>クラウド、GitHub統合</td>
                                <td>GitHubと完全統合、YAMLで設定</td>
                                <td>GitHubでホストするプロジェクト</td>
                            </tr>
                            <tr>
                                <td><strong>GitLab CI/CD</strong></td>
                                <td>クラウド/セルフホスト</td>
                                <td>GitLab統合、Auto DevOps</td>
                                <td>GitLabを使用するチーム</td>
                            </tr>
                            <tr>
                                <td><strong>CircleCI</strong></td>
                                <td>クラウド</td>
                                <td>高速、Dockerネイティブ</td>
                                <td>高速ビルドが必要</td>
                            </tr>
                            <tr>
                                <td><strong>Travis CI</strong></td>
                                <td>クラウド</td>
                                <td>シンプル、OSSプロジェクト向け</td>
                                <td>オープンソースプロジェクト</td>
                            </tr>
                        </tbody>
                    </table>

                    <h4>GitHub Actionsの例</h4>
                    <p>
                        GitHub Actionsは、YAMLファイルでワークフローを定義し、GitHubイベント（プッシュ、プルリクエストなど）をトリガーにパイプラインを実行します。
                    </p>
                    <pre class="code-block"><code class="language-yaml"># .github/workflows/ci.yml
name: CI Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      # リポジトリをチェックアウト
      - name: Checkout code
        uses: actions/checkout@v3

      # Node.js環境をセットアップ
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      # 依存関係をインストール
      - name: Install dependencies
        run: npm install

      # Lintを実行
      - name: Run linter
        run: npm run lint

      # テストを実行
      - name: Run tests
        run: npm test

      # ビルドを実行
      - name: Build
        run: npm run build</code></pre>

                    <h3 class="section-title">9.6 デプロイメント自動化とロールバック戦略</h3>
                    <p>
                        デプロイメントの自動化は、人為的ミスを減らし、リリース頻度を高めるための重要な要素です。また、問題が発生した際に迅速にロールバックできる仕組みも必要です。
                    </p>

                    <h4>デプロイメント戦略</h4>
                    <table class="table table-bordered comparison-table">
                        <thead>
                            <tr>
                                <th>戦略</th>
                                <th>説明</th>
                                <th>メリット</th>
                                <th>デメリット</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>ブルーグリーンデプロイメント</strong></td>
                                <td>本番環境（Blue）と同一の新環境（Green）を用意し、切り替える</td>
                                <td>即座のロールバック、ダウンタイムゼロ</td>
                                <td>2倍のリソースが必要</td>
                            </tr>
                            <tr>
                                <td><strong>カナリアリリース</strong></td>
                                <td>新バージョンを一部のユーザーに先行公開し、問題がなければ全体に展開</td>
                                <td>リスク低減、段階的な検証</td>
                                <td>複雑な監視が必要</td>
                            </tr>
                            <tr>
                                <td><strong>ローリングデプロイメント</strong></td>
                                <td>サーバーを順次、新バージョンに置き換えていく</td>
                                <td>リソース効率的</td>
                                <td>一時的に複数バージョン混在</td>
                            </tr>
                            <tr>
                                <td><strong>フィーチャートグル</strong></td>
                                <td>機能をコードに含めるが、フラグでON/OFFを制御</td>
                                <td>柔軟な機能公開、A/Bテスト可能</td>
                                <td>技術的負債の蓄積リスク</td>
                            </tr>
                        </tbody>
                    </table>

                    <h4>ブルーグリーンデプロイメントの流れ</h4>
                    <div class="mermaid">
                        flowchart TD
                            A["Blue環境<br/>(現在の本番)"] --> B["Green環境を<br/>新バージョンで構築"]
                            B --> C["Green環境で<br/>スモークテスト"]
                            C --> D{テスト<br/>成功?}
                            D -->|No| E[Green環境を破棄]
                            D -->|Yes| F["ロードバランサーを<br/>Greenに切り替え"]
                            F --> G["Greenが<br/>新しい本番環境"]
                            G --> H["Blueを待機<br/>(ロールバック用)"]
                    </div>

                    <h4>ロールバック戦略</h4>
                    <ul>
                        <li><strong>即座のロールバック</strong>: ブルーグリーンなら、ロードバランサーを切り戻すだけ</li>
                        <li><strong>バージョン管理</strong>: デプロイする成果物をバージョン管理し、特定バージョンに戻せるようにする</li>
                        <li><strong>自動ロールバック</strong>: エラー率やレスポンスタイムなどのメトリクスを監視し、閾値を超えたら自動でロールバック</li>
                        <li><strong>データベースマイグレーション</strong>: 前方互換性を持つマイグレーションを作成し、ロールバック時もデータ整合性を保つ</li>
                    </ul>

                    <h3 class="section-title">9.7 インフラストラクチャーアズコード（IaC）の基礎</h3>
                    <p>
                        インフラストラクチャーアズコード（Infrastructure as Code, IaC）は、インフラの構成をコードで定義し、バージョン管理・自動化する手法です。
                    </p>

                    <h4>IaCのメリット</h4>
                    <ul>
                        <li><strong>再現性</strong>: 同じコードから同じインフラを何度でも構築できる</li>
                        <li><strong>バージョン管理</strong>: インフラの変更履歴を追跡できる</li>
                        <li><strong>レビュー可能</strong>: コードレビューを通じて、インフラ変更を検証できる</li>
                        <li><strong>ドキュメントとしての価値</strong>: コードが最新のインフラ構成を正確に表す</li>
                        <li><strong>スピード</strong>: 手動設定に比べて、インフラの構築・変更が高速</li>
                    </ul>

                    <h4>主要なIaCツール</h4>
                    <table class="table table-bordered comparison-table">
                        <thead>
                            <tr>
                                <th>ツール</th>
                                <th>タイプ</th>
                                <th>特徴</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Terraform</strong></td>
                                <td>宣言型、マルチクラウド</td>
                                <td>AWS、Azure、GCPなど複数のクラウドに対応</td>
                            </tr>
                            <tr>
                                <td><strong>AWS CloudFormation</strong></td>
                                <td>宣言型、AWS専用</td>
                                <td>AWSリソースの管理に特化、JSON/YAML</td>
                            </tr>
                            <tr>
                                <td><strong>Ansible</strong></td>
                                <td>手続き型、エージェントレス</td>
                                <td>設定管理、サーバー構成の自動化</td>
                            </tr>
                            <tr>
                                <td><strong>Pulumi</strong></td>
                                <td>宣言型、プログラミング言語</td>
                                <td>TypeScript、Python等の言語で記述</td>
                            </tr>
                        </tbody>
                    </table>

                    <h4>Terraformの例</h4>
                    <pre class="code-block"><code class="language-bash"># main.tf - AWS EC2インスタンスの定義
provider "aws" {
  region = "ap-northeast-1"
}

resource "aws_instance" "web_server" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"

  tags = {
    Name = "WebServer"
    Environment = "Production"
  }
}

# インスタンスのパブリックIPを出力
output "instance_ip" {
  value = aws_instance.web_server.public_ip
}</code></pre>

                    <div class="exercise-container">
                        <h5>演習 9-2: CI/CDパイプラインのトラブルシューティング</h5>
                        <p><strong>目的:</strong> パイプラインの失敗原因を特定し、解決策を考える</p>
                        <h6>シナリオ</h6>
                        <p>GitHub Actionsでビルドが失敗しました。以下のエラーログを確認してください。</p>
                        <pre class="code-block"><code class="language-text">Run npm test
npm ERR! missing script: test

Error: Process completed with exit code 1.</code></pre>

                        <h6>考えてみましょう</h6>
                        <ol>
                            <li>このエラーの原因は何ですか？</li>
                            <li>どのようにこの問題を修正しますか？</li>
                            <li>このような問題を防ぐために、どのような対策が考えられますか？</li>
                        </ol>

                        <h6>ヒント</h6>
                        <p>package.jsonファイルのscriptsセクションを確認してください。</p>
                    </div>

                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <strong>継続的インテグレーション（CI）の基本原則を3つ挙げてください。</strong>
                            </li>
                            <li>
                                <strong>継続的デリバリーと継続的デプロイメントの違いを説明してください。</strong>
                            </li>
                            <li>
                                <strong>トランクベース開発とGitFlowの主な違いは何ですか？どのような場合にそれぞれを選択すべきですか？</strong>
                            </li>
                            <li>
                                <strong>ブルーグリーンデプロイメントとカナリアリリースの違いを説明してください。</strong>
                            </li>
                            <li>
                                <strong>ビルドパイプラインの各ステージは、どのような順序で実行されるべきですか？その理由も説明してください。</strong>
                            </li>
                            <li>
                                <strong>IaC（Infrastructure as Code）のメリットを3つ挙げてください。</strong>
                            </li>
                        </ol>
                    </div>

                    <h3 class="section-title">9.8 まとめ</h3>
                    <p>
                        この章では、継続的インテグレーション/デリバリー（CI/CD）の原則と実践方法を学びました。CI/CDは、アジャイル開発において高速で安定したリリースを実現するための基盤です。
                    </p>
                    <div class="highlight">
                        <h5>重要ポイント</h5>
                        <ul>
                            <li>CIで頻繁にコードを統合し、問題を早期発見する</li>
                            <li>継続的デリバリーでいつでもリリース可能な状態を維持する</li>
                            <li>ビルドパイプラインを構築し、段階的に品質を検証する</li>
                            <li>プロジェクトに適したブランチ戦略（トランクベース or GitFlow）を選択する</li>
                            <li>CI/CDツールを活用して、ビルドとデプロイを自動化する</li>
                            <li>適切なデプロイメント戦略で、リスクを最小化してリリースする</li>
                            <li>IaCでインフラをコード化し、再現性と保守性を向上させる</li>
                        </ul>
                    </div>

                    <div class="d-flex justify-content-between mt-4 mb-5">
                        <a href="agile-development-learning-material-08.html" class="btn btn-secondary">← 前の章: テスト駆動開発（TDD）とアジャイルテスティング</a>
                        <a href="agile-development-learning-material-10.html" class="btn btn-primary">次の章: アジャイルチームの運営と組織への導入 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>

    <!-- Mermaid.js 初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>
