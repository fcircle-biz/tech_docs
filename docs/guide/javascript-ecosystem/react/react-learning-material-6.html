<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React学習教材 第6章 - React Hooks - useEffectとライフサイクル</title>

    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>

    <style>
        body { font-family: 'Noto Sans JP', sans-serif; padding-top: 56px; }
        .navbar { background-color: #61DAFB; }
        .sidebar { position: sticky; top: 70px; height: calc(100vh - 70px); overflow-y: auto; }
        .chapter-title { color: #61DAFB; margin-top: 1.5rem; margin-bottom: 1rem; border-bottom: 2px solid #61DAFB; padding-bottom: 0.5rem; }
        .section-title { color: #00b4d8; margin-top: 1.2rem; margin-bottom: 0.8rem; }
        .quiz-container { background-color: #e0f7fa; border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; border-left: 4px solid #61DAFB; }
        .exercise-container { background-color: #f3e5f5; border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; border-left: 4px solid #9c27b0; }
        .highlight { background-color: #ffecb3; border-radius: 8px; padding: 1rem; margin: 1rem 0; border-left: 4px solid #ffc107; }
        .warning { background-color: #ffebee; border-radius: 8px; padding: 1rem; margin: 1rem 0; border-left: 4px solid #f44336; }
        .code-block { background-color: #1e1e1e; border-radius: 5px; padding: 1rem; margin: 1rem 0; }
        .nav-link.active { background-color: #61DAFB !important; color: white !important; }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand"><strong>React学習教材</strong></a>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
                <div class="position-sticky pt-3">
                    <ul class="nav flex-column">
                        <li class="nav-item"><a class="nav-link" href="react-learning-material-1.html">第1章: React入門と環境構築</a></li>
                        <li class="nav-item"><a class="nav-link" href="react-learning-material-2.html">第2章: JSXとコンポーネントの基礎</a></li>
                        <li class="nav-item"><a class="nav-link" href="react-learning-material-3.html">第3章: PropsとState - データの管理</a></li>
                        <li class="nav-item"><a class="nav-link" href="react-learning-material-4.html">第4章: イベント処理とユーザーインタラクション</a></li>
                        <li class="nav-item"><a class="nav-link" href="react-learning-material-5.html">第5章: リストとキー</a></li>
                        <li class="nav-item"><a class="nav-link active" href="react-learning-material-6.html">第6章: React Hooks - useEffectとライフサイクル</a></li>
                        <li class="nav-item"><a class="nav-link" href="react-learning-material-7.html">第7章: フォームとバリデーション</a></li>
                        <li class="nav-item"><a class="nav-link" href="react-learning-material-8.html">第8章: APIとの連携</a></li>
                        <li class="nav-item"><a class="nav-link" href="react-learning-material-9.html">第9章: React Routerとナビゲーション</a></li>
                        <li class="nav-item"><a class="nav-link" href="react-learning-material-10.html">第10章: 高度なトピック</a></li>
                    </ul>
                </div>
            </nav>

            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第6章: React Hooks - useEffectとライフサイクル</h1>
                </div>

                <div id="chapter6">
                    <h2 class="chapter-title">副作用とコンポーネントライフサイクル</h2>

                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>useEffectフックの基本概念を理解する</li>
                            <li>副作用（Side Effects）とは何かを学ぶ</li>
                            <li>コンポーネントのライフサイクルを理解する</li>
                            <li>依存配列の役割と使い方を習得する</li>
                            <li>クリーンアップ関数の実装方法を学ぶ</li>
                            <li>データフェッチング（API呼び出し）を実装する</li>
                            <li>タイマーやイベントリスナーの管理方法を知る</li>
                            <li>useEffectの実行タイミングと無限ループの回避方法を理解する</li>
                        </ul>
                    </div>

                    <h3 class="section-title">6.1 useEffectフックとは</h3>
                    <p>useEffectは、関数コンポーネントで「副作用（side effects）」を実行するためのHookです。クラスコンポーネントのライフサイクルメソッド（componentDidMount、componentDidUpdate、componentWillUnmount）の機能を統合したものです。</p>

                    <h4>副作用（Side Effects）とは</h4>
                    <p>副作用とは、コンポーネントのレンダリング以外の操作を指します：</p>
                    <ul>
                        <li>データの取得（API呼び出し）</li>
                        <li>DOM操作</li>
                        <li>タイマーの設定</li>
                        <li>イベントリスナーの登録</li>
                        <li>ローカルストレージへのアクセス</li>
                        <li>ログ出力</li>
                    </ul>

                    <h3 class="section-title">6.2 useEffectの基本構文</h3>

                    <div class="exercise-container">
                        <h5>実習 6-1: useEffectの基本的な使い方</h5>
                        <h6>基本構文</h6>
                        <pre class="code-block"><code class="language-javascript">import { useEffect } from 'react';

useEffect(() => {
  // 実行したい副作用の処理
  console.log('useEffectが実行されました');

  // クリーンアップ関数（オプション）
  return () => {
    console.log('クリーンアップが実行されました');
  };
}, [依存配列]);</code></pre>

                        <h6>シンプルな例：ドキュメントタイトルの更新</h6>
                        <pre class="code-block"><code class="language-javascript">import { useState, useEffect } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  // countが変わるたびに実行される
  useEffect(() => {
    document.title = `カウント: ${count}`;
  }, [count]);

  return (
    &lt;div&gt;
      &lt;p&gt;カウント: {count}&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;
        増やす
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>

                    <h3 class="section-title">6.3 依存配列の理解</h3>
                    <p>useEffectの第2引数である依存配列は、いつuseEffectを実行するかを制御します。</p>

                    <h4>3つのパターン</h4>

                    <pre class="code-block"><code class="language-javascript">// パターン1: 依存配列なし（毎回実行）
useEffect(() => {
  console.log('毎回のレンダリング後に実行');
});

// パターン2: 空の依存配列（初回のみ実行）
useEffect(() => {
  console.log('マウント時のみ実行');
}, []);

// パターン3: 依存配列あり（依存値が変更された時に実行）
useEffect(() => {
  console.log('countまたはnameが変更された時に実行');
}, [count, name]);</code></pre>

                    <div class="mermaid">
                        flowchart TD
                            A["コンポーネントレンダリング"] --> B{"依存配列の状態"}
                            B -->|"依存配列なし"| C["毎回実行"]
                            B -->|"空の配列 []"| D{"初回レンダリング?"}
                            D -->|"はい"| E["実行"]
                            D -->|"いいえ"| F["実行しない"]
                            B -->|"依存値あり [a, b]"| G{"依存値が変更?"}
                            G -->|"はい"| H["実行"]
                            G -->|"いいえ"| I["実行しない"]
                    </div>

                    <h3 class="section-title">6.4 データフェッチング</h3>

                    <div class="exercise-container">
                        <h5>実習 6-2: APIからデータを取得</h5>
                        <pre class="code-block"><code class="language-javascript">import { useState, useEffect } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // データ取得関数
    const fetchUsers = async () => {
      try {
        setLoading(true);
        const response = await fetch(
          'https://jsonplaceholder.typicode.com/users'
        );
        if (!response.ok) {
          throw new Error('データ取得に失敗しました');
        }
        const data = await response.json();
        setUsers(data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []); // 空の依存配列：初回のみ実行

  if (loading) return &lt;p&gt;ローディング中...&lt;/p&gt;;
  if (error) return &lt;p&gt;エラー: {error}&lt;/p&gt;;

  return (
    &lt;ul&gt;
      {users.map(user => (
        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
                    </div>

                    <h3 class="section-title">6.5 クリーンアップ関数</h3>
                    <p>useEffectから関数を返すことで、クリーンアップ処理を実行できます。これは、コンポーネントがアンマウントされる前や、次回のエフェクト実行前に呼ばれます。</p>

                    <div class="exercise-container">
                        <h5>実習 6-3: タイマーとクリーンアップ</h5>
                        <pre class="code-block"><code class="language-javascript">import { useState, useEffect } from 'react';

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    console.log('タイマー開始');

    // 1秒ごとに実行
    const interval = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);

    // クリーンアップ関数
    return () => {
      console.log('タイマー停止');
      clearInterval(interval);  // タイマーを停止
    };
  }, []); // 空の配列：初回のみセットアップ

  return &lt;p&gt;経過時間: {seconds}秒&lt;/p&gt;;
}</code></pre>

                        <h6>イベントリスナーのクリーンアップ</h6>
                        <pre class="code-block"><code class="language-javascript">function WindowSize() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => {
      setWidth(window.innerWidth);
    };

    // イベントリスナー登録
    window.addEventListener('resize', handleResize);

    // クリーンアップでイベントリスナー削除
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return &lt;p&gt;ウィンドウ幅: {width}px&lt;/p&gt;;
}</code></pre>
                    </div>

                    <h3 class="section-title">6.6 無限ループの回避</h3>

                    <div class="warning">
                        <h6>よくある間違い：無限ループ</h6>
                        <pre class="code-block"><code class="language-javascript">// ❌ 間違い：無限ループが発生
function BadExample() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    setCount(count + 1); // countを更新
  }, [count]); // countが依存配列にある

  // 無限ループ：
  // 1. useEffectでcountを更新
  // 2. countが変更されたのでuseEffectが再実行
  // 3. 再びcountを更新 → 無限ループ

  return &lt;p&gt;{count}&lt;/p&gt;;
}

// ✅ 正しい：適切な依存配列
function GoodExample() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // 何か初期化処理
    console.log('初期化');
  }, []); // 空の配列：初回のみ

  return (
    &lt;div&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;
        増やす
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>

                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>useEffectフックは何のために使用されますか？</li>
                            <li>副作用（Side Effects）の例を3つ挙げてください。</li>
                            <li>依存配列が空の場合、useEffectはいつ実行されますか？</li>
                            <li>クリーンアップ関数はいつ実行されますか？</li>
                            <li>なぜタイマーやイベントリスナーをクリーンアップする必要がありますか？</li>
                            <li>useEffectで無限ループが発生する原因は何ですか？</li>
                        </ol>

                        <details>
                            <summary>解答例</summary>
                            <ol>
                                <li>コンポーネント内で副作用（データ取得、DOM操作、タイマー設定など）を実行するために使用</li>
                                <li>API呼び出し、タイマーの設定、イベントリスナーの登録</li>
                                <li>コンポーネントのマウント時（初回レンダリング後）のみ実行される</li>
                                <li>コンポーネントがアンマウントされる前、または次回のエフェクト実行前</li>
                                <li>メモリリークを防ぎ、不要な処理の継続を停止するため</li>
                                <li>useEffect内でStateを更新し、そのStateが依存配列に含まれている場合</li>
                            </ol>
                        </details>
                    </div>

                    <div class="d-flex justify-content-between mt-4">
                        <a href="react-learning-material-5.html" class="btn btn-secondary">← 前の章</a>
                        <a href="react-learning-material-7.html" class="btn btn-primary">次の章 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>mermaid.initialize({ startOnLoad: true, theme: 'default' });</script>
</body>
</html>
