<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Framework学習教材 - 第10章：さらに一歩進んだSpring開発へ①</title>
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        .navbar {
            background-color: #28a745;
        }
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        .chapter-title {
            color: #28a745;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #28a745;
            padding-bottom: 0.5rem;
        }
        .section-title {
            color: #218838;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        code {
            display: block;
            background-color: #f5f5f5;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            white-space: pre;
            overflow-x: auto;
        }
        .quiz-container {
            background-color: #e8f4e8;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }
        .quiz-question {
            font-weight: 500;
            margin-bottom: 1rem;
        }
        .diagram {
            max-width: 100%;
            height: auto;
            margin: 1.5rem 0;
            text-align: center;
        }
        .exercise {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        .note {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        #table-of-contents .list-group-item {
            border: none;
            padding: 0.5rem 1rem;
        }
        #table-of-contents .list-group-item-action {
            color: #28a745;
        }
        #table-of-contents .list-group-item-action.active,
        .list-group-item.active {
            color: white !important;
            background-color: #28a745;
            border-color: #28a745;
        }
        .section-nav {
            padding-left: 1rem;
        }
        .inline-code {
            background-color: #f5f5f5;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            display: inline;
        }
        footer {
            background-color: #28a745;
            color: white;
            padding: 1rem 0;
            margin-top: 3rem;
        }
        .table-example {
            width: 100%;
            margin-bottom: 1rem;
            border-collapse: collapse;
        }
        .table-example th {
            background-color: #e8f4e8;
            border: 1px solid #c3e6cb;
            padding: 0.5rem;
            text-align: center;
        }
        .table-example td {
            border: 1px solid #c3e6cb;
            padding: 0.5rem;
            text-align: center;
        }
        .example-result {
            background-color: #f1f8e9;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
        }
        .warning {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 1rem;
            margin: 1.5rem 0;
        }
    </style>
</head>
<body data-bs-spy="scroll" data-bs-target="#tableOfContents">
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="#">Spring Framework学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="#introduction">はじめに</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#chapter10">第10章: さらに一歩進んだSpring開発へ①</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container my-4">
        <div class="row">
            <!-- Sidebar - Table of Contents -->
            <div class="col-lg-3">
                <div class="sidebar">
                    <div class="card">
                        <div class="card-header bg-success text-white">
                            <h5 class="mb-0">目次</h5>
                        </div>
                        <div id="table-of-contents" class="list-group list-group-flush">
                            <a href="#introduction" class="list-group-item list-group-item-action">はじめに</a>
                            <a href="#chapter10" class="list-group-item list-group-item-action">第10章: さらに一歩進んだSpring開発へ①</a>
                            <div class="section-nav">
                                <a href="#rest-api-basics" class="list-group-item list-group-item-action">10.1 REST API開発の基礎</a>
                                <a href="#rest-controller" class="list-group-item list-group-item-action">10.2 @RestControllerの活用</a>
                                <a href="#json-handling" class="list-group-item list-group-item-action">10.3 JSONデータの取り扱い</a>
                                <a href="#request-body" class="list-group-item list-group-item-action">10.4 @RequestBodyによるデータ受信</a>
                                <a href="#webclient-basics" class="list-group-item list-group-item-action">10.5 Spring WebClientの基礎</a>
                                <a href="#webclient-usage" class="list-group-item list-group-item-action">10.6 WebClientによる外部API連携</a>
                                <a href="#practical-exercises" class="list-group-item list-group-item-action">10.7 実践演習</a>
                                <a href="#chapter10-quiz" class="list-group-item list-group-item-action">10.8 理解度確認テスト</a>
                            </div>
                            <a href="#next-steps" class="list-group-item list-group-item-action">次のステップ</a>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Main Content -->
            <div class="col-lg-9">
                <section id="introduction">
                    <h1 class="display-5 mb-4">Spring Framework学習教材 - 第10章</h1>
                    <p class="lead">この教材では、REST API開発とSpring WebClientを使った外部API連携について学習します。この章では、モダンなSpringアプリケーション開発の重要な側面に焦点を当てます。</p>

                    <div class="note">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>RESTful APIの設計原則と実装方法</li>
                            <li>@RestControllerを使ったAPIエンドポイントの作成</li>
                            <li>JSONデータの変換と取り扱い方法</li>
                            <li>@RequestBodyを使ったリクエストパラメータの処理</li>
                            <li>Spring WebClientの基本的な使い方</li>
                            <li>WebClientを使った外部APIとの連携方法</li>
                        </ul>
                    </div>
                </section>

                <section id="chapter10">
                    <h2 class="chapter-title">第10章：さらに一歩進んだSpring開発へ①</h2>
                    <p>現代のWebアプリケーションでは、フロントエンドとバックエンドの分離、マイクロサービスアーキテクチャの採用が一般的になっています。この章では、RESTful APIの開発と外部サービスとの連携に焦点を当て、より高度なSpringアプリケーションの開発方法を学びます。</p>

                    <section id="rest-api-basics">
                        <h3 class="section-title">10.1 REST API開発の基礎</h3>
                        <p>REST（Representational State Transfer）は、Webサービスを設計するためのアーキテクチャスタイルで、シンプルでスケーラブルなAPIを構築するための原則を提供します。</p>

                        <h4>RESTの主要な原則</h4>
                        <ul>
                            <li><strong>リソース中心のアーキテクチャ</strong>: すべてはリソースとして表現され、固有のURI（Uniform Resource Identifier）で識別されます。</li>
                            <li><strong>HTTPメソッドの適切な使用</strong>: 各HTTPメソッドには特定の意味があります（GET, POST, PUT, DELETE, PATCH）。</li>
                            <li><strong>ステートレス通信</strong>: 各リクエストは独立していて、サーバーはセッション状態を保持しません。</li>
                            <li><strong>統一インターフェース</strong>: リソースの表現を標準化し、自己記述型メッセージを使用します。</li>
                            <li><strong>レイヤー化システム</strong>: クライアントはサーバーの内部実装を知る必要がありません。</li>
                        </ul>

                        <h4>RESTful APIとエンドポイント設計</h4>
                        <p>APIエンドポイントはリソースを表現し、操作するために設計されます。以下は一般的なエンドポイント設計のパターンです：</p>

                        <div class="table-responsive">
                            <table class="table-example">
                                <tr>
                                    <th>操作</th>
                                    <th>HTTPメソッド</th>
                                    <th>エンドポイント例</th>
                                    <th>説明</th>
                                </tr>
                                <tr>
                                    <td>リソース一覧取得</td>
                                    <td>GET</td>
                                    <td>/api/users</td>
                                    <td>すべてのユーザー情報を取得</td>
                                </tr>
                                <tr>
                                    <td>単一リソース取得</td>
                                    <td>GET</td>
                                    <td>/api/users/{id}</td>
                                    <td>特定IDのユーザー情報を取得</td>
                                </tr>
                                <tr>
                                    <td>リソース作成</td>
                                    <td>POST</td>
                                    <td>/api/users</td>
                                    <td>新しいユーザーを作成</td>
                                </tr>
                                <tr>
                                    <td>リソース更新</td>
                                    <td>PUT</td>
                                    <td>/api/users/{id}</td>
                                    <td>特定ユーザーの情報を更新</td>
                                </tr>
                                <tr>
                                    <td>リソース部分更新</td>
                                    <td>PATCH</td>
                                    <td>/api/users/{id}</td>
                                    <td>ユーザー情報の一部を更新</td>
                                </tr>
                                <tr>
                                    <td>リソース削除</td>
                                    <td>DELETE</td>
                                    <td>/api/users/{id}</td>
                                    <td>特定ユーザーを削除</td>
                                </tr>
                            </table>
                        </div>

                        <h4>HTTPステータスコードの適切な使用</h4>
                        <p>RESTful APIでは、適切なHTTPステータスコードを返すことで処理結果を明確に伝えることができます：</p>

                        <ul>
                            <li><strong>2xx (成功)</strong>:
                                <ul>
                                    <li>200 OK: リクエスト成功</li>
                                    <li>201 Created: リソース作成成功</li>
                                    <li>204 No Content: 成功したが返すコンテンツなし</li>
                                </ul>
                            </li>
                            <li><strong>4xx (クライアントエラー)</strong>:
                                <ul>
                                    <li>400 Bad Request: リクエスト形式が不正</li>
                                    <li>401 Unauthorized: 認証が必要</li>
                                    <li>403 Forbidden: 権限がない</li>
                                    <li>404 Not Found: リソースが存在しない</li>
                                    <li>409 Conflict: リソース競合</li>
                                </ul>
                            </li>
                            <li><strong>5xx (サーバーエラー)</strong>:
                                <ul>
                                    <li>500 Internal Server Error: サーバー内部エラー</li>
                                    <li>503 Service Unavailable: サービス利用不可</li>
                                </ul>
                            </li>
                        </ul>

                        <div class="note">
                            <h5>RESTの設計ポイント</h5>
                            <p>APIを設計する際は以下の点に注意しましょう：</p>
                            <ul>
                                <li>リソース名は複数形を使用する（/users, /products）</li>
                                <li>操作はHTTPメソッドで表現し、URLには含めない（/users/{id}/delete ではなく DELETE /users/{id}）</li>
                                <li>クエリパラメータはフィルタリング、ソート、ページネーションに使用（/users?role=admin&sort=name）</li>
                                <li>バージョニングを考慮する（/api/v1/users）</li>
                                <li>適切なHTTPステータスコードを返す</li>
                                <li>一貫したレスポンスフォーマットを使用する</li>
                            </ul>
                        </div>
                    </section>

                    <section id="rest-controller">
                        <h3 class="section-title">10.2 @RestControllerの活用</h3>
                        <p>Spring Framework では、RESTful API を実装するために @RestController アノテーションを提供しています。これは @Controller と @ResponseBody を組み合わせたものです。</p>

                        <h4>@Controller vs @RestController</h4>
                        <p>従来の @Controller アノテーションは、主にビューテンプレート（Thymeleaf, JSP など）を返すコントローラーを作成するために使用されます。一方、@RestController はデータ（通常は JSON 形式）を直接返すために設計されています。</p>

                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 220" width="600" height="220">
                                <!-- Controller -->
                                <rect x="50" y="50" width="200" height="60" fill="#e3f2fd" stroke="#2196f3" stroke-width="2" rx="5" />
                                <text x="150" y="85" text-anchor="middle" font-size="14">@Controller</text>
                                
                                <!-- ViewResolver -->
                                <rect x="350" y="20" width="200" height="50" fill="#e8f5e9" stroke="#4caf50" stroke-width="2" rx="5" />
                                <text x="450" y="50" text-anchor="middle" font-size="14">ViewResolver</text>
                                
                                <!-- View -->
                                <rect x="350" y="90" width="200" height="50" fill="#e8f5e9" stroke="#4caf50" stroke-width="2" rx="5" />
                                <text x="450" y="120" text-anchor="middle" font-size="14">View (HTML)</text>
                                
                                <!-- RestController -->
                                <rect x="50" y="150" width="200" height="60" fill="#fff3e0" stroke="#ff9800" stroke-width="2" rx="5" />
                                <text x="150" y="185" text-anchor="middle" font-size="14">@RestController</text>
                                
                                <!-- JSON -->
                                <rect x="350" y="150" width="200" height="60" fill="#fff3e0" stroke="#ff9800" stroke-width="2" rx="5" />
                                <text x="450" y="185" text-anchor="middle" font-size="14">JSON Response</text>
                                
                                <!-- Lines -->
                                <line x1="250" y1="70" x2="350" y2="45" stroke="#000" stroke-width="1.5" />
                                <line x1="450" y1="70" x2="450" y2="90" stroke="#000" stroke-width="1.5" />
                                <line x1="250" y1="180" x2="350" y2="180" stroke="#000" stroke-width="1.5" />
                                
                                <!-- Arrows -->
                                <polygon points="350,45 342,42 342,48" fill="#000" />
                                <polygon points="450,90 447,82 453,82" fill="#000" />
                                <polygon points="350,180 342,177 342,183" fill="#000" />
                            </svg>
                            <p class="text-center">図10.1: @Controller と @RestController の違い</p>
                        </div>

                        <h4>@RestController の基本的な使い方</h4>
                        <p>@RestController を使ってシンプルな API エンドポイントを作成してみましょう。</p>

                        <code>@RestController
@RequestMapping("/api/products")
public class ProductRestController {
    
    private final ProductService productService;
    
    public ProductRestController(ProductService productService) {
        this.productService = productService;
    }
    
    // 全商品リスト取得
    @GetMapping
    public List&lt;Product&gt; getAllProducts() {
        return productService.findAllProducts();
    }
    
    // 商品ID指定で取得
    @GetMapping("/{id}")
    public ResponseEntity&lt;Product&gt; getProductById(@PathVariable Long id) {
        return productService.findProductById(id)
                .map(product -> ResponseEntity.ok(product))
                .orElseGet(() -> ResponseEntity.notFound().build());
    }
}</code>

                        <p>上記のコードでは、@RestController アノテーションを使用して ProductRestController クラスを宣言しています。これにより、すべてのメソッドの戻り値が自動的に HTTP レスポンスボディに変換されます。</p>

                        <h4>ResponseEntity の活用</h4>
                        <p>単純にオブジェクトを返すだけでなく、ResponseEntity クラスを使用することで、レスポンスの HTTP ステータス、ヘッダー、ボディをより細かく制御できます。</p>

                        <code>@RestController
@RequestMapping("/api/orders")
public class OrderRestController {
    
    private final OrderService orderService;
    
    public OrderRestController(OrderService orderService) {
        this.orderService = orderService;
    }
    
    // 注文作成
    @PostMapping
    public ResponseEntity&lt;Order&gt; createOrder(@RequestBody OrderRequest orderRequest) {
        Order createdOrder = orderService.createOrder(orderRequest);
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(createdOrder.getId())
                .toUri();
        
        return ResponseEntity
                .created(location)  // 201 Created ステータスを設定
                .body(createdOrder);  // レスポンスボディに作成した注文を設定
    }
    
    // 注文取得（レスポンスヘッダーを追加）
    @GetMapping("/{id}")
    public ResponseEntity&lt;Order&gt; getOrderById(@PathVariable Long id) {
        return orderService.findOrderById(id)
                .map(order -> ResponseEntity.ok()
                        .header("X-Last-Modified", order.getLastModified().toString())
                        .body(order))
                .orElseGet(() -> ResponseEntity.notFound().build());
    }
    
    // 注文削除
    @DeleteMapping("/{id}")
    public ResponseEntity&lt;Void&gt; deleteOrder(@PathVariable Long id) {
        boolean deleted = orderService.deleteOrder(id);
        return deleted ? ResponseEntity.noContent().build() : ResponseEntity.notFound().build();
    }
}</code>

                        <p>ResponseEntity クラスを使用することで、次のようなことが可能になります：</p>
                        <ul>
                            <li>HTTP ステータスコードの適切な設定（200 OK, 201 Created, 204 No Content など）</li>
                            <li>カスタムヘッダーの追加</li>
                            <li>レスポンスボディの有無の制御</li>
                        </ul>

                        <div class="note">
                            <h5>@RestController の応用</h5>
                            <p>実際のアプリケーションでは、次のような機能と組み合わせて使うことが多いです：</p>
                            <ul>
                                <li><strong>@ControllerAdvice:</strong> グローバル例外ハンドリングと共通のレスポンス形式の提供</li>
                                <li><strong>Spring Security:</strong> API認証・認可の実装</li>
                                <li><strong>API文書化:</strong> SpringDoc、Swagger UIによるAPIドキュメントの自動生成</li>
                                <li><strong>バリデーション:</strong> @Valid アノテーションを使用した入力検証</li>
                            </ul>
                        </div>
                    </section>

                    <section id="json-handling">
                        <h3 class="section-title">10.3 JSONデータの取り扱い</h3>
                        <p>RESTful APIでは、JSON（JavaScript Object Notation）が最も一般的なデータ交換フォーマットとして使用されています。Spring Frameworkには、JSONデータを簡単に処理するための機能が組み込まれています。</p>

                        <h4>JSONとは</h4>
                        <p>JSONは軽量でテキストベースのデータ交換形式で、人間が読み書きしやすく、機械での解析や生成も容易です。JavaオブジェクトとJSONデータの間での変換が頻繁に行われます。</p>

                        <p>JSONの基本構造例：</p>
                        <code>{
  "id": 1,
  "name": "スマートフォン",
  "price": 60000,
  "inStock": true,
  "categories": ["電子機器", "通信機器"],
  "manufacturer": {
    "id": 1001,
    "name": "ABC Electronics",
    "country": "日本"
  }
}</code>

                        <h4>Spring BootにおけるJSON変換</h4>
                        <p>Spring Bootは、デフォルトでJacksonライブラリを使用してJavaオブジェクトとJSONの間の変換を自動的に処理します。特別な設定をしなくても、@RestControllerから返されたオブジェクトはJSONに変換されます。</p>

                        <h5>JavaオブジェクトからJSONへの変換制御</h5>
                        <p>Jacksonアノテーションを使用して、JSONへの変換をカスタマイズできます。</p>

                        <code>import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonFormat;

@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    private BigDecimal price;
    
    @JsonProperty("is_available")  // JSON出力時のプロパティ名を変更
    private boolean available;
    
    @JsonIgnore  // JSONに含めない
    private String internalCode;
    
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")  // 日付フォーマットを指定
    private LocalDateTime createdAt;
    
    // ゲッター・セッター省略
}</code>

                        <h5>主なJacksonアノテーション</h5>
                        <ul>
                            <li><strong>@JsonProperty:</strong> JSONのプロパティ名を指定</li>
                            <li><strong>@JsonIgnore:</strong> JSONシリアライズ時に除外するフィールドを指定</li>
                            <li><strong>@JsonFormat:</strong> 日付や数値のフォーマットを指定</li>
                            <li><strong>@JsonInclude:</strong> 条件付きでプロパティをJSONに含める</li>
                            <li><strong>@JsonSerialize:</strong> カスタムシリアライザを指定</li>
                            <li><strong>@JsonDeserialize:</strong> カスタムデシリアライザを指定</li>
                        </ul>

                        <code>import com.fasterxml.jackson.annotation.JsonInclude;

@RestController
@RequestMapping("/api/users")
public class UserRestController {

    private final UserService userService;
    
    // コンストラクタ省略
    
    @GetMapping("/{id}")
    public UserResponse getUserById(@PathVariable Long id) {
        User user = userService.findById(id);
        return new UserResponse(user);
    }
}

// nullでないフィールドのみをJSONに含める
@JsonInclude(JsonInclude.Include.NON_NULL)
class UserResponse {
    private Long id;
    private String username;
    private String email;
    private String profileImageUrl;  // nullの場合JSONに含まれない
    
    // コンストラクタ、ゲッター省略
}</code>

                        <h4>複雑なJSONデータ構造の処理</h4>
                        <p>入れ子になったオブジェクトやコレクションを含む複雑なJSONデータも自然に処理できます。</p>

                        <code>@RestController
@RequestMapping("/api/orders")
public class OrderController {

    private final OrderService orderService;
    
    // コンストラクタ省略
    
    @GetMapping("/{id}")
    public OrderDetailDTO getOrderDetails(@PathVariable Long id) {
        Order order = orderService.getOrderWithItems(id);
        return convertToDTO(order);
    }
    
    private OrderDetailDTO convertToDTO(Order order) {
        // Order（1）から OrderDetailDTO（複合オブジェクト）への変換
        OrderDetailDTO dto = new OrderDetailDTO();
        dto.setId(order.getId());
        dto.setOrderDate(order.getOrderDate());
        dto.setCustomer(new CustomerDTO(order.getCustomer()));
        
        // OrderItems（多）をDTO形式に変換
        List<OrderItemDTO> itemDTOs = order.getItems().stream()
            .map(item -> new OrderItemDTO(
                item.getId(),
                item.getProduct().getName(),
                item.getQuantity(),
                item.getPrice()
            ))
            .collect(Collectors.toList());
            
        dto.setItems(itemDTOs);
        dto.setTotalAmount(calculateTotal(order.getItems()));
        
        return dto;
    }
    
    // その他のメソッド省略
}</code>

                        <div class="note">
                            <h5>RESTful APIのレスポンス設計のベストプラクティス</h5>
                            <p>APIレスポンスを設計する際の推奨事項：</p>
                            <ul>
                                <li>一貫したレスポンス構造を使用する</li>
                                <li>エンティティを直接公開せず、DTOを使用する</li>
                                <li>PII（個人を特定できる情報）や機密情報を除外する</li>
                                <li>日付や数値の標準フォーマットを定義する</li>
                                <li>最小限必要な情報のみを返す（過剰な情報は避ける）</li>
                                <li>エラーレスポンスに役立つ情報を含める</li>
                            </ul>
                        </div>

                        <div class="warning">
                            <h5>セキュリティに関する注意</h5>
                            <p>JSONデータ処理における注意点：</p>
                            <ul>
                                <li>JSONの深さや大きさに制限を設ける（DoS攻撃の軽減）</li>
                                <li>機密データの誤った公開を避ける（@JsonIgnore の適切な使用）</li>
                                <li>Jacksonのデシリアライゼーション脆弱性に注意する（信頼できないクラスへのデシリアライズを制限）</li>
                                <li>入力JSONのバリデーションを行う</li>
                            </ul>
                        </div>
                    </section>

                    <section id="request-body">
                        <h3 class="section-title">10.4 @RequestBodyによるデータ受信</h3>
                        <p>クライアントからのJSONデータをJavaオブジェクトとして受け取るには、@RequestBodyアノテーションを使用します。この機能は、POST、PUT、PATCHリクエストでデータを受信する際に特に有用です。</p>

                        <h4>@RequestBodyの基本的な使い方</h4>
                        <p>@RequestBodyアノテーションをコントローラーメソッドの引数に付けることで、HTTPリクエストボディの内容がJavaオブジェクトに自動的に変換されます。</p>

                        <code>@RestController
@RequestMapping("/api/products")
public class ProductController {

    private final ProductService productService;
    
    public ProductController(ProductService productService) {
        this.productService = productService;
    }
    
    @PostMapping
    public ResponseEntity&lt;Product&gt; createProduct(@RequestBody ProductCreateDTO productDTO) {
        Product createdProduct = productService.createProduct(productDTO);
        
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(createdProduct.getId())
                .toUri();
                
        return ResponseEntity.created(location).body(createdProduct);
    }
}</code>

                        <p>例えば、クライアントが次のようなJSONデータをPOSTリクエストのボディに含めてリクエストを送信したとします：</p>

                        <code>{
  "name": "ワイヤレスイヤホン",
  "description": "高音質なワイヤレスイヤホン",
  "price": 15000,
  "categoryId": 5
}</code>

                        <p>このJSONデータは、次のようなProductCreateDTOクラスにマッピングされます：</p>

                        <code>public class ProductCreateDTO {
    private String name;
    private String description;
    private BigDecimal price;
    private Long categoryId;
    
    // ゲッター・セッター
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public BigDecimal getPrice() {
        return price;
    }
    
    public void setPrice(BigDecimal price) {
        this.price = price;
    }
    
    public Long getCategoryId() {
        return categoryId;
    }
    
    public void setCategoryId(Long categoryId) {
        this.categoryId = categoryId;
    }
}</code>

                        <h4>データ検証の追加</h4>
                        <p>@RequestBodyで受け取ったデータを検証するには、Beanバリデーションを使用できます。@Validアノテーションと組み合わせて使用します。</p>

                        <code>import javax.validation.Valid;
import javax.validation.constraints.*;

@RestController
@RequestMapping("/api/users")
public class UserController {

    private final UserService userService;
    
    // コンストラクタ省略
    
    @PostMapping
    public ResponseEntity&lt;UserResponse&gt; registerUser(@Valid @RequestBody UserRegistrationDTO userDTO) {
        User savedUser = userService.registerUser(userDTO);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(new UserResponse(savedUser));
    }
}

public class UserRegistrationDTO {
    @NotBlank(message = "ユーザー名は必須です")
    @Size(min = 5, max = 50, message = "ユーザー名は5〜50文字で入力してください")
    private String username;
    
    @NotBlank(message = "メールアドレスは必須です")
    @Email(message = "有効なメールアドレスを入力してください")
    private String email;
    
    @NotBlank(message = "パスワードは必須です")
    @Size(min = 8, message = "パスワードは8文字以上で入力してください")
    @Pattern(regexp = "^(?=.*[0-9])(?=.*[a-zA-Z]).*$", 
             message = "パスワードは少なくとも1つの数字と1つのアルファベットを含む必要があります")
    private String password;
    
    // ゲッター・セッター省略
}</code>

                        <p>バリデーションエラーが発生した場合、Spring MVCは自動的にMethodArgumentNotValidExceptionをスローします。このエラーをグローバルに処理するには、@ControllerAdviceを使用できます。</p>

                        <code>@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity&lt;ValidationErrorResponse&gt; handleValidationExceptions(
            MethodArgumentNotValidException ex) {
        
        ValidationErrorResponse errors = new ValidationErrorResponse();
        
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.addError(fieldName, errorMessage);
        });
        
        return ResponseEntity.badRequest().body(errors);
    }
}

// バリデーションエラー用のレスポンスクラス
public class ValidationErrorResponse {
    private List&lt;ValidationError&gt; errors = new ArrayList&lt;&gt;();
    
    public void addError(String field, String message) {
        errors.add(new ValidationError(field, message));
    }
    
    public List&lt;ValidationError&gt; getErrors() {
        return errors;
    }
    
    // 内部クラス
    public static class ValidationError {
        private String field;
        private String message;
        
        public ValidationError(String field, String message) {
            this.field = field;
            this.message = message;
        }
        
        // ゲッター・セッター省略
    }
}</code>

                        <h4>複雑なリクエストボディの処理</h4>
                        <p>ネストされたオブジェクト、リストなどの複雑な構造もJSONからマッピングできます。</p>

                        <code>// 注文作成APIの例
@RestController
@RequestMapping("/api/orders")
public class OrderController {

    private final OrderService orderService;
    
    // コンストラクタ省略
    
    @PostMapping
    public ResponseEntity&lt;OrderDTO&gt; createOrder(@Valid @RequestBody OrderCreateDTO orderDTO) {
        Order order = orderService.createOrder(orderDTO);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(new OrderDTO(order));
    }
}

// 複雑なリクエストDTO
public class OrderCreateDTO {
    @NotNull(message = "顧客IDは必須です")
    private Long customerId;
    
    private String shippingAddress;
    
    @NotEmpty(message = "注文項目は少なくとも1つ必要です")
    private List&lt;OrderItemDTO&gt; items;
    
    // ゲッター・セッター省略
}

public class OrderItemDTO {
    @NotNull(message = "商品IDは必須です")
    private Long productId;
    
    @Min(value = 1, message = "数量は1以上必要です")
    private int quantity;
    
    // ゲッター・セッター省略
}</code>

                        <p>このAPIに対して、クライアントは次のようなJSON形式でデータを送信できます：</p>

                        <code>{
  "customerId": 1001,
  "shippingAddress": "東京都渋谷区...",
  "items": [
    {
      "productId": 5,
      "quantity": 2
    },
    {
      "productId": 8,
      "quantity": 1
    }
  ]
}</code>

                        <div class="note">
                            <h5>DTOパターンの利点</h5>
                            <p>APIリクエスト・レスポンスにはDTO（Data Transfer Object）パターンを使用するメリット：</p>
                            <ul>
                                <li>内部モデル（エンティティ）と外部APIの分離</li>
                                <li>バージョニングしやすい</li>
                                <li>必要なデータのみを送受信可能</li>
                                <li>ドメインロジックの漏洩防止</li>
                                <li>セキュリティの向上（機密フィールドを除外可能）</li>
                                <li>バリデーションをユースケースに合わせて設計可能</li>
                            </ul>
                        </div>
                    </section>

                    <section id="webclient-basics">
                        <h3 class="section-title">10.5 Spring WebClientの基礎</h3>
                        <p>Spring WebClientは、Spring 5で導入されたノンブロッキングでリアクティブなHTTPクライアントです。従来のRestTemplateに代わる次世代のHTTPクライアントとして位置づけられています。</p>

                        <h4>WebClientの特徴</h4>
                        <ul>
                            <li><strong>リアクティブ</strong>: Reactive Streamsをサポートし、ノンブロッキング操作が可能</li>
                            <li><strong>柔軟なAPI</strong>: 宣言的なAPIでチェーンスタイルのメソッド呼び出しが可能</li>
                            <li><strong>効率的</strong>: 単一のスレッドで多くの並行リクエストを処理可能</li>
                            <li><strong>機能豊富</strong>: 様々なリクエスト・レスポンス処理オプションを提供</li>
                            <li><strong>テスト容易性</strong>: モックサーバーとの統合が容易</li>
                        </ul>

                        <h4>WebClientのセットアップ</h4>
                        <p>まず、Spring WebFluxの依存関係をプロジェクトに追加します（Spring Boot Starterを使用している場合）：</p>

                        <code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
&lt;/dependency&gt;</code>

                        <p>または、Gradleを使用している場合：</p>

                        <code>implementation 'org.springframework.boot:spring-boot-starter-webflux'</code>

                        <p>WebClientのインスタンスを作成する方法：</p>

                        <code>// 最もシンプルな方法
WebClient webClient = WebClient.create();

// ベースURLを指定
WebClient webClient = WebClient.create("https://api.example.com");

// カスタマイズしたWebClient
WebClient webClient = WebClient.builder()
        .baseUrl("https://api.example.com")
        .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
        .defaultCookie("cookie-name", "cookie-value")
        .build();</code>

                        <h4>Bean定義としてのWebClient</h4>
                        <p>通常は、WebClientをSpring Beanとして定義し、アプリケーション全体で再利用します：</p>

                        <code>@Configuration
public class WebClientConfig {

    @Bean
    public WebClient webClient() {
        return WebClient.builder()
                .baseUrl("https://api.example.com")
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .codecs(configurer -> configurer
                        .defaultCodecs()
                        .maxInMemorySize(16 * 1024 * 1024)) // バッファサイズ増加（16MB）
                .filter(logRequest())  // リクエストロギング
                .build();
    }
    
    // リクエストロギング用のフィルター
    private ExchangeFilterFunction logRequest() {
        return ExchangeFilterFunction.ofRequestProcessor(clientRequest -> {
            log.info("Request: {} {}", clientRequest.method(), clientRequest.url());
            return Mono.just(clientRequest);
        });
    }
}</code>

                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 250" width="600" height="250">
                                <!-- Spring App -->
                                <rect x="50" y="50" width="150" height="150" fill="#e3f2fd" stroke="#2196f3" stroke-width="2" rx="5" />
                                <text x="125" y="100" text-anchor="middle" font-size="14">Spring Application</text>
                                
                                <!-- WebClient -->
                                <rect x="70" y="120" width="110" height="50" fill="#fff3e0" stroke="#ff9800" stroke-width="2" rx="5" />
                                <text x="125" y="150" text-anchor="middle" font-size="14">WebClient</text>
                                
                                <!-- External API -->
                                <rect x="400" y="50" width="150" height="150" fill="#f3e5f5" stroke="#9c27b0" stroke-width="2" rx="5" />
                                <text x="475" y="100" text-anchor="middle" font-size="14">External API</text>
                                
                                <!-- API Endpoints -->
                                <rect x="420" y="120" width="110" height="30" fill="#e8f5e9" stroke="#4caf50" stroke-width="1.5" rx="3" />
                                <text x="475" y="140" text-anchor="middle" font-size="12">/api/products</text>
                                
                                <rect x="420" y="160" width="110" height="30" fill="#e8f5e9" stroke="#4caf50" stroke-width="1.5" rx="3" />
                                <text x="475" y="180" text-anchor="middle" font-size="12">/api/orders</text>
                                
                                <!-- Connecting Lines -->
                                <line x1="180" y1="135" x2="380" y2="135" stroke="#000" stroke-width="1.5" stroke-dasharray="5,5" />
                                <polygon points="380,135 372,132 372,138" fill="#000" />
                                
                                <line x1="380" y1="165" x2="180" y2="165" stroke="#000" stroke-width="1.5" stroke-dasharray="5,5" />
                                <polygon points="180,165 188,162 188,168" fill="#000" />
                                
                                <!-- Labels -->
                                <text x="280" y="125" text-anchor="middle" font-size="12">HTTP Request</text>
                                <text x="280" y="185" text-anchor="middle" font-size="12">HTTP Response</text>
                                
                                <text x="125" y="30" text-anchor="middle" font-size="16" font-weight="bold">Spring Application</text>
                                <text x="475" y="30" text-anchor="middle" font-size="16" font-weight="bold">External Service</text>
                            </svg>
                            <p class="text-center">図10.2: WebClientによる外部APIとの連携</p>
                        </div>
                    </section>

                    <section id="webclient-usage">
                        <h3 class="section-title">10.6 WebClientによる外部API連携</h3>
                        <p>WebClientを使用して外部APIと連携する方法を具体的に見ていきましょう。基本的なHTTPリクエストから、エラーハンドリング、レスポンス処理まで解説します。</p>

                        <h4>基本的なGETリクエスト</h4>
                        <p>WebClientを使用してGETリクエストを実行し、JSONレスポンスを処理する例：</p>

                        <code>@Service
public class ProductApiClient {
    
    private final WebClient webClient;
    
    public ProductApiClient(WebClient webClient) {
        this.webClient = webClient;
    }
    
    public Mono&lt;ProductDTO&gt; getProductById(Long id) {
        return webClient.get()
                .uri("/products/{id}", id)
                .retrieve()
                .bodyToMono(ProductDTO.class);
    }
    
    public Flux&lt;ProductDTO&gt; getAllProducts() {
        return webClient.get()
                .uri("/products")
                .retrieve()
                .bodyToFlux(ProductDTO.class);
    }
}</code>

                        <p>上記のコードでは、WebClientを使用して外部APIからプロダクト情報を取得しています。レスポンスはリアクティブな型（MonoやFlux）で返されます。</p>

                        <ul>
                            <li><strong>Mono&lt;T&gt;</strong>: 0または1つの要素を表す</li>
                            <li><strong>Flux&lt;T&gt;</strong>: 0、1つ、または複数の要素を表す</li>
                        </ul>

                        <h4>POSTリクエストの実行</h4>
                        <p>WebClientを使用してPOSTリクエストを送信し、新しいリソースを作成する例：</p>

                        <code>@Service
public class OrderApiClient {
    
    private final WebClient webClient;
    
    public OrderApiClient(WebClient webClient) {
        this.webClient = webClient;
    }
    
    public Mono&lt;OrderResponseDTO&gt; createOrder(OrderRequestDTO orderRequest) {
        return webClient.post()
                .uri("/orders")
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(orderRequest)  // リクエストボディを設定
                .retrieve()
                .bodyToMono(OrderResponseDTO.class);
    }
}</code>

                        <h4>クエリパラメータの追加</h4>
                        <p>クエリパラメータを含むリクエストを送信する例：</p>

                        <code>public Flux&lt;ProductDTO&gt; searchProducts(String keyword, int page, int size) {
    return webClient.get()
            .uri(uriBuilder -> uriBuilder
                    .path("/products/search")
                    .queryParam("keyword", keyword)
                    .queryParam("page", page)
                    .queryParam("size", size)
                    .build())
            .retrieve()
            .bodyToFlux(ProductDTO.class);
}</code>

                        <h4>リクエストヘッダーの追加</h4>
                        <p>カスタムヘッダーを含むリクエストを送信する例：</p>

                        <code>public Mono&lt;UserDTO&gt; getUserProfile(String token) {
    return webClient.get()
            .uri("/users/me")
            .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
            .retrieve()
            .bodyToMono(UserDTO.class);
}</code>

                        <h4>エラーハンドリング</h4>
                        <p>エラーレスポンスを適切に処理する方法：</p>

                        <code>public Mono&lt;ProductDTO&gt; getProductById(Long id) {
    return webClient.get()
            .uri("/products/{id}", id)
            .retrieve()
            // エラーハンドリング
            .onStatus(
                    HttpStatus::is4xxClientError,
                    response -> {
                        if (response.statusCode() == HttpStatus.NOT_FOUND) {
                            return Mono.error(new ResourceNotFoundException("製品が見つかりません: " + id));
                        }
                        return response.bodyToMono(String.class)
                                .flatMap(body -> Mono.error(new ClientException("クライアントエラー: " + body)));
                    })
            .onStatus(
                    HttpStatus::is5xxServerError,
                    response -> response.bodyToMono(String.class)
                            .flatMap(body -> Mono.error(new ServerException("サーバーエラー: " + body)))
            )
            .bodyToMono(ProductDTO.class);
}</code>

                        <h4>タイムアウト設定</h4>
                        <p>リクエストのタイムアウトを設定する例：</p>

                        <code>public Mono&lt;ProductDTO&gt; getProductWithTimeout(Long id) {
    return webClient.get()
            .uri("/products/{id}", id)
            .retrieve()
            .bodyToMono(ProductDTO.class)
            .timeout(Duration.ofSeconds(5))  // 5秒のタイムアウト
            .onErrorResume(TimeoutException.class, ex -> {
                log.error("リクエストがタイムアウトしました: " + ex.getMessage());
                return Mono.error(new ServiceException("サービス応答時間が長すぎます"));
            });
}</code>

                        <h4>非同期処理の実行</h4>
                        <p>WebClientのリアクティブな結果を実際のコードで使用する方法：</p>

                        <code>@RestController
@RequestMapping("/api/product-catalog")
public class ProductCatalogController {

    private final ProductApiClient productApiClient;
    
    public ProductCatalogController(ProductApiClient productApiClient) {
        this.productApiClient = productApiClient;
    }
    
    // リアクティブエンドポイント（WebFluxを使用）
    @GetMapping("/{id}")
    public Mono&lt;ProductDTO&gt; getProduct(@PathVariable Long id) {
        return productApiClient.getProductById(id);
    }
    
    // 従来のSpring MVCスタイルのエンドポイント
    @GetMapping("/sync/{id}")
    public ResponseEntity&lt;ProductDTO&gt; getProductSync(@PathVariable Long id) {
        // Monoを同期的にブロックして結果を取得
        ProductDTO product = productApiClient.getProductById(id)
                .block(Duration.ofSeconds(10));  // 最大10秒待機
                
        return ResponseEntity.ok(product);
    }
    
    // 複数のAPIコールを組み合わせる
    @GetMapping("/product-with-reviews/{id}")
    public Mono&lt;ProductDetailDTO&gt; getProductWithReviews(@PathVariable Long id) {
        // 製品情報とレビューを並行して取得
        Mono&lt;ProductDTO&gt; productMono = productApiClient.getProductById(id);
        Flux&lt;ReviewDTO&gt; reviewsFlux = productApiClient.getReviewsForProduct(id);
        
        // 両方の結果を組み合わせる
        return productMono.zipWith(reviewsFlux.collectList())
                .map(tuple -> {
                    ProductDTO product = tuple.getT1();
                    List&lt;ReviewDTO&gt; reviews = tuple.getT2();
                    
                    return new ProductDetailDTO(product, reviews);
                });
    }
}</code>

                        <div class="note">
                            <h5>WebClientとRestTemplateの比較</h5>
                            <table class="table-example">
                                <tr>
                                    <th>特徴</th>
                                    <th>WebClient</th>
                                    <th>RestTemplate</th>
                                </tr>
                                <tr>
                                    <td>ブロッキング/ノンブロッキング</td>
                                    <td>ノンブロッキング（非同期）</td>
                                    <td>ブロッキング（同期）</td>
                                </tr>
                                <tr>
                                    <td>サポートするプログラミングスタイル</td>
                                    <td>リアクティブ、非同期</td>
                                    <td>命令型、同期</td>
                                </tr>
                                <tr>
                                    <td>スレッド効率</td>
                                    <td>高い（少数のスレッドで多くのリクエストを処理）</td>
                                    <td>低い（リクエストごとにスレッドがブロック）</td>
                                </tr>
                                <tr>
                                    <td>学習曲線</td>
                                    <td>やや急（リアクティブプログラミングの理解が必要）</td>
                                    <td>緩やか（伝統的なプログラミングスタイル）</td>
                                </tr>
                                <tr>
                                    <td>将来性</td>
                                    <td>推奨（今後も開発継続）</td>
                                    <td>非推奨（維持モードで新機能なし）</td>
                                </tr>
                            </table>
                        </div>
                    </section>

                    <section id="practical-exercises">
                        <h3 class="section-title">10.7 実践演習</h3>
                        <div class="exercise">
                            <h4>演習1: REST APIの作成</h4>
                            <p>以下の要件を満たすREST APIを作成してください：</p>
                            <ol>
                                <li>商品（Product）のCRUD操作を提供するRESTful APIを実装する</li>
                                <li>商品モデルには以下のフィールドを含める：
                                    <ul>
                                        <li>id (Long): 商品ID</li>
                                        <li>name (String): 商品名</li>
                                        <li>description (String): 商品説明</li>
                                        <li>price (BigDecimal): 価格</li>
                                        <li>stock (Integer): 在庫数</li>
                                        <li>createdAt (LocalDateTime): 作成日時</li>
                                    </ul>
                                </li>
                                <li>適切なバリデーションを追加する</li>
                                <li>適切なHTTPステータスコードを返す</li>
                                <li>商品が見つからない場合のエラーハンドリングを実装する</li>
                            </ol>

                            <p>実装例：</p>
                            <code>@RestController
@RequestMapping("/api/products")
public class ProductController {

    private final ProductService productService;
    
    public ProductController(ProductService productService) {
        this.productService = productService;
    }
    
    @GetMapping
    public List&lt;ProductDTO&gt; getAllProducts() {
        return productService.findAllProducts()
                .stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }
    
    @GetMapping("/{id}")
    public ResponseEntity&lt;ProductDTO&gt; getProductById(@PathVariable Long id) {
        return productService.findProductById(id)
                .map(product -> ResponseEntity.ok(convertToDTO(product)))
                .orElseGet(() -> ResponseEntity.notFound().build());
    }
    
    @PostMapping
    public ResponseEntity&lt;ProductDTO&gt; createProduct(@Valid @RequestBody ProductCreateDTO productDTO) {
        Product product = convertToEntity(productDTO);
        Product savedProduct = productService.saveProduct(product);
        
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(savedProduct.getId())
                .toUri();
                
        return ResponseEntity.created(location).body(convertToDTO(savedProduct));
    }
    
    @PutMapping("/{id}")
    public ResponseEntity&lt;ProductDTO&gt; updateProduct(
            @PathVariable Long id, 
            @Valid @RequestBody ProductUpdateDTO productDTO) {
            
        return productService.findProductById(id)
                .map(existingProduct -> {
                    updateProductEntity(existingProduct, productDTO);
                    Product updatedProduct = productService.saveProduct(existingProduct);
                    return ResponseEntity.ok(convertToDTO(updatedProduct));
                })
                .orElseGet(() -> ResponseEntity.notFound().build());
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity&lt;Void&gt; deleteProduct(@PathVariable Long id) {
        return productService.findProductById(id)
                .map(product -> {
                    productService.deleteProduct(id);
                    return ResponseEntity.noContent().&lt;Void&gt;build();
                })
                .orElseGet(() -> ResponseEntity.notFound().build());
    }
    
    // 変換メソッド省略...
}</code>
                        </div>

                        <div class="exercise">
                            <h4>演習2: WebClientを使った外部API連携</h4>
                            <p>外部の天気APIから情報を取得し、表示するサービスを作成してください：</p>
                            <ol>
                                <li>WebClientを使って外部の天気APIにリクエストを送信する</li>
                                <li>都市名をパラメータとして受け取り、その都市の現在の天気情報を返すエンドポイントを作成する</li>
                                <li>適切なエラーハンドリングを実装する</li>
                                <li>レスポンスをキャッシュして、短時間内の同じリクエストに対しては再度APIを呼び出さないようにする</li>
                            </ol>

                            <p>実装例：</p>
                            <code>@Configuration
public class WebClientConfig {
    
    @Bean
    public WebClient weatherWebClient() {
        return WebClient.builder()
                .baseUrl("https://api.weatherapi.com/v1")
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }
}

@Service
public class WeatherService {
    
    private final WebClient webClient;
    private final Map&lt;String, CachedWeatherData&gt; cache = new ConcurrentHashMap&lt;&gt;();
    private static final Duration CACHE_DURATION = Duration.ofMinutes(30);
    
    public WeatherService(@Qualifier("weatherWebClient") WebClient webClient) {
        this.webClient = webClient;
    }
    
    public Mono&lt;WeatherResponse&gt; getWeatherForCity(String city) {
        // キャッシュチェック
        CachedWeatherData cachedData = cache.get(city);
        if (cachedData != null && !cachedData.isExpired()) {
            return Mono.just(cachedData.getData());
        }
        
        // 新しいデータ取得
        return webClient.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/current.json")
                        .queryParam("key", "YOUR_API_KEY")
                        .queryParam("q", city)
                        .build())
                .retrieve()
                .onStatus(
                        HttpStatus::is4xxClientError,
                        response -> {
                            if (response.statusCode() == HttpStatus.NOT_FOUND) {
                                return Mono.error(new ResourceNotFoundException("都市が見つかりません: " + city));
                            }
                            return response.bodyToMono(String.class)
                                    .flatMap(body -> Mono.error(new ClientException("クライアントエラー: " + body)));
                        })
                .onStatus(
                        HttpStatus::is5xxServerError,
                        response -> response.bodyToMono(String.class)
                                .flatMap(body -> Mono.error(new ServerException("サーバーエラー: " + body)))
                )
                .bodyToMono(WeatherResponse.class)
                .doOnNext(response -> {
                    // レスポンスをキャッシュに保存
                    cache.put(city, new CachedWeatherData(response, Instant.now().plus(CACHE_DURATION)));
                });
    }
    
    // キャッシュ用内部クラス
    private static class CachedWeatherData {
        private final WeatherResponse data;
        private final Instant expiresAt;
        
        public CachedWeatherData(WeatherResponse data, Instant expiresAt) {
            this.data = data;
            this.expiresAt = expiresAt;
        }
        
        public boolean isExpired() {
            return Instant.now().isAfter(expiresAt);
        }
        
        public WeatherResponse getData() {
            return data;
        }
    }
}

@RestController
@RequestMapping("/api/weather")
public class WeatherController {
    
    private final WeatherService weatherService;
    
    public WeatherController(WeatherService weatherService) {
        this.weatherService = weatherService;
    }
    
    @GetMapping("/{city}")
    public Mono&lt;WeatherResponse&gt; getWeather(@PathVariable String city) {
        return weatherService.getWeatherForCity(city);
    }
    
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleResourceNotFoundException(ResourceNotFoundException ex) {
        ErrorResponse error = new ErrorResponse("resource_not_found", ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    // 他の例外ハンドラ（省略）
}</code>
                        </div>
                    </section>

                    <section id="chapter10-quiz">
                        <h3 class="section-title">10.8 理解度確認テスト</h3>
                        <div class="quiz-container">
                            <h4>第10章の理解度チェック</h4>
                            <p>以下の問題に答えて、第10章の内容の理解度を確認しましょう。</p>
                            
                            <div class="quiz-question">
                                <p><strong>問題1:</strong> RESTfulなAPIにおいて、リソースの新規作成に適したHTTPメソッドはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1a" value="a">
                                    <label class="form-check-label" for="q1a">
                                        GET
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1b" value="b">
                                    <label class="form-check-label" for="q1b">
                                        POST
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1c" value="c">
                                        <label class="form-check-label" for="q1c">
                                        PUT
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1d" value="d">
                                        <label class="form-check-label" for="q1d">
                                        DELETE
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題2:</strong> Spring Frameworkで、JavaオブジェクトをJSONに自動変換するために使用されるライブラリは何ですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2a" value="a">
                                    <label class="form-check-label" for="q2a">
                                        GSON
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2b" value="b">
                                    <label class="form-check-label" for="q2b">
                                        Jackson
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2c" value="c">
                                        <label class="form-check-label" for="q2c">
                                        JSON.simple
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2d" value="d">
                                        <label class="form-check-label" for="q2d">
                                        org.json
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題3:</strong> @RestControllerアノテーションは、どの2つのアノテーションを組み合わせたものですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3a" value="a">
                                    <label class="form-check-label" for="q3a">
                                        @Controller と @ResponseStatus
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3b" value="b">
                                    <label class="form-check-label" for="q3b">
                                        @Controller と @ResponseBody
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3c" value="c">
                                        <label class="form-check-label" for="q3c">
                                        @Component と @RequestMapping
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3d" value="d">
                                        <label class="form-check-label" for="q3d">
                                        @Service と @ResponseEntity
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題4:</strong> WebClientとRestTemplateの主な違いは何ですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4a" value="a">
                                    <label class="form-check-label" for="q4a">
                                        WebClientはGETリクエストのみをサポートし、RestTemplateは全HTTPメソッドをサポートする
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4b" value="b">
                                    <label class="form-check-label" for="q4b">
                                        RestTemplateはSpring Boot 1.xのみで動作し、WebClientはSpring Boot 2.x以降でのみ動作する
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4c" value="c">
                                        <label class="form-check-label" for="q4c">
                                        WebClientはノンブロッキング・リアクティブな動作をし、RestTemplateはブロッキング動作をする
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4d" value="d">
                                        <label class="form-check-label" for="q4d">
                                        RestTemplateはJSONのみをサポートし、WebClientは複数のデータフォーマットをサポートする
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題5:</strong> リソースが正常に作成された場合に返すべき適切なHTTPステータスコードはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5a" value="a">
                                    <label class="form-check-label" for="q5a">
                                        200 OK
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5b" value="b">
                                    <label class="form-check-label" for="q5b">
                                        201 Created
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5c" value="c">
                                        <label class="form-check-label" for="q5c">
                                        204 No Content
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5d" value="d">
                                        <label class="form-check-label" for="q5d">
                                        302 Found
                                    </label>
                                </div>
                            </div>
                            
                            <button class="btn btn-success mt-3" id="checkAnswers">回答を確認</button>
                            <div id="quizResults" class="mt-3 d-none">
                                <div class="alert alert-success">
                                    <h5>正解:</h5>
                                    <ol>
                                        <li>b（POST）</li>
                                        <li>b（Jackson）</li>
                                        <li>b（@Controller と @ResponseBody）</li>
                                        <li>c（WebClientはノンブロッキング・リアクティブな動作をし、RestTemplateはブロッキング動作をする）</li>
                                        <li>b（201 Created）</li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="next-steps">
                        <h3 class="section-title">次のステップ</h3>
                        <p>この章では、REST API開発とWebClientを使った外部API連携について学びました。これらのスキルはマイクロサービスアーキテクチャや分散システムの開発において非常に重要です。</p>
                        <p>次の章では、より高度なSpring開発トピックとして、Spring Security、テストの実践、アプリケーションのデプロイについて学んでいきます。</p>
                        <div class="note">
                            <h5>推奨される追加学習</h5>
                            <ul>
                                <li><strong>REST API設計の詳細</strong>：<a href="https://restfulapi.net/" target="_blank">REST API Tutorial</a></li>
                                <li><strong>Spring WebFluxの詳細</strong>：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html" target="_blank">Spring WebFlux Documentation</a></li>
                                <li><strong>Project Reactor</strong>：<a href="https://projectreactor.io/docs/core/release/reference/" target="_blank">Reactor Core Documentation</a></li>
                                <li><strong>APIセキュリティ</strong>：<a href="https://owasp.org/www-project-api-security/" target="_blank">OWASP API Security Project</a></li>
                            </ul>
                        </div>
                    </section>
                </section>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="text-center py-4">
        <div class="container">
            <p class="mb-0">Copyright © 2025 F-Circle All rights reserved.</p>
        </div>
    </footer>

    <!-- Bootstrap JS and Popper.js -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 理解度テストの回答確認ボタンの処理
        document.getElementById('checkAnswers').addEventListener('click', function() {
            document.getElementById('quizResults').classList.remove('d-none');
        });
    </script>
</body>
</html>