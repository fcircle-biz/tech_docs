<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" id="viewport-meta">
    <title>React学習教材 第11章 - データフェッチングと状態同期</title>

    <!-- ダークモード早期適用（フラッシュ防止） -->
    <script>
        (function() {
            const saved = localStorage.getItem('darkMode');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (saved === 'dark' || (saved === null && prefersDark)) {
                document.documentElement.classList.add('dark');
            }
        })();
    </script>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // React - Cyan
                        primary: {
                            50: '#ecfeff',
                            100: '#cffafe',
                            200: '#a5f3fc',
                            300: '#67e8f9',
                            400: '#22d3ee',
                            500: '#06b6d4',
                            600: '#0891b2',
                            700: '#0e7490',
                            800: '#155e75',
                            900: '#164e63',
                        }
                    },
                    fontFamily: {
                        sans: ['"Noto Sans JP"', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    <!-- Google Fonts - Noto Sans JP -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- カスタムスタイル -->
    <link rel="stylesheet" href="styles.css">
</head>
<body class="font-sans bg-slate-50 text-slate-800 antialiased">
    <!-- ヘッダー/ナビゲーションバー -->
    <header class="fixed top-0 left-0 right-0 z-50 text-white header-rich header-rich-shadow">
        <nav class="w-full px-4 sm:px-6 lg:px-8 relative z-10">
            <div class="flex items-center justify-between py-3">
                <!-- 左側: ロゴとタイトルセクション -->
                <div class="flex items-center gap-4">
                    <!-- アイコン -->
                    <div class="relative group">
                        <div class="absolute inset-0 bg-gradient-to-br from-cyan-400/30 to-blue-400/30 rounded-2xl blur-lg group-hover:blur-xl transition-all"></div>
                        <div class="relative w-14 h-14 bg-white/10 rounded-xl flex items-center justify-center backdrop-blur-sm border border-white/20">
                            <i class="fab fa-react text-3xl icon-rotate-hover drop-shadow-lg"></i>
                        </div>
                    </div>

                    <!-- タイトルとメタ情報 -->
                    <div class="flex flex-col gap-1">
                        <div class="flex items-center gap-2">
                            <span class="text-xl font-bold tracking-wide drop-shadow-md">React学習教材</span>
                            <span class="hidden sm:inline-flex items-center gap-1 px-2 py-0.5 bg-white/20 rounded-md text-[10px] font-semibold uppercase tracking-wider">
                                <i class="fas fa-star text-yellow-300 text-[8px]"></i>
                                初級〜中級
                            </span>
                        </div>
                        <div class="flex items-center gap-3 text-[11px] text-white/90 font-medium">
                            <div class="flex items-center gap-1">
                                <i class="fas fa-code text-[9px]"></i>
                                <span>JavaScriptライブラリ</span>
                            </div>
                            <div class="hidden sm:flex items-center gap-1">
                                <i class="fas fa-clock text-[9px]"></i>
                                <span>推奨 40分</span>
                            </div>
                            <div class="hidden lg:flex items-center gap-1">
                                <i class="fas fa-language text-[9px]"></i>
                                <span>日本語</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 右側: サイドバートグルボタン -->
                <button id="sidebar-toggle-btn" class="w-10 h-10 flex items-center justify-center rounded-lg hover:bg-white/20 transition-all active:scale-95" title="サイドバーの表示/非表示">
                    <i class="fas fa-bars text-lg"></i>
                </button>
            </div>
        </nav>
    </header>

    <!-- メインレイアウト -->
    <div class="flex min-h-screen pt-20">
        <!-- サイドバーはsidebar-content.jsで動的に生成されます -->

        <!-- メインコンテンツ -->
        <main class="flex-1 min-w-0">
            <div class="max-w-5xl mx-auto px-4 sm:px-6 lg:px-10 py-6">
                <!-- パンくずリスト -->
                <nav class="flex items-center gap-2 text-sm text-slate-500 mb-6">
                    <a href="https://fcircle-biz.github.io/tech_docs/" class="hover:text-primary-600 transition-colors">ホーム</a>
                    <i class="fas fa-chevron-right text-xs"></i>
                    <a href="https://fcircle-biz.github.io/tech_docs/guide/programming-languages/javascript-ecosystem/react/" class="hover:text-primary-600 transition-colors">React</a>
                    <i class="fas fa-chevron-right text-xs"></i>
                    <span class="text-slate-700">第11章</span>
                </nav>

                <!-- 章ヘッダー -->
                <header class="mb-6">
                    <div class="flex items-center gap-3 mb-2">
                        <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium
                                     bg-primary-100 text-primary-700">
                            第11章
                        </span>
                    </div>
                    <h1 class="text-2xl sm:text-3xl font-bold text-slate-900 mb-2">データフェッチングと状態同期</h1>
                    <p class="text-slate-600">モダンなデータフェッチング戦略、TanStack Query（React Query）の実装、キャッシュ管理、楽観的更新、無限スクロール、リアルタイム同期（WebSocket）、エラーハンドリング、リトライ戦略、バックグラウンド再フェッチ、データの正規化について実践的に学びます。</p>
                </header>

                <!-- 学習目標カード -->
                <div class="bg-gradient-to-r from-amber-50 to-yellow-50 border border-amber-200
                            rounded-xl p-5 mb-6 overflow-hidden">
                    <div class="flex items-start gap-4">
                        <div class="flex-shrink-0 w-10 h-10 bg-amber-400 rounded-lg
                                    flex items-center justify-center">
                            <i class="fas fa-lightbulb text-white"></i>
                        </div>
                        <div>
                            <h2 class="text-lg font-semibold text-amber-800 mb-3">この章で学ぶこと</h2>
                            <ul class="space-y-2">
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>TanStack Query（React Query）の基本と実装</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>キャッシュ戦略と効率的なデータ管理</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>楽観的更新（Optimistic Updates）の実装</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>無限スクロールとページネーション</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>WebSocketを使ったリアルタイム同期</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>エラーハンドリングとリトライ戦略</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- セクション1: モダンなデータフェッチングの課題 -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        11.1 モダンなデータフェッチングの課題
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        従来のuseEffectとfetchを使ったデータ取得には、多くの課題があります。キャッシュ管理、ローディング状態、エラー処理、再フェッチ、重複リクエスト防止など、実装すべき機能が多岐にわたります。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">従来のアプローチの問題点</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">従来のデータフェッチング（問題が多い例）</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">// 従来のアプローチ - 多くの問題を抱える
function UserList() {
  const [users, setUsers] = useState&lt;User[]&gt;([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState&lt;Error | null&gt;(null);

  useEffect(() => {
    setIsLoading(true);
    fetch('/api/users')
      .then(res => res.json())
      .then(data => setUsers(data))
      .catch(err => setError(err))
      .finally(() => setIsLoading(false));
  }, []);

  // 問題点: キャッシュなし、リトライなし、重複防止なし、
  // 古いデータの扱いが曖昧、バックグラウンド再取得なし
}</code></pre>
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">解決すべき課題</h3>

                    <div class="grid md:grid-cols-2 gap-4 my-6">
                        <div class="bg-gradient-to-br from-red-50 to-orange-50 border border-red-200 rounded-xl p-4">
                            <h4 class="font-semibold text-red-800 mb-2 flex items-center gap-2">
                                <i class="fas fa-database"></i>
                                キャッシュ管理
                            </h4>
                            <p class="text-red-900 text-sm">
                                同じデータを何度も取得しない、適切なタイミングで再取得する、古いデータを破棄するなどの制御が必要
                            </p>
                        </div>

                        <div class="bg-gradient-to-br from-orange-50 to-yellow-50 border border-orange-200 rounded-xl p-4">
                            <h4 class="font-semibold text-orange-800 mb-2 flex items-center gap-2">
                                <i class="fas fa-sync-alt"></i>
                                状態の同期
                            </h4>
                            <p class="text-orange-900 text-sm">
                                サーバーの最新状態とクライアントの状態を同期し、常に最新のデータを表示する
                            </p>
                        </div>

                        <div class="bg-gradient-to-br from-blue-50 to-cyan-50 border border-blue-200 rounded-xl p-4">
                            <h4 class="font-semibold text-blue-800 mb-2 flex items-center gap-2">
                                <i class="fas fa-exclamation-triangle"></i>
                                エラーハンドリング
                            </h4>
                            <p class="text-blue-900 text-sm">
                                ネットワークエラー、タイムアウト、APIエラーなどを適切に処理し、ユーザーに通知する
                            </p>
                        </div>

                        <div class="bg-gradient-to-br from-purple-50 to-pink-50 border border-purple-200 rounded-xl p-4">
                            <h4 class="font-semibold text-purple-800 mb-2 flex items-center gap-2">
                                <i class="fas fa-bolt"></i>
                                パフォーマンス
                            </h4>
                            <p class="text-purple-900 text-sm">
                                重複リクエストの防止、並列リクエストの最適化、バックグラウンド更新などが必要
                            </p>
                        </div>
                    </div>

                    <div class="bg-emerald-50 border-l-4 border-emerald-500 p-4 my-6 rounded-r-lg overflow-hidden">
                        <div class="flex items-start gap-3">
                            <i class="fas fa-star text-emerald-600 mt-1"></i>
                            <div class="flex-1 min-w-0">
                                <p class="text-emerald-900 font-medium break-words">TanStack Queryの登場</p>
                                <p class="text-emerald-800 text-sm mt-1 break-words">
                                    TanStack Query（旧React Query）は、これらの課題を解決するために設計されたデータフェッチングライブラリです。サーバー状態の管理に特化し、複雑な非同期処理を簡単に実装できます。
                                </p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- セクション2: TanStack Queryの基本 -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        11.2 TanStack Queryの基本
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        TanStack Queryは、データフェッチング、キャッシング、同期、バックグラウンド更新を自動化します。まずは基本的なセットアップとuseQueryフックの使い方を学びましょう。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">インストールとセットアップ</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">パッケージのインストール</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-bash"># TanStack Queryのインストール
npm install @tanstack/react-query
# または
yarn add @tanstack/react-query</code></pre>
                    </div>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">QueryClientの設定</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">// main.tsx または App.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

// QueryClientインスタンスの作成
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5分間はデータを新鮮とみなす
      cacheTime: 10 * 60 * 1000, // 10分間キャッシュを保持
      retry: 3, // 失敗時に3回リトライ
    },
  },
});

function App() {
  return (
    &lt;QueryClientProvider client={queryClient}&gt;
      {/* アプリ全体 */}
      &lt;YourApp /&gt;
      {/* 開発ツール */}
      &lt;ReactQueryDevtools initialIsOpen={false} /&gt;
    &lt;/QueryClientProvider&gt;
  );
}</code></pre>
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">useQueryの基本</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">基本的なデータフェッチング</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">import { useQuery } from '@tanstack/react-query';

interface User {
  id: number;
  name: string;
  email: string;
}

// データ取得関数
const fetchUsers = async (): Promise&lt;User[]&gt; => {
  const response = await fetch('/api/users');
  if (!response.ok) throw new Error('データ取得に失敗しました');
  return response.json();
};

function UserList() {
  // useQueryでデータを取得
  const { data, isLoading, error, isError } = useQuery({
    queryKey: ['users'], // 一意のキー
    queryFn: fetchUsers, // データ取得関数
  });

  if (isLoading) return &lt;div&gt;読み込み中...&lt;/div&gt;;
  if (isError) return &lt;div&gt;エラー: {error.message}&lt;/div&gt;;

  return (
    &lt;ul&gt;
      {data?.map(user => (
        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
                    </div>

                    <div class="bg-blue-50 border border-blue-200 rounded-xl p-5 my-6">
                        <div class="flex items-start gap-3">
                            <i class="fas fa-info-circle text-blue-500 text-lg mt-0.5"></i>
                            <div>
                                <h3 class="font-semibold text-blue-800 mb-2">queryKeyの重要性</h3>
                                <p class="text-blue-900 text-sm">
                                    queryKeyは、キャッシュの識別子として機能します。同じqueryKeyを持つクエリは、キャッシュを共有します。パラメータが変わる場合は、queryKeyに含めることで、異なるデータとして管理できます。
                                </p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- セクション3: キャッシュ戦略とデータの鮮度 -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        11.3 キャッシュ戦略とデータの鮮度
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        TanStack Queryは、データの鮮度を管理するために、staleTime、cacheTime、refetchOnWindowFocusなどのオプションを提供します。これらを理解することで、効率的なデータ管理が可能になります。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">キャッシュライフサイクル</h3>

                    <div class="mermaid">
flowchart LR
    A["クエリ実行"] --> B["データ取得"]
    B --> C["Fresh状態<br/>staleTime以内"]
    C --> D["Stale状態<br/>古いデータ"]
    D --> E["バックグラウンド<br/>再取得"]
    E --> C
    D --> F["cacheTime経過"]
    F --> G["キャッシュ削除"]
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">主要な設定オプション</h3>

                    <table class="w-full border-collapse bg-white rounded-lg overflow-hidden shadow-sm my-6">
                        <thead>
                            <tr class="bg-primary-500 text-white">
                                <th class="px-4 py-3 text-left">オプション</th>
                                <th class="px-4 py-3 text-left">説明</th>
                                <th class="px-4 py-3 text-left">デフォルト</th>
                            </tr>
                        </thead>
                        <tbody class="text-sm">
                            <tr class="border-b border-slate-200">
                                <td class="px-4 py-3 font-medium text-slate-700">staleTime</td>
                                <td class="px-4 py-3 text-slate-600">データが新鮮とみなされる期間</td>
                                <td class="px-4 py-3 text-slate-600">0（即座にstale）</td>
                            </tr>
                            <tr class="border-b border-slate-200 bg-slate-50">
                                <td class="px-4 py-3 font-medium text-slate-700">cacheTime</td>
                                <td class="px-4 py-3 text-slate-600">キャッシュを保持する期間</td>
                                <td class="px-4 py-3 text-slate-600">5分</td>
                            </tr>
                            <tr class="border-b border-slate-200">
                                <td class="px-4 py-3 font-medium text-slate-700">refetchOnWindowFocus</td>
                                <td class="px-4 py-3 text-slate-600">ウィンドウフォーカス時に再取得</td>
                                <td class="px-4 py-3 text-slate-600">true</td>
                            </tr>
                            <tr class="border-b border-slate-200 bg-slate-50">
                                <td class="px-4 py-3 font-medium text-slate-700">refetchOnMount</td>
                                <td class="px-4 py-3 text-slate-600">マウント時に再取得</td>
                                <td class="px-4 py-3 text-slate-600">true</td>
                            </tr>
                            <tr>
                                <td class="px-4 py-3 font-medium text-slate-700">retry</td>
                                <td class="px-4 py-3 text-slate-600">失敗時のリトライ回数</td>
                                <td class="px-4 py-3 text-slate-600">3</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">キャッシュ戦略のカスタマイズ</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">// ユースケース別のキャッシュ戦略
function ProductList() {
  // 頻繁に更新されるデータ（株価など）
  const { data: stockData } = useQuery({
    queryKey: ['stocks'],
    queryFn: fetchStocks,
    staleTime: 0, // 常にstale（再取得）
    refetchInterval: 10000, // 10秒ごとに自動再取得
  });

  // 更新頻度が低いデータ（商品一覧など）
  const { data: products } = useQuery({
    queryKey: ['products'],
    queryFn: fetchProducts,
    staleTime: 30 * 60 * 1000, // 30分間は新鮮
    cacheTime: 60 * 60 * 1000, // 1時間キャッシュ
  });
}</code></pre>
                    </div>
                </section>

                <!-- セクション4: データの更新とuseMutation -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        11.4 データの更新とuseMutation
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        データの作成・更新・削除には、useMutationフックを使用します。ミューテーション成功後のキャッシュ更新や楽観的更新も実装できます。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">基本的なuseMutation</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">useMutationの実装</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">import { useMutation, useQueryClient } from '@tanstack/react-query';

interface Todo {
  id: number;
  title: string;
  completed: boolean;
}

const addTodo = async (newTodo: Omit&lt;Todo, 'id'&gt;): Promise&lt;Todo&gt; => {
  const response = await fetch('/api/todos', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(newTodo),
  });
  if (!response.ok) throw new Error('追加に失敗しました');
  return response.json();
};

function TodoForm() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: addTodo,
    onSuccess: () => {
      // 成功後、todosクエリを無効化して再取得
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    mutation.mutate({ title: 'New Todo', completed: false });
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;button disabled={mutation.isPending}&gt;
        {mutation.isPending ? '追加中...' : '追加'}
      &lt;/button&gt;
      {mutation.isError && &lt;p&gt;{mutation.error.message}&lt;/p&gt;}
    &lt;/form&gt;
  );
}</code></pre>
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">楽観的更新（Optimistic Updates）</h3>

                    <p class="text-slate-600 leading-relaxed">
                        楽観的更新は、サーバーレスポンスを待たずにUIを即座に更新する手法です。ユーザー体験が向上しますが、失敗時のロールバック処理が必要です。
                    </p>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">楽観的更新の実装</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">function useTodoMutation() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: addTodo,
    // ミューテーション実行前
    onMutate: async (newTodo) => {
      // 進行中の再取得をキャンセル
      await queryClient.cancelQueries({ queryKey: ['todos'] });

      // 現在のデータを保存（ロールバック用）
      const previousTodos = queryClient.getQueryData(['todos']);

      // 楽観的に更新
      queryClient.setQueryData&lt;Todo[]&gt;(['todos'], (old = []) => [
        ...old,
        { id: Date.now(), ...newTodo }, // 仮ID
      ]);

      return { previousTodos }; // コンテキストを返す
    },
    // 失敗時: ロールバック
    onError: (err, newTodo, context) => {
      queryClient.setQueryData(['todos'], context?.previousTodos);
    },
    // 成功時: サーバーデータで更新
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    },
  });
}</code></pre>
                    </div>
                </section>

                <!-- セクション5: 無限スクロールとページネーション -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        11.5 無限スクロールとページネーション
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        大量のデータを効率的に表示するために、useInfiniteQueryを使った無限スクロールを実装します。
                    </p>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">useInfiniteQueryの実装</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">import { useInfiniteQuery } from '@tanstack/react-query';

interface Post {
  id: number;
  title: string;
  content: string;
}

const fetchPosts = async ({ pageParam = 1 }) => {
  const response = await fetch(`/api/posts?page=${pageParam}&limit=10`);
  return response.json();
};

function PostList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts,
    getNextPageParam: (lastPage, pages) => {
      // 次のページ番号を返す（なければundefined）
      return lastPage.hasMore ? pages.length + 1 : undefined;
    },
    initialPageParam: 1,
  });

  return (
    &lt;div&gt;
      {data?.pages.map((page, i) => (
        &lt;div key={i}&gt;
          {page.posts.map((post: Post) => (
            &lt;article key={post.id}&gt;{post.title}&lt;/article&gt;
          ))}
        &lt;/div&gt;
      ))}

      &lt;button
        onClick={() => fetchNextPage()}
        disabled={!hasNextPage || isFetchingNextPage}
      &gt;
        {isFetchingNextPage ? '読み込み中...' : 'もっと見る'}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>
                </section>

                <!-- セクション6: リアルタイム同期（WebSocket） -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        11.6 リアルタイム同期（WebSocket）
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        WebSocketを使って、サーバーからのリアルタイム更新を受け取り、TanStack Queryのキャッシュを自動更新します。
                    </p>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">WebSocketとTanStack Queryの統合</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">import { useQueryClient } from '@tanstack/react-query';
import { useEffect } from 'react';

function useRealtimeMessages() {
  const queryClient = useQueryClient();

  useEffect(() => {
    const ws = new WebSocket('ws://localhost:3000/messages');

    ws.onmessage = (event) => {
      const newMessage = JSON.parse(event.data);

      // キャッシュを更新
      queryClient.setQueryData&lt;Message[]&gt;(['messages'], (old = []) => [
        ...old,
        newMessage,
      ]);
    };

    return () => ws.close();
  }, [queryClient]);
}</code></pre>
                    </div>
                </section>

                <!-- 実習 -->
                <div class="bg-gradient-to-r from-purple-50 to-fuchsia-50 border border-purple-200
                            rounded-xl p-5 my-6 overflow-hidden">
                    <div class="flex items-start gap-4">
                        <div class="flex-shrink-0 w-10 h-10 bg-purple-500 rounded-lg
                                    flex items-center justify-center">
                            <i class="fas fa-code text-white"></i>
                        </div>
                        <div class="flex-1 min-w-0">
                            <h3 class="text-lg font-semibold text-purple-800 mb-3 break-words">
                                実習 11-1: TanStack Queryで記事管理アプリを作成
                            </h3>
                            <p class="text-purple-900 mb-4 break-words">
                                記事の一覧表示、作成、削除機能を持つアプリを、TanStack Queryを使って実装しましょう。
                            </p>

                            <h4 class="font-medium text-purple-800 mb-2">実装する機能</h4>
                            <ul class="space-y-2 mb-4">
                                <li class="flex items-start gap-2 text-purple-900">
                                    <i class="fas fa-check text-purple-500 mt-1"></i>
                                    <span>useQueryで記事一覧を取得</span>
                                </li>
                                <li class="flex items-start gap-2 text-purple-900">
                                    <i class="fas fa-check text-purple-500 mt-1"></i>
                                    <span>useMutationで記事を作成</span>
                                </li>
                                <li class="flex items-start gap-2 text-purple-900">
                                    <i class="fas fa-check text-purple-500 mt-1"></i>
                                    <span>楽観的更新を実装</span>
                                </li>
                                <li class="flex items-start gap-2 text-purple-900">
                                    <i class="fas fa-check text-purple-500 mt-1"></i>
                                    <span>エラーハンドリングとリトライ</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- 理解度確認クイズ -->
                <div class="bg-gradient-to-r from-blue-50 to-cyan-50 border border-blue-200
                            rounded-xl p-5 my-6 overflow-hidden">
                    <div class="flex items-start gap-4">
                        <div class="flex-shrink-0 w-10 h-10 bg-blue-500 rounded-lg
                                    flex items-center justify-center">
                            <i class="fas fa-question text-white"></i>
                        </div>
                        <div class="flex-1 min-w-0">
                            <h3 class="text-lg font-semibold text-blue-800 mb-4 break-words">理解度確認クイズ</h3>
                            <ol class="space-y-4">
                                <li class="text-blue-900">
                                    <p class="font-medium mb-2 break-words">Q1. staleTimeとcacheTimeの違いは何ですか？</p>
                                    <details class="mt-2">
                                        <summary class="cursor-pointer text-blue-600 hover:text-blue-700 break-words">
                                            回答を表示
                                        </summary>
                                        <p class="mt-2 pl-4 text-blue-800 bg-blue-100 rounded-lg p-3 break-words">
                                            <strong>回答:</strong> staleTimeはデータが「新鮮」とみなされる期間、cacheTimeはキャッシュがメモリに保持される期間です。staleTime経過後も、cacheTime以内であればキャッシュから即座にデータを返しつつ、バックグラウンドで再取得します。
                                        </p>
                                    </details>
                                </li>
                                <li class="text-blue-900">
                                    <p class="font-medium mb-2 break-words">Q2. 楽観的更新のメリットとデメリットは何ですか？</p>
                                    <details class="mt-2">
                                        <summary class="cursor-pointer text-blue-600 hover:text-blue-700 break-words">
                                            回答を表示
                                        </summary>
                                        <p class="mt-2 pl-4 text-blue-800 bg-blue-100 rounded-lg p-3 break-words">
                                            <strong>回答:</strong> メリットは即座にUIが反映され、ユーザー体験が向上すること。デメリットは、サーバーエラー時のロールバック処理が必要で、実装が複雑になることです。
                                        </p>
                                    </details>
                                </li>
                                <li class="text-blue-900">
                                    <p class="font-medium mb-2 break-words">Q3. queryKeyの役割は何ですか？</p>
                                    <details class="mt-2">
                                        <summary class="cursor-pointer text-blue-600 hover:text-blue-700 break-words">
                                            回答を表示
                                        </summary>
                                        <p class="mt-2 pl-4 text-blue-800 bg-blue-100 rounded-lg p-3 break-words">
                                            <strong>回答:</strong> queryKeyは、クエリの一意の識別子として機能し、キャッシュの管理、無効化、更新に使用されます。同じqueryKeyを持つクエリは、同じキャッシュを共有します。
                                        </p>
                                    </details>
                                </li>
                            </ol>
                        </div>
                    </div>
                </div>

                <!-- 章まとめ -->
                <div class="bg-gradient-to-r from-slate-50 to-slate-100 border border-slate-200 rounded-xl p-6 my-8">
                    <h2 class="text-xl font-semibold text-slate-800 mb-4 flex items-center gap-2">
                        <i class="fas fa-bookmark text-primary-500"></i>
                        第11章のまとめ
                    </h2>
                    <ul class="space-y-3 text-slate-700">
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>TanStack Queryは、データフェッチングの複雑な課題を解決する強力なライブラリ</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>useQueryでデータ取得、useMutationでデータ更新を簡潔に実装できる</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>staleTime、cacheTimeを調整して、最適なキャッシュ戦略を実現</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>楽観的更新により、レスポンシブなユーザー体験を提供</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>useInfiniteQueryで無限スクロールを効率的に実装</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>WebSocketとの統合により、リアルタイム同期が可能</span>
                        </li>
                    </ul>

                    <div class="mt-6 p-4 bg-primary-50 rounded-lg border border-primary-200">
                        <p class="text-primary-900 font-medium mb-2">
                            <i class="fas fa-arrow-right text-primary-600 mr-2"></i>次の章では
                        </p>
                        <p class="text-primary-800 text-sm">
                            React Testing Libraryを使ったコンポーネントテスト、Jestでのユニットテスト、E2Eテスト、そしてCI/CDパイプライン構築とデプロイメントについて学習します。プロダクション品質のReactアプリケーションを完成させましょう。
                        </p>
                    </div>
                </div>

                <!-- 章間ナビゲーション -->
                <nav class="flex items-center justify-between pt-6 mt-6 border-t border-slate-200">
                    <a href="react-learning-material-10.html"
                       class="group flex items-center gap-3 px-4 py-3 rounded-xl
                              bg-slate-100 hover:bg-slate-200 text-slate-700 transition-colors">
                        <i class="fas fa-arrow-left transition-transform group-hover:-translate-x-1"></i>
                        <div class="text-left">
                            <span class="text-xs text-slate-500 block">前の章</span>
                            <span class="font-medium">第10章: React Router</span>
                        </div>
                    </a>
                    <a href="react-learning-material-12.html"
                       class="group flex items-center gap-3 px-4 py-3 rounded-xl
                              bg-primary-500 hover:bg-primary-600 text-white transition-colors">
                        <div class="text-right">
                            <span class="text-xs text-primary-100 block">次の章</span>
                            <span class="font-medium">第12章: テストとデプロイメント</span>
                        </div>
                        <i class="fas fa-arrow-right transition-transform group-hover:translate-x-1"></i>
                    </a>
                </nav>
            </div>
        </main>
    </div>

    <!-- フッター -->
    <footer class="bg-slate-800 text-slate-300">
        <div class="max-w-screen-2xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
            <div class="flex flex-col md:flex-row items-center justify-between gap-4">
                <p class="text-sm text-center md:text-left">
                    &copy; 2025 F-Circle. All rights reserved.<br>
                    本資料はAIツールを活用し、人間による編集・監修のもと作成されています。
                </p>
                <div class="flex items-center gap-4">
                    <a href="https://github.com/fcircle-biz" class="hover:text-white transition-colors">
                        <i class="fab fa-github text-xl"></i>
                    </a>
                </div>
            </div>
        </div>
    </footer>

    <!-- スクロールトップボタン -->
    <button id="scroll-top-btn"
            class="fixed bottom-6 right-6 w-12 h-12 bg-primary-500 text-white rounded-full
                   shadow-lg hover:bg-primary-600 transition-all duration-300
                   opacity-0 invisible translate-y-4"
            onclick="scrollToTop()">
        <i class="fas fa-arrow-up"></i>
    </button>

    <!-- サイドバー生成 -->
    <script src="sidebar-content.js"></script>

    <!-- 共通JavaScript -->
    <script src="main.js"></script>

    <!-- 描画ツール -->
    <script src="drawing-tool.js"></script>
</body>
</html>
