<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" id="viewport-meta">
    <title>React学習教材 第7章 - useReducer と Context API - 高度な状態管理</title>

    <!-- ダークモード早期適用（フラッシュ防止） -->
    <script>
        (function() {
            const saved = localStorage.getItem('darkMode');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (saved === 'dark' || (saved === null && prefersDark)) {
                document.documentElement.classList.add('dark');
            }
        })();
    </script>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // React - Cyan
                        primary: {
                            50: '#ecfeff',
                            100: '#cffafe',
                            200: '#a5f3fc',
                            300: '#67e8f9',
                            400: '#22d3ee',
                            500: '#06b6d4',
                            600: '#0891b2',
                            700: '#0e7490',
                            800: '#155e75',
                            900: '#164e63',
                        }
                    },
                    fontFamily: {
                        sans: ['"Noto Sans JP"', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    <!-- Google Fonts - Noto Sans JP -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- カスタムスタイル -->
    <link rel="stylesheet" href="styles.css">
</head>
<body class="font-sans bg-slate-50 text-slate-800 antialiased">
    <!-- ヘッダー/ナビゲーションバー -->
    <header class="fixed top-0 left-0 right-0 z-50 text-white header-rich header-rich-shadow">
        <nav class="w-full px-4 sm:px-6 lg:px-8 relative z-10">
            <div class="flex items-center justify-between py-3">
                <!-- 左側: ロゴとタイトルセクション -->
                <div class="flex items-center gap-4">
                    <!-- アイコン -->
                    <div class="relative group">
                        <div class="absolute inset-0 bg-gradient-to-br from-cyan-400/30 to-blue-400/30 rounded-2xl blur-lg group-hover:blur-xl transition-all"></div>
                        <div class="relative w-14 h-14 bg-white/10 rounded-xl flex items-center justify-center backdrop-blur-sm border border-white/20">
                            <i class="fab fa-react text-3xl icon-rotate-hover drop-shadow-lg"></i>
                        </div>
                    </div>

                    <!-- タイトルとメタ情報 -->
                    <div class="flex flex-col gap-1">
                        <div class="flex items-center gap-2">
                            <span class="text-xl font-bold tracking-wide drop-shadow-md">React学習教材</span>
                            <span class="hidden sm:inline-flex items-center gap-1 px-2 py-0.5 bg-white/20 rounded-md text-[10px] font-semibold uppercase tracking-wider">
                                <i class="fas fa-star text-yellow-300 text-[8px]"></i>
                                初級〜中級
                            </span>
                        </div>
                        <div class="flex items-center gap-3 text-[11px] text-white/90 font-medium">
                            <div class="flex items-center gap-1">
                                <i class="fas fa-code text-[9px]"></i>
                                <span>JavaScriptライブラリ</span>
                            </div>
                            <div class="hidden sm:flex items-center gap-1">
                                <i class="fas fa-clock text-[9px]"></i>
                                <span>所要時間 約24時間</span>
                            </div>
                            <div class="hidden lg:flex items-center gap-1">
                                <i class="fas fa-language text-[9px]"></i>
                                <span>日本語</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 右側: サイドバートグルボタン -->
                <button id="sidebar-toggle-btn" class="w-10 h-10 flex items-center justify-center rounded-lg hover:bg-white/20 transition-all active:scale-95" title="サイドバーの表示/非表示">
                    <i class="fas fa-bars text-lg"></i>
                </button>
            </div>
        </nav>
    </header>

    <!-- メインレイアウト -->
    <div class="flex min-h-screen pt-20">
        <!-- サイドバーはsidebar-content.jsで動的に生成されます -->

        <!-- メインコンテンツ -->
        <main class="flex-1 min-w-0">
            <div class="max-w-5xl mx-auto px-4 sm:px-6 lg:px-10 py-6">
                <!-- パンくずリスト -->
                <nav class="flex items-center gap-2 text-sm text-slate-500 mb-6">
                    <a href="https://fcircle-biz.github.io/tech_docs/" class="hover:text-primary-600 transition-colors">ホーム</a>
                    <i class="fas fa-chevron-right text-xs"></i>
                    <a href="https://fcircle-biz.github.io/tech_docs/guide/programming-languages/javascript-ecosystem/react/" class="hover:text-primary-600 transition-colors">React</a>
                    <i class="fas fa-chevron-right text-xs"></i>
                    <span class="text-slate-700">第7章</span>
                </nav>

                <!-- 章ヘッダー -->
                <header class="mb-6">
                    <div class="flex items-center gap-3 mb-2">
                        <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium
                                     bg-primary-100 text-primary-700">
                            第7章
                        </span>
                        <span class="text-sm text-slate-500">
                            <i class="fas fa-clock mr-1"></i>所要時間: 2時間30分
                        </span>
                    </div>
                    <h1 class="text-2xl sm:text-3xl font-bold text-slate-900 mb-2">useReducer と Context API - 高度な状態管理</h1>
                    <p class="text-slate-600">useReducerの設計パターン、Context APIの効果的な使用、複数コンテキストの組み合わせ、パフォーマンス最適化、状態管理ライブラリとの比較について学びます。</p>
                </header>

                <!-- 学習目標カード -->
                <div class="bg-gradient-to-r from-amber-50 to-yellow-50 border border-amber-200
                            rounded-xl p-5 mb-6 overflow-hidden">
                    <div class="flex items-start gap-4">
                        <div class="flex-shrink-0 w-10 h-10 bg-amber-400 rounded-lg
                                    flex items-center justify-center">
                            <i class="fas fa-lightbulb text-white"></i>
                        </div>
                        <div>
                            <h2 class="text-lg font-semibold text-amber-800 mb-3">この章で学ぶこと</h2>
                            <ul class="space-y-2">
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>useReducerの基本的な使い方と設計パターンを理解する</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>アクションとリデューサーの型定義をマスターする</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>Context APIを使ったグローバル状態管理を実装できる</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>Providerパターンで効率的に状態を共有できる</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>再レンダリングを最適化し、パフォーマンスを向上できる</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>状態管理ライブラリ（Zustand、Jotai）との違いを理解する</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- セクション1: useReducerの基本 -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        7.1 useReducerの基本 - useStateとの違い
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        useReducerは、複雑な状態ロジックを持つコンポーネントで、useStateの代替として使用できるReact Hookです。特に、次の状態が前の状態に依存する場合や、複数の関連する値を管理する場合に適しています。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">useStateとuseReducerの比較</h3>

                    <div class="grid md:grid-cols-2 gap-4 my-6">
                        <div class="bg-gradient-to-br from-blue-50 to-cyan-50 border border-blue-200 rounded-xl p-4">
                            <h4 class="font-semibold text-blue-800 mb-2 flex items-center gap-2">
                                <i class="fas fa-database"></i>
                                useState
                            </h4>
                            <ul class="space-y-2 text-blue-900 text-sm">
                                <li class="flex items-start gap-2">
                                    <i class="fas fa-check text-blue-500 text-xs mt-1"></i>
                                    <span>シンプルな状態管理に最適</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <i class="fas fa-check text-blue-500 text-xs mt-1"></i>
                                    <span>独立した値の管理</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <i class="fas fa-check text-blue-500 text-xs mt-1"></i>
                                    <span>直感的でわかりやすい</span>
                                </li>
                            </ul>
                        </div>

                        <div class="bg-gradient-to-br from-emerald-50 to-teal-50 border border-emerald-200 rounded-xl p-4">
                            <h4 class="font-semibold text-emerald-800 mb-2 flex items-center gap-2">
                                <i class="fas fa-cogs"></i>
                                useReducer
                            </h4>
                            <ul class="space-y-2 text-emerald-900 text-sm">
                                <li class="flex items-start gap-2">
                                    <i class="fas fa-check text-emerald-500 text-xs mt-1"></i>
                                    <span>複雑な状態ロジックに最適</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <i class="fas fa-check text-emerald-500 text-xs mt-1"></i>
                                    <span>関連する値のグループ管理</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <i class="fas fa-check text-emerald-500 text-xs mt-1"></i>
                                    <span>テストしやすい</span>
                                </li>
                            </ul>
                        </div>
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">useReducerの基本的な使い方</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">Counter.tsx（useReducer基本例）</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">import { useReducer } from 'react';

// 状態の型定義
type State = {
  count: number;
};

// アクションの型定義
type Action =
  | { type: 'INCREMENT' }
  | { type: 'DECREMENT' }
  | { type: 'RESET' }
  | { type: 'SET'; payload: number };

// リデューサー関数（純粋関数）
function counterReducer(state: State, action: Action): State {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    case 'RESET':
      return { count: 0 };
    case 'SET':
      return { count: action.payload };
    default:
      return state;
  }
}

function Counter() {
  // useReducerの使用
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    &lt;div&gt;
      &lt;h2&gt;カウント: {state.count}&lt;/h2&gt;
      &lt;button onClick={() => dispatch({ type: 'INCREMENT' })}&gt;+1&lt;/button&gt;
      &lt;button onClick={() => dispatch({ type: 'DECREMENT' })}&gt;-1&lt;/button&gt;
      &lt;button onClick={() => dispatch({ type: 'RESET' })}&gt;リセット&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>

                    <div class="bg-blue-50 border-l-4 border-blue-500 p-4 my-6 rounded-r-lg overflow-hidden">
                        <div class="flex items-start gap-3">
                            <i class="fas fa-lightbulb text-blue-600 mt-1"></i>
                            <div class="flex-1 min-w-0">
                                <p class="text-blue-900 font-medium break-words">リデューサーとは？</p>
                                <p class="text-blue-800 text-sm mt-1 break-words">
                                    リデューサーは、現在の状態とアクションを受け取り、新しい状態を返す純粋関数です。同じ入力には常に同じ出力を返すため、テストが容易で予測可能です。
                                </p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- セクション2: 複雑な状態管理の実践 -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        7.2 複雑な状態管理の実践 - Todoアプリケーション
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        実際のアプリケーションでは、複数のプロパティと複雑なロジックを持つ状態を管理します。Todoアプリケーションを例に、useReducerの実践的な使い方を学びましょう。
                    </p>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">TodoApp.tsx（複雑な状態管理）</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">import { useReducer } from 'react';

// Todo項目の型
type Todo = {
  id: number;
  text: string;
  completed: boolean;
};

// 状態の型
type State = {
  todos: Todo[];
  filter: 'all' | 'active' | 'completed';
};

// アクションの型
type Action =
  | { type: 'ADD_TODO'; payload: string }
  | { type: 'TOGGLE_TODO'; payload: number }
  | { type: 'DELETE_TODO'; payload: number }
  | { type: 'SET_FILTER'; payload: State['filter'] };

// リデューサー
function todoReducer(state: State, action: Action): State {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [
          ...state.todos,
          { id: Date.now(), text: action.payload, completed: false }
        ]
      };
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };
    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload)
      };
    case 'SET_FILTER':
      return { ...state, filter: action.payload };
    default:
      return state;
  }
}</code></pre>
                    </div>

                    <div class="bg-emerald-50 border-l-4 border-emerald-500 p-4 my-6 rounded-r-lg overflow-hidden">
                        <div class="flex items-start gap-3">
                            <i class="fas fa-star text-emerald-600 mt-1"></i>
                            <div class="flex-1 min-w-0">
                                <p class="text-emerald-900 font-medium break-words">イミュータブル更新の重要性</p>
                                <p class="text-emerald-800 text-sm mt-1 break-words">
                                    リデューサー内では、常に新しいオブジェクトを返す必要があります。スプレッド演算子（...）を使って、既存の状態を変更せずに新しい状態を作成します。
                                </p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- セクション3: Context APIの基本 -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        7.3 Context API - グローバル状態の共有
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        Context APIを使うと、Propsのバケツリレーを避けて、コンポーネントツリー全体で状態を共有できます。認証情報、テーマ設定、ユーザー設定など、多くのコンポーネントで必要な情報を管理するのに適しています。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">Context APIの仕組み</h3>
                    <div class="mermaid">
flowchart TB
    App["App<br/>Provider設置"]
    Header["Header"]
    Main["Main"]
    Sidebar["Sidebar"]
    Content["Content"]
    Button["Button"]

    App --> Header
    App --> Main
    Main --> Sidebar
    Main --> Content
    Content --> Button

    App -.->|Context経由で<br/>状態を共有| Header
    App -.->|Context経由で<br/>状態を共有| Button
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">Context APIの実装</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">ThemeContext.tsx（Context作成例）</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">import { createContext, useContext, useState, ReactNode } from 'react';

// Contextの型定義
type Theme = 'light' | 'dark';
type ThemeContextType = {
  theme: Theme;
  toggleTheme: () => void;
};

// Contextの作成
const ThemeContext = createContext&lt;ThemeContextType | undefined&gt;(undefined);

// Providerコンポーネント
export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState&lt;Theme&gt;('light');

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  return (
    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

// カスタムフック（Contextを使いやすくする）
export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}</code></pre>
                    </div>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">App.tsx（Providerの使用）</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">import { ThemeProvider, useTheme } from './ThemeContext';

// テーマを使用するコンポーネント
function ThemeToggleButton() {
  const { theme, toggleTheme } = useTheme();

  return (
    &lt;button onClick={toggleTheme}&gt;
      現在のテーマ: {theme}
    &lt;/button&gt;
  );
}

// アプリケーション
function App() {
  return (
    &lt;ThemeProvider&gt;
      &lt;div&gt;
        &lt;h1&gt;テーマ切り替えアプリ&lt;/h1&gt;
        &lt;ThemeToggleButton /&gt;
      &lt;/div&gt;
    &lt;/ThemeProvider&gt;
  );
}</code></pre>
                    </div>
                </section>

                <!-- セクション4: useReducerとContextの組み合わせ -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        7.4 useReducerとContextの組み合わせ - スケーラブルな状態管理
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        useReducerとContext APIを組み合わせると、Reduxのようなグローバル状態管理を、追加のライブラリなしで実装できます。中規模のアプリケーションに最適なパターンです。
                    </p>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">AppStateContext.tsx（組み合わせパターン）</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">import { createContext, useContext, useReducer, ReactNode } from 'react';

// 状態とアクションの型定義
type User = { id: number; name: string } | null;
type State = {
  user: User;
  isLoading: boolean;
};

type Action =
  | { type: 'LOGIN'; payload: User }
  | { type: 'LOGOUT' }
  | { type: 'SET_LOADING'; payload: boolean };

// リデューサー
function appReducer(state: State, action: Action): State {
  switch (action.type) {
    case 'LOGIN':
      return { ...state, user: action.payload, isLoading: false };
    case 'LOGOUT':
      return { ...state, user: null };
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };
    default:
      return state;
  }
}

// Contextの型
type AppContextType = {
  state: State;
  dispatch: React.Dispatch&lt;Action&gt;;
};

// Contextの作成
const AppContext = createContext&lt;AppContextType | undefined&gt;(undefined);

// Provider
export function AppProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(appReducer, {
    user: null,
    isLoading: false
  });

  return (
    &lt;AppContext.Provider value={{ state, dispatch }}&gt;
      {children}
    &lt;/AppContext.Provider&gt;
  );
}

// カスタムフック
export function useAppState() {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppState must be used within AppProvider');
  }
  return context;
}</code></pre>
                    </div>
                </section>

                <!-- セクション5: パフォーマンス最適化 -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        7.5 パフォーマンス最適化 - 再レンダリングの制御
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        Context APIを使う際の最大の課題は、不必要な再レンダリングです。Contextの値が変更されると、そのContextを使用しているすべてのコンポーネントが再レンダリングされます。これを最適化する方法を学びましょう。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">問題のあるパターン</h3>

                    <div class="bg-red-50 border-l-4 border-red-500 p-4 my-6 rounded-r-lg overflow-hidden">
                        <div class="flex items-start gap-3">
                            <i class="fas fa-exclamation-triangle text-red-600 mt-1"></i>
                            <div class="flex-1 min-w-0">
                                <p class="text-red-900 font-medium break-words">注意: 過度な再レンダリング</p>
                                <p class="text-red-800 text-sm mt-1 break-words">
                                    Providerコンポーネント内で毎回新しいオブジェクトを作成すると、Contextを使用するすべてのコンポーネントが不必要に再レンダリングされます。
                                </p>
                            </div>
                        </div>
                    </div>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">❌ 悪い例（毎回新しいオブジェクト作成）</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">// 悪い例: 毎回新しいオブジェクトが作成される
function BadProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState(null);

  return (
    &lt;UserContext.Provider value={{ user, setUser }}&gt;
      {children}
    &lt;/UserContext.Provider&gt;
  );
}</code></pre>
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">最適化されたパターン</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">✅ 良い例（useMemoで最適化）</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">import { useMemo } from 'react';

// 良い例: useMemoで値をメモ化
function OptimizedProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState(null);

  // 値をメモ化（userが変わった時だけ再作成）
  const value = useMemo(() => ({ user, setUser }), [user]);

  return (
    &lt;UserContext.Provider value={value}&gt;
      {children}
    &lt;/UserContext.Provider&gt;
  );
}</code></pre>
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">Contextの分割</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">状態とdispatchを分割</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">// 状態用のContext
const StateContext = createContext&lt;State | undefined&gt;(undefined);
// Dispatch用のContext
const DispatchContext = createContext&lt;Dispatch&lt;Action&gt; | undefined&gt;(undefined);

export function AppProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(appReducer, initialState);

  return (
    &lt;StateContext.Provider value={state}&gt;
      &lt;DispatchContext.Provider value={dispatch}&gt;
        {children}
      &lt;/DispatchContext.Provider&gt;
    &lt;/StateContext.Provider&gt;
  );
}

// dispatchしか使わないコンポーネントは状態変更で再レンダリングされない
export const useAppDispatch = () => useContext(DispatchContext);</code></pre>
                    </div>
                </section>

                <!-- セクション6: 状態管理ライブラリとの比較 -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        7.6 状態管理ライブラリとの比較 - いつ使い分けるか
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        useReducer + Context APIは強力ですが、大規模アプリケーションではZustand、Jotai、Reduxなどの専用ライブラリを検討する価値があります。それぞれの特徴と使い分けを理解しましょう。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">主要な状態管理ライブラリ</h3>

                    <div class="space-y-4">
                        <div class="bg-slate-50 border border-slate-200 rounded-lg p-4">
                            <h4 class="font-semibold text-slate-800 mb-1 flex items-center gap-2">
                                <i class="fas fa-box text-primary-500"></i>
                                useReducer + Context API
                            </h4>
                            <p class="text-slate-600 text-sm mb-2">
                                追加ライブラリ不要、Reactの標準機能のみで実装
                            </p>
                            <div class="text-sm">
                                <span class="text-emerald-600">✓ 適している:</span> 小〜中規模アプリ、学習目的<br>
                                <span class="text-red-600">✗ 不向き:</span> 大規模アプリ、複雑なミドルウェアが必要
                            </div>
                        </div>

                        <div class="bg-slate-50 border border-slate-200 rounded-lg p-4">
                            <h4 class="font-semibold text-slate-800 mb-1 flex items-center gap-2">
                                <i class="fas fa-feather text-primary-500"></i>
                                Zustand
                            </h4>
                            <p class="text-slate-600 text-sm mb-2">
                                軽量でシンプル、Hooksベースの状態管理
                            </p>
                            <div class="text-sm">
                                <span class="text-emerald-600">✓ 適している:</span> モダンなアプリ、TypeScript<br>
                                <span class="text-red-600">✗ 不向き:</span> 複雑なタイムトラベルデバッグが必要
                            </div>
                        </div>

                        <div class="bg-slate-50 border border-slate-200 rounded-lg p-4">
                            <h4 class="font-semibold text-slate-800 mb-1 flex items-center gap-2">
                                <i class="fas fa-atom text-primary-500"></i>
                                Jotai
                            </h4>
                            <p class="text-slate-600 text-sm mb-2">
                                アトミックな状態管理、Recoil風のAPI
                            </p>
                            <div class="text-sm">
                                <span class="text-emerald-600">✓ 適している:</span> 細かい状態分割、派生状態<br>
                                <span class="text-red-600">✗ 不向き:</span> 単純なグローバル状態のみ
                            </div>
                        </div>

                        <div class="bg-slate-50 border border-slate-200 rounded-lg p-4">
                            <h4 class="font-semibold text-slate-800 mb-1 flex items-center gap-2">
                                <i class="fas fa-layer-group text-primary-500"></i>
                                Redux Toolkit
                            </h4>
                            <p class="text-slate-600 text-sm mb-2">
                                エンタープライズ向け、豊富なエコシステム
                            </p>
                            <div class="text-sm">
                                <span class="text-emerald-600">✓ 適している:</span> 大規模アプリ、チーム開発<br>
                                <span class="text-red-600">✗ 不向き:</span> 小規模アプリ、学習コストを避けたい
                            </div>
                        </div>
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">Zustandの基本例</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">store.ts（Zustand）</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">import { create } from 'zustand';

// Zustandストアの作成
type Store = {
  count: number;
  increment: () => void;
  decrement: () => void;
  reset: () => void;
};

export const useStore = create&lt;Store&gt;((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 })
}));

// 使用例
function Counter() {
  const { count, increment, decrement, reset } = useStore();

  return (
    &lt;div&gt;
      &lt;h2&gt;カウント: {count}&lt;/h2&gt;
      &lt;button onClick={increment}&gt;+1&lt;/button&gt;
      &lt;button onClick={decrement}&gt;-1&lt;/button&gt;
      &lt;button onClick={reset}&gt;リセット&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>
                </section>

                <!-- 実習 -->
                <div class="bg-gradient-to-r from-purple-50 to-fuchsia-50 border border-purple-200
                            rounded-xl p-5 my-6 overflow-hidden">
                    <div class="flex items-start gap-4">
                        <div class="flex-shrink-0 w-10 h-10 bg-purple-500 rounded-lg
                                    flex items-center justify-center">
                            <i class="fas fa-code text-white"></i>
                        </div>
                        <div class="flex-1 min-w-0">
                            <h3 class="text-lg font-semibold text-purple-800 mb-3 break-words">
                                実習 7-1: ショッピングカートの実装
                            </h3>
                            <p class="text-purple-900 mb-4 break-words">
                                useReducerとContext APIを使って、ショッピングカート機能を実装しましょう。商品の追加、削除、数量変更、合計金額の計算を実装します。
                            </p>

                            <h4 class="font-medium text-purple-800 mb-2">実装する機能</h4>
                            <ol class="space-y-3 mb-4">
                                <li class="flex items-start gap-3 text-purple-900">
                                    <span class="flex-shrink-0 w-6 h-6 bg-purple-200 rounded-full
                                                 flex items-center justify-center text-sm font-medium">1</span>
                                    <span class="flex-1 min-w-0 break-words">
                                        カート状態管理（商品リスト、合計金額）
                                    </span>
                                </li>
                                <li class="flex items-start gap-3 text-purple-900">
                                    <span class="flex-shrink-0 w-6 h-6 bg-purple-200 rounded-full
                                                 flex items-center justify-center text-sm font-medium">2</span>
                                    <span class="flex-1 min-w-0 break-words">商品の追加・削除・数量変更アクション</span>
                                </li>
                                <li class="flex items-start gap-3 text-purple-900">
                                    <span class="flex-shrink-0 w-6 h-6 bg-purple-200 rounded-full
                                                 flex items-center justify-center text-sm font-medium">3</span>
                                    <span class="flex-1 min-w-0 break-words">合計金額の自動計算</span>
                                </li>
                                <li class="flex items-start gap-3 text-purple-900">
                                    <span class="flex-shrink-0 w-6 h-6 bg-purple-200 rounded-full
                                                 flex items-center justify-center text-sm font-medium">4</span>
                                    <span class="flex-1 min-w-0 break-words">Context APIで全体に状態共有</span>
                                </li>
                            </ol>

                            <h4 class="font-medium text-purple-800 mb-2">期待される結果</h4>
                            <p class="text-purple-900 text-sm">
                                商品一覧から商品をカートに追加でき、カート内で数量変更や削除ができます。合計金額がリアルタイムで更新されます。
                            </p>
                        </div>
                    </div>
                </div>

                <!-- 理解度確認クイズ -->
                <div class="bg-gradient-to-r from-blue-50 to-cyan-50 border border-blue-200
                            rounded-xl p-5 my-6 overflow-hidden">
                    <div class="flex items-start gap-4">
                        <div class="flex-shrink-0 w-10 h-10 bg-blue-500 rounded-lg
                                    flex items-center justify-center">
                            <i class="fas fa-question text-white"></i>
                        </div>
                        <div class="flex-1 min-w-0">
                            <h3 class="text-lg font-semibold text-blue-800 mb-4 break-words">理解度確認クイズ</h3>
                            <ol class="space-y-4">
                                <li class="text-blue-900">
                                    <p class="font-medium mb-2 break-words">Q1. useReducerがuseStateより適している状況はどれですか?</p>
                                    <details class="mt-2">
                                        <summary class="cursor-pointer text-blue-600 hover:text-blue-700 break-words">
                                            回答を表示
                                        </summary>
                                        <p class="mt-2 pl-4 text-blue-800 bg-blue-100 rounded-lg p-3 break-words">
                                            <strong>回答:</strong> 複雑な状態ロジック、複数の関連する値の管理、状態更新のテストが必要な場合にuseReducerが適しています。例えば、Todoリストやショッピングカートのような、複数の操作を持つ状態管理に最適です。
                                        </p>
                                    </details>
                                </li>
                                <li class="text-blue-900">
                                    <p class="font-medium mb-2 break-words">Q2. Context APIを使う際の主な注意点は何ですか?</p>
                                    <details class="mt-2">
                                        <summary class="cursor-pointer text-blue-600 hover:text-blue-700 break-words">
                                            回答を表示
                                        </summary>
                                        <p class="mt-2 pl-4 text-blue-800 bg-blue-100 rounded-lg p-3 break-words">
                                            <strong>回答:</strong> Contextの値が変更されると、そのContextを使用しているすべてのコンポーネントが再レンダリングされます。useMemoで値をメモ化したり、Contextを分割することで、不必要な再レンダリングを防ぐことができます。
                                        </p>
                                    </details>
                                </li>
                                <li class="text-blue-900">
                                    <p class="font-medium mb-2 break-words">Q3. リデューサー関数の重要な特徴は何ですか?</p>
                                    <details class="mt-2">
                                        <summary class="cursor-pointer text-blue-600 hover:text-blue-700 break-words">
                                            回答を表示
                                        </summary>
                                        <p class="mt-2 pl-4 text-blue-800 bg-blue-100 rounded-lg p-3 break-words">
                                            <strong>回答:</strong> リデューサーは純粋関数である必要があります。同じ入力には常に同じ出力を返し、副作用を持たず、既存の状態を変更せずに新しい状態を返します。これにより、テストが容易で予測可能な動作が保証されます。
                                        </p>
                                    </details>
                                </li>
                                <li class="text-blue-900">
                                    <p class="font-medium mb-2 break-words">Q4. ZustandとuseReducer+Contextの主な違いは何ですか?</p>
                                    <details class="mt-2">
                                        <summary class="cursor-pointer text-blue-600 hover:text-blue-700 break-words">
                                            回答を表示
                                        </summary>
                                        <p class="mt-2 pl-4 text-blue-800 bg-blue-100 rounded-lg p-3 break-words">
                                            <strong>回答:</strong> Zustandはより軽量でシンプルなAPI、自動的な再レンダリング最適化、ボイラープレートコードが少ないという利点があります。useReducer+Contextは追加ライブラリ不要で、Reactの標準機能のみで実装できる利点があります。
                                        </p>
                                    </details>
                                </li>
                            </ol>
                        </div>
                    </div>
                </div>

                <!-- 章まとめ -->
                <div class="bg-gradient-to-r from-slate-50 to-slate-100 border border-slate-200 rounded-xl p-6 my-8">
                    <h2 class="text-xl font-semibold text-slate-800 mb-4 flex items-center gap-2">
                        <i class="fas fa-bookmark text-primary-500"></i>
                        第7章のまとめ
                    </h2>
                    <ul class="space-y-3 text-slate-700">
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>useReducerは複雑な状態ロジックを管理するのに適したReact Hook</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>リデューサーは純粋関数で、テストしやすく予測可能</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>Context APIでPropsのバケツリレーを回避し、グローバル状態を共有</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>useReducerとContextを組み合わせて、スケーラブルな状態管理を実装</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>useMemoやContextの分割で再レンダリングを最適化</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>Zustand、Jotai、Reduxなどの状態管理ライブラリと使い分ける</span>
                        </li>
                    </ul>

                    <div class="mt-6 p-4 bg-primary-50 rounded-lg border border-primary-200">
                        <p class="text-primary-900 font-medium mb-2">
                            <i class="fas fa-arrow-right text-primary-600 mr-2"></i>次の章では
                        </p>
                        <p class="text-primary-800 text-sm">
                            カスタムフックの作成方法と設計原則について学習します。useDebounce、useFetch、useLocalStorageなどの実用的なカスタムフックを実装し、ロジックの再利用性を高める方法を習得しましょう。
                        </p>
                    </div>
                </div>

                <!-- 章間ナビゲーション -->
                <nav class="flex items-center justify-between pt-6 mt-6 border-t border-slate-200">
                    <a href="react-learning-material-06.html"
                       class="group flex items-center gap-3 px-4 py-3 rounded-xl
                              bg-slate-100 hover:bg-slate-200 transition-colors">
                        <i class="fas fa-arrow-left text-slate-400 group-hover:text-slate-600 transition-transform group-hover:-translate-x-1"></i>
                        <div>
                            <span class="text-xs text-slate-500 block">前の章</span>
                            <span class="text-slate-700 font-medium">第6章: イベント処理とフォーム</span>
                        </div>
                    </a>
                    <a href="react-learning-material-08.html"
                       class="group flex items-center gap-3 px-4 py-3 rounded-xl
                              bg-primary-500 hover:bg-primary-600 text-white transition-colors">
                        <div class="text-right">
                            <span class="text-xs text-primary-100 block">次の章</span>
                            <span class="font-medium">第8章: カスタムフック</span>
                        </div>
                        <i class="fas fa-arrow-right transition-transform group-hover:translate-x-1"></i>
                    </a>
                </nav>
            </div>
        </main>
    </div>

    <!-- フッター -->
    <footer class="bg-slate-800 text-slate-300">
        <div class="max-w-screen-2xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
            <div class="flex flex-col md:flex-row items-center justify-between gap-4">
                <p class="text-sm text-center md:text-left">
                    &copy; 2025 F-Circle. All rights reserved.<br>
                    本資料はAIツールを活用し、人間による編集・監修のもと作成されています。
                </p>
                <div class="flex items-center gap-4">
                    <a href="https://github.com/fcircle-biz" class="hover:text-white transition-colors">
                        <i class="fab fa-github text-xl"></i>
                    </a>
                </div>
            </div>
        </div>
    </footer>

    <!-- スクロールトップボタン -->
    <button id="scroll-top-btn"
            class="fixed bottom-6 right-6 w-12 h-12 bg-primary-500 text-white rounded-full
                   shadow-lg hover:bg-primary-600 transition-all duration-300
                   opacity-0 invisible translate-y-4"
            onclick="scrollToTop()">
        <i class="fas fa-arrow-up"></i>
    </button>

    <!-- サイドバー生成 -->
    <script src="sidebar-content.js"></script>

    <!-- 共通JavaScript -->
    <script src="main.js"></script>

    <!-- 描画ツール -->
    <script src="drawing-tool.js"></script>
</body>
</html>
