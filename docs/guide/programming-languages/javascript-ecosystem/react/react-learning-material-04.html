<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" id="viewport-meta">
    <title>React学習教材 第4章 - useState - 状態管理の基礎</title>

    <!-- ダークモード早期適用（フラッシュ防止） -->
    <script>
        (function() {
            const saved = localStorage.getItem('darkMode');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (saved === 'dark' || (saved === null && prefersDark)) {
                document.documentElement.classList.add('dark');
            }
        })();
    </script>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // React - Cyan
                        primary: {
                            50: '#ecfeff',
                            100: '#cffafe',
                            200: '#a5f3fc',
                            300: '#67e8f9',
                            400: '#22d3ee',
                            500: '#06b6d4',
                            600: '#0891b2',
                            700: '#0e7490',
                            800: '#155e75',
                            900: '#164e63',
                        }
                    },
                    fontFamily: {
                        sans: ['"Noto Sans JP"', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    <!-- Google Fonts - Noto Sans JP -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- カスタムスタイル -->
    <link rel="stylesheet" href="styles.css">
</head>
<body class="font-sans bg-slate-50 text-slate-800 antialiased">
    <!-- ヘッダー/ナビゲーションバー -->
    <header class="fixed top-0 left-0 right-0 z-50 text-white header-rich header-rich-shadow">
        <nav class="w-full px-4 sm:px-6 lg:px-8 relative z-10">
            <div class="flex items-center justify-between py-3">
                <!-- 左側: ロゴとタイトルセクション -->
                <div class="flex items-center gap-4">
                    <!-- アイコン -->
                    <div class="relative group">
                        <div class="absolute inset-0 bg-gradient-to-br from-cyan-400/30 to-blue-400/30 rounded-2xl blur-lg group-hover:blur-xl transition-all"></div>
                        <div class="relative w-14 h-14 bg-white/10 rounded-xl flex items-center justify-center backdrop-blur-sm border border-white/20">
                            <i class="fab fa-react text-3xl icon-rotate-hover drop-shadow-lg"></i>
                        </div>
                    </div>

                    <!-- タイトルとメタ情報 -->
                    <div class="flex flex-col gap-1">
                        <div class="flex items-center gap-2">
                            <span class="text-xl font-bold tracking-wide drop-shadow-md">React学習教材</span>
                            <span class="hidden sm:inline-flex items-center gap-1 px-2 py-0.5 bg-white/20 rounded-md text-[10px] font-semibold uppercase tracking-wider">
                                <i class="fas fa-star text-yellow-300 text-[8px]"></i>
                                初級〜中級
                            </span>
                        </div>
                        <div class="flex items-center gap-3 text-[11px] text-white/90 font-medium">
                            <div class="flex items-center gap-1">
                                <i class="fas fa-code text-[9px]"></i>
                                <span>JavaScriptライブラリ</span>
                            </div>
                            <div class="hidden sm:flex items-center gap-1">
                                <i class="fas fa-clock text-[9px]"></i>
                                <span>推奨 45分</span>
                            </div>
                            <div class="hidden lg:flex items-center gap-1">
                                <i class="fas fa-language text-[9px]"></i>
                                <span>日本語</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 右側: サイドバートグルボタン -->
                <button id="sidebar-toggle-btn" class="w-10 h-10 flex items-center justify-center rounded-lg hover:bg-white/20 transition-all active:scale-95" title="サイドバーの表示/非表示">
                    <i class="fas fa-bars text-lg"></i>
                </button>
            </div>
        </nav>
    </header>

    <!-- メインレイアウト -->
    <div class="flex min-h-screen pt-20">
        <!-- サイドバーはsidebar-content.jsで動的に生成されます -->

        <!-- メインコンテンツ -->
        <main class="flex-1 min-w-0">
            <div class="max-w-5xl mx-auto px-4 sm:px-6 lg:px-10 py-6">
                <!-- パンくずリスト -->
                <nav class="flex items-center gap-2 text-sm text-slate-500 mb-6">
                    <a href="https://fcircle-biz.github.io/tech_docs/" class="hover:text-primary-600 transition-colors">ホーム</a>
                    <i class="fas fa-chevron-right text-xs"></i>
                    <a href="https://fcircle-biz.github.io/tech_docs/guide/programming-languages/javascript-ecosystem/react/" class="hover:text-primary-600 transition-colors">React</a>
                    <i class="fas fa-chevron-right text-xs"></i>
                    <span class="text-slate-700">第4章</span>
                </nav>

                <!-- 章ヘッダー -->
                <header class="mb-6">
                    <div class="flex items-center gap-3 mb-2">
                        <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium
                                     bg-primary-100 text-primary-700">
                            第4章
                        </span>
                    </div>
                    <h1 class="text-2xl sm:text-3xl font-bold text-slate-900 mb-2">useState - 状態管理の基礎</h1>
                    <p class="text-slate-600">useStateの内部動作、状態の初期化パターン、関数型更新、複雑なオブジェクトや配列の状態管理、イミュータブル更新の重要性、React18の自動バッチング機能、パフォーマンス最適化について詳しく学びます。</p>
                </header>

                <!-- 学習目標カード -->
                <div class="bg-gradient-to-r from-amber-50 to-yellow-50 border border-amber-200
                            rounded-xl p-5 mb-6 overflow-hidden">
                    <div class="flex items-start gap-4">
                        <div class="flex-shrink-0 w-10 h-10 bg-amber-400 rounded-lg
                                    flex items-center justify-center">
                            <i class="fas fa-lightbulb text-white"></i>
                        </div>
                        <div>
                            <h2 class="text-lg font-semibold text-amber-800 mb-3">この章で学ぶこと</h2>
                            <ul class="space-y-2">
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>useStateの内部動作と仕組みを理解する</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>状態の初期化パターンと遅延初期化を使いこなす</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>関数型更新で正確な状態更新を実装する</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>オブジェクトと配列の状態をイミュータブルに更新する</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>React18の自動バッチング機能を活用する</span>
                                </li>
                                <li class="flex items-start gap-2 text-amber-900">
                                    <i class="fas fa-check-circle text-amber-500 mt-1 flex-shrink-0"></i>
                                    <span>useState使用時のパフォーマンス最適化手法を習得する</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- セクション1: useStateの基本と内部動作 -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        4.1 useStateの基本と内部動作
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        useStateは、関数コンポーネント内で状態（state）を管理するための基本的なReact Hookです。状態が変更されると、コンポーネントが再レンダリングされ、UIが更新されます。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">useStateの基本構文</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">useStateの基本的な使い方</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">import { useState } from 'react';

function Counter() {
  // [現在の状態, 状態を更新する関数] = useState(初期値)
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;カウント: {count}&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;
        +1
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">useStateの内部動作</h3>

                    <div class="mermaid">
flowchart TB
    A["コンポーネント初回レンダリング"] --> B["useState初期化<br/>初期値を状態として保存"]
    B --> C["JSXレンダリング<br/>初期値を表示"]
    C --> D["ユーザー操作<br/>setState呼び出し"]
    D --> E["状態更新をスケジュール"]
    E --> F["再レンダリング実行"]
    F --> G["新しい状態値で<br/>JSXレンダリング"]
    G --> H["DOM更新"]
    H --> D
                    </div>

                    <div class="bg-blue-50 border border-blue-200 rounded-xl p-5 my-6">
                        <div class="flex items-start gap-3">
                            <i class="fas fa-info-circle text-blue-500 text-lg mt-0.5"></i>
                            <div>
                                <h3 class="font-semibold text-blue-800 mb-2">状態の保持場所</h3>
                                <p class="text-blue-900 text-sm">
                                    useStateで定義した状態は、Reactの内部管理領域（ファイバーノード）に保存されます。コンポーネントが再レンダリングされても、状態は失われず、Reactが自動的に管理してくれます。
                                </p>
                            </div>
                        </div>
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">TypeScriptでの型定義</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">useStateの型安全な使用</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">// プリミティブ型（型推論が効く）
const [count, setCount] = useState(0); // number型
const [name, setName] = useState(''); // string型

// 明示的な型定義
const [count, setCount] = useState&lt;number&gt;(0);

// オブジェクト型の状態
interface User {
  id: number;
  name: string;
  email: string;
}

const [user, setUser] = useState&lt;User&gt;({
  id: 1,
  name: 'John Doe',
  email: 'john@example.com'
});

// null許容型
const [user, setUser] = useState&lt;User | null&gt;(null);</code></pre>
                    </div>
                </section>

                <!-- セクション2: 状態の初期化パターン -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        4.2 状態の初期化パターン
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        useStateの初期値は、様々な方法で設定できます。パフォーマンスを考慮した適切な初期化パターンを理解しましょう。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">直接値による初期化</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">シンプルな初期化</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">// プリミティブ値
const [count, setCount] = useState(0);

// オブジェクト
const [user, setUser] = useState({ name: 'John', age: 30 });

// 配列
const [items, setItems] = useState(['Item 1', 'Item 2']);</code></pre>
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">遅延初期化（Lazy Initialization）</h3>
                    <p class="text-slate-600 leading-relaxed">
                        初期値の計算コストが高い場合は、関数を渡すことで初回レンダリング時のみ実行されるようにできます。
                    </p>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">遅延初期化の例</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">// ❌ 悪い例：毎回レンダリングで計算される
const [data, setData] = useState(expensiveCalculation());

// ✅ 良い例：初回レンダリング時のみ計算
const [data, setData] = useState(() => expensiveCalculation());

// LocalStorageからの読み込み例
const [theme, setTheme] = useState(() => {
  const saved = localStorage.getItem('theme');
  return saved ? JSON.parse(saved) : 'light';
});

// 複雑な配列生成の例
const [items, setItems] = useState(() => {
  return Array.from({ length: 1000 }, (_, i) => ({
    id: i,
    value: Math.random()
  }));
});</code></pre>
                    </div>

                    <div class="bg-emerald-50 border-l-4 border-emerald-500 p-4 my-6 rounded-r-lg overflow-hidden">
                        <div class="flex items-start gap-3">
                            <i class="fas fa-star text-emerald-600 mt-1"></i>
                            <div class="flex-1 min-w-0">
                                <p class="text-emerald-900 font-medium break-words">遅延初期化のメリット</p>
                                <p class="text-emerald-800 text-sm mt-1 break-words">
                                    関数を渡すことで、初回レンダリング時のみ実行されます。再レンダリング時には関数は実行されず、前回の状態が使われるため、パフォーマンスが向上します。
                                </p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- セクション3: 関数型更新 -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        4.3 関数型更新（Functional Update）
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        状態更新時に、現在の状態値に依存する場合は、関数型更新を使用することで、常に最新の状態値を参照できます。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">直接更新 vs 関数型更新</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">更新方法の比較</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">function Counter() {
  const [count, setCount] = useState(0);

  // ❌ 直接更新（問題が発生する可能性あり）
  const handleIncrement = () => {
    setCount(count + 1);
    setCount(count + 1); // 2増えると期待するが、1しか増えない
  };

  // ✅ 関数型更新（常に正しい結果）
  const handleIncrementCorrect = () => {
    setCount(prev => prev + 1);
    setCount(prev => prev + 1); // 正しく2増える
  };

  return (
    &lt;div&gt;
      &lt;p&gt;カウント: {count}&lt;/p&gt;
      &lt;button onClick={handleIncrementCorrect}&gt;+2&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>

                    <div class="bg-red-50 border-l-4 border-red-500 p-4 my-6 rounded-r-lg overflow-hidden">
                        <div class="flex items-start gap-3">
                            <i class="fas fa-exclamation-triangle text-red-600 mt-1"></i>
                            <div class="flex-1 min-w-0">
                                <p class="text-red-900 font-medium break-words">クロージャの罠</p>
                                <p class="text-red-800 text-sm mt-1 break-words">
                                    直接更新では、イベントハンドラー内で参照される <code class="bg-red-100 px-1 rounded">count</code> は、レンダリング時の値がキャプチャされます。複数回更新しても、同じ古い値を参照するため、期待通りに動作しません。
                                </p>
                            </div>
                        </div>
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">非同期処理での関数型更新</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">非同期処理での使用例</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">function DataFetcher() {
  const [data, setData] = useState&lt;string[]&gt;([]);

  const fetchData = async () => {
    const response = await fetch('/api/data');
    const newData = await response.json();

    // ✅ 関数型更新で既存データに追加
    setData(prev => [...prev, ...newData]);
  };

  return (
    &lt;div&gt;
      &lt;button onClick={fetchData}&gt;データ追加取得&lt;/button&gt;
      &lt;ul&gt;
        {data.map((item, i) => (
          &lt;li key={i}&gt;{item}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>
                </section>

                <!-- セクション4: オブジェクトの状態管理 -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        4.4 オブジェクトの状態管理とイミュータブル更新
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        Reactでは、状態をイミュータブル（不変）に扱う必要があります。オブジェクトの状態を更新する際は、新しいオブジェクトを生成します。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">オブジェクトの更新パターン</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">オブジェクト状態の更新</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">interface User {
  name: string;
  age: number;
  email: string;
}

function UserProfile() {
  const [user, setUser] = useState&lt;User&gt;({
    name: 'John Doe',
    age: 30,
    email: 'john@example.com'
  });

  // ❌ 間違い：直接変更（再レンダリングされない）
  const updateNameWrong = () => {
    user.name = 'Jane Doe';
    setUser(user);
  };

  // ✅ 正しい：スプレッド演算子で新オブジェクト作成
  const updateName = (newName: string) => {
    setUser({ ...user, name: newName });
  };

  // ✅ 正しい：関数型更新 + スプレッド演算子
  const updateAge = (increment: number) => {
    setUser(prev => ({ ...prev, age: prev.age + increment }));
  };

  return (
    &lt;div&gt;
      &lt;p&gt;名前: {user.name}&lt;/p&gt;
      &lt;p&gt;年齢: {user.age}&lt;/p&gt;
      &lt;button onClick={() => updateName('Jane Doe')}&gt;名前変更&lt;/button&gt;
      &lt;button onClick={() => updateAge(1)}&gt;年齢+1&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">ネストしたオブジェクトの更新</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">深いネストの更新</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">interface Address {
  street: string;
  city: string;
}

interface UserWithAddress {
  name: string;
  address: Address;
}

function UserForm() {
  const [user, setUser] = useState&lt;UserWithAddress&gt;({
    name: 'John',
    address: { street: '123 Main St', city: 'Tokyo' }
  });

  // ネストしたプロパティの更新
  const updateCity = (newCity: string) => {
    setUser(prev => ({
      ...prev,
      address: { ...prev.address, city: newCity }
    }));
  };

  return (
    &lt;div&gt;
      &lt;p&gt;都市: {user.address.city}&lt;/p&gt;
      &lt;button onClick={() => updateCity('Osaka')}&gt;都市変更&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>

                    <div class="bg-blue-50 border-l-4 border-blue-500 p-4 my-6 rounded-r-lg overflow-hidden">
                        <div class="flex items-start gap-3">
                            <i class="fas fa-lightbulb text-blue-600 mt-1"></i>
                            <div class="flex-1 min-w-0">
                                <p class="text-blue-900 font-medium break-words">Immerライブラリの活用</p>
                                <p class="text-blue-800 text-sm mt-1 break-words">
                                    深くネストしたオブジェクトの更新が複雑になる場合は、Immerライブラリの使用を検討しましょう。ミュータブルな書き方でイミュータブルな更新が可能になります。
                                </p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- セクション5: 配列の状態管理 -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        4.5 配列の状態管理
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        配列の状態管理も、イミュータブルな方法で行います。元の配列を変更せず、新しい配列を生成することが重要です。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">配列操作のパターン</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">配列の追加・削除・更新</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

function TodoList() {
  const [todos, setTodos] = useState&lt;Todo[]&gt;([]);

  // 追加：末尾に追加
  const addTodo = (text: string) => {
    const newTodo: Todo = {
      id: Date.now(),
      text,
      completed: false
    };
    setTodos(prev => [...prev, newTodo]);
  };

  // 追加：先頭に追加
  const addTodoToTop = (text: string) => {
    const newTodo: Todo = { id: Date.now(), text, completed: false };
    setTodos(prev => [newTodo, ...prev]);
  };

  // 削除：IDで削除
  const deleteTodo = (id: number) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  };

  // 更新：完了状態をトグル
  const toggleTodo = (id: number) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id
        ? { ...todo, completed: !todo.completed }
        : todo
    ));
  };

  return (
    &lt;div&gt;
      &lt;ul&gt;
        {todos.map(todo => (
          &lt;li key={todo.id}&gt;
            &lt;input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            /&gt;
            {todo.text}
            &lt;button onClick={() => deleteTodo(todo.id)}&gt;削除&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>

                    <div class="bg-red-50 border-l-4 border-red-500 p-4 my-6 rounded-r-lg overflow-hidden">
                        <div class="flex items-start gap-3">
                            <i class="fas fa-exclamation-triangle text-red-600 mt-1"></i>
                            <div class="flex-1 min-w-0">
                                <p class="text-red-900 font-medium break-words">ミュータブルメソッドの禁止</p>
                                <p class="text-red-800 text-sm mt-1 break-words">
                                    <code class="bg-red-100 px-1 rounded">push()</code>、<code class="bg-red-100 px-1 rounded">pop()</code>、<code class="bg-red-100 px-1 rounded">splice()</code>、<code class="bg-red-100 px-1 rounded">sort()</code> などは元の配列を変更するため、使用しないでください。代わりにスプレッド演算子や <code class="bg-red-100 px-1 rounded">map()</code>、<code class="bg-red-100 px-1 rounded">filter()</code> などを使用します。
                                </p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- セクション6: 状態のバッチングと自動バッチング -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        4.6 状態のバッチングとReact18の自動バッチング
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        Reactは、複数の状態更新を1つの再レンダリングにまとめる「バッチング」を行います。React18では、この機能がさらに強化されています。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">React17以前のバッチング</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">イベントハンドラー内でのバッチング</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">function Counter() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  // イベントハンドラー内：バッチングされる（1回だけ再レンダリング）
  const handleClick = () => {
    setCount(c => c + 1); // 状態更新1
    setFlag(f => !f);     // 状態更新2
    // → 1回の再レンダリングで両方反映
  };

  // 非同期処理内：バッチングされない（React17以前）
  const handleAsyncClick = () => {
    setTimeout(() => {
      setCount(c => c + 1); // 再レンダリング1回目
      setFlag(f => !f);     // 再レンダリング2回目
      // → 合計2回の再レンダリング
    }, 1000);
  };

  return (
    &lt;button onClick={handleClick}&gt;クリック&lt;/button&gt;
  );
}</code></pre>
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">React18の自動バッチング</h3>
                    <p class="text-slate-600 leading-relaxed">
                        React18では、非同期処理内やPromise、setTimeoutなど、あらゆる場面で自動的にバッチングされるようになりました。
                    </p>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">React18の自動バッチング</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">import { useState } from 'react';

function AutoBatchingExample() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  // React18では、これらすべてでバッチングされる
  const handleFetch = async () => {
    const data = await fetch('/api/data');

    setCount(c => c + 1);
    setFlag(f => !f);
    // → 1回の再レンダリングで両方反映
  };

  const handleTimeout = () => {
    setTimeout(() => {
      setCount(c => c + 1);
      setFlag(f => !f);
      // → React18では1回の再レンダリング
    }, 1000);
  };

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;p&gt;Flag: {flag.toString()}&lt;/p&gt;
      &lt;button onClick={handleFetch}&gt;Fetch&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>

                    <div class="bg-emerald-50 border-l-4 border-emerald-500 p-4 my-6 rounded-r-lg overflow-hidden">
                        <div class="flex items-start gap-3">
                            <i class="fas fa-star text-emerald-600 mt-1"></i>
                            <div class="flex-1 min-w-0">
                                <p class="text-emerald-900 font-medium break-words">自動バッチングのメリット</p>
                                <p class="text-emerald-800 text-sm mt-1 break-words">
                                    再レンダリング回数が減少し、パフォーマンスが向上します。開発者が意識せずとも最適化が行われるため、コードがシンプルになります。
                                </p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- セクション7: パフォーマンス最適化 -->
                <section class="prose prose-slate max-w-none mb-8">
                    <h2 class="flex items-center gap-3 text-xl font-semibold text-slate-800
                               border-l-4 border-primary-500 pl-4 mb-4">
                        4.7 useStateのパフォーマンス最適化
                    </h2>
                    <p class="text-slate-600 leading-relaxed">
                        useState使用時のパフォーマンス最適化のベストプラクティスを理解しましょう。
                    </p>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">状態の分割</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">状態の適切な分割</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">// ❌ 悪い例：すべてを1つの状態に
function Form() {
  const [form, setForm] = useState({
    name: '',
    email: '',
    age: 0,
    isSubscribed: false
  });

  // 1つのフィールド変更で全体が再レンダリング
  const handleNameChange = (name: string) => {
    setForm({ ...form, name });
  };
}

// ✅ 良い例：独立した状態に分割
function FormOptimized() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);
  const [isSubscribed, setIsSubscribed] = useState(false);

  // 関連性のあるものだけグループ化
  const [address, setAddress] = useState({
    street: '',
    city: '',
    zipCode: ''
  });
}</code></pre>
                    </div>

                    <h3 class="text-lg font-semibold text-slate-800 mt-6 mb-3">不要な再レンダリングの回避</h3>

                    <div class="code-block-wrapper my-6">
                        <div class="flex items-center justify-between bg-slate-800 px-4 py-2 rounded-t-lg">
                            <span class="text-slate-400 text-sm">同じ値での更新を避ける</span>
                            <button class="copy-btn text-slate-400 hover:text-white transition-colors"
                                    onclick="copyCode(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <pre class="!mt-0 !rounded-t-none"><code class="language-typescript">function Counter() {
  const [count, setCount] = useState(0);

  // ✅ 条件付き更新
  const handleReset = () => {
    // 既に0の場合は更新しない
    if (count !== 0) {
      setCount(0);
    }
  };

  // または、関数型更新で判定
  const handleResetFunctional = () => {
    setCount(prev => prev === 0 ? prev : 0);
  };

  return (
    &lt;div&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button onClick={handleReset}&gt;リセット&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>

                    <div class="bg-blue-50 border border-blue-200 rounded-xl p-5 my-6">
                        <div class="flex items-start gap-3">
                            <i class="fas fa-info-circle text-blue-500 text-lg mt-0.5"></i>
                            <div>
                                <h3 class="font-semibold text-blue-800 mb-2">Object.isによる同一性チェック</h3>
                                <p class="text-blue-900 text-sm">
                                    Reactは、<code class="bg-blue-100 px-1 rounded text-blue-900">Object.is()</code> で新旧の値を比較します。同じ値であれば、再レンダリングをスキップします。オブジェクトや配列の場合は参照が異なると再レンダリングされるため注意が必要です。
                                </p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- 実習 -->
                <div class="bg-gradient-to-r from-purple-50 to-fuchsia-50 border border-purple-200
                            rounded-xl p-5 my-6 overflow-hidden">
                    <div class="flex items-start gap-4">
                        <div class="flex-shrink-0 w-10 h-10 bg-purple-500 rounded-lg
                                    flex items-center justify-center">
                            <i class="fas fa-code text-white"></i>
                        </div>
                        <div class="flex-1 min-w-0">
                            <h3 class="text-lg font-semibold text-purple-800 mb-3 break-words">
                                実習 4-1: Todoリストアプリの実装
                            </h3>
                            <p class="text-purple-900 mb-4 break-words">
                                useStateを使って、タスクの追加・削除・完了状態の切り替えができるTodoリストを作成しましょう。
                            </p>

                            <h4 class="font-medium text-purple-800 mb-2">要件</h4>
                            <ul class="space-y-2 mb-4 text-purple-900 text-sm">
                                <li class="flex items-start gap-2">
                                    <i class="fas fa-check text-purple-500 mt-1"></i>
                                    <span>タスクを追加できる</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <i class="fas fa-check text-purple-500 mt-1"></i>
                                    <span>タスクを削除できる</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <i class="fas fa-check text-purple-500 mt-1"></i>
                                    <span>タスクの完了状態をトグルできる</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <i class="fas fa-check text-purple-500 mt-1"></i>
                                    <span>完了済みタスク数を表示する</span>
                                </li>
                            </ul>

                            <h4 class="font-medium text-purple-800 mb-2">実装コード</h4>
                            <div class="code-block-wrapper">
                                <button onclick="copyCode(this)" class="copy-btn px-3 py-1.5 bg-slate-700 hover:bg-slate-600 text-white text-sm rounded-lg transition-colors">
                                    <i class="fas fa-copy mr-1"></i>コピー
                                </button>
                                <pre class="!bg-slate-800 !rounded-lg overflow-x-auto"><code class="language-typescript">import { useState } from 'react';

interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

function TodoApp() {
  const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
  const [inputText, setInputText] = useState('');

  // タスク追加
  const handleAddTodo = () => {
    if (inputText.trim() === '') return;

    const newTodo: Todo = {
      id: Date.now(),
      text: inputText,
      completed: false
    };

    setTodos(prev => [...prev, newTodo]);
    setInputText(''); // 入力欄をクリア
  };

  // タスク削除
  const handleDeleteTodo = (id: number) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  };

  // 完了状態トグル
  const handleToggleTodo = (id: number) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id
        ? { ...todo, completed: !todo.completed }
        : todo
    ));
  };

  // 完了済みタスク数
  const completedCount = todos.filter(todo => todo.completed).length;

  return (
    &lt;div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}&gt;
      &lt;h1&gt;Todoリスト&lt;/h1&gt;

      &lt;div style={{ marginBottom: '20px' }}&gt;
        &lt;input
          type="text"
          value={inputText}
          onChange={(e) => setInputText(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && handleAddTodo()}
          placeholder="新しいタスクを入力"
          style={{ padding: '8px', marginRight: '8px', width: '70%' }}
        /&gt;
        &lt;button onClick={handleAddTodo}&gt;追加&lt;/button&gt;
      &lt;/div&gt;

      &lt;p&gt;完了: {completedCount} / {todos.length}&lt;/p&gt;

      &lt;ul style={{ listStyle: 'none', padding: 0 }}&gt;
        {todos.map(todo => (
          &lt;li
            key={todo.id}
            style={{
              padding: '10px',
              borderBottom: '1px solid #ddd',
              display: 'flex',
              alignItems: 'center',
              gap: '10px'
            }}
          &gt;
            &lt;input
              type="checkbox"
              checked={todo.completed}
              onChange={() => handleToggleTodo(todo.id)}
            /&gt;
            &lt;span style={{
              textDecoration: todo.completed ? 'line-through' : 'none',
              flex: 1
            }}&gt;
              {todo.text}
            &lt;/span&gt;
            &lt;button onClick={() => handleDeleteTodo(todo.id)}&gt;削除&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

export default TodoApp;</code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 理解度確認クイズ -->
                <div class="bg-gradient-to-r from-blue-50 to-cyan-50 border border-blue-200
                            rounded-xl p-5 my-6 overflow-hidden">
                    <div class="flex items-start gap-4">
                        <div class="flex-shrink-0 w-10 h-10 bg-blue-500 rounded-lg
                                    flex items-center justify-center">
                            <i class="fas fa-question text-white"></i>
                        </div>
                        <div class="flex-1 min-w-0">
                            <h3 class="text-lg font-semibold text-blue-800 mb-4 break-words">理解度確認クイズ</h3>
                            <ol class="space-y-4">
                                <li class="text-blue-900">
                                    <p class="font-medium mb-2 break-words">Q1. useStateで状態を更新する際、なぜイミュータブルに更新する必要がありますか？</p>
                                    <details class="mt-2">
                                        <summary class="cursor-pointer text-blue-600 hover:text-blue-700 break-words">
                                            回答を表示
                                        </summary>
                                        <p class="mt-2 pl-4 text-blue-800 bg-blue-100 rounded-lg p-3 break-words">
                                            <strong>回答:</strong> Reactは、状態が変更されたかどうかを参照の比較（Object.is）で判定します。元のオブジェクトを直接変更すると参照が変わらないため、Reactが変更を検知できず、再レンダリングが行われません。新しいオブジェクトを生成することで、正しく再レンダリングがトリガーされます。
                                        </p>
                                    </details>
                                </li>
                                <li class="text-blue-900">
                                    <p class="font-medium mb-2 break-words">Q2. 関数型更新を使うべきなのはどのような場合ですか？</p>
                                    <details class="mt-2">
                                        <summary class="cursor-pointer text-blue-600 hover:text-blue-700 break-words">
                                            回答を表示
                                        </summary>
                                        <p class="mt-2 pl-4 text-blue-800 bg-blue-100 rounded-lg p-3 break-words">
                                            <strong>回答:</strong> 現在の状態値に基づいて更新を行う場合や、同じイベントハンドラー内で複数回状態を更新する場合には、関数型更新（<code class="bg-blue-200 px-1 rounded">setState(prev => prev + 1)</code>）を使用します。これにより、常に最新の状態値を参照できます。
                                        </p>
                                    </details>
                                </li>
                                <li class="text-blue-900">
                                    <p class="font-medium mb-2 break-words">Q3. React18の自動バッチングとは何ですか？</p>
                                    <details class="mt-2">
                                        <summary class="cursor-pointer text-blue-600 hover:text-blue-700 break-words">
                                            回答を表示
                                        </summary>
                                        <p class="mt-2 pl-4 text-blue-800 bg-blue-100 rounded-lg p-3 break-words">
                                            <strong>回答:</strong> React18では、イベントハンドラー内だけでなく、Promise、setTimeout、非同期処理など、あらゆる場面で複数の状態更新を自動的に1つの再レンダリングにまとめます。これにより、パフォーマンスが向上します。
                                        </p>
                                    </details>
                                </li>
                                <li class="text-blue-900">
                                    <p class="font-medium mb-2 break-words">Q4. 配列の状態を更新する際、なぜpush()を使ってはいけませんか？</p>
                                    <details class="mt-2">
                                        <summary class="cursor-pointer text-blue-600 hover:text-blue-700 break-words">
                                            回答を表示
                                        </summary>
                                        <p class="mt-2 pl-4 text-blue-800 bg-blue-100 rounded-lg p-3 break-words">
                                            <strong>回答:</strong> push()は元の配列を直接変更（ミュータブル操作）するため、Reactが変更を検知できません。代わりにスプレッド演算子（<code class="bg-blue-200 px-1 rounded">[...prev, newItem]</code>）を使って新しい配列を生成する必要があります。
                                        </p>
                                    </details>
                                </li>
                            </ol>
                        </div>
                    </div>
                </div>

                <!-- 章まとめ -->
                <div class="bg-gradient-to-r from-slate-50 to-slate-100 border border-slate-200 rounded-xl p-6 my-8">
                    <h2 class="text-xl font-semibold text-slate-800 mb-4 flex items-center gap-2">
                        <i class="fas fa-bookmark text-primary-500"></i>
                        第4章のまとめ
                    </h2>
                    <ul class="space-y-3 text-slate-700">
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>useStateはReactの基本的なHookで、状態管理を実現する</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>遅延初期化により、初期値の計算コストを最適化できる</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>関数型更新で、常に最新の状態値を参照した更新が可能</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>オブジェクトや配列はイミュータブルに更新する必要がある</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>React18の自動バッチングにより、パフォーマンスが自動的に最適化される</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <i class="fas fa-check-circle text-primary-500 mt-1 flex-shrink-0"></i>
                            <span>状態の適切な分割と条件付き更新で、不要な再レンダリングを回避できる</span>
                        </li>
                    </ul>

                    <div class="mt-6 p-4 bg-primary-50 rounded-lg border border-primary-200">
                        <p class="text-primary-900 font-medium mb-2">
                            <i class="fas fa-arrow-right text-primary-600 mr-2"></i>次の章では
                        </p>
                        <p class="text-primary-800 text-sm">
                            useEffectを使った副作用の管理とライフサイクル制御について学習します。データフェッチング、購読、クリーンアップ処理など、実践的なパターンを習得しましょう。
                        </p>
                    </div>
                </div>

                <!-- 章間ナビゲーション -->
                <nav class="flex items-center justify-between pt-6 mt-6 border-t border-slate-200">
                    <a href="react-learning-material-03.html"
                       class="group flex items-center gap-3 px-4 py-3 rounded-xl
                              bg-slate-100 hover:bg-slate-200 transition-colors">
                        <i class="fas fa-arrow-left text-slate-400 group-hover:text-slate-600 transition-transform group-hover:-translate-x-1"></i>
                        <div>
                            <span class="text-xs text-slate-500 block">前の章</span>
                            <span class="text-slate-700 font-medium">第3章: 関数コンポーネントとProps</span>
                        </div>
                    </a>
                    <a href="react-learning-material-05.html"
                       class="group flex items-center gap-3 px-4 py-3 rounded-xl
                              bg-primary-500 hover:bg-primary-600 text-white transition-colors">
                        <div class="text-right">
                            <span class="text-xs text-primary-100 block">次の章</span>
                            <span class="font-medium">第5章: useEffect - 副作用とライフサイクル</span>
                        </div>
                        <i class="fas fa-arrow-right transition-transform group-hover:translate-x-1"></i>
                    </a>
                </nav>
            </div>
        </main>
    </div>

    <!-- フッター -->
    <footer class="bg-slate-800 text-slate-300">
        <div class="max-w-screen-2xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
            <div class="flex flex-col md:flex-row items-center justify-between gap-4">
                <p class="text-sm text-center md:text-left">
                    &copy; 2025 F-Circle. All rights reserved.<br>
                    本資料はAIツールを活用し、人間による編集・監修のもと作成されています。
                </p>
                <div class="flex items-center gap-4">
                    <a href="https://github.com/fcircle-biz" class="hover:text-white transition-colors">
                        <i class="fab fa-github text-xl"></i>
                    </a>
                </div>
            </div>
        </div>
    </footer>

    <!-- スクロールトップボタン -->
    <button id="scroll-top-btn"
            class="fixed bottom-6 right-6 w-12 h-12 bg-primary-500 text-white rounded-full
                   shadow-lg hover:bg-primary-600 transition-all duration-300
                   opacity-0 invisible translate-y-4"
            onclick="scrollToTop()">
        <i class="fas fa-arrow-up"></i>
    </button>

    <!-- サイドバー生成 -->
    <script src="sidebar-content.js"></script>

    <!-- 共通JavaScript -->
    <script src="main.js"></script>

    <!-- 描画ツール -->
    <script src="drawing-tool.js"></script>
</body>
</html>
