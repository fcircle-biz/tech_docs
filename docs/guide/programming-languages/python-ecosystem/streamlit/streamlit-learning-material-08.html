<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamlit学習教材 第8章 - データベース連携とAPI統合</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->

    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #4caf50;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
            background-color: #f8f9fa;
        }

        /* タイトル */
        .chapter-title {
            color: #4caf50;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #4caf50;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #66bb6a;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e8f5e8;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #4caf50;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .info-box {
            background-color: #e1f5fe;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #2196F3;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #4caf50 !important;
            color: white !important;
        }

        .nav-link {
            color: #666;
        }

        .nav-link:hover {
            background-color: #e8f5e8;
            color: #4caf50;
        }

        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        pre {
            background-color: #f5f5f5;
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
        }

        code {
            background-color: #f5f5f5;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Streamlit学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="../README.md">学習ガイドに戻る</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        章の一覧
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-01.html">第1章: 入門と環境構築</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-02.html">第2章: 基本的なUIコンポーネント</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-03.html">第3章: データ表示と可視化</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-04.html">第4章: ユーザー入力とインタラクション</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-05.html">第5章: セッション状態管理</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-06.html">第6章: ファイル操作とデータ処理</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-07.html">第7章: マルチページアプリケーション</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="#chapter8">第8章: データベース連携とAPI統合</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-09.html">第9章: デプロイメントと本番環境</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-10.html">第10章: 実践的なデータ分析アプリ開発</a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <!-- 章ヘッダー -->
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第8章: データベース連携とAPI統合</h1>
                </div>

                <div id="chapter8">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">外部データソースとの統合とリアルタイムデータ処理</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>SQLiteとPostgreSQLデータベースとの連携</li>
                            <li>外部APIとの通信とデータ取得</li>
                            <li>リアルタイムデータ更新の実装</li>
                            <li>基本的な認証機能の実装</li>
                            <li>データベースCRUD操作とStreamlitの統合</li>
                        </ul>
                    </div>

                    <!-- セクション1: データベース連携 -->
                    <h3 class="section-title">8.1 データベース連携の基礎</h3>
                    <p>Streamlitアプリケーションでは、SQLiteやPostgreSQLなどのデータベースと連携して、永続的なデータ管理を実現できます。</p>
                    
                    <h4>サポートされるデータベース</h4>
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>データベース</th>
                                <th>特徴</th>
                                <th>適用場面</th>
                                <th>ライブラリ</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>SQLite</td>
                                <td>ファイルベース、軽量</td>
                                <td>開発・プロトタイプ</td>
                                <td>sqlite3（標準）</td>
                            </tr>
                            <tr>
                                <td>PostgreSQL</td>
                                <td>高機能、本格的</td>
                                <td>本番環境</td>
                                <td>psycopg2, SQLAlchemy</td>
                            </tr>
                            <tr>
                                <td>MySQL</td>
                                <td>広く普及</td>
                                <td>Webアプリケーション</td>
                                <td>PyMySQL, SQLAlchemy</td>
                            </tr>
                            <tr>
                                <td>MongoDB</td>
                                <td>NoSQL、JSON形式</td>
                                <td>ドキュメント指向</td>
                                <td>pymongo</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="info-box">
                        <h6>データベース設計のベストプラクティス</h6>
                        <ul>
                            <li><strong>接続プール</strong>: st.connection()でコネクション管理</li>
                            <li><strong>SQLインジェクション対策</strong>: パラメータ化クエリの使用</li>
                            <li><strong>トランザクション管理</strong>: データ整合性の保証</li>
                            <li><strong>キャッシュ活用</strong>: @st.cache_dataでクエリ結果をキャッシュ</li>
                        </ul>
                    </div>

                    <div class="exercise-container">
                        <h5>実習 8-1: SQLiteデータベース連携アプリ</h5>
                        <p>SQLiteデータベースと連携した顧客管理システムを作成します。</p>
                        
                        <h6>database_app.py を作成</h6>
                        <pre class="code-block"><code class="language-python">import streamlit as st
import sqlite3
import pandas as pd
from datetime import datetime, date
import hashlib
import uuid

# ページ設定
st.set_page_config(
    page_title="データベース連携アプリ",
    page_icon="🗄️",
    layout="wide"
)

class DatabaseManager:
    """データベース管理クラス"""
    
    def __init__(self, db_path="customers.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """データベースとテーブルを初期化"""
        with sqlite3.connect(self.db_path) as conn:
            # 顧客テーブル
            conn.execute("""
                CREATE TABLE IF NOT EXISTS customers (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    customer_id TEXT UNIQUE NOT NULL,
                    name TEXT NOT NULL,
                    email TEXT UNIQUE NOT NULL,
                    phone TEXT,
                    address TEXT,
                    company TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # 注文テーブル
            conn.execute("""
                CREATE TABLE IF NOT EXISTS orders (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    order_id TEXT UNIQUE NOT NULL,
                    customer_id TEXT NOT NULL,
                    product_name TEXT NOT NULL,
                    quantity INTEGER NOT NULL,
                    unit_price REAL NOT NULL,
                    total_amount REAL NOT NULL,
                    order_date DATE NOT NULL,
                    status TEXT DEFAULT 'pending',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (customer_id) REFERENCES customers (customer_id)
                )
            """)
            
            conn.commit()
    
    @st.cache_data(ttl=60)  # 1分間キャッシュ
    def get_customers(_self):
        """全顧客データを取得"""
        with sqlite3.connect(_self.db_path) as conn:
            return pd.read_sql_query("SELECT * FROM customers ORDER BY created_at DESC", conn)
    
    @st.cache_data(ttl=60)
    def get_orders(_self):
        """全注文データを取得"""
        with sqlite3.connect(_self.db_path) as conn:
            query = """
                SELECT o.*, c.name as customer_name, c.email 
                FROM orders o 
                JOIN customers c ON o.customer_id = c.customer_id 
                ORDER BY o.created_at DESC
            """
            return pd.read_sql_query(query, conn)
    
    def add_customer(self, name, email, phone=None, address=None, company=None):
        """新しい顧客を追加"""
        customer_id = f"CUST-{uuid.uuid4().hex[:8].upper()}"
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute("""
                    INSERT INTO customers (customer_id, name, email, phone, address, company)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (customer_id, name, email, phone, address, company))
                conn.commit()
                # キャッシュをクリア
                st.cache_data.clear()
                return True, customer_id
        except sqlite3.IntegrityError as e:
            return False, str(e)
    
    def update_customer(self, customer_id, name, email, phone=None, address=None, company=None):
        """顧客情報を更新"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute("""
                    UPDATE customers 
                    SET name=?, email=?, phone=?, address=?, company=?, updated_at=CURRENT_TIMESTAMP
                    WHERE customer_id=?
                """, (name, email, phone, address, company, customer_id))
                conn.commit()
                # キャッシュをクリア
                st.cache_data.clear()
                return True, "更新成功"
        except sqlite3.IntegrityError as e:
            return False, str(e)
    
    def delete_customer(self, customer_id):
        """顧客を削除"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                # 関連する注文も削除
                conn.execute("DELETE FROM orders WHERE customer_id=?", (customer_id,))
                conn.execute("DELETE FROM customers WHERE customer_id=?", (customer_id,))
                conn.commit()
                # キャッシュをクリア
                st.cache_data.clear()
                return True, "削除成功"
        except Exception as e:
            return False, str(e)
    
    def add_order(self, customer_id, product_name, quantity, unit_price):
        """新しい注文を追加"""
        order_id = f"ORD-{uuid.uuid4().hex[:8].upper()}"
        total_amount = quantity * unit_price
        order_date = date.today()
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute("""
                    INSERT INTO orders (order_id, customer_id, product_name, quantity, unit_price, total_amount, order_date)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (order_id, customer_id, product_name, quantity, unit_price, total_amount, order_date))
                conn.commit()
                # キャッシュをクリア
                st.cache_data.clear()
                return True, order_id
        except Exception as e:
            return False, str(e)
    
    def get_customer_by_id(self, customer_id):
        """IDで顧客を検索"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute("SELECT * FROM customers WHERE customer_id=?", (customer_id,))
            return cursor.fetchone()

# データベースマネージャーの初期化
@st.cache_resource
def get_database_manager():
    return DatabaseManager()

db = get_database_manager()

st.title("🗄️ データベース連携顧客管理システム")

# タブで機能を分割
tab1, tab2, tab3, tab4 = st.tabs(["👥 顧客管理", "📦 注文管理", "📊 統計情報", "🔧 データベース管理"])

with tab1:
    st.subheader("顧客管理")
    
    # サイドバーで操作選択
    with st.sidebar:
        st.header("顧客操作")
        operation = st.radio("操作を選択", ["表示", "追加", "編集", "削除"])
    
    if operation == "表示":
        st.write("**登録顧客一覧**")
        
        customers_df = db.get_customers()
        
        if not customers_df.empty:
            # 検索機能
            search_term = st.text_input("🔍 顧客検索（名前またはメール）")
            
            if search_term:
                mask = customers_df['name'].str.contains(search_term, case=False, na=False) | \
                       customers_df['email'].str.contains(search_term, case=False, na=False)
                filtered_df = customers_df[mask]
            else:
                filtered_df = customers_df
            
            # 表示列の選択
            display_columns = st.multiselect(
                "表示する列を選択",
                options=filtered_df.columns.tolist(),
                default=['customer_id', 'name', 'email', 'company', 'created_at']
            )
            
            if display_columns:
                st.dataframe(
                    filtered_df[display_columns], 
                    use_container_width=True,
                    hide_index=True
                )
            
            # 統計情報
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric("総顧客数", len(customers_df))
            
            with col2:
                companies = customers_df['company'].dropna().nunique()
                st.metric("登録企業数", companies)
            
            with col3:
                today_customers = customers_df[
                    pd.to_datetime(customers_df['created_at']).dt.date == date.today()
                ]
                st.metric("今日の新規登録", len(today_customers))
        
        else:
            st.info("まだ顧客が登録されていません。")
    
    elif operation == "追加":
        st.write("**新規顧客登録**")
        
        with st.form("add_customer_form"):
            col1, col2 = st.columns(2)
            
            with col1:
                name = st.text_input("顧客名 *", placeholder="山田太郎")
                email = st.text_input("メールアドレス *", placeholder="yamada@example.com")
                phone = st.text_input("電話番号", placeholder="03-1234-5678")
            
            with col2:
                company = st.text_input("会社名", placeholder="株式会社サンプル")
                address = st.text_area("住所", placeholder="東京都渋谷区...")
            
            submitted = st.form_submit_button("💾 顧客を登録", type="primary")
            
            if submitted:
                if name and email:
                    success, result = db.add_customer(name, email, phone, address, company)
                    
                    if success:
                        st.success(f"✅ 顧客が正常に登録されました！\n顧客ID: {result}")
                        st.balloons()
                    else:
                        st.error(f"❌ 登録に失敗しました: {result}")
                else:
                    st.error("❌ 必須項目（顧客名、メールアドレス）を入力してください。")
    
    elif operation == "編集":
        st.write("**顧客情報編集**")
        
        customers_df = db.get_customers()
        
        if not customers_df.empty:
            # 編集する顧客を選択
            customer_options = {
                f"{row['name']} ({row['customer_id']})": row['customer_id'] 
                for _, row in customers_df.iterrows()
            }
            
            selected_customer_label = st.selectbox("編集する顧客を選択", list(customer_options.keys()))
            
            if selected_customer_label:
                customer_id = customer_options[selected_customer_label]
                customer_data = db.get_customer_by_id(customer_id)
                
                if customer_data:
                    # 現在の情報を表示
                    st.write(f"**編集対象**: {customer_data[2]} ({customer_data[1]})")
                    
                    with st.form("edit_customer_form"):
                        col1, col2 = st.columns(2)
                        
                        with col1:
                            name = st.text_input("顧客名 *", value=customer_data[2])
                            email = st.text_input("メールアドレス *", value=customer_data[3])
                            phone = st.text_input("電話番号", value=customer_data[4] or "")
                        
                        with col2:
                            company = st.text_input("会社名", value=customer_data[6] or "")
                            address = st.text_area("住所", value=customer_data[5] or "")
                        
                        submitted = st.form_submit_button("💾 更新", type="primary")
                        
                        if submitted:
                            if name and email:
                                success, result = db.update_customer(customer_id, name, email, phone, address, company)
                                
                                if success:
                                    st.success("✅ 顧客情報が正常に更新されました！")
                                else:
                                    st.error(f"❌ 更新に失敗しました: {result}")
                            else:
                                st.error("❌ 必須項目（顧客名、メールアドレス）を入力してください。")
        else:
            st.info("編集可能な顧客がいません。")
    
    elif operation == "削除":
        st.write("**顧客削除**")
        
        customers_df = db.get_customers()
        
        if not customers_df.empty:
            # 削除する顧客を選択
            customer_options = {
                f"{row['name']} ({row['customer_id']})": row['customer_id'] 
                for _, row in customers_df.iterrows()
            }
            
            selected_customer_label = st.selectbox("削除する顧客を選択", list(customer_options.keys()))
            
            if selected_customer_label:
                customer_id = customer_options[selected_customer_label]
                customer_data = db.get_customer_by_id(customer_id)
                
                if customer_data:
                    # 顧客情報を表示
                    st.write(f"**削除対象**: {customer_data[2]} ({customer_data[1]})")
                    st.write(f"**メール**: {customer_data[3]}")
                    st.write(f"**会社**: {customer_data[6] or 'なし'}")
                    
                    st.warning("⚠️ この操作は取り消せません。関連する注文データも削除されます。")
                    
                    if st.button("🗑️ 削除実行", type="secondary"):
                        success, result = db.delete_customer(customer_id)
                        
                        if success:
                            st.success("✅ 顧客が正常に削除されました。")
                        else:
                            st.error(f"❌ 削除に失敗しました: {result}")
        else:
            st.info("削除可能な顧客がいません。")

with tab2:
    st.subheader("注文管理")
    
    operation = st.radio("操作を選択", ["注文一覧", "新規注文"], horizontal=True)
    
    if operation == "注文一覧":
        st.write("**注文履歴**")
        
        orders_df = db.get_orders()
        
        if not orders_df.empty:
            # フィルタリング
            col1, col2 = st.columns(2)
            
            with col1:
                status_filter = st.multiselect(
                    "ステータスでフィルタ",
                    options=orders_df['status'].unique(),
                    default=orders_df['status'].unique()
                )
            
            with col2:
                date_range = st.date_input(
                    "期間でフィルタ",
                    value=(orders_df['order_date'].min(), orders_df['order_date'].max()),
                    min_value=orders_df['order_date'].min(),
                    max_value=orders_df['order_date'].max()
                )
            
            # フィルタ適用
            filtered_orders = orders_df[orders_df['status'].isin(status_filter)]
            
            if len(date_range) == 2:
                filtered_orders = filtered_orders[
                    (pd.to_datetime(filtered_orders['order_date']).dt.date >= date_range[0]) &
                    (pd.to_datetime(filtered_orders['order_date']).dt.date <= date_range[1])
                ]
            
            # 表示
            display_cols = ['order_id', 'customer_name', 'product_name', 'quantity', 'total_amount', 'order_date', 'status']
            st.dataframe(filtered_orders[display_cols], use_container_width=True, hide_index=True)
            
            # 統計情報
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("総注文数", len(filtered_orders))
            
            with col2:
                total_amount = filtered_orders['total_amount'].sum()
                st.metric("総売上", f"¥{total_amount:,.0f}")
            
            with col3:
                avg_amount = filtered_orders['total_amount'].mean()
                st.metric("平均注文額", f"¥{avg_amount:,.0f}")
            
            with col4:
                pending_orders = len(filtered_orders[filtered_orders['status'] == 'pending'])
                st.metric("保留中注文", pending_orders)
        
        else:
            st.info("まだ注文がありません。")
    
    elif operation == "新規注文":
        st.write("**新規注文登録**")
        
        customers_df = db.get_customers()
        
        if not customers_df.empty:
            with st.form("add_order_form"):
                # 顧客選択
                customer_options = {
                    f"{row['name']} ({row['customer_id']})": row['customer_id'] 
                    for _, row in customers_df.iterrows()
                }
                
                selected_customer = st.selectbox("顧客を選択", list(customer_options.keys()))
                
                col1, col2 = st.columns(2)
                
                with col1:
                    product_name = st.text_input("商品名 *", placeholder="商品A")
                    quantity = st.number_input("数量 *", min_value=1, value=1)
                
                with col2:
                    unit_price = st.number_input("単価 *", min_value=0.0, value=1000.0, step=100.0)
                    total_preview = quantity * unit_price
                    st.write(f"**合計金額**: ¥{total_preview:,.0f}")
                
                submitted = st.form_submit_button("📦 注文を登録", type="primary")
                
                if submitted:
                    if selected_customer and product_name and quantity > 0 and unit_price > 0:
                        customer_id = customer_options[selected_customer]
                        success, result = db.add_order(customer_id, product_name, quantity, unit_price)
                        
                        if success:
                            st.success(f"✅ 注文が正常に登録されました！\n注文ID: {result}")
                        else:
                            st.error(f"❌ 注文登録に失敗しました: {result}")
                    else:
                        st.error("❌ 全ての必須項目を正しく入力してください。")
        else:
            st.info("注文を登録するには、まず顧客を登録してください。")

with tab3:
    st.subheader("統計情報")
    
    customers_df = db.get_customers()
    orders_df = db.get_orders()
    
    if not customers_df.empty or not orders_df.empty:
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("**顧客統計**")
            if not customers_df.empty:
                # 企業別顧客数
                if customers_df['company'].notna().any():
                    company_counts = customers_df['company'].value_counts().head(10)
                    st.bar_chart(company_counts)
                
                # 新規登録推移
                customers_df['date'] = pd.to_datetime(customers_df['created_at']).dt.date
                daily_registrations = customers_df.groupby('date').size()
                st.line_chart(daily_registrations)
        
        with col2:
            st.write("**注文統計**")
            if not orders_df.empty:
                # 商品別売上
                product_sales = orders_df.groupby('product_name')['total_amount'].sum().head(10)
                st.bar_chart(product_sales)
                
                # 日別売上推移
                orders_df['order_date'] = pd.to_datetime(orders_df['order_date'])
                daily_sales = orders_df.groupby(orders_df['order_date'].dt.date)['total_amount'].sum()
                st.line_chart(daily_sales)
    else:
        st.info("統計を表示するためのデータがありません。")

with tab4:
    st.subheader("データベース管理")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.write("**データベース情報**")
        
        # テーブル情報
        with sqlite3.connect(db.db_path) as conn:
            # 顧客テーブル
            customer_count = conn.execute("SELECT COUNT(*) FROM customers").fetchone()[0]
            st.metric("顧客テーブル", f"{customer_count} レコード")
            
            # 注文テーブル
            order_count = conn.execute("SELECT COUNT(*) FROM orders").fetchone()[0]
            st.metric("注文テーブル", f"{order_count} レコード")
            
            # データベースサイズ
            import os
            if os.path.exists(db.db_path):
                db_size = os.path.getsize(db.db_path) / 1024  # KB
                st.metric("データベースサイズ", f"{db_size:.1f} KB")
    
    with col2:
        st.write("**データベース操作**")
        
        if st.button("🔄 キャッシュをクリア"):
            st.cache_data.clear()
            st.success("キャッシュがクリアされました")
        
        if st.button("📊 サンプルデータを追加"):
            # サンプル顧客を追加
            sample_customers = [
                ("田中一郎", "tanaka@example.com", "03-1111-1111", "東京都新宿区", "株式会社A"),
                ("佐藤花子", "sato@example.com", "03-2222-2222", "東京都渋谷区", "株式会社B"),
                ("山田太郎", "yamada@example.com", "03-3333-3333", "大阪府大阪市", "株式会社C")
            ]
            
            for name, email, phone, address, company in sample_customers:
                db.add_customer(name, email, phone, address, company)
            
            st.success("サンプルデータが追加されました")
        
        st.warning("⚠️ 以下の操作は注意して実行してください")
        
        if st.button("🗑️ 全データを削除", type="secondary"):
            with sqlite3.connect(db.db_path) as conn:
                conn.execute("DELETE FROM orders")
                conn.execute("DELETE FROM customers")
                conn.commit()
            st.cache_data.clear()
            st.success("全データが削除されました")
</code></pre>
                        
                        <h6>必要なライブラリのインストール</h6>
                        <pre class="code-block"><code class="language-python"># 基本的にはStreamlitに含まれている標準ライブラリを使用
# 追加でPyMySQL（MySQL用）やpsycopg2（PostgreSQL用）が必要な場合
pip install pymysql psycopg2-binary sqlalchemy</code></pre>
                        
                        <h6>実行と確認</h6>
                        <pre class="code-block"><code class="language-bash">streamlit run database_app.py</code></pre>
                        
                        <h6>期待される結果</h6>
                        <p>SQLiteデータベースと完全に統合された顧客・注文管理システムが表示され、CRUD操作がすべて正常に動作することが確認できます。</p>
                    </div>

                    <!-- セクション2: API統合 -->
                    <h3 class="section-title">8.2 外部API統合とリアルタイムデータ</h3>
                    <p>外部APIからデータを取得し、リアルタイムで更新するアプリケーションを構築する方法を学習します。</p>

                    <div class="exercise-container">
                        <h5>実習 8-2: API統合リアルタイムダッシュボード</h5>
                        <p>複数の外部APIからデータを取得し、リアルタイムで更新するダッシュボードを作成します。</p>
                        
                        <h6>api_integration_app.py を作成</h6>
                        <pre class="code-block"><code class="language-python">import streamlit as st
import requests
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, timedelta
import time
import json
import base64
from typing import Dict, Any, Optional

# ページ設定
st.set_page_config(
    page_title="API統合ダッシュボード",
    page_icon="🌐",
    layout="wide",
    initial_sidebar_state="expanded"
)

class APIManager:
    """API管理クラス"""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.timeout = 10
        
        # レート制限対応
        self.last_request_time = {}
        self.min_interval = 1  # 最小リクエスト間隔（秒）
    
    def _rate_limit_check(self, api_name: str):
        """レート制限チェック"""
        current_time = time.time()
        last_time = self.last_request_time.get(api_name, 0)
        
        if current_time - last_time < self.min_interval:
            time.sleep(self.min_interval - (current_time - last_time))
        
        self.last_request_time[api_name] = time.time()
    
    @st.cache_data(ttl=300)  # 5分間キャッシュ
    def get_weather_data(_self, city: str = "Tokyo") -> Dict[str, Any]:
        """天気予報データを取得（OpenWeatherMap風のダミーAPI）"""
        _self._rate_limit_check("weather")
        
        try:
            # 実際のAPIの代わりにダミーデータを生成
            import random
            
            weather_data = {
                "city": city,
                "country": "JP",
                "temperature": round(random.uniform(15, 35), 1),
                "humidity": random.randint(40, 80),
                "pressure": random.randint(990, 1030),
                "wind_speed": round(random.uniform(0, 15), 1),
                "description": random.choice(["晴れ", "曇り", "雨", "雪"]),
                "timestamp": datetime.now().isoformat()
            }
            
            return {"success": True, "data": weather_data}
        
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    @st.cache_data(ttl=60)  # 1分間キャッシュ
    def get_stock_data(_self, symbol: str = "AAPL") -> Dict[str, Any]:
        """株価データを取得（ダミー）"""
        _self._rate_limit_check("stock")
        
        try:
            import random
            
            # ダミー株価データ
            base_price = 150.0
            change_percent = random.uniform(-5, 5)
            current_price = base_price * (1 + change_percent / 100)
            
            stock_data = {
                "symbol": symbol,
                "price": round(current_price, 2),
                "change": round(current_price - base_price, 2),
                "change_percent": round(change_percent, 2),
                "volume": random.randint(1000000, 10000000),
                "high": round(current_price * 1.05, 2),
                "low": round(current_price * 0.95, 2),
                "timestamp": datetime.now().isoformat()
            }
            
            return {"success": True, "data": stock_data}
        
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    @st.cache_data(ttl=120)  # 2分間キャッシュ
    def get_news_data(_self, category: str = "technology") -> Dict[str, Any]:
        """ニュースデータを取得（ダミー）"""
        _self._rate_limit_check("news")
        
        try:
            # ダミーニュースデータ
            sample_news = [
                {
                    "title": "AI技術の最新動向について",
                    "summary": "人工知能技術の最新トレンドと今後の展望...",
                    "category": "technology",
                    "published_at": (datetime.now() - timedelta(hours=2)).isoformat(),
                    "source": "Tech News"
                },
                {
                    "title": "新しいプログラミング言語が登場",
                    "summary": "開発者向けの新言語がリリースされ、注目を集めています...",
                    "category": "technology",
                    "published_at": (datetime.now() - timedelta(hours=5)).isoformat(),
                    "source": "Dev Weekly"
                },
                {
                    "title": "クラウドコンピューティングの未来",
                    "summary": "クラウド技術の進化と企業への影響について...",
                    "category": "technology",
                    "published_at": (datetime.now() - timedelta(hours=8)).isoformat(),
                    "source": "Cloud Today"
                }
            ]
            
            return {"success": True, "data": sample_news}
        
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    @st.cache_data(ttl=180)  # 3分間キャッシュ
    def get_crypto_data(_self) -> Dict[str, Any]:
        """仮想通貨データを取得（ダミー）"""
        _self._rate_limit_check("crypto")
        
        try:
            import random
            
            crypto_data = []
            
            cryptos = ["Bitcoin", "Ethereum", "Ripple", "Litecoin"]
            base_prices = [45000, 3000, 0.5, 150]
            
            for crypto, base_price in zip(cryptos, base_prices):
                change_percent = random.uniform(-10, 10)
                current_price = base_price * (1 + change_percent / 100)
                
                crypto_data.append({
                    "name": crypto,
                    "symbol": crypto[:3].upper(),
                    "price": round(current_price, 2),
                    "change_24h": round(change_percent, 2),
                    "volume_24h": random.randint(1000000, 100000000),
                    "market_cap": round(current_price * random.randint(10000000, 100000000), 2)
                })
            
            return {"success": True, "data": crypto_data}
        
        except Exception as e:
            return {"success": False, "error": str(e)}

# APIマネージャーの初期化
@st.cache_resource
def get_api_manager():
    return APIManager()

api_manager = get_api_manager()

# セッション状態の初期化
if 'auto_refresh' not in st.session_state:
    st.session_state.auto_refresh = False

if 'refresh_interval' not in st.session_state:
    st.session_state.refresh_interval = 30

st.title("🌐 API統合リアルタイムダッシュボード")

# サイドバー設定
st.sidebar.header("⚙️ ダッシュボード設定")

# 自動更新設定
auto_refresh = st.sidebar.checkbox("自動更新", value=st.session_state.auto_refresh)
st.session_state.auto_refresh = auto_refresh

if auto_refresh:
    refresh_interval = st.sidebar.slider(
        "更新間隔（秒）", 
        min_value=10, 
        max_value=300, 
        value=st.session_state.refresh_interval,
        step=10
    )
    st.session_state.refresh_interval = refresh_interval

# 手動更新ボタン
if st.sidebar.button("🔄 手動更新", type="primary"):
    st.cache_data.clear()
    st.rerun()

# データソース選択
st.sidebar.subheader("📊 表示データ")
show_weather = st.sidebar.checkbox("天気予報", value=True)
show_stocks = st.sidebar.checkbox("株価情報", value=True)
show_crypto = st.sidebar.checkbox("仮想通貨", value=True)
show_news = st.sidebar.checkbox("ニュース", value=True)

# API接続状況
st.sidebar.subheader("🔗 API接続状況")

# 最終更新時刻表示
last_update = datetime.now().strftime("%Y/%m/%d %H:%M:%S")
st.sidebar.write(f"**最終更新**: {last_update}")

# メインダッシュボード
col1, col2 = st.columns([2, 1])

with col1:
    # 天気予報セクション
    if show_weather:
        st.subheader("🌤️ 天気予報")
        
        weather_result = api_manager.get_weather_data("Tokyo")
        
        if weather_result["success"]:
            weather_data = weather_result["data"]
            
            col1_1, col1_2, col1_3, col1_4 = st.columns(4)
            
            with col1_1:
                st.metric(
                    "気温", 
                    f"{weather_data['temperature']}°C",
                    delta=f"{weather_data['description']}"
                )
            
            with col1_2:
                st.metric("湿度", f"{weather_data['humidity']}%")
            
            with col1_3:
                st.metric("気圧", f"{weather_data['pressure']} hPa")
            
            with col1_4:
                st.metric("風速", f"{weather_data['wind_speed']} m/s")
        
        else:
            st.error(f"天気データの取得に失敗: {weather_result['error']}")
    
    # 株価情報セクション
    if show_stocks:
        st.subheader("📈 株価情報")
        
        symbols = ["AAPL", "GOOGL", "MSFT", "TSLA"]
        
        stock_data_list = []
        
        for symbol in symbols:
            stock_result = api_manager.get_stock_data(symbol)
            
            if stock_result["success"]:
                stock_data_list.append(stock_result["data"])
        
        if stock_data_list:
            stock_df = pd.DataFrame(stock_data_list)
            
            # 株価表示
            for _, stock in stock_df.iterrows():
                col_symbol, col_price, col_change = st.columns([1, 1, 1])
                
                with col_symbol:
                    st.write(f"**{stock['symbol']}**")
                
                with col_price:
                    st.metric("価格", f"${stock['price']}")
                
                with col_change:
                    delta_color = "normal" if stock['change'] >= 0 else "inverse"
                    st.metric(
                        "変動", 
                        f"{stock['change_percent']:+.2f}%",
                        delta=f"${stock['change']:+.2f}"
                    )
            
            # 株価チャート
            fig_stocks = px.bar(
                stock_df, 
                x='symbol', 
                y='price',
                title='株価比較',
                color='change_percent',
                color_continuous_scale='RdYlGn'
            )
            st.plotly_chart(fig_stocks, use_container_width=True)
    
    # 仮想通貨セクション
    if show_crypto:
        st.subheader("₿ 仮想通貨")
        
        crypto_result = api_manager.get_crypto_data()
        
        if crypto_result["success"]:
            crypto_data = crypto_result["data"]
            crypto_df = pd.DataFrame(crypto_data)
            
            # 仮想通貨表示
            st.dataframe(
                crypto_df,
                use_container_width=True,
                hide_index=True,
                column_config={
                    "price": st.column_config.NumberColumn("価格 ($)", format="$%.2f"),
                    "change_24h": st.column_config.NumberColumn("24h変動 (%)", format="%.2f%%"),
                    "volume_24h": st.column_config.NumberColumn("24h取引量", format="$%d"),
                    "market_cap": st.column_config.NumberColumn("時価総額", format="$%.0f")
                }
            )
            
            # 仮想通貨チャート
            fig_crypto = px.scatter(
                crypto_df,
                x='volume_24h',
                y='price',
                size='market_cap',
                color='change_24h',
                hover_name='name',
                title='仮想通貨マップ（価格 vs 取引量）',
                color_continuous_scale='RdYlGn'
            )
            st.plotly_chart(fig_crypto, use_container_width=True)

with col2:
    # ニュースセクション
    if show_news:
        st.subheader("📰 最新ニュース")
        
        news_result = api_manager.get_news_data("technology")
        
        if news_result["success"]:
            news_data = news_result["data"]
            
            for article in news_data:
                with st.container():
                    st.write(f"**{article['title']}**")
                    st.write(f"*{article['source']}*")
                    st.write(article['summary'])
                    
                    published_time = datetime.fromisoformat(article['published_at'].replace('Z', '+00:00'))
                    time_ago = datetime.now() - published_time.replace(tzinfo=None)
                    
                    if time_ago.days > 0:
                        time_str = f"{time_ago.days}日前"
                    elif time_ago.seconds > 3600:
                        time_str = f"{time_ago.seconds // 3600}時間前"
                    else:
                        time_str = f"{time_ago.seconds // 60}分前"
                    
                    st.caption(f"🕒 {time_str}")
                    st.divider()
    
    # システム情報
    st.subheader("ℹ️ システム情報")
    
    # API統計
    with st.container():
        st.write("**API統計**")
        
        api_stats = {
            "天気API": "✅ 正常" if show_weather else "⚪ 無効",
            "株価API": "✅ 正常" if show_stocks else "⚪ 無効",
            "仮想通貨API": "✅ 正常" if show_crypto else "⚪ 無効",
            "ニュースAPI": "✅ 正常" if show_news else "⚪ 無効"
        }
        
        for api_name, status in api_stats.items():
            st.write(f"- {api_name}: {status}")
    
    # パフォーマンス情報
    if st.checkbox("パフォーマンス情報を表示"):
        st.write("**パフォーマンス**")
        
        # キャッシュ情報
        cache_info = st.cache_data.info if hasattr(st.cache_data, 'info') else "情報なし"
        st.write(f"キャッシュ情報: {cache_info}")
        
        # メモリ使用量（概算）
        import sys
        memory_usage = sys.getsizeof(st.session_state) / 1024
        st.write(f"セッションメモリ: {memory_usage:.1f} KB")

# 自動更新機能
if auto_refresh:
    # プレースホルダーでカウントダウン表示
    placeholder = st.empty()
    
    for remaining in range(refresh_interval, 0, -1):
        placeholder.write(f"⏰ 次の更新まで: {remaining}秒")
        time.sleep(1)
    
    placeholder.empty()
    
    # キャッシュクリアして再実行
    st.cache_data.clear()
    st.rerun()

# フッター
st.markdown("---")
st.markdown("""
<div style='text-align: center; color: #666; font-size: 0.8em;'>
    🌐 API統合ダッシュボード | データは学習目的のサンプルです
</div>
""", unsafe_allow_html=True)</code></pre>
                        
                        <h6>実行と確認</h6>
                        <pre class="code-block"><code class="language-bash">streamlit run api_integration_app.py</code></pre>
                        
                        <h6>期待される結果</h6>
                        <p>複数のAPIからリアルタイムでデータを取得し、自動更新機能付きの統合ダッシュボードが表示され、各種データが適切に可視化されることが確認できます。</p>
                    </div>

                    <!-- セクション3: 認証とセキュリティ -->
                    <h3 class="section-title">8.3 認証機能とセキュリティ</h3>
                    <p>Streamlitアプリケーションに基本的な認証機能とセキュリティ対策を実装する方法を学習します。</p>

                    <div class="warning">
                        <h6>セキュリティの重要性</h6>
                        <ul>
                            <li><strong>パスワード管理</strong>: ハッシュ化と適切な保存</li>
                            <li><strong>セッション管理</strong>: セキュアなセッション状態</li>
                            <li><strong>入力検証</strong>: SQLインジェクション対策</li>
                            <li><strong>アクセス制御</strong>: 適切な権限管理</li>
                        </ul>
                    </div>

                    <div class="exercise-container">
                        <h5>実習 8-3: 認証機能付きセキュアアプリ</h5>
                        <p>ユーザー認証、セッション管理、アクセス制御を含むセキュアなアプリケーションを作成します。</p>
                        
                        <h6>auth_app.py を作成</h6>
                        <pre class="code-block"><code class="language-python">import streamlit as st
import hashlib
import sqlite3
import secrets
import time
from datetime import datetime, timedelta
import re
from typing import Optional, Dict, Any

# ページ設定
st.set_page_config(
    page_title="認証機能付きアプリ",
    page_icon="🔐",
    layout="wide"
)

class AuthManager:
    """認証管理クラス"""
    
    def __init__(self, db_path="auth.db"):
        self.db_path = db_path
        self.init_database()
        
        # セッション設定
        self.session_timeout = 3600  # 1時間
        self.max_login_attempts = 5
        self.lockout_duration = 300  # 5分
    
    def init_database(self):
        """データベース初期化"""
        with sqlite3.connect(self.db_path) as conn:
            # ユーザーテーブル
            conn.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT UNIQUE NOT NULL,
                    email TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    salt TEXT NOT NULL,
                    role TEXT DEFAULT 'user',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_login TIMESTAMP,
                    is_active BOOLEAN DEFAULT 1
                )
            """)
            
            # セッションテーブル
            conn.execute("""
                CREATE TABLE IF NOT EXISTS sessions (
                    session_id TEXT PRIMARY KEY,
                    username TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    expires_at TIMESTAMP NOT NULL,
                    ip_address TEXT,
                    user_agent TEXT
                )
            """)
            
            # ログインログテーブル
            conn.execute("""
                CREATE TABLE IF NOT EXISTS login_logs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT,
                    ip_address TEXT,
                    success BOOLEAN,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    error_message TEXT
                )
            """)
            
            conn.commit()
            
            # 管理者アカウントが存在しない場合は作成
            self._create_admin_if_not_exists(conn)
    
    def _create_admin_if_not_exists(self, conn):
        """管理者アカウントが存在しない場合は作成"""
        cursor = conn.execute("SELECT COUNT(*) FROM users WHERE role = 'admin'")
        if cursor.fetchone()[0] == 0:
            # デフォルト管理者アカウントを作成
            self._create_user_internal(conn, "admin", "admin@example.com", "admin123", "admin")
    
    def _hash_password(self, password: str, salt: bytes = None) -> tuple:
        """パスワードをハッシュ化"""
        if salt is None:
            salt = secrets.token_bytes(32)
        
        # PBKDF2を使用してハッシュ化
        password_hash = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)
        
        return password_hash.hex(), salt.hex()
    
    def _create_user_internal(self, conn, username: str, email: str, password: str, role: str = "user"):
        """内部用ユーザー作成"""
        password_hash, salt = self._hash_password(password)
        
        conn.execute("""
            INSERT INTO users (username, email, password_hash, salt, role)
            VALUES (?, ?, ?, ?, ?)
        """, (username, email, password_hash, salt, role))
    
    def validate_password(self, password: str) -> Dict[str, Any]:
        """パスワード強度チェック"""
        errors = []
        
        if len(password) < 8:
            errors.append("パスワードは8文字以上である必要があります")
        
        if not re.search(r'[A-Z]', password):
            errors.append("大文字を含む必要があります")
        
        if not re.search(r'[a-z]', password):
            errors.append("小文字を含む必要があります")
        
        if not re.search(r'\d', password):
            errors.append("数字を含む必要があります")
        
        return {
            "valid": len(errors) == 0,
            "errors": errors
        }
    
    def validate_email(self, email: str) -> bool:
        """メールアドレス形式チェック"""
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None
    
    def create_user(self, username: str, email: str, password: str, role: str = "user") -> Dict[str, Any]:
        """新しいユーザーを作成"""
        # 入力検証
        if not username or not email or not password:
            return {"success": False, "error": "全ての項目を入力してください"}
        
        if not self.validate_email(email):
            return {"success": False, "error": "有効なメールアドレスを入力してください"}
        
        password_check = self.validate_password(password)
        if not password_check["valid"]:
            return {"success": False, "error": "\\n".join(password_check["errors"])}
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                # 重複チェック
                cursor = conn.execute("SELECT COUNT(*) FROM users WHERE username = ? OR email = ?", (username, email))
                if cursor.fetchone()[0] > 0:
                    return {"success": False, "error": "ユーザー名またはメールアドレスが既に使用されています"}
                
                self._create_user_internal(conn, username, email, password, role)
                conn.commit()
                
                return {"success": True, "message": "ユーザーが正常に作成されました"}
        
        except Exception as e:
            return {"success": False, "error": f"ユーザー作成エラー: {str(e)}"}
    
    def authenticate(self, username: str, password: str) -> Dict[str, Any]:
        """ユーザー認証"""
        # ログイン試行回数チェック
        if self._is_locked_out(username):
            return {"success": False, "error": "アカウントがロックされています。しばらく待ってから再試行してください"}
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute("""
                    SELECT username, password_hash, salt, role, is_active 
                    FROM users WHERE username = ?
                """, (username,))
                
                user = cursor.fetchone()
                
                if user is None:
                    self._log_login_attempt(username, False, "ユーザーが存在しません")
                    return {"success": False, "error": "認証に失敗しました"}
                
                username_db, password_hash_db, salt_db, role, is_active = user
                
                if not is_active:
                    self._log_login_attempt(username, False, "アカウントが無効です")
                    return {"success": False, "error": "アカウントが無効です"}
                
                # パスワード検証
                password_hash, _ = self._hash_password(password, bytes.fromhex(salt_db))
                
                if password_hash == password_hash_db:
                    # 認証成功
                    self._log_login_attempt(username, True)
                    self._update_last_login(username)
                    
                    return {
                        "success": True,
                        "user": {
                            "username": username_db,
                            "role": role
                        }
                    }
                else:
                    # 認証失敗
                    self._log_login_attempt(username, False, "パスワードが無効です")
                    return {"success": False, "error": "認証に失敗しました"}
        
        except Exception as e:
            self._log_login_attempt(username, False, f"システムエラー: {str(e)}")
            return {"success": False, "error": "システムエラーが発生しました"}
    
    def _is_locked_out(self, username: str) -> bool:
        """アカウントロックアウト状態をチェック"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute("""
                SELECT COUNT(*) FROM login_logs 
                WHERE username = ? AND success = 0 
                AND timestamp > datetime('now', '-5 minutes')
            """, (username,))
            
            failed_attempts = cursor.fetchone()[0]
            return failed_attempts >= self.max_login_attempts
    
    def _log_login_attempt(self, username: str, success: bool, error_message: str = None):
        """ログイン試行をログに記録"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT INTO login_logs (username, success, error_message)
                VALUES (?, ?, ?)
            """, (username, success, error_message))
            conn.commit()
    
    def _update_last_login(self, username: str):
        """最終ログイン時刻を更新"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                UPDATE users SET last_login = CURRENT_TIMESTAMP 
                WHERE username = ?
            """, (username,))
            conn.commit()
    
    def create_session(self, username: str) -> str:
        """セッションを作成"""
        session_id = secrets.token_urlsafe(32)
        expires_at = datetime.now() + timedelta(seconds=self.session_timeout)
        
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT INTO sessions (session_id, username, expires_at)
                VALUES (?, ?, ?)
            """, (session_id, username, expires_at))
            conn.commit()
        
        return session_id
    
    def validate_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """セッションを検証"""
        if not session_id:
            return None
        
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute("""
                SELECT username, expires_at FROM sessions 
                WHERE session_id = ? AND expires_at > datetime('now')
            """, (session_id,))
            
            session = cursor.fetchone()
            
            if session:
                username, expires_at = session
                return {"username": username, "expires_at": expires_at}
        
        return None
    
    def logout(self, session_id: str):
        """ログアウト"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("DELETE FROM sessions WHERE session_id = ?", (session_id,))
            conn.commit()
    
    def get_user_info(self, username: str) -> Optional[Dict[str, Any]]:
        """ユーザー情報を取得"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute("""
                SELECT username, email, role, created_at, last_login, is_active
                FROM users WHERE username = ?
            """, (username,))
            
            user = cursor.fetchone()
            
            if user:
                return {
                    "username": user[0],
                    "email": user[1],
                    "role": user[2],
                    "created_at": user[3],
                    "last_login": user[4],
                    "is_active": user[5]
                }
        
        return None

# 認証マネージャーの初期化
@st.cache_resource
def get_auth_manager():
    return AuthManager()

auth_manager = get_auth_manager()

# セッション状態の初期化
if 'authenticated' not in st.session_state:
    st.session_state.authenticated = False

if 'session_id' not in st.session_state:
    st.session_state.session_id = None

if 'user_info' not in st.session_state:
    st.session_state.user_info = None

# セッション検証
if st.session_state.session_id:
    session_info = auth_manager.validate_session(st.session_state.session_id)
    
    if session_info:
        st.session_state.authenticated = True
        st.session_state.user_info = auth_manager.get_user_info(session_info['username'])
    else:
        # セッション無効
        st.session_state.authenticated = False
        st.session_state.session_id = None
        st.session_state.user_info = None

def show_login_page():
    """ログインページを表示"""
    st.title("🔐 ログイン")
    
    tab1, tab2 = st.tabs(["ログイン", "新規登録"])
    
    with tab1:
        st.subheader("ログイン")
        
        with st.form("login_form"):
            username = st.text_input("ユーザー名")
            password = st.text_input("パスワード", type="password")
            
            submitted = st.form_submit_button("ログイン", type="primary")
            
            if submitted:
                if username and password:
                    result = auth_manager.authenticate(username, password)
                    
                    if result["success"]:
                        # ログイン成功
                        session_id = auth_manager.create_session(username)
                        
                        st.session_state.authenticated = True
                        st.session_state.session_id = session_id
                        st.session_state.user_info = auth_manager.get_user_info(username)
                        
                        st.success("ログインに成功しました！")
                        st.rerun()
                    else:
                        st.error(result["error"])
                else:
                    st.error("ユーザー名とパスワードを入力してください")
    
    with tab2:
        st.subheader("新規登録")
        
        with st.form("register_form"):
            new_username = st.text_input("ユーザー名（新規）")
            new_email = st.text_input("メールアドレス")
            new_password = st.text_input("パスワード（新規）", type="password")
            confirm_password = st.text_input("パスワード確認", type="password")
            
            submitted = st.form_submit_button("アカウント作成", type="secondary")
            
            if submitted:
                if new_username and new_email and new_password and confirm_password:
                    if new_password != confirm_password:
                        st.error("パスワードが一致しません")
                    else:
                        result = auth_manager.create_user(new_username, new_email, new_password)
                        
                        if result["success"]:
                            st.success("アカウントが作成されました！ログインしてください。")
                        else:
                            st.error(result["error"])
                else:
                    st.error("全ての項目を入力してください")
    
    # デモ用情報
    st.markdown("---")
    with st.expander("🔍 デモ用ログイン情報"):
        st.info("""
        **管理者アカウント**
        - ユーザー名: admin
        - パスワード: admin123
        
        **注意**: これは学習用のデモアプリです。実際の運用では強力なパスワードを使用してください。
        """)

def show_dashboard():
    """ダッシュボードを表示"""
    user_info = st.session_state.user_info
    
    st.title(f"📊 ダッシュボード - {user_info['username']}さん")
    
    # ヘッダー情報
    col1, col2, col3 = st.columns([2, 1, 1])
    
    with col1:
        st.write(f"**ログインユーザー**: {user_info['username']}")
        st.write(f"**権限**: {user_info['role']}")
        st.write(f"**メール**: {user_info['email']}")
    
    with col2:
        if user_info['last_login']:
            last_login = datetime.fromisoformat(user_info['last_login'].replace('Z', '+00:00'))
            st.metric("最終ログイン", last_login.strftime("%m/%d %H:%M"))
    
    with col3:
        if st.button("🚪 ログアウト", type="secondary"):
            auth_manager.logout(st.session_state.session_id)
            
            st.session_state.authenticated = False
            st.session_state.session_id = None
            st.session_state.user_info = None
            
            st.success("ログアウトしました")
            st.rerun()
    
    st.markdown("---")
    
    # 権限別コンテンツ
    if user_info['role'] == 'admin':
        show_admin_content()
    else:
        show_user_content()

def show_admin_content():
    """管理者向けコンテンツ"""
    st.subheader("🛠️ 管理者機能")
    
    tab1, tab2, tab3 = st.tabs(["ユーザー管理", "ログ分析", "システム設定"])
    
    with tab1:
        st.write("**登録ユーザー一覧**")
        
        with sqlite3.connect(auth_manager.db_path) as conn:
            users_df = pd.read_sql_query("""
                SELECT username, email, role, created_at, last_login, is_active
                FROM users ORDER BY created_at DESC
            """, conn)
        
        st.dataframe(users_df, use_container_width=True)
    
    with tab2:
        st.write("**ログイン履歴**")
        
        with sqlite3.connect(auth_manager.db_path) as conn:
            logs_df = pd.read_sql_query("""
                SELECT username, success, timestamp, error_message
                FROM login_logs ORDER BY timestamp DESC LIMIT 50
            """, conn)
        
        if not logs_df.empty:
            st.dataframe(logs_df, use_container_width=True)
            
            # ログイン成功率
            success_rate = logs_df['success'].mean() * 100
            st.metric("ログイン成功率", f"{success_rate:.1f}%")
    
    with tab3:
        st.write("**システム設定**")
        
        st.info("管理者向けシステム設定機能（実装例）")
        
        if st.button("🔄 セッションクリーンアップ"):
            with sqlite3.connect(auth_manager.db_path) as conn:
                conn.execute("DELETE FROM sessions WHERE expires_at < datetime('now')")
                conn.commit()
            st.success("期限切れセッションを削除しました")

def show_user_content():
    """一般ユーザー向けコンテンツ"""
    st.subheader("👤 ユーザー機能")
    
    st.info("認証が必要なコンテンツの例")
    
    # サンプルコンテンツ
    tab1, tab2 = st.tabs(["データ表示", "設定"])
    
    with tab1:
        st.write("**保護されたデータ**")
        
        # サンプルデータ
        sample_data = pd.DataFrame({
            'Date': pd.date_range('2024-01-01', periods=10),
            'Value': range(10, 20),
            'Category': ['A', 'B'] * 5
        })
        
        st.dataframe(sample_data)
    
    with tab2:
        st.write("**ユーザー設定**")
        
        user_info = st.session_state.user_info
        
        st.write(f"ユーザー名: {user_info['username']}")
        st.write(f"メールアドレス: {user_info['email']}")
        st.write(f"アカウント作成日: {user_info['created_at']}")

# メインアプリケーション
def main():
    if not st.session_state.authenticated:
        show_login_page()
    else:
        show_dashboard()

if __name__ == "__main__":
    main()</code></pre>
                        
                        <h6>実行と確認</h6>
                        <pre class="code-block"><code class="language-bash">streamlit run auth_app.py</code></pre>
                        
                        <h6>期待される結果</h6>
                        <p>完全な認証システム（ユーザー登録、ログイン、セッション管理、権限管理）を持つセキュアなアプリケーションが表示され、管理者と一般ユーザーで異なるコンテンツが確認できます。</p>
                    </div>

                    <!-- 理解度確認 -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <strong>Streamlitでデータベース接続をキャッシュするために使用するデコレータは何ですか？</strong>
                                <ul style="list-style-type: none;">
                                    <li>a) @st.cache</li>
                                    <li>b) @st.cache_data</li>
                                    <li>c) @st.cache_resource</li>
                                    <li>d) @st.memo</li>
                                </ul>
                                <details style="margin-top: 0.5rem;">
                                    <summary>解答を見る</summary>
                                    <p><strong>答え: c)</strong> @st.cache_resourceはデータベース接続オブジェクトなどのリソースをキャッシュする際に使用します。@st.cache_dataはデータをキャッシュする場合に使用します。</p>
                                </details>
                            </li>
                            
                            <li>
                                <strong>SQLインジェクション攻撃を防ぐための基本的な対策を2つ挙げてください</strong>
                                <details style="margin-top: 0.5rem;">
                                    <summary>解答を見る</summary>
                                    <p><strong>答え例:</strong><br>
                                    1. <strong>パラメータ化クエリ</strong>: プリペアドステートメントを使用<br>
                                    2. <strong>入力検証</strong>: ユーザー入力の厳格なバリデーション<br>
                                    3. <strong>エスケープ処理</strong>: 特殊文字の適切なエスケープ<br>
                                    4. <strong>最小権限の原則</strong>: データベースユーザーの権限制限</p>
                                </details>
                            </li>
                            
                            <li>
                                <strong>セキュアなパスワード管理で重要な要素を3つ答えてください</strong>
                                <details style="margin-top: 0.5rem;">
                                    <summary>解答を見る</summary>
                                    <p><strong>答え:</strong><br>
                                    1. <strong>ハッシュ化</strong>: PBKDF2、bcrypt、scryptなどの強力なハッシュ関数<br>
                                    2. <strong>ソルト</strong>: レインボーテーブル攻撃対策<br>
                                    3. <strong>強度チェック</strong>: 長さ、複雑さの要件<br>
                                    4. <strong>セキュアな保存</strong>: 平文でのパスワード保存禁止</p>
                                </details>
                            </li>
                        </ol>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="streamlit-learning-material-07.html" class="btn btn-secondary">← 前の章: マルチページアプリケーション</a>
                        <a href="streamlit-learning-material-09.html" class="btn btn-primary">次の章: デプロイメントと本番環境 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JavaScript -->

    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>