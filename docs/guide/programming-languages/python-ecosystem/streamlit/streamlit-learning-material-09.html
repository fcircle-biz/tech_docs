<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamlit学習教材 第9章 - デプロイメントと本番環境</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->

    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #4caf50;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
            background-color: #f8f9fa;
        }

        /* タイトル */
        .chapter-title {
            color: #4caf50;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #4caf50;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #66bb6a;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e8f5e8;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #4caf50;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .info-box {
            background-color: #e1f5fe;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #2196F3;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #4caf50 !important;
            color: white !important;
        }

        .nav-link {
            color: #666;
        }

        .nav-link:hover {
            background-color: #e8f5e8;
            color: #4caf50;
        }

        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        pre {
            background-color: #f5f5f5;
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
        }

        code {
            background-color: #f5f5f5;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Streamlit学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="../README.md">学習ガイドに戻る</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        章の一覧
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-01.html">第1章: 入門と環境構築</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-02.html">第2章: 基本的なUIコンポーネント</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-03.html">第3章: データ表示と可視化</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-04.html">第4章: ユーザー入力とインタラクション</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-05.html">第5章: セッション状態管理</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-06.html">第6章: ファイル操作とデータ処理</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-07.html">第7章: マルチページアプリケーション</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-08.html">第8章: データベース連携とAPI統合</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="#chapter9">第9章: デプロイメントと本番環境</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-10.html">第10章: 実践的なデータ分析アプリ開発</a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <!-- 章ヘッダー -->
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第9章: デプロイメントと本番環境</h1>
                </div>

                <div id="chapter9">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">Streamlit Cloud、Docker、本番環境への展開</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>Streamlit Cloudへのデプロイメント手順</li>
                            <li>環境変数とシークレット管理</li>
                            <li>Dockerによるコンテナ化とデプロイ</li>
                            <li>パフォーマンス最適化の技法</li>
                            <li>エラーハンドリングとロギング実装</li>
                        </ul>
                    </div>

                    <!-- セクション1: Streamlit Cloud デプロイ -->
                    <h3 class="section-title">9.1 Streamlit Cloud デプロイメント</h3>
                    <p>Streamlit Cloudは、Streamlitアプリケーションを無料で簡単にデプロイできる公式のホスティングサービスです。</p>
                    
                    <h4>デプロイメント方法の比較</h4>
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>方法</th>
                                <th>難易度</th>
                                <th>費用</th>
                                <th>適用場面</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Streamlit Cloud</td>
                                <td>⭐</td>
                                <td>無料</td>
                                <td>プロトタイプ、個人プロジェクト</td>
                            </tr>
                            <tr>
                                <td>Heroku</td>
                                <td>⭐⭐</td>
                                <td>低～中</td>
                                <td>小規模商用アプリ</td>
                            </tr>
                            <tr>
                                <td>AWS/GCP/Azure</td>
                                <td>⭐⭐⭐</td>
                                <td>中～高</td>
                                <td>企業レベル、スケーラブル</td>
                            </tr>
                            <tr>
                                <td>Docker + VPS</td>
                                <td>⭐⭐⭐⭐</td>
                                <td>低～中</td>
                                <td>カスタム環境、自己管理</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="exercise-container">
                        <h5>実習 9-1: Streamlit Cloud デプロイ準備</h5>
                        <p>本番環境を想定したアプリケーションを作成し、Streamlit Cloudにデプロイする準備を行います。</p>
                        
                        <h6>プロジェクト構造の準備</h6>
                        <pre class="code-block"><code class="language-text">production_app/
├── app.py                    # メインアプリケーション
├── requirements.txt          # 依存関係
├── .streamlit/
│   └── config.toml          # Streamlit設定
├── pages/
│   ├── dashboard.py         # ダッシュボードページ
│   └── analytics.py         # 分析ページ
├── utils/
│   ├── data_loader.py       # データ読み込み
│   └── logger.py            # ログ管理
├── data/
│   └── sample_data.csv      # サンプルデータ
└── README.md                # プロジェクト説明</code></pre>
                        
                        <h6>requirements.txt を作成</h6>
                        <pre class="code-block"><code class="language-python"># Streamlit requirements.txt
streamlit>=1.28.0
pandas>=2.0.0
numpy>=1.24.0
plotly>=5.15.0
requests>=2.31.0
python-dotenv>=1.0.0

# オプション（必要に応じて）
scikit-learn>=1.3.0
seaborn>=0.12.0
openpyxl>=3.1.0</code></pre>
                        
                        <h6>.streamlit/config.toml を作成</h6>
                        <pre class="code-block"><code class="language-ini">[global]
developmentMode = false

[server]
runOnSave = true
port = 8501

[browser]
gatherUsageStats = false
serverAddress = "0.0.0.0"

[theme]
primaryColor = "#4CAF50"
backgroundColor = "#FFFFFF"
secondaryBackgroundColor = "#F0F2F6"
textColor = "#262730"
font = "sans serif"

[client]
caching = true
showErrorDetails = false

[logger]
level = "info"</code></pre>
                        
                        <h6>utils/logger.py を作成</h6>
                        <pre class="code-block"><code class="language-python">import logging
import sys
from datetime import datetime
import streamlit as st
from typing import Optional

class StreamlitLogger:
    """Streamlit用ログ管理クラス"""
    
    def __init__(self, name: str = "streamlit_app", level: str = "INFO"):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(getattr(logging, level.upper()))
        
        # ハンドラーが既に存在する場合は追加しない
        if not self.logger.handlers:
            self._setup_handlers()
    
    def _setup_handlers(self):
        """ログハンドラーを設定"""
        # コンソールハンドラー
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(logging.INFO)
        
        # フォーマッター
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        console_handler.setFormatter(formatter)
        
        self.logger.addHandler(console_handler)
    
    def info(self, message: str, show_in_app: bool = False):
        """情報ログ"""
        self.logger.info(message)
        if show_in_app:
            st.info(f"ℹ️ {message}")
    
    def warning(self, message: str, show_in_app: bool = False):
        """警告ログ"""
        self.logger.warning(message)
        if show_in_app:
            st.warning(f"⚠️ {message}")
    
    def error(self, message: str, exception: Optional[Exception] = None, show_in_app: bool = True):
        """エラーログ"""
        if exception:
            self.logger.error(f"{message}: {str(exception)}", exc_info=True)
        else:
            self.logger.error(message)
        
        if show_in_app:
            st.error(f"❌ {message}")
    
    def success(self, message: str, show_in_app: bool = True):
        """成功ログ"""
        self.logger.info(f"SUCCESS: {message}")
        if show_in_app:
            st.success(f"✅ {message}")
    
    def debug(self, message: str):
        """デバッグログ"""
        self.logger.debug(message)

# グローバルロガーインスタンス
@st.cache_resource
def get_logger():
    return StreamlitLogger()

# 使用例
# logger = get_logger()
# logger.info("アプリケーションが開始されました", show_in_app=True)</code></pre>
                        
                        <h6>utils/data_loader.py を作成</h6>
                        <pre class="code-block"><code class="language-python">import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import requests
from typing import Optional, Dict, Any
import os
from utils.logger import get_logger

logger = get_logger()

class DataLoader:
    """データ読み込み管理クラス"""
    
    @staticmethod
    @st.cache_data(ttl=3600, show_spinner="データを読み込み中...")
    def load_csv_data(file_path: str) -> Optional[pd.DataFrame]:
        """CSVファイルを読み込み"""
        try:
            if os.path.exists(file_path):
                df = pd.read_csv(file_path)
                logger.info(f"CSVファイルを読み込みました: {file_path}")
                return df
            else:
                logger.warning(f"ファイルが見つかりません: {file_path}")
                return None
        
        except Exception as e:
            logger.error(f"CSVファイルの読み込みに失敗", exception=e)
            return None
    
    @staticmethod
    @st.cache_data(ttl=1800, show_spinner="APIからデータを取得中...")
    def fetch_api_data(url: str, headers: Optional[Dict] = None) -> Optional[Dict[str, Any]]:
        """API からデータを取得"""
        try:
            response = requests.get(url, headers=headers or {}, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            logger.info(f"APIデータを取得しました: {url}")
            return data
        
        except requests.exceptions.Timeout:
            logger.error("API リクエストがタイムアウトしました")
            return None
        
        except requests.exceptions.RequestException as e:
            logger.error(f"API リクエストに失敗", exception=e)
            return None
        
        except Exception as e:
            logger.error(f"データ取得中にエラーが発生", exception=e)
            return None
    
    @staticmethod
    @st.cache_data(ttl=600)
    def generate_sample_data(rows: int = 1000) -> pd.DataFrame:
        """サンプルデータを生成"""
        try:
            logger.info(f"サンプルデータを生成中: {rows}行")
            
            np.random.seed(42)
            
            # 日付範囲
            start_date = datetime.now() - timedelta(days=365)
            dates = pd.date_range(start_date, periods=rows, freq='D')
            
            # サンプルデータ生成
            data = {
                'date': dates[:rows],
                'sales': np.random.normal(50000, 15000, rows).astype(int),
                'visitors': np.random.normal(1000, 200, rows).astype(int),
                'conversion_rate': np.random.normal(0.05, 0.02, rows).clip(0, 1),
                'region': np.random.choice(['Tokyo', 'Osaka', 'Nagoya', 'Fukuoka'], rows),
                'category': np.random.choice(['Electronics', 'Clothing', 'Food', 'Books'], rows),
                'customer_satisfaction': np.random.normal(4.0, 0.8, rows).clip(1, 5)
            }
            
            df = pd.DataFrame(data)
            
            # 売上に季節性を追加
            df['month'] = df['date'].dt.month
            seasonal_factor = 1 + 0.3 * np.sin(2 * np.pi * (df['month'] - 1) / 12)
            df['sales'] = (df['sales'] * seasonal_factor).astype(int)
            
            # 曜日効果を追加
            df['weekday'] = df['date'].dt.weekday
            weekend_factor = np.where(df['weekday'] >= 5, 1.2, 1.0)
            df['visitors'] = (df['visitors'] * weekend_factor).astype(int)
            
            logger.success(f"サンプルデータを生成完了: {len(df)}行", show_in_app=False)
            return df
        
        except Exception as e:
            logger.error(f"サンプルデータ生成に失敗", exception=e)
            return pd.DataFrame()
    
    @staticmethod
    def validate_data(df: pd.DataFrame) -> Dict[str, Any]:
        """データ品質チェック"""
        if df.empty:
            return {"valid": False, "issues": ["データが空です"]}
        
        issues = []
        
        # 欠損値チェック
        missing_data = df.isnull().sum()
        if missing_data.any():
            issues.append(f"欠損値が存在します: {missing_data[missing_data > 0].to_dict()}")
        
        # 重複チェック
        duplicate_count = df.duplicated().sum()
        if duplicate_count > 0:
            issues.append(f"重複行が{duplicate_count}件存在します")
        
        # データ型チェック
        numeric_columns = df.select_dtypes(include=[np.number]).columns
        for col in numeric_columns:
            if df[col].isna().sum() > len(df) * 0.5:
                issues.append(f"数値列'{col}'の欠損率が50%を超えています")
        
        return {
            "valid": len(issues) == 0,
            "issues": issues,
            "summary": {
                "rows": len(df),
                "columns": len(df.columns),
                "missing_values": missing_data.sum(),
                "duplicate_rows": duplicate_count
            }
        }

# 使用例のためのヘルパー関数
def load_and_validate_data():
    """データ読み込みと検証のワークフロー"""
    loader = DataLoader()
    
    # サンプルデータを生成
    df = loader.generate_sample_data(500)
    
    if not df.empty:
        # データ品質チェック
        validation_result = loader.validate_data(df)
        
        if validation_result["valid"]:
            logger.success("データ品質チェックに合格しました")
        else:
            logger.warning(f"データ品質に問題があります: {validation_result['issues']}")
        
        return df, validation_result
    
    return None, None</code></pre>
                        
                        <h6>app.py を作成</h6>
                        <pre class="code-block"><code class="language-python">import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime
import os
from utils.data_loader import DataLoader, load_and_validate_data
from utils.logger import get_logger

# ページ設定
st.set_page_config(
    page_title="Production Ready Streamlit App",
    page_icon="🚀",
    layout="wide",
    initial_sidebar_state="expanded"
)

# ロガー初期化
logger = get_logger()

# カスタムCSS
st.markdown("""
<style>
    .main-header {
        background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
        padding: 1rem;
        border-radius: 10px;
        color: white;
        text-align: center;
        margin-bottom: 2rem;
    }
    
    .metric-card {
        background: white;
        padding: 1rem;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin: 0.5rem 0;
    }
    
    .status-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
    }
    
    .status-healthy { background-color: #4CAF50; }
    .status-warning { background-color: #FF9800; }
    .status-error { background-color: #F44336; }
</style>
""", unsafe_allow_html=True)

# メイン関数
def main():
    """メインアプリケーション"""
    
    # ヘッダー
    st.markdown("""
    <div class="main-header">
        <h1>🚀 Production Ready Dashboard</h1>
        <p>高品質なStreamlitアプリケーションのデモ</p>
    </div>
    """, unsafe_allow_html=True)
    
    # サイドバー設定
    with st.sidebar:
        st.header("⚙️ 設定")
        
        # 環境情報
        st.subheader("🌍 環境情報")
        env_status = get_environment_status()
        display_environment_status(env_status)
        
        # データ設定
        st.subheader("📊 データ設定")
        
        data_source = st.selectbox(
            "データソース",
            ["サンプルデータ", "ローカルファイル", "外部API"]
        )
        
        if data_source == "サンプルデータ":
            data_size = st.slider("データサイズ", 100, 2000, 500)
        
        # 表示設定
        st.subheader("📈 表示設定")
        
        chart_theme = st.selectbox(
            "チャートテーマ",
            ["plotly", "plotly_white", "plotly_dark", "ggplot2"]
        )
        
        show_raw_data = st.checkbox("生データを表示", value=False)
        auto_refresh = st.checkbox("自動更新", value=False)
        
        if auto_refresh:
            refresh_interval = st.slider("更新間隔（秒）", 30, 300, 60)
    
    try:
        # データ読み込み
        with st.spinner("データを準備中..."):
            if data_source == "サンプルデータ":
                df, validation_result = load_and_validate_data()
                
                if df is not None:
                    # データサイズ調整
                    if len(df) > data_size:
                        df = df.sample(n=data_size).sort_values('date').reset_index(drop=True)
                    
                    logger.info(f"データを読み込みました: {len(df)}行", show_in_app=False)
                else:
                    st.error("データの読み込みに失敗しました")
                    return
            
            else:
                st.info(f"{data_source}は実装準備中です")
                return
        
        # データ概要表示
        display_data_overview(df, validation_result)
        
        # メインダッシュボード
        display_main_dashboard(df, chart_theme)
        
        # 詳細分析（タブ形式）
        display_detailed_analysis(df, chart_theme)
        
        # 生データ表示（オプション）
        if show_raw_data:
            display_raw_data(df)
        
        # フッター
        display_footer()
        
        # 自動更新
        if auto_refresh:
            time.sleep(refresh_interval)
            st.rerun()
    
    except Exception as e:
        logger.error("アプリケーション実行中にエラーが発生", exception=e)
        st.error("予期しないエラーが発生しました。管理者にお問い合わせください。")

def get_environment_status():
    """環境状態を取得"""
    status = {
        "streamlit_version": st.__version__,
        "python_version": f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}",
        "environment": os.getenv("ENVIRONMENT", "development"),
        "debug_mode": os.getenv("DEBUG", "false").lower() == "true",
        "cache_enabled": True,
        "last_updated": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    
    return status

def display_environment_status(status):
    """環境状態を表示"""
    # 環境タイプに基づく色分け
    env_colors = {
        "production": "status-healthy",
        "staging": "status-warning", 
        "development": "status-error"
    }
    
    env_color = env_colors.get(status["environment"], "status-error")
    
    st.markdown(f"""
    <div style="font-size: 0.9em;">
        <div><span class="status-indicator {env_color}"></span>環境: {status["environment"]}</div>
        <div>Streamlit: {status["streamlit_version"]}</div>
        <div>Python: {status["python_version"]}</div>
        <div>更新: {status["last_updated"]}</div>
    </div>
    """, unsafe_allow_html=True)

def display_data_overview(df, validation_result):
    """データ概要を表示"""
    st.subheader("📋 データ概要")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("総データ数", f"{len(df):,}")
    
    with col2:
        st.metric("列数", len(df.columns))
    
    with col3:
        date_range = (df['date'].max() - df['date'].min()).days
        st.metric("期間", f"{date_range}日")
    
    with col4:
        avg_sales = df['sales'].mean()
        st.metric("平均売上", f"¥{avg_sales:,.0f}")
    
    # データ品質インジケーター
    if validation_result:
        quality_color = "🟢" if validation_result["valid"] else "🟡"
        st.write(f"{quality_color} **データ品質**: {'良好' if validation_result['valid'] else '要注意'}")
        
        if not validation_result["valid"]:
            with st.expander("データ品質の詳細"):
                for issue in validation_result["issues"]:
                    st.warning(issue)

def display_main_dashboard(df, theme):
    """メインダッシュボードを表示"""
    st.subheader("📊 メインダッシュボード")
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        # 売上推移グラフ
        fig_sales = px.line(
            df, 
            x='date', 
            y='sales',
            title='売上推移',
            template=theme
        )
        fig_sales.update_traces(line_color='#4CAF50')
        fig_sales.update_layout(height=400)
        st.plotly_chart(fig_sales, use_container_width=True)
    
    with col2:
        # 地域別売上円グラフ
        region_sales = df.groupby('region')['sales'].sum().reset_index()
        
        fig_region = px.pie(
            region_sales,
            values='sales',
            names='region',
            title='地域別売上構成',
            template=theme
        )
        fig_region.update_layout(height=400)
        st.plotly_chart(fig_region, use_container_width=True)

def display_detailed_analysis(df, theme):
    """詳細分析を表示"""
    st.subheader("🔍 詳細分析")
    
    tab1, tab2, tab3 = st.tabs(["📈 トレンド分析", "🏷️ カテゴリ分析", "😊 顧客満足度"])
    
    with tab1:
        # 移動平均
        window = st.slider("移動平均期間", 7, 60, 30)
        df_ma = df.copy()
        df_ma['sales_ma'] = df_ma['sales'].rolling(window=window).mean()
        
        fig_trend = go.Figure()
        
        fig_trend.add_trace(go.Scatter(
            x=df_ma['date'],
            y=df_ma['sales'],
            mode='lines',
            name='日次売上',
            line=dict(color='lightblue', width=1),
            opacity=0.6
        ))
        
        fig_trend.add_trace(go.Scatter(
            x=df_ma['date'],
            y=df_ma['sales_ma'],
            mode='lines',
            name=f'{window}日移動平均',
            line=dict(color='#4CAF50', width=3)
        ))
        
        fig_trend.update_layout(
            title='売上トレンド分析',
            template=theme,
            height=500
        )
        
        st.plotly_chart(fig_trend, use_container_width=True)
    
    with tab2:
        # カテゴリ別分析
        category_stats = df.groupby('category').agg({
            'sales': ['sum', 'mean', 'count'],
            'visitors': 'sum'
        }).round(0)
        
        category_stats.columns = ['総売上', '平均売上', '取引数', '総訪問者数']
        
        st.dataframe(category_stats, use_container_width=True)
        
        # カテゴリ別パフォーマンス
        fig_category = px.scatter(
            df,
            x='visitors',
            y='sales',
            color='category',
            size='sales',
            title='カテゴリ別パフォーマンス（売上 vs 訪問者数）',
            template=theme
        )
        
        st.plotly_chart(fig_category, use_container_width=True)
    
    with tab3:
        # 顧客満足度分析
        satisfaction_stats = df.groupby('region')['customer_satisfaction'].agg(['mean', 'std']).round(2)
        satisfaction_stats.columns = ['平均満足度', '標準偏差']
        
        st.dataframe(satisfaction_stats, use_container_width=True)
        
        # 満足度分布
        fig_satisfaction = px.histogram(
            df,
            x='customer_satisfaction',
            color='region',
            title='地域別顧客満足度分布',
            template=theme,
            nbins=20
        )
        
        st.plotly_chart(fig_satisfaction, use_container_width=True)

def display_raw_data(df):
    """生データを表示"""
    st.subheader("🗃️ 生データ")
    
    # フィルタリングオプション
    col1, col2 = st.columns(2)
    
    with col1:
        regions = st.multiselect("地域フィルタ", df['region'].unique(), default=df['region'].unique())
    
    with col2:
        categories = st.multiselect("カテゴリフィルタ", df['category'].unique(), default=df['category'].unique())
    
    # フィルタ適用
    filtered_df = df[
        (df['region'].isin(regions)) & 
        (df['category'].isin(categories))
    ]
    
    st.dataframe(filtered_df, use_container_width=True, height=400)
    
    # ダウンロードボタン
    csv = filtered_df.to_csv(index=False, encoding='utf-8-sig')
    st.download_button(
        label="📄 CSVダウンロード",
        data=csv,
        file_name=f"data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
        mime="text/csv"
    )

def display_footer():
    """フッターを表示"""
    st.markdown("---")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("**アプリケーション情報**")
        st.write("- バージョン: 1.0.0")
        st.write("- 最終更新: 2024年")
    
    with col2:
        st.markdown("**技術スタック**")
        st.write("- Streamlit")
        st.write("- Plotly")
        st.write("- Pandas")
    
    with col3:
        st.markdown("**サポート**")
        st.write("- [ドキュメント](https://docs.streamlit.io/)")
        st.write("- [GitHub](https://github.com/streamlit/streamlit)")

if __name__ == "__main__":
    import sys
    main()</code></pre>
                        
                        <h6>README.md を作成</h6>
                        <pre class="code-block"><code class="language-python"># Production Ready Streamlit App

## 概要
本番環境対応のStreamlitアプリケーションのサンプルです。

## 機能
- 📊 リアルタイムダッシュボード
- 📈 データ可視化
- 🔍 詳細分析機能
- ⚙️ 設定管理
- 📝 ログ管理
- 🚀 本番環境対応

## セットアップ

### ローカル環境
```bash
pip install -r requirements.txt
streamlit run app.py
```

### Streamlit Cloud デプロイ
1. GitHubリポジトリにプッシュ
2. Streamlit Cloudでリポジトリを選択
3. デプロイ実行

## 環境変数
```
ENVIRONMENT=production
DEBUG=false
DATABASE_URL=your_database_url
API_KEY=your_api_key
```

## ディレクトリ構造
```
production_app/
├── app.py                    # メインアプリ
├── requirements.txt          # 依存関係
├── .streamlit/config.toml   # 設定
├── utils/                   # ユーティリティ
└── data/                    # データファイル
```

## ライセンス
MIT License</code></pre>
                        
                        <h6>実行と確認</h6>
                        <pre class="code-block"><code class="language-bash">cd production_app
streamlit run app.py</code></pre>
                        
                        <h6>期待される結果</h6>
                        <p>本番環境対応の高品質なStreamlitアプリケーションが表示され、ログ管理、エラーハンドリング、設定管理が適切に実装されていることが確認できます。</p>
                    </div>

                    <!-- セクション2: Dockerコンテナ化 -->
                    <h3 class="section-title">9.2 Dockerによるコンテナ化</h3>
                    <p>Dockerを使用してStreamlitアプリケーションをコンテナ化し、環境に依存しない展開を実現します。</p>

                    <div class="exercise-container">
                        <h5>実習 9-2: Docker コンテナ化</h5>
                        <p>StreamlitアプリケーションをDockerコンテナとして構築し、本番環境に適した設定を行います。</p>
                        
                        <h6>Dockerfile を作成</h6>
                        <pre class="code-block"><code class="language-python"># マルチステージビルドによる軽量化
FROM python:3.11-slim as builder

# システムの更新と必要なパッケージのインストール
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    software-properties-common \
    git \
    && rm -rf /var/lib/apt/lists/*

# 作業ディレクトリの設定
WORKDIR /app

# 依存関係ファイルをコピー
COPY requirements.txt .

# Pythonの依存関係をインストール
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# 本番用ステージ
FROM python:3.11-slim

# システムユーザーの作成（セキュリティ向上）
RUN groupadd -r streamlit && useradd -r -g streamlit streamlit

# 必要なシステムパッケージのインストール
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# 作業ディレクトリの設定
WORKDIR /app

# Pythonライブラリをbuilderステージからコピー
COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=builder /usr/local/bin /usr/local/bin

# アプリケーションファイルをコピー
COPY --chown=streamlit:streamlit . .

# ポート番号の公開
EXPOSE 8501

# ヘルスチェックの設定
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8501/_stcore/health || exit 1

# streamlitユーザーに切り替え
USER streamlit

# Streamlitアプリケーションの起動
CMD ["streamlit", "run", "app.py", "--server.port=8501", "--server.address=0.0.0.0"]</code></pre>
                        
                        <h6>.dockerignore を作成</h6>
                        <pre class="code-block"><code class="language-python"># Git関連
.git
.gitignore

# Python関連
__pycache__
*.pyc
*.pyo
*.pyd
.Python
env
pip-log.txt
pip-delete-this-directory.txt
.tox
.coverage
.coverage.*
.pytest_cache
nosetests.xml
.mypy_cache

# IDE関連
.vscode
.idea
*.swp
*.swo
*~

# OS関連
.DS_Store
Thumbs.db

# ログファイル
*.log

# 一時ファイル
*.tmp
*.temp

# ドキュメント
README.md
docs/
*.md

# Docker関連
Dockerfile*
docker-compose*
.dockerignore</code></pre>
                        
                        <h6>docker-compose.yml を作成</h6>
                        <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  streamlit-app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: streamlit-production
    ports:
      - "8501:8501"
    environment:
      - ENVIRONMENT=production
      - DEBUG=false
      - PYTHONUNBUFFERED=1
    volumes:
      # ログディレクトリのマウント（オプション）
      - ./logs:/app/logs
      # データディレクトリのマウント（オプション）
      - ./data:/app/data:ro
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8501/_stcore/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - streamlit-network
    
  # リバースプロキシ（Nginx）
  nginx:
    image: nginx:alpine
    container_name: streamlit-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      streamlit-app:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - streamlit-network

  # データベース（オプション）
  postgres:
    image: postgres:15-alpine
    container_name: streamlit-db
    environment:
      POSTGRES_DB: streamlit_db
      POSTGRES_USER: streamlit_user
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-secure_password}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    restart: unless-stopped
    networks:
      - streamlit-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U streamlit_user -d streamlit_db"]
      interval: 30s
      timeout: 10s
      retries: 5

  # Redis（キャッシュ用、オプション）
  redis:
    image: redis:7-alpine
    container_name: streamlit-redis
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD:-redis_password}
    volumes:
      - redis_data:/data
    restart: unless-stopped
    networks:
      - streamlit-network
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  postgres_data:
  redis_data:

networks:
  streamlit-network:
    driver: bridge</code></pre>
                        
                        <h6>nginx/nginx.conf を作成</h6>
                        <pre class="code-block"><code class="language-nginx">events {
    worker_connections 1024;
}

http {
    upstream streamlit {
        server streamlit-app:8501;
    }
    
    # レート制限の設定
    limit_req_zone $binary_remote_addr zone=streamlit_ratelimit:10m rate=10r/s;
    
    # ログフォーマット
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    # 基本設定
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 100M;
    
    # Gzip圧縮
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/javascript
        application/xml+rss
        application/json;
    
    # HTTPS サーバー（本番環境用）
    server {
        listen 443 ssl http2;
        server_name your-domain.com;
        
        # SSL設定
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;
        
        # セキュリティヘッダー
        add_header X-Frame-Options DENY;
        add_header X-Content-Type-Options nosniff;
        add_header X-XSS-Protection "1; mode=block";
        add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload";
        
        # レート制限適用
        limit_req zone=streamlit_ratelimit burst=20 nodelay;
        
        location / {
            proxy_pass http://streamlit;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header X-Forwarded-Port $server_port;
            
            # WebSocket設定
            proxy_buffering off;
            proxy_cache off;
            proxy_read_timeout 86400;
        }
        
        # 静的ファイルのキャッシュ
        location ~* \.(css|js|png|jpg|jpeg|gif|ico|svg)$ {
            proxy_pass http://streamlit;
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
        
        # ヘルスチェック
        location /_stcore/health {
            proxy_pass http://streamlit;
            access_log off;
        }
        
        access_log /var/log/nginx/streamlit_access.log main;
        error_log /var/log/nginx/streamlit_error.log;
    }
    
    # HTTP から HTTPS へのリダイレクト
    server {
        listen 80;
        server_name your-domain.com;
        return 301 https://$server_name$request_uri;
    }
}</code></pre>
                        
                        <h6>環境設定ファイル（.env）を作成</h6>
                        <pre class="code-block"><code class="language-python"># 本番環境設定
ENVIRONMENT=production
DEBUG=false

# データベース設定
POSTGRES_PASSWORD=your_secure_password
DATABASE_URL=postgresql://streamlit_user:your_secure_password@postgres:5432/streamlit_db

# Redis設定
REDIS_PASSWORD=your_redis_password
REDIS_URL=redis://:your_redis_password@redis:6379/0

# API設定
API_KEY=your_api_key
SECRET_KEY=your_secret_key

# SSL設定
SSL_CERT_PATH=/etc/nginx/ssl/cert.pem
SSL_KEY_PATH=/etc/nginx/ssl/key.pem

# その他の設定
LOG_LEVEL=INFO
MAX_UPLOAD_SIZE=100MB</code></pre>
                        
                        <h6>Makefile を作成（開発効率化）</h6>
                        <pre class="code-block"><code class="language-python"># Streamlit Docker デプロイ用 Makefile

.PHONY: build run stop clean logs shell test deploy

# Docker イメージのビルド
build:
	docker-compose build --no-cache

# アプリケーションの起動
run:
	docker-compose up -d

# アプリケーションの停止
stop:
	docker-compose down

# 完全クリーンアップ
clean:
	docker-compose down -v --remove-orphans
	docker system prune -f

# ログの確認
logs:
	docker-compose logs -f streamlit-app

# コンテナ内でのシェル実行
shell:
	docker-compose exec streamlit-app /bin/bash

# アプリケーションのテスト
test:
	docker-compose exec streamlit-app python -m pytest tests/

# 本番デプロイ
deploy: build
	@echo "本番環境へのデプロイを開始..."
	docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
	@echo "デプロイ完了"

# 開発環境の起動
dev:
	docker-compose -f docker-compose.yml -f docker-compose.dev.yml up

# SSL証明書の生成（開発用）
ssl-dev:
	mkdir -p nginx/ssl
	openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
		-keyout nginx/ssl/key.pem \
		-out nginx/ssl/cert.pem \
		-subj "/C=JP/ST=Tokyo/L=Tokyo/O=Dev/CN=localhost"

# ヘルスチェック
health:
	curl -f http://localhost:8501/_stcore/health || echo "アプリケーションが応答しません"

# データベースマイグレーション
migrate:
	docker-compose exec streamlit-app python manage.py migrate

# バックアップ
backup:
	docker-compose exec postgres pg_dump -U streamlit_user streamlit_db > backup_$(shell date +%Y%m%d_%H%M%S).sql

# 使用方法を表示
help:
	@echo "利用可能なコマンド:"
	@echo "  build    - Dockerイメージをビルド"
	@echo "  run      - アプリケーションを起動"
	@echo "  stop     - アプリケーションを停止"
	@echo "  clean    - 完全クリーンアップ"
	@echo "  logs     - ログを表示"
	@echo "  shell    - コンテナ内シェル"
	@echo "  test     - テスト実行"
	@echo "  deploy   - 本番デプロイ"
	@echo "  health   - ヘルスチェック"
	@echo "  ssl-dev  - 開発用SSL証明書生成"
	@echo "  backup   - データベースバックアップ"</code></pre>
                        
                        <h6>実行と確認</h6>
                        <pre class="code-block"><code class="language-python"># Dockerイメージをビルド
make build

# アプリケーションを起動
make run

# ログを確認
make logs

# ヘルスチェック
make health

# 停止
make stop</code></pre>
                        
                        <h6>期待される結果</h6>
                        <p>完全にコンテナ化されたStreamlitアプリケーションが起動し、Nginx経由でHTTPS対応、データベース統合、Redis キャッシュを含む本番環境対応のシステムが確認できます。</p>
                    </div>

                    <!-- セクション3: パフォーマンス最適化 -->
                    <h3 class="section-title">9.3 パフォーマンス最適化とモニタリング</h3>
                    <p>本番環境での高いパフォーマンスを実現するための最適化技法とモニタリング手法を学習します。</p>

                    <div class="info-box">
                        <h6>パフォーマンス最適化のポイント</h6>
                        <ul>
                            <li><strong>キャッシュ戦略</strong>: 効果的なst.cache_dataの活用</li>
                            <li><strong>データ処理最適化</strong>: チャンク処理と並列化</li>
                            <li><strong>メモリ管理</strong>: 大容量データの効率的な処理</li>
                            <li><strong>レスポンス時間短縮</strong>: 非同期処理の活用</li>
                        </ul>
                    </div>

                    <div class="exercise-container">
                        <h5>実習 9-3: パフォーマンス監視システム</h5>
                        <p>アプリケーションのパフォーマンスを監視し、ボトルネックを特定するシステムを構築します。</p>
                        
                        <h6>performance_monitor.py を作成</h6>
                        <pre class="code-block"><code class="language-python">import streamlit as st
import time
import psutil
import threading
from datetime import datetime, timedelta
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from typing import Dict, List, Any
import sys
import gc

class PerformanceMonitor:
    """パフォーマンス監視クラス"""
    
    def __init__(self):
        if 'performance_data' not in st.session_state:
            st.session_state.performance_data = []
        
        if 'monitoring_active' not in st.session_state:
            st.session_state.monitoring_active = False
    
    def get_system_metrics(self) -> Dict[str, Any]:
        """システムメトリクスを取得"""
        try:
            # CPU使用率
            cpu_percent = psutil.cpu_percent(interval=1)
            
            # メモリ使用状況
            memory = psutil.virtual_memory()
            
            # ディスク使用状況
            disk = psutil.disk_usage('/')
            
            # プロセス情報
            process = psutil.Process()
            process_memory = process.memory_info()
            
            return {
                'timestamp': datetime.now(),
                'cpu_percent': cpu_percent,
                'memory_total': memory.total / (1024**3),  # GB
                'memory_used': memory.used / (1024**3),   # GB
                'memory_percent': memory.percent,
                'disk_total': disk.total / (1024**3),     # GB
                'disk_used': disk.used / (1024**3),       # GB
                'disk_percent': (disk.used / disk.total) * 100,
                'process_memory': process_memory.rss / (1024**2),  # MB
                'process_cpu': process.cpu_percent(),
                'active_threads': threading.active_count()
            }
        except Exception as e:
            st.error(f"システムメトリクス取得エラー: {e}")
            return {}
    
    def get_streamlit_metrics(self) -> Dict[str, Any]:
        """Streamlit固有のメトリクスを取得"""
        try:
            # セッション状態のサイズ
            session_size = sys.getsizeof(st.session_state)
            
            # ガベージコレクション情報
            gc_counts = gc.get_count()
            
            # キャッシュ情報（概算）
            cache_info = {
                'cache_enabled': True,  # st.cache_dataが有効かどうか
                'cache_entries': len(st.session_state) if hasattr(st, 'session_state') else 0
            }
            
            return {
                'session_size_kb': session_size / 1024,
                'gc_gen0': gc_counts[0],
                'gc_gen1': gc_counts[1],
                'gc_gen2': gc_counts[2],
                'cache_entries': cache_info['cache_entries']
            }
        except Exception as e:
            st.error(f"Streamlitメトリクス取得エラー: {e}")
            return {}
    
    def record_metrics(self):
        """メトリクスを記録"""
        system_metrics = self.get_system_metrics()
        streamlit_metrics = self.get_streamlit_metrics()
        
        if system_metrics and streamlit_metrics:
            combined_metrics = {**system_metrics, **streamlit_metrics}
            st.session_state.performance_data.append(combined_metrics)
            
            # 古いデータを削除（最新100件のみ保持）
            if len(st.session_state.performance_data) > 100:
                st.session_state.performance_data = st.session_state.performance_data[-100:]
    
    def get_performance_dataframe(self) -> pd.DataFrame:
        """パフォーマンスデータをDataFrameとして取得"""
        if not st.session_state.performance_data:
            return pd.DataFrame()
        
        return pd.DataFrame(st.session_state.performance_data)
    
    def analyze_performance(self, df: pd.DataFrame) -> Dict[str, Any]:
        """パフォーマンス分析"""
        if df.empty:
            return {}
        
        analysis = {
            'cpu_avg': df['cpu_percent'].mean(),
            'cpu_max': df['cpu_percent'].max(),
            'memory_avg': df['memory_percent'].mean(),
            'memory_max': df['memory_percent'].max(),
            'process_memory_avg': df['process_memory'].mean(),
            'process_memory_max': df['process_memory'].max(),
            'session_size_avg': df['session_size_kb'].mean(),
            'cache_entries_avg': df['cache_entries'].mean()
        }
        
        # アラート判定
        alerts = []
        if analysis['cpu_avg'] > 80:
            alerts.append("高CPU使用率")
        if analysis['memory_avg'] > 90:
            alerts.append("高メモリ使用率")
        if analysis['process_memory_avg'] > 500:  # 500MB
            alerts.append("プロセスメモリ過多")
        
        analysis['alerts'] = alerts
        return analysis

def show_performance_dashboard():
    """パフォーマンスダッシュボードを表示"""
    st.title("📊 パフォーマンス監視ダッシュボード")
    
    monitor = PerformanceMonitor()
    
    # 制御パネル
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("📈 メトリクス記録"):
            monitor.record_metrics()
            st.success("メトリクスを記録しました")
    
    with col2:
        if st.button("🔄 自動記録開始"):
            st.session_state.monitoring_active = True
            st.success("自動記録を開始しました")
    
    with col3:
        if st.button("⏹️ 自動記録停止"):
            st.session_state.monitoring_active = False
            st.info("自動記録を停止しました")
    
    # 自動記録機能
    if st.session_state.monitoring_active:
        monitor.record_metrics()
        time.sleep(5)  # 5秒間隔
        st.rerun()
    
    # データ取得
    df = monitor.get_performance_dataframe()
    
    if df.empty:
        st.info("パフォーマンスデータがありません。「メトリクス記録」ボタンを押してデータを収集してください。")
        return
    
    # 分析結果表示
    analysis = monitor.analyze_performance(df)
    
    # アラート表示
    if analysis.get('alerts'):
        st.error("⚠️ パフォーマンスアラート:")
        for alert in analysis['alerts']:
            st.error(f"- {alert}")
    
    # メトリクス概要
    st.subheader("📋 現在のメトリクス")
    
    latest_metrics = df.iloc[-1] if len(df) > 0 else None
    
    if latest_metrics is not None:
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                "CPU使用率",
                f"{latest_metrics['cpu_percent']:.1f}%",
                delta=f"{latest_metrics['cpu_percent'] - analysis['cpu_avg']:.1f}%" if 'cpu_avg' in analysis else None
            )
        
        with col2:
            st.metric(
                "メモリ使用率",
                f"{latest_metrics['memory_percent']:.1f}%",
                delta=f"{latest_metrics['memory_percent'] - analysis['memory_avg']:.1f}%" if 'memory_avg' in analysis else None
            )
        
        with col3:
            st.metric(
                "プロセスメモリ",
                f"{latest_metrics['process_memory']:.1f}MB",
                delta=f"{latest_metrics['process_memory'] - analysis['process_memory_avg']:.1f}MB" if 'process_memory_avg' in analysis else None
            )
        
        with col4:
            st.metric(
                "セッションサイズ",
                f"{latest_metrics['session_size_kb']:.1f}KB",
                delta=f"{latest_metrics['session_size_kb'] - analysis['session_size_avg']:.1f}KB" if 'session_size_avg' in analysis else None
            )
    
    # グラフ表示
    st.subheader("📈 パフォーマンス推移")
    
    tab1, tab2, tab3 = st.tabs(["システムリソース", "プロセス情報", "Streamlit固有"])
    
    with tab1:
        # CPU使用率
        fig_cpu = px.line(
            df, 
            x='timestamp', 
            y='cpu_percent',
            title='CPU使用率推移',
            labels={'cpu_percent': 'CPU使用率 (%)', 'timestamp': '時刻'}
        )
        fig_cpu.add_hline(y=80, line_dash="dash", line_color="red", annotation_text="危険レベル")
        st.plotly_chart(fig_cpu, use_container_width=True)
        
        # メモリ使用率
        fig_memory = px.line(
            df, 
            x='timestamp', 
            y='memory_percent',
            title='メモリ使用率推移',
            labels={'memory_percent': 'メモリ使用率 (%)', 'timestamp': '時刻'}
        )
        fig_memory.add_hline(y=90, line_dash="dash", line_color="red", annotation_text="危険レベル")
        st.plotly_chart(fig_memory, use_container_width=True)
    
    with tab2:
        # プロセスメモリ
        fig_proc_mem = px.line(
            df, 
            x='timestamp', 
            y='process_memory',
            title='プロセスメモリ使用量',
            labels={'process_memory': 'メモリ使用量 (MB)', 'timestamp': '時刻'}
        )
        st.plotly_chart(fig_proc_mem, use_container_width=True)
        
        # アクティブスレッド数
        fig_threads = px.line(
            df, 
            x='timestamp', 
            y='active_threads',
            title='アクティブスレッド数',
            labels={'active_threads': 'スレッド数', 'timestamp': '時刻'}
        )
        st.plotly_chart(fig_threads, use_container_width=True)
    
    with tab3:
        # セッション状態サイズ
        fig_session = px.line(
            df, 
            x='timestamp', 
            y='session_size_kb',
            title='セッション状態サイズ',
            labels={'session_size_kb': 'サイズ (KB)', 'timestamp': '時刻'}
        )
        st.plotly_chart(fig_session, use_container_width=True)
        
        # ガベージコレクション
        fig_gc = go.Figure()
        fig_gc.add_trace(go.Scatter(x=df['timestamp'], y=df['gc_gen0'], name='Gen 0'))
        fig_gc.add_trace(go.Scatter(x=df['timestamp'], y=df['gc_gen1'], name='Gen 1'))
        fig_gc.add_trace(go.Scatter(x=df['timestamp'], y=df['gc_gen2'], name='Gen 2'))
        fig_gc.update_layout(title='ガベージコレクション世代別オブジェクト数')
        st.plotly_chart(fig_gc, use_container_width=True)
    
    # 詳細統計
    st.subheader("📊 統計サマリー")
    
    if analysis:
        stats_df = pd.DataFrame([
            ['CPU使用率 (平均)', f"{analysis['cpu_avg']:.1f}%"],
            ['CPU使用率 (最大)', f"{analysis['cpu_max']:.1f}%"],
            ['メモリ使用率 (平均)', f"{analysis['memory_avg']:.1f}%"],
            ['メモリ使用率 (最大)', f"{analysis['memory_max']:.1f}%"],
            ['プロセスメモリ (平均)', f"{analysis['process_memory_avg']:.1f}MB"],
            ['プロセスメモリ (最大)', f"{analysis['process_memory_max']:.1f}MB"],
        ], columns=['メトリクス', '値'])
        
        st.dataframe(stats_df, use_container_width=True, hide_index=True)
    
    # データエクスポート
    st.subheader("💾 データエクスポート")
    
    if st.button("📄 パフォーマンスデータをダウンロード"):
        csv = df.to_csv(index=False, encoding='utf-8-sig')
        st.download_button(
            label="CSVダウンロード",
            data=csv,
            file_name=f"performance_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
            mime="text/csv"
        )

if __name__ == "__main__":
    show_performance_dashboard()</code></pre>
                        
                        <h6>実行と確認</h6>
                        <pre class="code-block"><code class="language-bash">pip install psutil
streamlit run performance_monitor.py</code></pre>
                        
                        <h6>期待される結果</h6>
                        <p>リアルタイムでシステムリソースとStreamlitアプリケーションのパフォーマンスを監視し、ボトルネックを特定できる包括的な監視ダッシュボードが表示されます。</p>
                    </div>

                    <!-- 理解度確認 -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <strong>Streamlit Cloudでアプリケーションをデプロイする際に必要な必須ファイルは何ですか？</strong>
                                <ul style="list-style-type: none;">
                                    <li>a) Dockerfile</li>
                                    <li>b) requirements.txt</li>
                                    <li>c) docker-compose.yml</li>
                                    <li>d) nginx.conf</li>
                                </ul>
                                <details style="margin-top: 0.5rem;">
                                    <summary>解答を見る</summary>
                                    <p><strong>答え: b)</strong> requirements.txtはStreamlit Cloudデプロイ時に依存関係を管理するために必須です。</p>
                                </details>
                            </li>
                            
                            <li>
                                <strong>Dockerコンテナ化する際のセキュリティベストプラクティスを2つ挙げてください</strong>
                                <details style="margin-top: 0.5rem;">
                                    <summary>解答を見る</summary>
                                    <p><strong>答え例:</strong><br>
                                    1. <strong>非rootユーザー</strong>: コンテナ内でrootユーザーを使用しない<br>
                                    2. <strong>最小権限の原則</strong>: 必要最小限の権限のみ付与<br>
                                    3. <strong>マルチステージビルド</strong>: 本番用イメージの軽量化<br>
                                    4. <strong>.dockerignore</strong>: 不要なファイルの除外</p>
                                </details>
                            </li>
                            
                            <li>
                                <strong>Streamlitアプリケーションのパフォーマンス最適化で重要な要素を3つ答えてください</strong>
                                <details style="margin-top: 0.5rem;">
                                    <summary>解答を見る</summary>
                                    <p><strong>答え:</strong><br>
                                    1. <strong>効果的なキャッシュ</strong>: @st.cache_dataの適切な使用<br>
                                    2. <strong>データ処理最適化</strong>: チャンク処理と並列化<br>
                                    3. <strong>メモリ管理</strong>: 不要なデータの適切な解放<br>
                                    4. <strong>レスポンシブUI</strong>: ユーザー体験の向上</p>
                                </details>
                            </li>
                        </ol>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="streamlit-learning-material-08.html" class="btn btn-secondary">← 前の章: データベース連携とAPI統合</a>
                        <a href="streamlit-learning-material-10.html" class="btn btn-primary">次の章: 実践的なデータ分析アプリ開発 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JavaScript -->

    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>