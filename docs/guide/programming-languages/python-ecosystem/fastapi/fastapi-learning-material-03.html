<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastAPI学習教材 第3章 - Pydanticモデルとデータ検証</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #2e7d32;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }

        /* タイトル */
        .chapter-title {
            color: #2e7d32;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #2e7d32;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #4caf50;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e8f5e8;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #2e7d32;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #2e7d32 !important;
            color: white !important;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand">
                <strong>FastAPI学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="fastapi-learning-material-01.html">
                                第1章: FastAPI入門と環境構築
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="fastapi-learning-material-02.html">
                                第2章: ルーティングとリクエスト処理
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="fastapi-learning-material-03.html">
                                第3章: Pydanticモデルとデータ検証
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="fastapi-learning-material-04.html">
                                第4章: レスポンス処理と例外ハンドリング
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="fastapi-learning-material-05.html">
                                第5章: 依存性注入とミドルウェア
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="fastapi-learning-material-06.html">
                                第6章: データベース連携とORM
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="fastapi-learning-material-07.html">
                                第7章: 認証とセキュリティ
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="fastapi-learning-material-08.html">
                                第8章: 非同期処理とパフォーマンス最適化
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="fastapi-learning-material-09.html">
                                第9章: テストとドキュメント
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="fastapi-learning-material-10.html">
                                第10章: デプロイメントと本番環境
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <!-- 章ヘッダー -->
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第3章: Pydanticモデルとデータ検証</h1>
                </div>

                <div id="chapter3">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">型安全なデータモデリングとバリデーション</h2>
                    
                    <!-- 学習目標（必須） -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>Pydanticライブラリの概念と基本的な使用方法</li>
                            <li>データモデル定義による型安全性の実現</li>
                            <li>自動バリデーションとエラーハンドリング</li>
                            <li>レスポンスモデルとシリアライゼーション</li>
                            <li>ネストしたモデルと複雑なデータ構造の設計</li>
                        </ul>
                    </div>

                    <!-- セクション1: Pydanticとは -->
                    <h3 class="section-title">3.1 Pydanticの概要と重要性</h3>
                    
                    <p>Pydanticは、Pythonの型ヒントを使用してデータ検証とシリアライゼーションを行うライブラリです。FastAPIの核となる技術の一つで、APIの堅牢性と開発効率を大幅に向上させます。</p>
                    
                    <div class="mermaid">
                        graph TB
                            A["HTTPリクエスト<br/>(JSON)"] --> B["Pydanticモデル"]
                            B --> C["型変換"]
                            C --> D["バリデーション"]
                            D --> E["Pythonオブジェクト"]
                            E --> F["ビジネスロジック"]
                            
                            F --> G["Pydanticモデル"]
                            G --> H["シリアライゼーション"]
                            H --> I["HTTPレスポンス<br/>(JSON)"]
                    </div>

                    <p><strong>Pydanticが解決する課題</strong></p>
                    <ul>
                        <li><strong>型安全性</strong>: 実行時の型エラーを事前に防止</li>
                        <li><strong>データ検証</strong>: 入力データの妥当性を自動チェック</li>
                        <li><strong>ドキュメント生成</strong>: モデル定義から自動でAPIドキュメントを生成</li>
                        <li><strong>開発効率</strong>: IDE支援とコード補完の向上</li>
                    </ul>

                    <div class="highlight">
                        <h6>従来の辞書型データ処理との比較</h6>
                        <p><strong>従来の方法（辞書使用）:</strong></p>
                        <ul>
                            <li>型チェックなし、実行時エラーが発生しやすい</li>
                            <li>手動でのバリデーションが必要</li>
                            <li>IDEでのコード補完が効かない</li>
                        </ul>
                        <p><strong>Pydanticモデル使用:</strong></p>
                        <ul>
                            <li>自動型変換とバリデーション</li>
                            <li>コンパイル時の型チェック</li>
                            <li>優れた開発者体験とコード補完</li>
                        </ul>
                    </div>

                    <!-- セクション2: 基本的なPydanticモデル -->
                    <h3 class="section-title">3.2 基本的なPydanticモデルの作成</h3>
                    
                    <p>Pydanticモデルは、BaseModelを継承したクラスとして定義します。各フィールドには型ヒントを付与し、必要に応じてデフォルト値やバリデーションルールを設定します。</p>

                    <div class="exercise-container">
                        <h5>実習 3-1: 基本的なPydanticモデルの定義</h5>
                        <p>ユーザー情報を管理するモデルを作成し、基本的な機能を理解しましょう。</p>
                        <h6>実装例</h6>
                        <pre class="code-block"><code class="language-python">from fastapi import FastAPI
from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import datetime
from enum import Enum

app = FastAPI()

# ユーザーの役割を定義（Enum使用）
class UserRole(str, Enum):
    admin = "admin"
    user = "user"
    guest = "guest"

# ユーザー作成用のモデル
class UserCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=50, description="ユーザー名")
    email: EmailStr = Field(..., description="メールアドレス")
    age: int = Field(..., ge=0, le=120, description="年齢（0-120歳）")
    role: UserRole = Field(UserRole.user, description="ユーザー役割")
    bio: Optional[str] = Field(None, max_length=500, description="自己紹介（任意）")

# レスポンス用のユーザーモデル
class UserResponse(BaseModel):
    id: int
    name: str
    email: EmailStr
    age: int
    role: UserRole
    bio: Optional[str]
    created_at: datetime
    updated_at: datetime

# 仮のユーザーデータベース
users_db = []
user_id_counter = 1

@app.post("/users", response_model=UserResponse)
def create_user(user: UserCreate):
    """新規ユーザー作成（Pydanticモデル使用）"""
    global user_id_counter
    
    # 新規ユーザーの作成
    current_time = datetime.now()
    new_user = UserResponse(
        id=user_id_counter,
        name=user.name,
        email=user.email,
        age=user.age,
        role=user.role,
        bio=user.bio,
        created_at=current_time,
        updated_at=current_time
    )
    
    users_db.append(new_user)
    user_id_counter += 1
    
    return new_user

@app.get("/users", response_model=list[UserResponse])
def get_users():
    """すべてのユーザーを取得"""
    return users_db</code></pre>
                        <h6>期待される結果</h6>
                        <p>型安全性が確保され、不正なデータが送信された場合は自動的にバリデーションエラーが返されます。</p>
                    </div>

                    <div class="warning">
                        <h6>Pydanticモデル作成時の注意点</h6>
                        <ul>
                            <li><strong>EmailStr型の使用</strong>: email-validator パッケージのインストールが必要</li>
                            <li><strong>Field()の活用</strong>: バリデーションルールと説明文を設定</li>
                            <li><strong>Enum使用</strong>: 選択肢を制限したい場合に有効</li>
                            <li><strong>モデルの分離</strong>: 作成用とレスポンス用でモデルを分ける</li>
                        </ul>
                    </div>

                    <!-- セクション3: バリデーションルール -->
                    <h3 class="section-title">3.3 詳細なバリデーションルールの設定</h3>
                    
                    <p>Pydanticでは、Field()関数を使用して詳細なバリデーションルールを設定できます。これにより、データの整合性を保ち、不正な入力を防ぐことができます。</p>

                    <div class="exercise-container">
                        <h5>実習 3-2: 高度なバリデーションルールの実装</h5>
                        <p>商品管理システムを例に、様々なバリデーションルールを実装します。</p>
                        <h6>実装例</h6>
                        <pre class="code-block"><code class="language-python">from pydantic import BaseModel, Field, validator, root_validator
from typing import List, Optional
from decimal import Decimal
import re

class ProductCreate(BaseModel):
    name: str = Field(
        ..., 
        min_length=3, 
        max_length=100, 
        description="商品名（3-100文字）"
    )
    price: Decimal = Field(
        ..., 
        gt=0, 
        le=1000000, 
        decimal_places=2,
        description="価格（0円超、100万円以下、小数点以下2桁）"
    )
    sku: str = Field(
        ..., 
        regex=r'^[A-Z]{2}-\d{6}$',
        description="SKUコード（例: AB-123456）"
    )
    category: str = Field(..., description="商品カテゴリー")
    tags: List[str] = Field(
        default_factory=list, 
        max_items=10,
        description="商品タグ（最大10個）"
    )
    description: Optional[str] = Field(
        None, 
        max_length=1000,
        description="商品説明（最大1000文字）"
    )
    discount_rate: Optional[float] = Field(
        None, 
        ge=0, 
        le=1,
        description="割引率（0-1の範囲）"
    )

    @validator('name')
    def validate_name(cls, v):
        """商品名のカスタムバリデーション"""
        if not v.strip():
            raise ValueError('商品名は空文字列にできません')
        
        # 禁止文字のチェック
        forbidden_chars = ['<', '>', '&', '"']
        for char in forbidden_chars:
            if char in v:
                raise ValueError(f'商品名に使用できない文字が含まれています: {char}')
        
        return v.strip()

    @validator('tags')
    def validate_tags(cls, v):
        """タグのカスタムバリデーション"""
        # 重複チェック
        if len(v) != len(set(v)):
            raise ValueError('重複するタグが含まれています')
        
        # 各タグの長さチェック
        for tag in v:
            if len(tag.strip()) < 2:
                raise ValueError('各タグは2文字以上である必要があります')
        
        return [tag.strip() for tag in v]

    @validator('category')
    def validate_category(cls, v):
        """カテゴリーの検証"""
        allowed_categories = [
            'electronics', 'books', 'clothing', 'home', 'sports'
        ]
        if v.lower() not in allowed_categories:
            raise ValueError(f'カテゴリーは次のいずれかである必要があります: {", ".join(allowed_categories)}')
        return v.lower()

    @root_validator
    def validate_discount_logic(cls, values):
        """複数フィールド間の整合性チェック"""
        price = values.get('price')
        discount_rate = values.get('discount_rate')
        category = values.get('category')
        
        # 高価格商品の割引率制限
        if price and discount_rate:
            if price > 50000 and discount_rate > 0.3:
                raise ValueError('高価格商品（5万円超）の割引率は30%以下にしてください')
        
        # カテゴリー別の価格制限
        if price and category == 'books' and price > 10000:
            raise ValueError('書籍カテゴリーの商品は1万円以下にしてください')
        
        return values

# FastAPIエンドポイント
@app.post("/products")
def create_product(product: ProductCreate):
    """商品作成（高度なバリデーション付き）"""
    
    # 計算された割引後価格を追加
    discounted_price = product.price
    if product.discount_rate:
        discounted_price = product.price * (1 - product.discount_rate)
    
    return {
        "message": "商品が作成されました",
        "product": product.dict(),
        "discounted_price": discounted_price
    }</code></pre>
                        <h6>期待される結果</h6>
                        <p>様々なバリデーションルールが機能し、不正なデータに対して適切なエラーメッセージが返されます。</p>
                    </div>

                    <!-- セクション4: ネストしたモデル -->
                    <h3 class="section-title">3.4 ネストしたモデルと複雑なデータ構造</h3>
                    
                    <p>実際のアプリケーションでは、オブジェクト間の関係を表現するために、ネストしたモデル構造が必要になります。Pydanticは、この複雑さを型安全に管理できます。</p>

                    <div class="mermaid">
                        classDiagram
                            class Order {
                                +int id
                                +datetime created_at
                                +User customer
                                +List[OrderItem] items
                                +Address shipping_address
                            }
                            class User {
                                +int id
                                +str name
                                +str email
                            }
                            class OrderItem {
                                +int product_id
                                +str product_name
                                +int quantity
                                +Decimal unit_price
                            }
                            class Address {
                                +str street
                                +str city
                                +str postal_code
                            }
                            
                            Order *-- User
                            Order *-- OrderItem
                            Order *-- Address
                    </div>

                    <div class="exercise-container">
                        <h5>実習 3-3: ネストしたモデルの実装</h5>
                        <p>注文管理システムを例に、複雑なデータ構造を持つモデルを作成します。</p>
                        <h6>実装例</h6>
                        <pre class="code-block"><code class="language-python">from pydantic import BaseModel, Field, validator
from typing import List
from decimal import Decimal
from datetime import datetime

# 住所モデル
class Address(BaseModel):
    street: str = Field(..., min_length=5, max_length=100)
    city: str = Field(..., min_length=2, max_length=50)
    postal_code: str = Field(..., regex=r'^\d{3}-\d{4}$')
    prefecture: str = Field(..., min_length=2, max_length=10)

# 顧客情報モデル
class Customer(BaseModel):
    id: int
    name: str = Field(..., min_length=1, max_length=50)
    email: EmailStr
    phone: Optional[str] = Field(None, regex=r'^\d{3}-\d{4}-\d{4}$')

# 注文アイテムモデル
class OrderItem(BaseModel):
    product_id: int = Field(..., gt=0)
    product_name: str = Field(..., min_length=1, max_length=100)
    quantity: int = Field(..., gt=0, le=100)
    unit_price: Decimal = Field(..., gt=0, decimal_places=2)
    
    @validator('unit_price')
    def validate_price(cls, v):
        if v > 1000000:
            raise ValueError('単価が高すぎます（100万円以下）')
        return v

# メインの注文モデル
class OrderCreate(BaseModel):
    customer: Customer
    items: List[OrderItem] = Field(..., min_items=1, max_items=50)
    shipping_address: Address
    notes: Optional[str] = Field(None, max_length=500)

    @validator('items')
    def validate_items(cls, v):
        """注文アイテムの検証"""
        # 重複商品IDチェック
        product_ids = [item.product_id for item in v]
        if len(product_ids) != len(set(product_ids)):
            raise ValueError('同じ商品が複数回指定されています')
        
        return v

    @root_validator
    def validate_order_total(cls, values):
        """注文全体の検証"""
        items = values.get('items', [])
        
        # 合計金額の計算と制限
        total_amount = sum(
            item.quantity * item.unit_price for item in items
        )
        
        if total_amount > 5000000:  # 500万円制限
            raise ValueError('注文合計額が上限（500万円）を超えています')
        
        return values

# レスポンス用モデル
class OrderResponse(BaseModel):
    id: int
    customer: Customer
    items: List[OrderItem]
    shipping_address: Address
    subtotal: Decimal
    tax: Decimal
    total_amount: Decimal
    status: str
    created_at: datetime
    notes: Optional[str]

# FastAPIエンドポイント
@app.post("/orders", response_model=OrderResponse)
def create_order(order: OrderCreate):
    """注文作成（ネストしたモデル使用）"""
    
    # 金額計算
    subtotal = sum(item.quantity * item.unit_price for item in order.items)
    tax = subtotal * Decimal('0.1')  # 10%税率
    total_amount = subtotal + tax
    
    # レスポンスデータの作成
    order_response = OrderResponse(
        id=12345,  # 実際はDB生成
        customer=order.customer,
        items=order.items,
        shipping_address=order.shipping_address,
        subtotal=subtotal,
        tax=tax,
        total_amount=total_amount,
        status="pending",
        created_at=datetime.now(),
        notes=order.notes
    )
    
    return order_response</code></pre>
                        <h6>期待される結果</h6>
                        <p>複雑なネストしたデータ構造が適切にバリデーションされ、型安全性が確保されます。</p>
                    </div>

                    <!-- セクション5: レスポンスモデル -->
                    <h3 class="section-title">3.5 レスポンスモデルとシリアライゼーション</h3>
                    
                    <p>レスポンスモデルは、APIから返すデータの形式を定義し、適切なシリアライゼーションを行います。これにより、一貫性のあるAPI設計と、機密情報の除外が可能になります。</p>

                    <div class="exercise-container">
                        <h5>実習 3-4: レスポンスモデルの効果的な使用</h5>
                        <p>ユーザー管理システムで、機密情報を含むデータの安全な返却を実装します。</p>
                        <h6>実装例</h6>
                        <pre class="code-block"><code class="language-python">from pydantic import BaseModel, Field, SecretStr
from typing import Optional, List
from datetime import datetime

# 内部用の完全なユーザーモデル（機密情報含む）
class UserInternal(BaseModel):
    id: int
    username: str
    email: EmailStr
    password_hash: str  # 機密情報
    full_name: str
    is_active: bool
    is_admin: bool
    created_at: datetime
    last_login: Optional[datetime]
    login_count: int
    api_key: str  # 機密情報

# パブリック用レスポンスモデル（機密情報除外）
class UserPublic(BaseModel):
    id: int
    username: str
    full_name: str
    is_active: bool
    created_at: datetime
    last_login: Optional[datetime]

# 管理者用レスポンスモデル（より多くの情報を含む）
class UserAdmin(BaseModel):
    id: int
    username: str
    email: EmailStr
    full_name: str
    is_active: bool
    is_admin: bool
    created_at: datetime
    last_login: Optional[datetime]
    login_count: int
    # パスワードハッシュやAPIキーは含まない

# ユーザーリスト用の簡略モデル
class UserSummary(BaseModel):
    id: int
    username: str
    full_name: str
    is_active: bool

# 仮のデータ
sample_user = UserInternal(
    id=1,
    username="john_doe",
    email="john@example.com",
    password_hash="$2b$12$encrypted_password_hash",
    full_name="John Doe",
    is_active=True,
    is_admin=False,
    created_at=datetime.now(),
    last_login=datetime.now(),
    login_count=25,
    api_key="secret_api_key_12345"
)

@app.get("/users/{user_id}", response_model=UserPublic)
def get_user_public(user_id: int):
    """パブリック用ユーザー情報取得（機密情報除外）"""
    # 実際のDBからの取得処理をシミュレート
    user_data = sample_user
    
    # 自動的にUserPublicモデルに変換（機密情報は除外される）
    return user_data

@app.get("/admin/users/{user_id}", response_model=UserAdmin)
def get_user_admin(user_id: int):
    """管理者用ユーザー情報取得（より詳細な情報）"""
    # 管理者権限チェック（実際の実装では認証処理が必要）
    user_data = sample_user
    
    # UserAdminモデルに自動変換
    return user_data

@app.get("/users", response_model=List[UserSummary])
def get_users_list():
    """ユーザー一覧取得（簡略情報）"""
    users_data = [sample_user]  # 実際は複数ユーザー
    
    # 各ユーザーがUserSummaryモデルに自動変換される
    return users_data</code></pre>
                        <h6>期待される結果</h6>
                        <p>各エンドポイントで適切な情報のみが返却され、機密情報が漏洩することなく安全なAPI設計が実現されます。</p>
                    </div>

                    <div class="highlight">
                        <h6>レスポンスモデル使用のメリット</h6>
                        <ul>
                            <li><strong>セキュリティ</strong>: 機密情報の自動除外</li>
                            <li><strong>一貫性</strong>: 同じエンドポイントから常に同じ形式のデータ</li>
                            <li><strong>ドキュメント</strong>: APIドキュメントに正確なレスポンス形式が自動記載</li>
                            <li><strong>型安全性</strong>: レスポンスデータの型チェック</li>
                        </ul>
                    </div>

                    <!-- セクション6: カスタムバリデーター -->
                    <h3 class="section-title">3.6 カスタムバリデーターの実装</h3>
                    
                    <p>ビジネスロジックに特化したバリデーションが必要な場合、カスタムバリデーターを実装できます。</p>

                    <div class="exercise-container">
                        <h5>実習 3-5: カスタムバリデーターの実装</h5>
                        <p>会員登録システムで業務固有のバリデーションルールを実装します。</p>
                        <h6>実装例</h6>
                        <pre class="code-block"><code class="language-python">from pydantic import BaseModel, validator, root_validator
import re
from datetime import datetime, date

class MemberRegistration(BaseModel):
    username: str = Field(..., min_length=3, max_length=20)
    email: EmailStr
    password: str = Field(..., min_length=8)
    birth_date: date
    phone: str = Field(..., regex=r'^\d{3}-\d{4}-\d{4}$')
    referral_code: Optional[str] = None

    @validator('username')
    def validate_username(cls, v):
        """ユーザー名のカスタム検証"""
        # 英数字とアンダースコアのみ許可
        if not re.match(r'^[a-zA-Z0-9_]+$', v):
            raise ValueError('ユーザー名は英数字とアンダースコアのみ使用可能です')
        
        # 予約語チェック
        reserved_names = ['admin', 'root', 'system', 'api']
        if v.lower() in reserved_names:
            raise ValueError('この名前は使用できません')
        
        return v

    @validator('password')
    def validate_password(cls, v):
        """パスワードの強度チェック"""
        # 大文字・小文字・数字・記号を含む
        if not re.search(r'[A-Z]', v):
            raise ValueError('パスワードには大文字を含めてください')
        if not re.search(r'[a-z]', v):
            raise ValueError('パスワードには小文字を含めてください')
        if not re.search(r'\d', v):
            raise ValueError('パスワードには数字を含めてください')
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', v):
            raise ValueError('パスワードには記号を含めてください')
        
        return v

    @validator('birth_date')
    def validate_birth_date(cls, v):
        """生年月日の妥当性チェック"""
        today = date.today()
        age = today.year - v.year - ((today.month, today.day) < (v.month, v.day))
        
        if v >= today:
            raise ValueError('生年月日は過去の日付である必要があります')
        
        if age < 13:
            raise ValueError('13歳未満の方は登録できません')
        
        if age > 120:
            raise ValueError('生年月日を正しく入力してください')
        
        return v

    @validator('referral_code')
    def validate_referral_code(cls, v):
        """紹介コードの検証"""
        if v is None:
            return v
        
        # 6桁の英数字コード
        if not re.match(r'^[A-Z0-9]{6}$', v):
            raise ValueError('紹介コードは6桁の英数字である必要があります')
        
        # 実際のシステムでは、DBでの存在確認を行う
        # 今回はダミーの有効コードを設定
        valid_codes = ['ABC123', 'DEF456', 'GHI789']
        if v not in valid_codes:
            raise ValueError('無効な紹介コードです')
        
        return v

    @root_validator
    def validate_registration(cls, values):
        """登録全体の整合性チェック"""
        username = values.get('username')
        email = values.get('email')
        
        # 同じドメインのメールとユーザー名の組み合わせチェック
        if username and email:
            email_domain = email.split('@')[1]
            if username.lower() in email.lower():
                raise ValueError('セキュリティのため、メールアドレスにユーザー名を含めることはできません')
        
        return values

@app.post("/register")
def register_member(registration: MemberRegistration):
    """会員登録（カスタムバリデーション付き）"""
    
    # 登録処理のシミュレート
    member_data = {
        "id": 12345,
        "username": registration.username,
        "email": registration.email,
        "birth_date": registration.birth_date.isoformat(),
        "phone": registration.phone,
        "referral_used": registration.referral_code is not None,
        "registered_at": datetime.now().isoformat()
    }
    
    return {
        "message": "会員登録が完了しました",
        "member": member_data
    }</code></pre>
                        <h6>期待される結果</h6>
                        <p>ビジネスロジックに応じた詳細なバリデーションが機能し、適切なエラーメッセージが返されます。</p>
                    </div>

                    <!-- 理解度確認クイズ -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <strong>Pydanticモデルを定義する際に継承する基底クラスは何ですか？</strong>
                                <details>
                                    <summary>解答例</summary>
                                    <p>BaseModel<br>
                                    例: class User(BaseModel):</p>
                                </details>
                            </li>
                            <li>
                                <strong>Field()関数で数値の範囲を制限するパラメータを2つ挙げてください。</strong>
                                <details>
                                    <summary>解答例</summary>
                                    <p>gt（より大きい）、ge（以上）、lt（より小さい）、le（以下）<br>
                                    例: age: int = Field(..., ge=0, le=120)</p>
                                </details>
                            </li>
                            <li>
                                <strong>複数のフィールド間での整合性をチェックするために使用するデコレータは何ですか？</strong>
                                <details>
                                    <summary>解答例</summary>
                                    <p>@root_validator<br>
                                    複数のフィールドの値を同時に検証できる</p>
                                </details>
                            </li>
                            <li>
                                <strong>FastAPIエンドポイントでレスポンスモデルを指定する際に使用するパラメータは何ですか？</strong>
                                <details>
                                    <summary>解答例</summary>
                                    <p>response_model<br>
                                    例: @app.get("/users", response_model=UserResponse)</p>
                                </details>
                            </li>
                        </ol>
                    </div>

                    <!-- まとめ -->
                    <h3 class="section-title">3.7 まとめ</h3>
                    <p>この章では、Pydanticモデルを使用した型安全なデータモデリングとバリデーションについて学習しました。</p>
                    
                    <div class="highlight">
                        <h6>この章で習得したスキル</h6>
                        <ul>
                            <li>Pydanticモデルの基本的な定義と使用方法</li>
                            <li>Field()を使用した詳細なバリデーションルール設定</li>
                            <li>カスタムバリデーターによる業務固有の検証ロジック</li>
                            <li>ネストしたモデルによる複雑なデータ構造の表現</li>
                            <li>レスポンスモデルによるセキュアなデータ返却</li>
                            <li>型安全性による堅牢なAPI設計</li>
                        </ul>
                    </div>

                    <p>次の章では、レスポンス処理と例外ハンドリングについて詳しく学習し、エラーに対する適切な対応方法を身に付けます。</p>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="fastapi-learning-material-02.html" class="btn btn-secondary">← 前の章: ルーティングとリクエスト処理</a>
                        <a href="fastapi-learning-material-04.html" class="btn btn-primary">次の章: レスポンス処理と例外ハンドリング →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js 初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>