<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastAPI学習教材 第7章 - 認証とセキュリティ</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <style>
        body { font-family: 'Noto Sans JP', sans-serif; padding-top: 56px; }
        .navbar { background-color: #2e7d32; }
        .sidebar { position: sticky; top: 70px; height: calc(100vh - 70px); overflow-y: auto; }
        .chapter-title { color: #2e7d32; margin-top: 1.5rem; margin-bottom: 1rem; border-bottom: 2px solid #2e7d32; padding-bottom: 0.5rem; }
        .section-title { color: #4caf50; margin-top: 1.2rem; margin-bottom: 0.8rem; }
        .quiz-container { background-color: #e8f5e8; border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; border-left: 4px solid #2e7d32; }
        .exercise-container { background-color: #f3e5f5; border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; border-left: 4px solid #9c27b0; }
        .highlight { background-color: #ffecb3; border-radius: 8px; padding: 1rem; margin: 1rem 0; border-left: 4px solid #ffc107; }
        .warning { background-color: #ffebee; border-radius: 8px; padding: 1rem; margin: 1rem 0; border-left: 4px solid #f44336; }
        .code-block { background-color: #1e1e1e; border-radius: 5px; padding: 1rem; margin: 1rem 0; }
        .nav-link.active { background-color: #2e7d32 !important; color: white !important; }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid"><a class="navbar-brand"><strong>FastAPI学習教材</strong></a></div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <ul class="nav flex-column">
                        <li class="nav-item"><a class="nav-link" href="fastapi-learning-material-01.html">第1章: FastAPI入門と環境構築</a></li>
                        <li class="nav-item"><a class="nav-link" href="fastapi-learning-material-02.html">第2章: ルーティングとリクエスト処理</a></li>
                        <li class="nav-item"><a class="nav-link" href="fastapi-learning-material-03.html">第3章: Pydanticモデルとデータ検証</a></li>
                        <li class="nav-item"><a class="nav-link" href="fastapi-learning-material-04.html">第4章: レスポンス処理と例外ハンドリング</a></li>
                        <li class="nav-item"><a class="nav-link" href="fastapi-learning-material-05.html">第5章: 依存性注入とミドルウェア</a></li>
                        <li class="nav-item"><a class="nav-link" href="fastapi-learning-material-06.html">第6章: データベース連携とORM</a></li>
                        <li class="nav-item"><a class="nav-link active" href="fastapi-learning-material-07.html">第7章: 認証とセキュリティ</a></li>
                        <li class="nav-item"><a class="nav-link" href="fastapi-learning-material-08.html">第8章: 非同期処理とパフォーマンス最適化</a></li>
                        <li class="nav-item"><a class="nav-link" href="fastapi-learning-material-09.html">第9章: テストとドキュメント</a></li>
                        <li class="nav-item"><a class="nav-link" href="fastapi-learning-material-10.html">第10章: デプロイメントと本番環境</a></li>
                    </ul>
                </div>
            </nav>

            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第7章: 認証とセキュリティ</h1>
                </div>

                <div id="chapter7">
                    <h2 class="chapter-title">セキュアなAPI設計：JWT認証とOAuth2実装</h2>
                    
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>JWT（JSON Web Token）による認証システム実装</li>
                            <li>OAuth2プロトコルの理解とFastAPI統合</li>
                            <li>パスワードハッシング化とセキュリティ強化</li>
                            <li>ロールベースアクセス制御（RBAC）の実装</li>
                            <li>セキュリティベストプラクティスと脆弱性対策</li>
                        </ul>
                    </div>

                    <h3 class="section-title">7.1 JWT認証システムの基本実装</h3>
                    <p>JWT（JSON Web Token）は、安全な情報伝送のための業界標準です。ステートレスな認証を実現し、マイクロサービスアーキテクチャに最適です。</p>

                    <div class="mermaid">
                        sequenceDiagram
                            participant Client as クライアント
                            participant Auth as 認証API
                            participant Protected as 保護されたAPI
                            participant DB as データベース
                            
                            Client->>Auth: ログイン (username, password)
                            Auth->>DB: ユーザー認証
                            DB->>Auth: ユーザー情報
                            Auth->>Auth: JWTトークン生成
                            Auth->>Client: アクセストークン
                            
                            Client->>Protected: APIリクエスト (Bearer token)
                            Protected->>Protected: JWTトークン検証
                            Protected->>Client: APIレスポンス
                    </div>

                    <div class="exercise-container">
                        <h5>実習 7-1: JWT認証システムの実装</h5>
                        <h6>実装例</h6>
                        <pre class="code-block"><code class="language-python"># auth.py
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from passlib.context import CryptContext
from jose import JWTError, jwt
import os

# 設定
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key-here")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# パスワードハッシュ化
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# OAuth2スキーム
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# パスワード関連関数
def verify_password(plain_password: str, hashed_password: str) -> bool:
    """パスワード検証"""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """パスワードハッシュ化"""
    return pwd_context.hash(password)

def create_access_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:
    """JWTアクセストークン作成"""
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str) -> Dict[str, Any]:
    """JWTトークン検証"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        
        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="トークンが無効です",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        return payload
    
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="トークンが無効です",
            headers={"WWW-Authenticate": "Bearer"},
        )

# ユーザー認証関数
def authenticate_user(username: str, password: str) -> Optional[Dict[str, Any]]:
    """ユーザー認証（簡易版）"""
    # 実際のシステムではデータベースから取得
    fake_users_db = {
        "testuser": {
            "username": "testuser",
            "full_name": "Test User",
            "email": "test@example.com",
            "hashed_password": get_password_hash("testpass"),
            "roles": ["user"]
        },
        "admin": {
            "username": "admin",
            "full_name": "Administrator",
            "email": "admin@example.com",
            "hashed_password": get_password_hash("adminpass"),
            "roles": ["user", "admin"]
        }
    }
    
    user = fake_users_db.get(username)
    if not user:
        return None
    
    if not verify_password(password, user["hashed_password"]):
        return None
    
    return user

async def get_current_user(token: str = Depends(oauth2_scheme)) -> Dict[str, Any]:
    """現在のユーザー取得"""
    payload = verify_token(token)
    username: str = payload.get("sub")
    
    # 実際のシステムではデータベースから取得
    user = authenticate_user(username, "dummy")  # パスワードチェックは省略
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ユーザーが見つかりません",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    return user

async def get_current_active_user(current_user: Dict[str, Any] = Depends(get_current_user)) -> Dict[str, Any]:
    """アクティブユーザー取得"""
    if not current_user.get("is_active", True):
        raise HTTPException(status_code=400, detail="非アクティブユーザーです")
    return current_user

# 認証エンドポイント
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

class User(BaseModel):
    username: str
    email: Optional[str] = None
    full_name: Optional[str] = None
    roles: list[str] = []

@app.post("/token", response_model=Token)
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
    """ログイン（アクセストークン取得）"""
    user = authenticate_user(form_data.username, form_data.password)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ユーザー名またはパスワードが正しくありません",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user["username"], "roles": user["roles"]},
        expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/users/me", response_model=User)
async def read_users_me(current_user: Dict[str, Any] = Depends(get_current_active_user)):
    """現在のユーザー情報取得"""
    return User(**current_user)</code></pre>
                    </div>

                    <h3 class="section-title">7.2 ロールベースアクセス制御（RBAC）</h3>
                    <p>ユーザーの役割に基づいてアクセス権限を制御するシステムを実装します。</p>

                    <div class="exercise-container">
                        <h5>実習 7-2: RBAC実装</h5>
                        <h6>実装例</h6>
                        <pre class="code-block"><code class="language-python"># rbac.py
from typing import List, Set
from enum import Enum
from fastapi import Depends, HTTPException, status

class Role(str, Enum):
    USER = "user"
    MODERATOR = "moderator"
    ADMIN = "admin"
    SUPER_ADMIN = "super_admin"

class Permission(str, Enum):
    READ_POST = "read:post"
    WRITE_POST = "write:post"
    DELETE_POST = "delete:post"
    READ_USER = "read:user"
    WRITE_USER = "write:user"
    DELETE_USER = "delete:user"
    ADMIN_PANEL = "admin:panel"

# ロール-権限マッピング
ROLE_PERMISSIONS: dict[Role, Set[Permission]] = {
    Role.USER: {
        Permission.READ_POST,
        Permission.WRITE_POST,
        Permission.READ_USER,
    },
    Role.MODERATOR: {
        Permission.READ_POST,
        Permission.WRITE_POST,
        Permission.DELETE_POST,
        Permission.READ_USER,
    },
    Role.ADMIN: {
        Permission.READ_POST,
        Permission.WRITE_POST,
        Permission.DELETE_POST,
        Permission.READ_USER,
        Permission.WRITE_USER,
        Permission.DELETE_USER,
        Permission.ADMIN_PANEL,
    },
    Role.SUPER_ADMIN: set(Permission),  # 全権限
}

def get_permissions_for_roles(roles: List[str]) -> Set[Permission]:
    """ロールに基づく権限セット取得"""
    permissions = set()
    
    for role_str in roles:
        try:
            role = Role(role_str)
            permissions.update(ROLE_PERMISSIONS.get(role, set()))
        except ValueError:
            continue  # 無効なロールは無視
    
    return permissions

def require_permissions(*required_permissions: Permission):
    """権限チェック用デコレータファクトリー"""
    def permission_checker(current_user: dict = Depends(get_current_active_user)):
        user_roles = current_user.get("roles", [])
        user_permissions = get_permissions_for_roles(user_roles)
        
        missing_permissions = set(required_permissions) - user_permissions
        
        if missing_permissions:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"必要な権限がありません: {', '.join(missing_permissions)}"
            )
        
        return current_user
    
    return permission_checker

def require_roles(*required_roles: Role):
    """ロールチェック用デコレータファクトリー"""
    def role_checker(current_user: dict = Depends(get_current_active_user)):
        user_roles = set(current_user.get("roles", []))
        required_roles_set = {role.value for role in required_roles}
        
        if not user_roles.intersection(required_roles_set):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"必要なロールがありません: {', '.join(required_roles_set)}"
            )
        
        return current_user
    
    return role_checker

# RBAC適用エンドポイント例
@app.get("/posts")
async def read_posts(
    current_user: dict = Depends(require_permissions(Permission.READ_POST))
):
    """投稿一覧取得（読み取り権限必要）"""
    return {"posts": ["投稿1", "投稿2", "投稿3"], "user": current_user["username"]}

@app.post("/posts")
async def create_post(
    post_data: dict,
    current_user: dict = Depends(require_permissions(Permission.WRITE_POST))
):
    """投稿作成（書き込み権限必要）"""
    return {"message": "投稿が作成されました", "author": current_user["username"]}

@app.delete("/posts/{post_id}")
async def delete_post(
    post_id: int,
    current_user: dict = Depends(require_permissions(Permission.DELETE_POST))
):
    """投稿削除（削除権限必要）"""
    return {"message": f"投稿 {post_id} が削除されました"}

@app.get("/admin/dashboard")
async def admin_dashboard(
    current_user: dict = Depends(require_roles(Role.ADMIN, Role.SUPER_ADMIN))
):
    """管理者ダッシュボード（管理者ロール必要）"""
    return {
        "message": "管理者ダッシュボードへようこそ",
        "admin": current_user["username"],
        "permissions": list(get_permissions_for_roles(current_user["roles"]))
    }

@app.get("/users/{user_id}")
async def get_user_details(
    user_id: int,
    current_user: dict = Depends(require_permissions(Permission.READ_USER))
):
    """ユーザー詳細取得"""
    # 自分の情報または管理者権限があれば表示
    if (user_id == current_user.get("id") or 
        Permission.ADMIN_PANEL in get_permissions_for_roles(current_user["roles"])):
        return {"user_id": user_id, "details": "ユーザー詳細情報"}
    else:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="他のユーザーの情報にアクセスする権限がありません"
        )</code></pre>
                    </div>

                    <h3 class="section-title">7.3 セキュリティベストプラクティス</h3>
                    <p>実際のプロダクション環境で必要なセキュリティ対策を実装します。</p>

                    <div class="warning">
                        <h6>セキュリティリスクの主な要因</h6>
                        <ul>
                            <li><strong>弱いパスワードポリシー</strong>: 簡単に推測されるパスワード</li>
                            <li><strong>SQL インジェクション</strong>: 不適切なクエリ処理</li>
                            <li><strong>XSS攻撃</strong>: 入力値のサニタイゼーション不備</li>
                            <li><strong>CSRF攻撃</strong>: リクエストの正当性チェック不備</li>
                            <li><strong>機密情報の漏洩</strong>: ログやエラーメッセージでの情報露出</li>
                        </ul>
                    </div>

                    <div class="exercise-container">
                        <h5>実習 7-3: セキュリティ強化実装</h5>
                        <h6>実装例</h6>
                        <pre class="code-block"><code class="language-python"># security.py
import re
import secrets
import hashlib
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from fastapi import HTTPException, Request, Depends
from pydantic import BaseModel, validator
import logging

logger = logging.getLogger(__name__)

class PasswordPolicy:
    """パスワードポリシー検証"""
    MIN_LENGTH = 8
    MAX_LENGTH = 128
    
    @staticmethod
    def validate_password(password: str) -> tuple[bool, list[str]]:
        """パスワード強度チェック"""
        errors = []
        
        if len(password) < PasswordPolicy.MIN_LENGTH:
            errors.append(f"パスワードは{PasswordPolicy.MIN_LENGTH}文字以上である必要があります")
        
        if len(password) > PasswordPolicy.MAX_LENGTH:
            errors.append(f"パスワードは{PasswordPolicy.MAX_LENGTH}文字以下である必要があります")
        
        if not re.search(r'[A-Z]', password):
            errors.append("パスワードには大文字を含めてください")
        
        if not re.search(r'[a-z]', password):
            errors.append("パスワードには小文字を含めてください")
        
        if not re.search(r'\d', password):
            errors.append("パスワードには数字を含めてください")
        
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
            errors.append("パスワードには記号を含めてください")
        
        # 共通パスワードチェック
        common_passwords = ["password", "123456", "qwerty", "admin"]
        if password.lower() in common_passwords:
            errors.append("よく使用されるパスワードは使用できません")
        
        return len(errors) == 0, errors

class RateLimiter:
    """レート制限実装"""
    def __init__(self, max_requests: int = 5, window_minutes: int = 15):
        self.max_requests = max_requests
        self.window_minutes = window_minutes
        self.attempts: Dict[str, list] = {}
    
    def is_allowed(self, identifier: str) -> bool:
        """リクエスト許可チェック"""
        now = datetime.utcnow()
        window_start = now - timedelta(minutes=self.window_minutes)
        
        if identifier not in self.attempts:
            self.attempts[identifier] = []
        
        # 古い記録を削除
        self.attempts[identifier] = [
            attempt for attempt in self.attempts[identifier]
            if attempt > window_start
        ]
        
        # リクエスト数チェック
        if len(self.attempts[identifier]) >= self.max_requests:
            return False
        
        # 新しいリクエストを記録
        self.attempts[identifier].append(now)
        return True
    
    def get_remaining_time(self, identifier: str) -> int:
        """次回リクエスト可能まで時間（秒）"""
        if identifier not in self.attempts or not self.attempts[identifier]:
            return 0
        
        oldest_attempt = min(self.attempts[identifier])
        next_allowed = oldest_attempt + timedelta(minutes=self.window_minutes)
        remaining = next_allowed - datetime.utcnow()
        
        return max(0, int(remaining.total_seconds()))

# グローバルレート制限インスタンス
login_rate_limiter = RateLimiter(max_requests=5, window_minutes=15)

class SecureUserRegistration(BaseModel):
    username: str
    email: str
    password: str
    confirm_password: str
    
    @validator('username')
    def validate_username(cls, v):
        if not re.match(r'^[a-zA-Z0-9_]{3,20}$', v):
            raise ValueError('ユーザー名は3-20文字の英数字とアンダースコアのみ使用可能です')
        return v
    
    @validator('password')
    def validate_password(cls, v):
        is_valid, errors = PasswordPolicy.validate_password(v)
        if not is_valid:
            raise ValueError('; '.join(errors))
        return v
    
    @validator('confirm_password')
    def passwords_match(cls, v, values):
        if 'password' in values and v != values['password']:
            raise ValueError('パスワードが一致しません')
        return v

def get_client_ip(request: Request) -> str:
    """クライアントIP取得"""
    # プロキシ経由の場合のX-Forwarded-Forヘッダーも考慮
    forwarded_for = request.headers.get("X-Forwarded-For")
    if forwarded_for:
        return forwarded_for.split(",")[0].strip()
    return request.client.host

async def rate_limit_check(request: Request):
    """レート制限チェック依存性"""
    client_ip = get_client_ip(request)
    
    if not login_rate_limiter.is_allowed(client_ip):
        remaining_time = login_rate_limiter.get_remaining_time(client_ip)
        
        logger.warning(f"Rate limit exceeded for IP: {client_ip}")
        
        raise HTTPException(
            status_code=429,
            detail=f"リクエスト制限に達しました。{remaining_time}秒後に再試行してください",
            headers={"Retry-After": str(remaining_time)}
        )

def generate_secure_token() -> str:
    """セキュアなトークン生成"""
    return secrets.token_urlsafe(32)

def hash_sensitive_data(data: str) -> str:
    """機密データのハッシュ化"""
    return hashlib.sha256(data.encode()).hexdigest()

# セキュリティ強化されたエンドポイント
@app.post("/secure/register")
async def secure_register(
    user_data: SecureUserRegistration,
    request: Request,
    _: None = Depends(rate_limit_check)  # レート制限適用
):
    """セキュアなユーザー登録"""
    
    client_ip = get_client_ip(request)
    
    # セキュリティログ出力
    logger.info(f"User registration attempt: {user_data.username} from IP: {client_ip}")
    
    # パスワードハッシュ化（実際のDBに保存）
    hashed_password = get_password_hash(user_data.password)
    
    # ユーザー情報（パスワードは除外してレスポンス）
    user_response = {
        "username": user_data.username,
        "email": user_data.email,
        "created_at": datetime.utcnow().isoformat()
    }
    
    logger.info(f"User registered successfully: {user_data.username}")
    
    return {
        "message": "ユーザー登録が完了しました",
        "user": user_response
    }

@app.post("/secure/login")
async def secure_login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    request: Request = None,
    _: None = Depends(rate_limit_check)
):
    """セキュアなログイン"""
    
    client_ip = get_client_ip(request)
    
    # ログイン試行ログ
    logger.info(f"Login attempt: {form_data.username} from IP: {client_ip}")
    
    user = authenticate_user(form_data.username, form_data.password)
    
    if not user:
        # セキュリティのため、詳細なエラー情報は避ける
        logger.warning(f"Failed login attempt: {form_data.username} from IP: {client_ip}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ログイン情報が正しくありません",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 成功ログ
    logger.info(f"Successful login: {form_data.username} from IP: {client_ip}")
    
    # JWTトークン生成
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user["username"], "roles": user["roles"]},
        expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}</code></pre>
                    </div>

                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <strong>JWTトークンの3つの部分を順番に挙げてください。</strong>
                                <details><summary>解答</summary><p>Header（ヘッダー）、Payload（ペイロード）、Signature（署名）</p></details>
                            </li>
                            <li>
                                <strong>パスワードを安全にハッシュ化するためのPythonライブラリは？</strong>
                                <details><summary>解答</summary><p>passlib (bcryptアルゴリズム使用)</p></details>
                            </li>
                            <li>
                                <strong>OAuth2PasswordBearerで設定するtokenUrlパラメータの役割は？</strong>
                                <details><summary>解答</summary><p>トークンを取得するためのエンドポイントURLを指定</p></details>
                            </li>
                        </ol>
                    </div>

                    <h3 class="section-title">7.4 まとめ</h3>
                    <div class="highlight">
                        <h6>この章で習得したスキル</h6>
                        <ul>
                            <li>JWT認証システムの実装と運用</li>
                            <li>OAuth2プロトコルに準拠した認証フロー</li>
                            <li>ロールベースアクセス制御（RBAC）設計</li>
                            <li>パスワードセキュリティとハッシュ化</li>
                            <li>レート制限とセキュリティ強化</li>
                            <li>セキュリティログと監査機能</li>
                        </ul>
                    </div>

                    <div class="d-flex justify-content-between mt-4">
                        <a href="fastapi-learning-material-06.html" class="btn btn-secondary">← 前の章: データベース連携とORM</a>
                        <a href="fastapi-learning-material-08.html" class="btn btn-primary">次の章: 非同期処理とパフォーマンス最適化 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>mermaid.initialize({ startOnLoad: true, theme: 'default' });</script>
</body>
</html>