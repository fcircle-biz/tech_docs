<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python SQLModel学習教材 第4章 - リレーションシップと結合</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        
        .navbar {
            background-color: #306998;
        }
        
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        
        .chapter-title {
            color: #306998;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #306998;
            padding-bottom: 0.5rem;
        }
        
        .section-title {
            color: #4b8bbe;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        
        .quiz-container {
            background-color: #e6f2ff;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #306998;
        }
        
        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }
        
        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }
        
        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }
        
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }
        
        .nav-link.active {
            background-color: #306998 !important;
            color: white !important;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Python SQLModel 学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../README.html">概要</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="https://sqlmodel.tiangolo.com/" target="_blank">公式ドキュメント</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- Sidebar -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
                <div class="position-sticky pt-3">
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-01.html">
                                第1章: SQLModel入門と環境構築
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-02.html">
                                第2章: モデル定義と型安全性
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-03.html">
                                第3章: 基本的なCRUD操作
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="python-sqlmodel-learning-material-04.html">
                                第4章: リレーションシップと結合
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-05.html">
                                第5章: FastAPIとの統合開発
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-06.html">
                                第6章: 高度なクエリとパフォーマンス
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-07.html">
                                第7章: データベースマイグレーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-08.html">
                                第8章: 実践的なWeb API開発
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- Main Content -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第4章: リレーションシップと結合</h1>
                </div>

                <div id="chapter4">
                    <h2 class="chapter-title">型安全なリレーションシップの定義</h2>
                    
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>1対多（One-to-Many）リレーションシップの定義</li>
                            <li>多対多（Many-to-Many）リレーションシップの実装</li>
                            <li>外部キー制約とカスケード操作</li>
                            <li>関連データの効率的な取得方法</li>
                            <li>型安全なリレーションシップの活用</li>
                            <li>JOINクエリとEager Loading</li>
                        </ul>
                    </div>

                    <h3 class="section-title">4.1 1対多リレーションシップ</h3>
                    <p>最も一般的なリレーションシップパターンである1対多の関係を学習します。ユーザーと投稿の関係を例に、実装方法を理解しましょう。</p>
                    
                    <div class="exercise-container">
                        <h5>実習 4-1: 1対多リレーションシップの実装</h5>
                        <p>ユーザーと投稿の1対多関係を定義し、関連データの操作を学習します。</p>
                        
                        <h6>実行例 (relationship_models.py)</h6>
                        <pre class="code-block"><code class="language-python">from datetime import datetime
from typing import List, Optional
from sqlmodel import SQLModel, Field, Relationship

class User(SQLModel, table=True):
    __tablename__ = "users"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    username: str = Field(max_length=50, unique=True, index=True)
    email: str = Field(max_length=255, unique=True, index=True)
    full_name: Optional[str] = Field(default=None, max_length=200)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    is_active: bool = Field(default=True)
    
    # 1対多のリレーションシップ（1人のユーザーが複数の投稿を持つ）
    posts: List["Post"] = Relationship(back_populates="author")

class Post(SQLModel, table=True):
    __tablename__ = "posts"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    title: str = Field(min_length=1, max_length=200)
    content: str = Field(min_length=1)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: Optional[datetime] = Field(default=None)
    is_published: bool = Field(default=False)
    
    # 外部キー
    author_id: int = Field(foreign_key="users.id")
    
    # 多対1のリレーションシップ（複数の投稿が1人のユーザーに属する）
    author: User = Relationship(back_populates="posts")

# データベース作成とテストデータ
from sqlmodel import create_engine, Session, select

DATABASE_URL = "sqlite:///./relationships.db"
engine = create_engine(DATABASE_URL, echo=True)

def create_tables():
    SQLModel.metadata.create_all(engine)

def create_user_with_posts():
    """ユーザーと投稿を作成"""
    with Session(engine) as session:
        # ユーザー作成
        user = User(
            username="john_blogger",
            email="john@blog.com",
            full_name="John Blogger"
        )
        session.add(user)
        session.flush()  # IDを取得
        
        # 投稿作成
        posts = [
            Post(
                title="SQLModelの基礎",
                content="SQLModelの基本的な使い方について...",
                author_id=user.id,
                is_published=True
            ),
            Post(
                title="Pythonでのデータベース操作",
                content="効率的なデータベース操作の方法...",
                author_id=user.id,
                is_published=False
            ),
            Post(
                title="FastAPIとSQLModelの統合",
                content="FastAPIでSQLModelを活用する方法...",
                author_id=user.id,
                is_published=True
            )
        ]
        
        for post in posts:
            session.add(post)
        
        session.commit()
        return user.id

def get_user_with_posts(user_id: int):
    """ユーザーとその投稿を取得"""
    with Session(engine) as session:
        # ユーザーを取得
        user = session.get(User, user_id)
        if not user:
            return None
        
        # 関連する投稿を明示的に取得
        statement = select(Post).where(Post.author_id == user_id)
        posts = session.exec(statement).all()
        
        return user, posts

if __name__ == "__main__":
    create_tables()
    user_id = create_user_with_posts()
    
    # データ取得
    user, posts = get_user_with_posts(user_id)
    print(f"ユーザー: {user.username}")
    print(f"投稿数: {len(posts)}")
    for post in posts:
        print(f"  - {post.title} ({'公開' if post.is_published else '下書き'})")</code></pre>
                    </div>

                    <h3 class="section-title">4.2 多対多リレーションシップ</h3>
                    <p>投稿とタグの関係など、多対多のリレーションシップを実装します。中間テーブルを使用した複雑な関係を理解しましょう。</p>

                    <div class="exercise-container">
                        <h5>実習 4-2: 多対多リレーションシップの実装</h5>
                        <p>投稿とタグの多対多関係を中間テーブルを使って実装します。</p>
                        
                        <h6>実行例 (many_to_many.py)</h6>
                        <pre class="code-block"><code class="language-python">from typing import List, Optional
from sqlmodel import SQLModel, Field, Relationship

# 中間テーブル（投稿とタグの関連を管理）
class PostTagLink(SQLModel, table=True):
    __tablename__ = "post_tag_links"
    
    post_id: Optional[int] = Field(
        default=None, 
        foreign_key="posts.id", 
        primary_key=True
    )
    tag_id: Optional[int] = Field(
        default=None, 
        foreign_key="tags.id", 
        primary_key=True
    )
    created_at: datetime = Field(default_factory=datetime.utcnow)

class Tag(SQLModel, table=True):
    __tablename__ = "tags"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str = Field(max_length=50, unique=True, index=True)
    description: Optional[str] = Field(default=None, max_length=200)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    # 多対多のリレーションシップ
    posts: List["Post"] = Relationship(
        back_populates="tags",
        link_model=PostTagLink
    )

# 既存のPostモデルに多対多関係を追加
class Post(SQLModel, table=True):
    __tablename__ = "posts"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    title: str = Field(min_length=1, max_length=200)
    content: str = Field(min_length=1)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: Optional[datetime] = Field(default=None)
    is_published: bool = Field(default=False)
    
    # 1対多の関係
    author_id: int = Field(foreign_key="users.id")
    author: User = Relationship(back_populates="posts")
    
    # 多対多の関係
    tags: List[Tag] = Relationship(
        back_populates="posts",
        link_model=PostTagLink
    )

def create_tags_and_posts():
    """タグと投稿を作成し、関連付けを行う"""
    with Session(engine) as session:
        # タグを作成
        tags = [
            Tag(name="Python", description="Python関連の内容"),
            Tag(name="Web開発", description="Web開発に関する内容"),
            Tag(name="データベース", description="データベース関連の内容"),
            Tag(name="API", description="API開発に関する内容"),
            Tag(name="チュートリアル", description="学習用のチュートリアル")
        ]
        
        for tag in tags:
            session.add(tag)
        session.flush()
        
        # ユーザーを作成
        user = User(
            username="tech_writer",
            email="writer@tech.com",
            full_name="Tech Writer"
        )
        session.add(user)
        session.flush()
        
        # 投稿を作成
        posts = [
            Post(
                title="Python Web開発入門",
                content="PythonでWebアプリを開発する方法...",
                author_id=user.id,
                is_published=True
            ),
            Post(
                title="SQLModelでAPI開発",
                content="SQLModelを使ったAPI開発手法...",
                author_id=user.id,
                is_published=True
            ),
            Post(
                title="データベース設計のベストプラクティス",
                content="効率的なデータベース設計について...",
                author_id=user.id,
                is_published=False
            )
        ]
        
        for post in posts:
            session.add(post)
        session.flush()
        
        # タグと投稿を関連付け
        # 投稿1: Python, Web開発, チュートリアル
        session.add(PostTagLink(post_id=posts[0].id, tag_id=tags[0].id))  # Python
        session.add(PostTagLink(post_id=posts[0].id, tag_id=tags[1].id))  # Web開発
        session.add(PostTagLink(post_id=posts[0].id, tag_id=tags[4].id))  # チュートリアル
        
        # 投稿2: Python, API, データベース
        session.add(PostTagLink(post_id=posts[1].id, tag_id=tags[0].id))  # Python
        session.add(PostTagLink(post_id=posts[1].id, tag_id=tags[2].id))  # データベース
        session.add(PostTagLink(post_id=posts[1].id, tag_id=tags[3].id))  # API
        
        # 投稿3: データベース
        session.add(PostTagLink(post_id=posts[2].id, tag_id=tags[2].id))  # データベース
        
        session.commit()
        return posts

def get_posts_with_tags():
    """投稿とそのタグを取得"""
    with Session(engine) as session:
        # 投稿を取得
        statement = select(Post).where(Post.is_published == True)
        posts = session.exec(statement).all()
        
        for post in posts:
            # 各投稿のタグを取得
            tag_statement = select(Tag).join(PostTagLink).where(
                PostTagLink.post_id == post.id
            )
            tags = session.exec(tag_statement).all()
            
            print(f"\n投稿: {post.title}")
            print(f"タグ: {', '.join([tag.name for tag in tags])}")

def get_posts_by_tag(tag_name: str):
    """特定のタグが付いた投稿を取得"""
    with Session(engine) as session:
        statement = select(Post).join(PostTagLink).join(Tag).where(
            Tag.name == tag_name
        )
        posts = session.exec(statement).all()
        return posts

if __name__ == "__main__":
    create_tables()
    posts = create_tags_and_posts()
    
    # データ表示
    get_posts_with_tags()
    
    # 特定タグの投稿を検索
    python_posts = get_posts_by_tag("Python")
    print(f"\nPythonタグの投稿数: {len(python_posts)}")
    for post in python_posts:
        print(f"  - {post.title}")</code></pre>
                    </div>

                    <h3 class="section-title">4.3 JOINクエリとEager Loading</h3>
                    <p>効率的な関連データの取得方法を学習します。N+1問題を回避し、パフォーマンスを向上させるテクニックを習得しましょう。</p>

                    <div class="exercise-container">
                        <h5>実習 4-3: 効率的な関連データ取得</h5>
                        <p>JOINクエリを使用した効率的なデータ取得方法を実装します。</p>
                        
                        <h6>実行例 (join_queries.py)</h6>
                        <pre class="code-block"><code class="language-python">from sqlmodel import select, join
from sqlalchemy.orm import selectinload

def get_users_with_posts_efficient():
    """効率的なユーザーと投稿の取得（JOINクエリ）"""
    with Session(engine) as session:
        # JOINを使用した一度のクエリで関連データを取得
        statement = (
            select(User, Post)
            .join(Post, User.id == Post.author_id)
            .where(Post.is_published == True)
        )
        
        results = session.exec(statement).all()
        
        # 結果を整理
        user_posts = {}
        for user, post in results:
            if user.id not in user_posts:
                user_posts[user.id] = {
                    'user': user,
                    'posts': []
                }
            user_posts[user.id]['posts'].append(post)
        
        return user_posts

def get_posts_with_authors_and_tags():
    """投稿と作者、タグを一度のクエリで取得"""
    with Session(engine) as session:
        statement = (
            select(Post)
            .join(User, Post.author_id == User.id)
            .join(PostTagLink, Post.id == PostTagLink.post_id, isouter=True)
            .join(Tag, PostTagLink.tag_id == Tag.id, isouter=True)
            .where(Post.is_published == True)
        )
        
        results = session.exec(statement).all()
        return results

def get_user_posts_count():
    """ユーザーごとの投稿数を取得（集計クエリ）"""
    with Session(engine) as session:
        from sqlalchemy import func
        
        statement = (
            select(User.username, func.count(Post.id).label('post_count'))
            .join(Post, User.id == Post.author_id, isouter=True)
            .group_by(User.id, User.username)
        )
        
        results = session.exec(statement).all()
        for username, count in results:
            print(f"{username}: {count}件の投稿")

def get_popular_tags():
    """人気のタグを投稿数と一緒に取得"""
    with Session(engine) as session:
        from sqlalchemy import func
        
        statement = (
            select(Tag.name, func.count(PostTagLink.post_id).label('usage_count'))
            .join(PostTagLink, Tag.id == PostTagLink.tag_id)
            .group_by(Tag.id, Tag.name)
            .order_by(func.count(PostTagLink.post_id).desc())
        )
        
        results = session.exec(statement).all()
        print("人気タグランキング:")
        for i, (tag_name, count) in enumerate(results, 1):
            print(f"{i}. {tag_name}: {count}回使用")

def search_posts_with_filters(
    tag_name: Optional[str] = None,
    author_username: Optional[str] = None,
    published_only: bool = True
):
    """複数条件での投稿検索"""
    with Session(engine) as session:
        statement = select(Post).join(User, Post.author_id == User.id)
        
        # タグでフィルタリング
        if tag_name:
            statement = statement.join(PostTagLink).join(Tag).where(
                Tag.name == tag_name
            )
        
        # 作者でフィルタリング
        if author_username:
            statement = statement.where(User.username == author_username)
        
        # 公開状態でフィルタリング
        if published_only:
            statement = statement.where(Post.is_published == True)
        
        posts = session.exec(statement).all()
        return posts

# N+1問題の回避例
def avoid_n_plus_1_problem():
    """N+1問題を回避した効率的なデータ取得"""
    with Session(engine) as session:
        # 悪い例：N+1問題が発生
        print("=== 悪い例（N+1問題） ===")
        users = session.exec(select(User)).all()
        for user in users:
            # 各ユーザーごとに追加のクエリが実行される
            posts = session.exec(select(Post).where(Post.author_id == user.id)).all()
            print(f"{user.username}: {len(posts)}件の投稿")
        
        print("\n=== 良い例（JOINを使用） ===")
        # 良い例：JOINで一度に取得
        statement = (
            select(User.username, func.count(Post.id).label('post_count'))
            .join(Post, User.id == Post.author_id, isouter=True)
            .group_by(User.id, User.username)
        )
        results = session.exec(statement).all()
        for username, count in results:
            print(f"{username}: {count}件の投稿")

if __name__ == "__main__":
    # 効率的なデータ取得のテスト
    print("=== ユーザーと投稿の効率的取得 ===")
    user_posts = get_users_with_posts_efficient()
    for user_id, data in user_posts.items():
        user = data['user']
        posts = data['posts']
        print(f"{user.username}: {len(posts)}件の公開投稿")
    
    print("\n=== ユーザーごとの投稿数 ===")
    get_user_posts_count()
    
    print("\n=== 人気タグ ===")
    get_popular_tags()
    
    print("\n=== N+1問題の回避 ===")
    avoid_n_plus_1_problem()</code></pre>
                    </div>

                    <h3 class="section-title">4.4 カスケード操作と外部キー制約</h3>
                    <p>関連データの整合性を保つためのカスケード操作と外部キー制約について学習します。</p>

                    <div class="warning">
                        <h6>カスケード操作の種類</h6>
                        <ul>
                            <li><strong>CASCADE</strong>: 親レコード削除時に子レコードも削除</li>
                            <li><strong>SET NULL</strong>: 親レコード削除時に外部キーをNULLに設定</li>
                            <li><strong>RESTRICT</strong>: 子レコードが存在する場合、親レコードの削除を禁止</li>
                            <li><strong>SET DEFAULT</strong>: 親レコード削除時に外部キーをデフォルト値に設定</li>
                        </ul>
                    </div>

                    <pre class="code-block"><code class="language-python"># カスケード削除の例
class Post(SQLModel, table=True):
    __tablename__ = "posts"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    title: str = Field(min_length=1, max_length=200)
    content: str
    
    # カスケード削除を設定
    author_id: int = Field(foreign_key="users.id", ondelete="CASCADE")
    author: User = Relationship(back_populates="posts")

# 外部キー制約のテスト
def test_foreign_key_constraints():
    with Session(engine) as session:
        try:
            # 存在しないユーザーIDを指定
            invalid_post = Post(
                title="無効な投稿",
                content="存在しないユーザーに関連付け",
                author_id=999999  # 存在しないID
            )
            session.add(invalid_post)
            session.commit()
        except Exception as e:
            session.rollback()
            print(f"外部キー制約エラー: {e}")</code></pre>

                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>1対多と多対多リレーションシップの主な違いは何ですか？</li>
                            <li>N+1問題とは何で、どのように回避できますか？</li>
                            <li>中間テーブル（Link Model）が必要な場面はいつですか？</li>
                            <li>JOINクエリでisouterパラメータを使用する理由は？</li>
                            <li>カスケード削除を使用する際の注意点は何ですか？</li>
                        </ol>
                        
                        <details class="mt-3">
                            <summary>解答例</summary>
                            <ol>
                                <li>1対多：一つの親に複数の子、多対多：複数対複数で中間テーブルが必要</li>
                                <li>関連データ取得で大量のクエリが発生する問題。JOINや事前読み込みで回避</li>
                                <li>多対多関係を実装する時や、関連に追加属性が必要な時</li>
                                <li>LEFT JOINを実行して、関連データがなくても親データを取得するため</li>
                                <li>意図しないデータ削除、パフォーマンス影響、復旧困難性</li>
                            </ol>
                        </details>
                    </div>

                    <div class="d-flex justify-content-between mt-4">
                        <a href="python-sqlmodel-learning-material-03.html" class="btn btn-secondary">← 前の章：基本的なCRUD操作</a>
                        <a href="python-sqlmodel-learning-material-05.html" class="btn btn-primary">次の章：FastAPIとの統合開発 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
</body>
</html>