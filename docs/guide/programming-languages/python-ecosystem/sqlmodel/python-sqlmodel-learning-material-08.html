<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python SQLModel学習教材 第8章 - 実践的なWeb API開発</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        
        .navbar {
            background-color: #306998;
        }
        
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        
        .chapter-title {
            color: #306998;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #306998;
            padding-bottom: 0.5rem;
        }
        
        .section-title {
            color: #4b8bbe;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        
        .quiz-container {
            background-color: #e6f2ff;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #306998;
        }
        
        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }
        
        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }
        
        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }
        
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }
        
        .nav-link.active {
            background-color: #306998 !important;
            color: white !important;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Python SQLModel 学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../README.html">概要</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="https://sqlmodel.tiangolo.com/" target="_blank">公式ドキュメント</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- Sidebar -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
                <div class="position-sticky pt-3">
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-01.html">
                                第1章: SQLModel入門と環境構築
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-02.html">
                                第2章: モデル定義と型安全性
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-03.html">
                                第3章: 基本的なCRUD操作
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-04.html">
                                第4章: リレーションシップと結合
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-05.html">
                                第5章: FastAPIとの統合開発
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-06.html">
                                第6章: 高度なクエリとパフォーマンス
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-07.html">
                                第7章: データベースマイグレーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="python-sqlmodel-learning-material-08.html">
                                第8章: 実践的なWeb API開発
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- Main Content -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第8章: 実践的なWeb API開発</h1>
                </div>

                <div id="chapter8">
                    <h2 class="chapter-title">エンタープライズレベルのAPI開発</h2>
                    
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>認証・認可システムの実装</li>
                            <li>ファイルアップロード処理の実装</li>
                            <li>非同期処理との統合</li>
                            <li>テスト駆動開発（TDD）の実践</li>
                            <li>本番環境でのベストプラクティス</li>
                            <li>完全なブログAPIアプリケーションの構築</li>
                        </ul>
                    </div>

                    <h3 class="section-title">8.1 認証・認可システムの実装</h3>
                    <p>本格的なWebアプリケーションには認証・認可システムが不可欠です。JWTトークンを使用したセキュアな認証システムを実装します。</p>
                    
                    <div class="exercise-container">
                        <h5>実習 8-1: JWT認証システムの実装</h5>
                        <p>JWTトークンを使用した認証・認可システムを実装します。</p>
                        
                        <h6>依存関係の追加</h6>
                        <pre class="code-block"><code class="language-bash"># 認証関連パッケージのインストール
pip install python-jose[cryptography] passlib[bcrypt] python-multipart</code></pre>
                        
                        <h6>実行例 (app/auth.py)</h6>
                        <pre class="code-block"><code class="language-python">import os
from datetime import datetime, timedelta
from typing import Optional, Union
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import JWTError, jwt
from passlib.context import CryptContext
from sqlmodel import Session, select
from .database import get_session
from .models import User

# 設定
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key-here")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# パスワードハッシュ化
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# OAuth2スキーム
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/token")

class AuthService:
    """認証サービスクラス"""
    
    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        """パスワード検証"""
        return pwd_context.verify(plain_password, hashed_password)
    
    @staticmethod
    def get_password_hash(password: str) -> str:
        """パスワードハッシュ化"""
        return pwd_context.hash(password)
    
    @staticmethod
    def authenticate_user(session: Session, username: str, password: str) -> Optional[User]:
        """ユーザー認証"""
        statement = select(User).where(User.username == username)
        user = session.exec(statement).first()
        
        if not user:
            return None
        if not AuthService.verify_password(password, user.password_hash):
            return None
        
        return user
    
    @staticmethod
    def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
        """アクセストークン作成"""
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=15)
        
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    @staticmethod
    def get_current_user(
        token: str = Depends(oauth2_scheme),
        session: Session = Depends(get_session)
    ) -> User:
        """現在のユーザー取得"""
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="認証情報を検証できません",
            headers={"WWW-Authenticate": "Bearer"},
        )
        
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
        except JWTError:
            raise credentials_exception
        
        statement = select(User).where(User.username == username)
        user = session.exec(statement).first()
        
        if user is None:
            raise credentials_exception
        
        return user
    
    @staticmethod
    def get_current_active_user(current_user: User = Depends(get_current_user)) -> User:
        """アクティブなユーザー取得"""
        if not current_user.is_active:
            raise HTTPException(status_code=400, detail="非アクティブユーザーです")
        return current_user

# 権限チェック関数
def require_permission(permission: str):
    """権限チェックデコレータ"""
    def permission_checker(current_user: User = Depends(AuthService.get_current_active_user)):
        # 実際の実装では、ユーザーの権限をチェック
        if not current_user.is_admin and permission == "admin":
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="この操作を実行する権限がありません"
            )
        return current_user
    return permission_checker</code></pre>
                        
                        <h6>実行例 (app/routers/auth.py)</h6>
                        <pre class="code-block"><code class="language-python">from datetime import timedelta
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlmodel import Session
from ..database import get_session
from ..auth import AuthService, ACCESS_TOKEN_EXPIRE_MINUTES
from ..models import User
from ..schemas import UserCreate, UserRead, Token

router = APIRouter(prefix="/auth", tags=["authentication"])

@router.post("/register", response_model=UserRead, status_code=201)
def register_user(
    user_data: UserCreate,
    session: Session = Depends(get_session)
):
    """新規ユーザー登録"""
    # ユーザー名重複チェック
    existing_user = session.exec(
        select(User).where(User.username == user_data.username)
    ).first()
    
    if existing_user:
        raise HTTPException(
            status_code=400,
            detail="ユーザー名は既に使用されています"
        )
    
    # メールアドレス重複チェック
    existing_email = session.exec(
        select(User).where(User.email == user_data.email)
    ).first()
    
    if existing_email:
        raise HTTPException(
            status_code=400,
            detail="メールアドレスは既に使用されています"
        )
    
    # パスワードハッシュ化
    hashed_password = AuthService.get_password_hash(user_data.password)
    
    # ユーザー作成
    user = User(
        username=user_data.username,
        email=user_data.email,
        full_name=user_data.full_name,
        password_hash=hashed_password
    )
    
    session.add(user)
    session.commit()
    session.refresh(user)
    
    return user

@router.post("/token", response_model=Token)
def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    session: Session = Depends(get_session)
):
    """ログインしてアクセストークンを取得"""
    user = AuthService.authenticate_user(
        session, form_data.username, form_data.password
    )
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ユーザー名またはパスワードが正しくありません",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = AuthService.create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/me", response_model=UserRead)
def read_users_me(current_user: User = Depends(AuthService.get_current_active_user)):
    """現在のユーザー情報を取得"""
    return current_user

@router.put("/me", response_model=UserRead)
def update_user_me(
    user_update: UserUpdate,
    current_user: User = Depends(AuthService.get_current_active_user),
    session: Session = Depends(get_session)
):
    """現在のユーザー情報を更新"""
    update_data = user_update.dict(exclude_unset=True)
    
    for field, value in update_data.items():
        if field != "password":  # パスワード更新は別エンドポイントで
            setattr(current_user, field, value)
    
    current_user.updated_at = datetime.utcnow()
    session.add(current_user)
    session.commit()
    session.refresh(current_user)
    
    return current_user</code></pre>
                    </div>

                    <h3 class="section-title">8.2 ファイルアップロード処理</h3>
                    <p>画像アップロードなど、ファイル処理機能を実装します。セキュリティを考慮した安全なファイルアップロード機能を構築しましょう。</p>

                    <div class="exercise-container">
                        <h5>実習 8-2: ファイルアップロード機能の実装</h5>
                        <p>プロフィール画像やブログ投稿の画像アップロード機能を実装します。</p>
                        
                        <h6>実行例 (app/routers/files.py)</h6>
                        <pre class="code-block"><code class="language-python">import os
import uuid
from pathlib import Path
from typing import List
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, status
from fastapi.responses import FileResponse
from PIL import Image
import aiofiles
from ..auth import AuthService
from ..models import User

router = APIRouter(prefix="/files", tags=["files"])

# 設定
UPLOAD_DIR = Path("uploads")
UPLOAD_DIR.mkdir(exist_ok=True)
MAX_FILE_SIZE = 5 * 1024 * 1024  # 5MB
ALLOWED_EXTENSIONS = {".jpg", ".jpeg", ".png", ".gif"}
ALLOWED_MIME_TYPES = {"image/jpeg", "image/png", "image/gif"}

class FileService:
    """ファイル処理サービス"""
    
    @staticmethod
    def validate_file(file: UploadFile) -> None:
        """ファイルバリデーション"""
        # ファイルサイズチェック
        if file.size > MAX_FILE_SIZE:
            raise HTTPException(
                status_code=413,
                detail=f"ファイルサイズが大きすぎます。上限: {MAX_FILE_SIZE / 1024 / 1024}MB"
            )
        
        # MIMEタイプチェック
        if file.content_type not in ALLOWED_MIME_TYPES:
            raise HTTPException(
                status_code=400,
                detail=f"サポートされていないファイル形式です。対応形式: {', '.join(ALLOWED_MIME_TYPES)}"
            )
        
        # 拡張子チェック
        file_extension = Path(file.filename).suffix.lower()
        if file_extension not in ALLOWED_EXTENSIONS:
            raise HTTPException(
                status_code=400,
                detail=f"サポートされていない拡張子です。対応拡張子: {', '.join(ALLOWED_EXTENSIONS)}"
            )
    
    @staticmethod
    def generate_filename(original_filename: str) -> str:
        """安全なファイル名を生成"""
        file_extension = Path(original_filename).suffix.lower()
        unique_id = str(uuid.uuid4())
        return f"{unique_id}{file_extension}"
    
    @staticmethod
    async def save_file(file: UploadFile, filename: str) -> Path:
        """ファイルを保存"""
        file_path = UPLOAD_DIR / filename
        
        async with aiofiles.open(file_path, 'wb') as f:
            content = await file.read()
            await f.write(content)
        
        return file_path
    
    @staticmethod
    def resize_image(file_path: Path, max_size: tuple = (800, 600)) -> None:
        """画像をリサイズ"""
        try:
            with Image.open(file_path) as img:
                # 画像のサイズを確認
                if img.size[0] > max_size[0] or img.size[1] > max_size[1]:
                    # アスペクト比を保持してリサイズ
                    img.thumbnail(max_size, Image.Resampling.LANCZOS)
                    img.save(file_path, optimize=True, quality=85)
        except Exception as e:
            raise HTTPException(
                status_code=500,
                detail=f"画像処理エラー: {str(e)}"
            )

@router.post("/upload-avatar", response_model=dict)
async def upload_avatar(
    file: UploadFile = File(...),
    current_user: User = Depends(AuthService.get_current_active_user)
):
    """プロフィール画像をアップロード"""
    # ファイルバリデーション
    FileService.validate_file(file)
    
    # ファイル名生成
    filename = FileService.generate_filename(file.filename)
    
    try:
        # ファイル保存
        file_path = await FileService.save_file(file, filename)
        
        # 画像リサイズ
        FileService.resize_image(file_path, max_size=(300, 300))
        
        # ユーザーのアバターURLを更新
        avatar_url = f"/api/v1/files/{filename}"
        current_user.avatar_url = avatar_url
        
        # データベース更新
        session.add(current_user)
        session.commit()
        
        return {
            "message": "プロフィール画像がアップロードされました",
            "avatar_url": avatar_url,
            "filename": filename
        }
        
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"ファイルアップロードエラー: {str(e)}"
        )

@router.post("/upload-multiple", response_model=dict)
async def upload_multiple_files(
    files: List[UploadFile] = File(...),
    current_user: User = Depends(AuthService.get_current_active_user)
):
    """複数ファイルのアップロード"""
    if len(files) > 5:
        raise HTTPException(
            status_code=400,
            detail="一度にアップロードできるファイル数は5個までです"
        )
    
    uploaded_files = []
    
    for file in files:
        # ファイルバリデーション
        FileService.validate_file(file)
        
        # ファイル名生成
        filename = FileService.generate_filename(file.filename)
        
        try:
            # ファイル保存
            file_path = await FileService.save_file(file, filename)
            
            # 画像リサイズ
            FileService.resize_image(file_path)
            
            uploaded_files.append({
                "original_name": file.filename,
                "filename": filename,
                "url": f"/api/v1/files/{filename}",
                "size": file.size
            })
            
        except Exception as e:
            # 既にアップロードされたファイルを削除
            for uploaded in uploaded_files:
                try:
                    (UPLOAD_DIR / uploaded["filename"]).unlink(missing_ok=True)
                except:
                    pass
            
            raise HTTPException(
                status_code=500,
                detail=f"ファイルアップロードエラー: {str(e)}"
            )
    
    return {
        "message": f"{len(uploaded_files)}個のファイルがアップロードされました",
        "files": uploaded_files
    }

@router.get("/{filename}")
async def get_file(filename: str):
    """ファイルを取得"""
    file_path = UPLOAD_DIR / filename
    
    if not file_path.exists():
        raise HTTPException(status_code=404, detail="ファイルが見つかりません")
    
    return FileResponse(
        path=file_path,
        filename=filename,
        media_type="application/octet-stream"
    )

@router.delete("/{filename}")
async def delete_file(
    filename: str,
    current_user: User = Depends(AuthService.get_current_active_user)
):
    """ファイルを削除"""
    file_path = UPLOAD_DIR / filename
    
    if not file_path.exists():
        raise HTTPException(status_code=404, detail="ファイルが見つかりません")
    
    try:
        file_path.unlink()
        return {"message": "ファイルが削除されました"}
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"ファイル削除エラー: {str(e)}"
        )</code></pre>
                    </div>

                    <h3 class="section-title">8.3 非同期処理との統合</h3>
                    <p>重い処理を非同期で実行し、ユーザーエクスペリエンスを向上させる方法を学習します。</p>

                    <div class="exercise-container">
                        <h5>実習 8-3: 非同期タスク処理の実装</h5>
                        <p>Celeryを使用した非同期タスク処理を実装します。</p>
                        
                        <h6>依存関係の追加</h6>
                        <pre class="code-block"><code class="language-bash"># 非同期処理用パッケージのインストール
pip install celery[redis] flower</code></pre>
                        
                        <h6>実行例 (app/tasks.py)</h6>
                        <pre class="code-block"><code class="language-python">import os
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from celery import Celery
from typing import List
from .database import engine
from .models import User, Post
from sqlmodel import Session, select

# Celeryの設定
REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379/0")
celery_app = Celery("blog_api", broker=REDIS_URL, backend=REDIS_URL)

celery_app.conf.update(
    task_serializer="json",
    accept_content=["json"],
    result_serializer="json",
    timezone="Asia/Tokyo",
    enable_utc=True,
)

@celery_app.task(bind=True)
def send_email_task(self, to_email: str, subject: str, body: str):
    """メール送信タスク"""
    try:
        # SMTP設定（環境変数から取得）
        smtp_server = os.getenv("SMTP_SERVER", "smtp.gmail.com")
        smtp_port = int(os.getenv("SMTP_PORT", "587"))
        smtp_username = os.getenv("SMTP_USERNAME")
        smtp_password = os.getenv("SMTP_PASSWORD")
        
        if not all([smtp_username, smtp_password]):
            raise ValueError("SMTP認証情報が設定されていません")
        
        # メール作成
        msg = MIMEMultipart()
        msg["From"] = smtp_username
        msg["To"] = to_email
        msg["Subject"] = subject
        
        msg.attach(MIMEText(body, "plain", "utf-8"))
        
        # SMTP接続してメール送信
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()
            server.login(smtp_username, smtp_password)
            server.send_message(msg)
        
        return {"status": "success", "message": f"メールを {to_email} に送信しました"}
        
    except Exception as e:
        # リトライ設定
        raise self.retry(exc=e, countdown=60, max_retries=3)

@celery_app.task
def generate_report_task(user_id: int):
    """レポート生成タスク"""
    with Session(engine) as session:
        # ユーザー取得
        user = session.get(User, user_id)
        if not user:
            return {"status": "error", "message": "ユーザーが見つかりません"}
        
        # ユーザーの投稿統計を取得
        statement = select(Post).where(Post.author_id == user_id)
        posts = session.exec(statement).all()
        
        published_posts = [p for p in posts if p.is_published]
        draft_posts = [p for p in posts if not p.is_published]
        
        # レポート生成
        report = {
            "user_id": user_id,
            "username": user.username,
            "total_posts": len(posts),
            "published_posts": len(published_posts),
            "draft_posts": len(draft_posts),
            "generated_at": datetime.utcnow().isoformat()
        }
        
        # レポートをファイルに保存（実際の実装ではS3などに保存）
        report_path = f"reports/user_{user_id}_report.json"
        os.makedirs("reports", exist_ok=True)
        
        with open(report_path, "w", encoding="utf-8") as f:
            json.dump(report, f, ensure_ascii=False, indent=2)
        
        return {
            "status": "success", 
            "report_path": report_path,
            "report": report
        }

@celery_app.task
def bulk_email_task(user_ids: List[int], subject: str, body: str):
    """一括メール送信タスク"""
    with Session(engine) as session:
        success_count = 0
        error_count = 0
        
        for user_id in user_ids:
            user = session.get(User, user_id)
            if not user or not user.email:
                error_count += 1
                continue
            
            try:
                # 個別のメール送信タスクをキューに追加
                send_email_task.delay(user.email, subject, body)
                success_count += 1
            except Exception:
                error_count += 1
        
        return {
            "status": "completed",
            "success_count": success_count,
            "error_count": error_count
        }

@celery_app.task
def cleanup_old_files_task():
    """古いファイルのクリーンアップタスク"""
    import time
    from pathlib import Path
    
    upload_dir = Path("uploads")
    if not upload_dir.exists():
        return {"status": "success", "message": "アップロードディレクトリが存在しません"}
    
    # 30日以上古いファイルを削除
    cutoff_time = time.time() - (30 * 24 * 60 * 60)
    deleted_count = 0
    
    for file_path in upload_dir.iterdir():
        if file_path.is_file() and file_path.stat().st_mtime < cutoff_time:
            try:
                file_path.unlink()
                deleted_count += 1
            except Exception:
                pass
    
    return {
        "status": "success",
        "deleted_files": deleted_count,
        "message": f"{deleted_count}個の古いファイルを削除しました"
    }</code></pre>
                        
                        <h6>実行例 (app/routers/tasks.py)</h6>
                        <pre class="code-block"><code class="language-python">from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from ..auth import AuthService, require_permission
from ..models import User
from ..tasks import send_email_task, generate_report_task, bulk_email_task
from pydantic import BaseModel, EmailStr
from typing import List

router = APIRouter(prefix="/tasks", tags=["tasks"])

class EmailRequest(BaseModel):
    to_email: EmailStr
    subject: str
    body: str

class BulkEmailRequest(BaseModel):
    user_ids: List[int]
    subject: str
    body: str

@router.post("/send-email")
async def send_email(
    email_request: EmailRequest,
    current_user: User = Depends(AuthService.get_current_active_user)
):
    """メール送信タスクをキューに追加"""
    task = send_email_task.delay(
        email_request.to_email,
        email_request.subject,
        email_request.body
    )
    
    return {
        "message": "メール送信タスクがキューに追加されました",
        "task_id": task.id
    }

@router.post("/generate-report")
async def generate_user_report(
    current_user: User = Depends(AuthService.get_current_active_user)
):
    """ユーザーレポート生成タスクをキューに追加"""
    task = generate_report_task.delay(current_user.id)
    
    return {
        "message": "レポート生成タスクがキューに追加されました",
        "task_id": task.id
    }

@router.post("/bulk-email")
async def send_bulk_email(
    email_request: BulkEmailRequest,
    current_user: User = Depends(require_permission("admin"))
):
    """一括メール送信タスクをキューに追加（管理者のみ）"""
    task = bulk_email_task.delay(
        email_request.user_ids,
        email_request.subject,
        email_request.body
    )
    
    return {
        "message": "一括メール送信タスクがキューに追加されました",
        "task_id": task.id
    }

@router.get("/status/{task_id}")
async def get_task_status(
    task_id: str,
    current_user: User = Depends(AuthService.get_current_active_user)
):
    """タスクの実行状況を取得"""
    from ..tasks import celery_app
    
    task_result = celery_app.AsyncResult(task_id)
    
    if task_result.state == "PENDING":
        response = {
            "task_id": task_id,
            "state": task_result.state,
            "status": "タスクが実行待ちです"
        }
    elif task_result.state == "SUCCESS":
        response = {
            "task_id": task_id,
            "state": task_result.state,
            "result": task_result.result
        }
    else:
        response = {
            "task_id": task_id,
            "state": task_result.state,
            "error": str(task_result.info)
        }
    
    return response</code></pre>
                    </div>

                    <h3 class="section-title">8.4 テスト駆動開発（TDD）</h3>
                    <p>品質の高いAPIを構築するため、包括的なテストスイートを実装します。</p>

                    <div class="exercise-container">
                        <h5>実習 8-4: 統合テストスイートの実装</h5>
                        <p>認証、CRUD操作、ファイルアップロードを含む統合テストを実装します。</p>
                        
                        <h6>実行例 (tests/test_integration.py)</h6>
                        <pre class="code-block"><code class="language-python">import pytest
import tempfile
import os
from fastapi.testclient import TestClient
from sqlmodel import SQLModel, create_engine, Session
from sqlmodel.pool import StaticPool
from app.main import app
from app.database import get_session
from app.models import User, Post
from app.auth import AuthService

# テスト用のインメモリデータベース
@pytest.fixture(name="session")
def session_fixture():
    engine = create_engine(
        "sqlite:///:memory:",
        connect_args={"check_same_thread": False},
        poolclass=StaticPool,
    )
    SQLModel.metadata.create_all(engine)
    with Session(engine) as session:
        yield session

@pytest.fixture(name="client")
def client_fixture(session: Session):
    def get_session_override():
        return session
    
    app.dependency_overrides[get_session] = get_session_override
    client = TestClient(app)
    yield client
    app.dependency_overrides.clear()

@pytest.fixture(name="test_user")
def test_user_fixture(session: Session):
    """テスト用ユーザーを作成"""
    user = User(
        username="testuser",
        email="test@example.com",
        full_name="Test User",
        password_hash=AuthService.get_password_hash("testpassword"),
        is_active=True
    )
    session.add(user)
    session.commit()
    session.refresh(user)
    return user

@pytest.fixture(name="auth_headers")
def auth_headers_fixture(client: TestClient):
    """認証ヘッダーを取得"""
    # ユーザー登録
    client.post("/api/v1/auth/register", json={
        "username": "authuser",
        "email": "auth@example.com",
        "password": "authpassword"
    })
    
    # ログインしてトークンを取得
    response = client.post("/api/v1/auth/token", data={
        "username": "authuser",
        "password": "authpassword"
    })
    
    token = response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}

class TestAuthenticationFlow:
    """認証フローのテスト"""
    
    def test_user_registration(self, client: TestClient):
        """ユーザー登録のテスト"""
        response = client.post("/api/v1/auth/register", json={
            "username": "newuser",
            "email": "newuser@example.com",
            "password": "newpassword",
            "full_name": "New User"
        })
        
        assert response.status_code == 201
        data = response.json()
        assert data["username"] == "newuser"
        assert data["email"] == "newuser@example.com"
        assert "password" not in data
    
    def test_duplicate_registration(self, client: TestClient):
        """重複登録のテスト"""
        # 最初の登録
        client.post("/api/v1/auth/register", json={
            "username": "duplicate",
            "email": "duplicate@example.com",
            "password": "password"
        })
        
        # 重複登録の試行
        response = client.post("/api/v1/auth/register", json={
            "username": "duplicate",
            "email": "different@example.com",
            "password": "password"
        })
        
        assert response.status_code == 400
        assert "既に使用されています" in response.json()["detail"]
    
    def test_login_success(self, client: TestClient):
        """ログイン成功のテスト"""
        # ユーザー登録
        client.post("/api/v1/auth/register", json={
            "username": "loginuser",
            "email": "login@example.com",
            "password": "loginpassword"
        })
        
        # ログイン
        response = client.post("/api/v1/auth/token", data={
            "username": "loginuser",
            "password": "loginpassword"
        })
        
        assert response.status_code == 200
        data = response.json()
        assert "access_token" in data
        assert data["token_type"] == "bearer"
    
    def test_login_failure(self, client: TestClient):
        """ログイン失敗のテスト"""
        response = client.post("/api/v1/auth/token", data={
            "username": "nonexistent",
            "password": "wrongpassword"
        })
        
        assert response.status_code == 401

class TestUserManagement:
    """ユーザー管理のテスト"""
    
    def test_get_current_user(self, client: TestClient, auth_headers: dict):
        """現在のユーザー取得のテスト"""
        response = client.get("/api/v1/auth/me", headers=auth_headers)
        
        assert response.status_code == 200
        data = response.json()
        assert data["username"] == "authuser"
    
    def test_update_user_profile(self, client: TestClient, auth_headers: dict):
        """ユーザープロフィール更新のテスト"""
        response = client.put("/api/v1/auth/me", 
            headers=auth_headers,
            json={"full_name": "Updated Name"}
        )
        
        assert response.status_code == 200
        data = response.json()
        assert data["full_name"] == "Updated Name"

class TestPostManagement:
    """投稿管理のテスト"""
    
    def test_create_post(self, client: TestClient, auth_headers: dict):
        """投稿作成のテスト"""
        response = client.post("/api/v1/posts/", 
            headers=auth_headers,
            json={
                "title": "Test Post",
                "content": "This is a test post",
                "is_published": True
            }
        )
        
        assert response.status_code == 201
        data = response.json()
        assert data["title"] == "Test Post"
        assert data["is_published"] is True
    
    def test_get_posts(self, client: TestClient, auth_headers: dict):
        """投稿一覧取得のテスト"""
        # テスト投稿を作成
        client.post("/api/v1/posts/", 
            headers=auth_headers,
            json={
                "title": "Public Post",
                "content": "This is public",
                "is_published": True
            }
        )
        
        response = client.get("/api/v1/posts/")
        
        assert response.status_code == 200
        data = response.json()
        assert len(data) > 0
    
    def test_unauthorized_post_creation(self, client: TestClient):
        """未認証での投稿作成テスト"""
        response = client.post("/api/v1/posts/", json={
            "title": "Unauthorized Post",
            "content": "This should fail"
        })
        
        assert response.status_code == 401

class TestFileUpload:
    """ファイルアップロードのテスト"""
    
    def test_avatar_upload(self, client: TestClient, auth_headers: dict):
        """アバターアップロードのテスト"""
        # テスト用の画像ファイルを作成
        with tempfile.NamedTemporaryFile(suffix=".jpg", delete=False) as tmp_file:
            # 簡単なJPEGファイルのヘッダー
            tmp_file.write(b'\xff\xd8\xff\xe0\x00\x10JFIF')
            tmp_file.flush()
            
            with open(tmp_file.name, "rb") as f:
                response = client.post("/api/v1/files/upload-avatar",
                    headers=auth_headers,
                    files={"file": ("test.jpg", f, "image/jpeg")}
                )
        
        # テストファイルを削除
        os.unlink(tmp_file.name)
        
        assert response.status_code == 200
        data = response.json()
        assert "avatar_url" in data
        assert "filename" in data

class TestTaskManagement:
    """タスク管理のテスト"""
    
    def test_email_task_creation(self, client: TestClient, auth_headers: dict):
        """メールタスク作成のテスト"""
        response = client.post("/api/v1/tasks/send-email",
            headers=auth_headers,
            json={
                "to_email": "test@example.com",
                "subject": "Test Email",
                "body": "This is a test email"
            }
        )
        
        assert response.status_code == 200
        data = response.json()
        assert "task_id" in data

# パフォーマンステスト
class TestPerformance:
    """パフォーマンステスト"""
    
    def test_bulk_post_creation(self, client: TestClient, auth_headers: dict):
        """大量投稿作成のパフォーマンステスト"""
        import time
        
        start_time = time.time()
        
        # 100件の投稿を作成
        for i in range(100):
            response = client.post("/api/v1/posts/",
                headers=auth_headers,
                json={
                    "title": f"Performance Test Post {i}",
                    "content": f"Content for post {i}",
                    "is_published": True
                }
            )
            assert response.status_code == 201
        
        end_time = time.time()
        duration = end_time - start_time
        
        # 100件の作成が10秒以内に完了することを確認
        assert duration < 10, f"Bulk creation took {duration:.2f} seconds"

# テスト実行
if __name__ == "__main__":
    pytest.main([__file__, "-v"])</code></pre>
                    </div>

                    <h3 class="section-title">8.5 本番環境でのベストプラクティス</h3>
                    <p>本番環境での運用を考慮した最終的な実装とデプロイメント準備を行います。</p>

                    <div class="warning">
                        <h6>本番環境チェックリスト</h6>
                        <ul>
                            <li><strong>セキュリティ</strong>: HTTPS、CORS設定、入力値検証、SQLインジェクション対策</li>
                            <li><strong>パフォーマンス</strong>: データベース接続プール、キャッシング、CDN活用</li>
                            <li><strong>監視</strong>: ログ収集、メトリクス監視、アラート設定</li>
                            <li><strong>可用性</strong>: ロードバランサー、ヘルスチェック、自動復旧</li>
                            <li><strong>バックアップ</strong>: 定期バックアップ、災害復旧計画</li>
                        </ul>
                    </div>

                    <div class="exercise-container">
                        <h5>実習 8-5: 本番環境設定の完成</h5>
                        <p>本番環境での運用に必要な設定とデプロイメント準備を完成させます。</p>
                        
                        <h6>実行例 (app/config.py)</h6>
                        <pre class="code-block"><code class="language-python">import os
from pydantic import BaseSettings

class Settings(BaseSettings):
    """アプリケーション設定"""
    
    # 基本設定
    app_name: str = "Blog API"
    debug: bool = False
    
    # データベース設定
    database_url: str = os.getenv("DATABASE_URL", "sqlite:///./app.db")
    
    # セキュリティ設定
    secret_key: str = os.getenv("SECRET_KEY", "change-me-in-production")
    access_token_expire_minutes: int = 30
    
    # CORS設定
    allowed_origins: list = ["https://yourdomain.com"]
    
    # Redis設定
    redis_url: str = os.getenv("REDIS_URL", "redis://localhost:6379/0")
    
    # メール設定
    smtp_server: str = os.getenv("SMTP_SERVER", "smtp.gmail.com")
    smtp_port: int = int(os.getenv("SMTP_PORT", "587"))
    smtp_username: str = os.getenv("SMTP_USERNAME", "")
    smtp_password: str = os.getenv("SMTP_PASSWORD", "")
    
    # ファイル設定
    max_file_size: int = 5 * 1024 * 1024  # 5MB
    upload_dir: str = "uploads"
    
    # ログ設定
    log_level: str = os.getenv("LOG_LEVEL", "INFO")
    
    class Config:
        env_file = ".env"

settings = Settings()</code></pre>
                        
                        <h6>実行例 (Dockerfile)</h6>
                        <pre class="code-block"><code class="language-dockerfile"># Dockerfile
FROM python:3.11-slim

# 作業ディレクトリの設定
WORKDIR /app

# システムパッケージの更新
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Python依存関係のインストール
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# アプリケーションファイルのコピー
COPY . .

# アップロードディレクトリの作成
RUN mkdir -p uploads

# 非rootユーザーの作成
RUN useradd --create-home --shell /bin/bash app \
    && chown -R app:app /app
USER app

# ポート公開
EXPOSE 8000

# ヘルスチェック
HEALTHCHECK --interval=30s --timeout=30s --start-period=30s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# アプリケーション起動
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]</code></pre>
                        
                        <h6>実行例 (docker-compose.yml)</h6>
                        <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/blogapi
      - REDIS_URL=redis://redis:6379/0
      - SECRET_KEY=your-production-secret-key
    depends_on:
      - db
      - redis
    volumes:
      - ./uploads:/app/uploads
    restart: unless-stopped

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=blogapi
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    restart: unless-stopped

  celery:
    build: .
    command: celery -A app.tasks worker --loglevel=info
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/blogapi
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - db
      - redis
    restart: unless-stopped

  flower:
    build: .
    command: celery -A app.tasks flower --port=5555
    ports:
      - "5555:5555"
    environment:
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - redis
    restart: unless-stopped

volumes:
  postgres_data:</code></pre>
                    </div>

                    <div class="quiz-container">
                        <h5>総合理解度確認クイズ</h5>
                        <ol>
                            <li>JWTトークンの仕組みと利点は何ですか？</li>
                            <li>ファイルアップロードで考慮すべきセキュリティ対策は？</li>
                            <li>非同期タスク処理が必要な場面はどのような時ですか？</li>
                            <li>統合テストで確認すべき項目を5つ挙げてください。</li>
                            <li>本番環境での監視で重要な指標は何ですか？</li>
                            <li>SQLModelを使用した開発の主なメリットを説明してください。</li>
                        </ol>
                        
                        <details class="mt-3">
                            <summary>解答例</summary>
                            <ol>
                                <li>自己完結型トークン、ステートレス、スケーラブル、セキュアな情報伝達</li>
                                <li>ファイル形式検証、サイズ制限、アップロード先の分離、ウイルススキャン</li>
                                <li>メール送信、レポート生成、画像処理、大量データ処理など時間のかかる処理</li>
                                <li>認証フロー、CRUD操作、権限チェック、エラーハンドリング、パフォーマンス</li>
                                <li>レスポンス時間、エラー率、CPU/メモリ使用率、データベース接続数</li>
                                <li>型安全性、コード重複排除、FastAPI統合、自動バリデーション、開発効率向上</li>
                            </ol>
                        </details>
                    </div>

                    <div class="highlight">
                        <h5>学習の完了おめでとうございます！</h5>
                        <p>この章で、SQLModelを使用した実践的なWeb API開発の全体像を学習しました。認証システム、ファイル処理、非同期タスク、テスト駆動開発、本番環境への対応など、エンタープライズレベルのアプリケーション開発に必要な要素を身につけることができました。</p>
                        
                        <p><strong>次のステップ：</strong></p>
                        <ul>
                            <li>実際のプロジェクトでSQLModelを活用する</li>
                            <li>マイクロサービスアーキテクチャの学習</li>
                            <li>GraphQLとの統合</li>
                            <li>Kubernetes等でのコンテナオーケストレーション</li>
                        </ul>
                    </div>

                    <div class="d-flex justify-content-between mt-4">
                        <a href="python-sqlmodel-learning-material-07.html" class="btn btn-secondary">← 前の章：データベースマイグレーション</a>
                        <a href="../README.html" class="btn btn-success">学習ガイドに戻る</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
</body>
</html>