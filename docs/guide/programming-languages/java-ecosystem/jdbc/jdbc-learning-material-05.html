<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JDBC学習教材 第5章 - 高度なJDBC機能</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #f57c00;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }

        /* タイトル */
        .chapter-title {
            color: #f57c00;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #f57c00;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #ff9800;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #fff3e0;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #f57c00;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #f57c00 !important;
            color: white !important;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand">
                <strong>JDBC学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
                <div class="position-sticky pt-3">
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-01.html">第1章: JDBCの基礎</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-02.html">第2章: データベース接続</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-03.html">第3章: 基本的なCRUD操作</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-04.html">第4章: 例外処理とリソース管理</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="jdbc-learning-material-05.html">第5章: 高度なJDBC機能</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-06.html">第6章: JDBCとオブジェクト指向設計</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-07.html">第7章: パフォーマンスとセキュリティ</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-08.html">第8章: 総合プロジェクト - 図書館管理システム</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-09.html">第9章: JDBCリファレンス</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-10.html">第10章: データベース固有の設定</a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <!-- 章ヘッダー -->
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第5章: 高度なJDBC機能</h1>
                </div>

                <div id="chapter5">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">パフォーマンスとスケーラビリティの向上</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>バッチ処理によるパフォーマンス最適化</li>
                            <li>トランザクション管理（commit、rollback）の理論と実践</li>
                            <li>ストアドプロシージャとファンクションの呼び出し</li>
                            <li>在庫管理システムを例にしたトランザクション処理の実装</li>
                            <li>大量データ処理における効率的な手法</li>
                        </ul>
                    </div>

                    <!-- セクション1: バッチ処理 -->
                    <h3 class="section-title">5.1 バッチ処理によるパフォーマンス最適化</h3>
                    <p>バッチ処理は、複数のSQL文をグループ化して一度に実行する技術です。大量のデータを処理する際に、個別実行と比べて大幅な性能向上を実現できます。</p>

                    <div class="mermaid">
                        flowchart TB
                            subgraph "通常の処理"
                                A1[SQL1実行] --> B1[結果待ち]
                                B1 --> A2[SQL2実行]
                                A2 --> B2[結果待ち]
                                A2 --> A3[SQL3実行]
                                A3 --> B3[結果待ち]
                            end
                            
                            subgraph "バッチ処理"
                                C1[SQL1] --> D[バッチに追加]
                                C2[SQL2] --> D
                                C3[SQL3] --> D
                                D --> E[バッチ実行]
                                E --> F[まとめて結果取得]
                            end
                    </div>

                    <h4>バッチ処理の利点</h4>
                    <ul>
                        <li><strong>ネットワーク通信の削減</strong>：複数SQLを一度に送信</li>
                        <li><strong>データベースサーバーの処理効率向上</strong>：最適化された実行プランの活用</li>
                        <li><strong>レスポンス時間の短縮</strong>：特に大量データの挿入・更新で効果的</li>
                        <li><strong>システムリソースの効率的利用</strong>：CPUとメモリの最適化</li>
                    </ul>

                    <!-- 実習1: バッチ処理 -->
                    <div class="exercise-container">
                        <h5>実習 5-1: PreparedStatementバッチ処理</h5>
                        <p>大量のユーザーデータを効率的に挿入するバッチ処理プログラムを作成します。</p>

                        <h6>手順</h6>
                        <ol>
                            <li>バッチ処理用のテーブルを準備</li>
                            <li>通常の挿入処理とバッチ処理の性能を比較</li>
                            <li>エラー処理を含むバッチ処理を実装</li>
                        </ol>

                        <h6>テーブル作成SQL</h6>
                        <pre class="code-block"><code class="language-sql">CREATE TABLE batch_users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    age INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);</code></pre>

                        <h6>バッチ処理実装例</h6>
                        <pre class="code-block"><code class="language-java">public class BatchProcessExample {
    private static final String DB_URL = "jdbc:postgresql://localhost:5432/testdb";
    private static final String DB_USER = "user";
    private static final String DB_PASSWORD = "password";
    
    /**
     * 通常の挿入処理（比較用）
     */
    public void insertUsersNormal(List&lt;User&gt; users) {
        String sql = "INSERT INTO batch_users (name, email, age) VALUES (?, ?, ?)";
        
        try (Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
             PreparedStatement statement = connection.prepareStatement(sql)) {
            
            long startTime = System.currentTimeMillis();
            
            for (User user : users) {
                statement.setString(1, user.getName());
                statement.setString(2, user.getEmail());
                statement.setInt(3, user.getAge());
                statement.executeUpdate(); // 個別実行
            }
            
            long endTime = System.currentTimeMillis();
            System.out.println("通常処理: " + (endTime - startTime) + "ms で " + users.size() + "件処理");
            
        } catch (SQLException e) {
            System.err.println("通常挿入エラー: " + e.getMessage());
        }
    }
    
    /**
     * バッチ処理による挿入
     */
    public void insertUsersBatch(List&lt;User&gt; users) {
        String sql = "INSERT INTO batch_users (name, email, age) VALUES (?, ?, ?)";
        
        try (Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
             PreparedStatement statement = connection.prepareStatement(sql)) {
            
            long startTime = System.currentTimeMillis();
            
            // バッチサイズを設定（メモリ使用量とのバランス）
            int batchSize = 1000;
            int count = 0;
            
            for (User user : users) {
                statement.setString(1, user.getName());
                statement.setString(2, user.getEmail());
                statement.setInt(3, user.getAge());
                statement.addBatch(); // バッチに追加
                count++;
                
                // バッチサイズに達したら実行
                if (count % batchSize == 0) {
                    int[] results = statement.executeBatch();
                    System.out.println(results.length + "件のバッチを実行");
                }
            }
            
            // 残りのバッチを実行
            if (count % batchSize != 0) {
                int[] results = statement.executeBatch();
                System.out.println("最後のバッチ " + results.length + "件を実行");
            }
            
            long endTime = System.currentTimeMillis();
            System.out.println("バッチ処理: " + (endTime - startTime) + "ms で " + users.size() + "件処理");
            
        } catch (SQLException e) {
            System.err.println("バッチ挿入エラー: " + e.getMessage());
        }
    }
}

// ユーザーデータクラス
class User {
    private String name;
    private String email;
    private int age;
    
    public User(String name, String email, int age) {
        this.name = name;
        this.email = email;
        this.age = age;
    }
    
    // getter methods
    public String getName() { return name; }
    public String getEmail() { return email; }
    public int getAge() { return age; }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>バッチ処理は通常の個別実行と比べて、大幅な性能向上を示します。特に1000件以上のデータでは顕著な差が現れます。</p>
                    </div>

                    <!-- セクション2: トランザクション管理 -->
                    <h3 class="section-title">5.2 トランザクション管理の基本</h3>
                    <p>トランザクションは、データベース操作の一貫性を保証する重要な概念です。複数の関連する操作をひとつの単位として扱い、すべて成功するかすべて失敗するかを保証します。</p>

                    <div class="mermaid">
                        flowchart TD
                            A[トランザクション開始] --> B{操作1成功？}
                            B -->|Yes| C{操作2成功？}
                            B -->|No| G[Rollback]
                            C -->|Yes| D{操作3成功？}
                            C -->|No| G
                            D -->|Yes| E[Commit]
                            D -->|No| G
                            E --> F[トランザクション完了]
                            G --> H[全変更を取り消し]
                            H --> I[エラー処理]
                    </div>

                    <h4>ACIDプロパティ</h4>
                    <p>トランザクションは以下の4つの性質（ACIDプロパティ）を満たす必要があります：</p>
                    <ul>
                        <li><strong>Atomicity（原子性）</strong>：すべての操作が成功するか、すべてが失敗するか</li>
                        <li><strong>Consistency（一貫性）</strong>：データベースの整合性制約を常に満たす</li>
                        <li><strong>Isolation（分離性）</strong>：同時実行されるトランザクションが互いに影響しない</li>
                        <li><strong>Durability（永続性）</strong>：コミット後のデータは永続的に保存される</li>
                    </ul>

                    <!-- 実習2: トランザクション -->
                    <div class="exercise-container">
                        <h5>実習 5-2: 在庫管理システムでのトランザクション処理</h5>
                        <p>商品購入処理において、在庫減少と注文登録を一つのトランザクションで処理する実例を学習します。</p>

                        <h6>テーブル設計</h6>
                        <pre class="code-block"><code class="language-sql">-- 商品テーブル
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    stock INTEGER NOT NULL CHECK (stock >= 0),
    price DECIMAL(10,2) NOT NULL
);

-- 注文テーブル
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    product_id INTEGER REFERENCES products(id),
    quantity INTEGER NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 初期データ
INSERT INTO products (name, stock, price) VALUES 
('ノートPC', 10, 89800.00),
('マウス', 50, 2980.00),
('キーボード', 30, 8900.00);</code></pre>

                        <h6>トランザクション処理実装</h6>
                        <pre class="code-block"><code class="language-java">public class InventoryManager {
    private static final String DB_URL = "jdbc:postgresql://localhost:5432/testdb";
    private static final String DB_USER = "user";
    private static final String DB_PASSWORD = "password";
    
    /**
     * 商品購入処理（トランザクション使用）
     * @param productId 商品ID
     * @param quantity 購入数量
     * @return 成功した場合true
     */
    public boolean purchaseProduct(int productId, int quantity) {
        String checkStockSql = "SELECT stock, price FROM products WHERE id = ?";
        String updateStockSql = "UPDATE products SET stock = stock - ? WHERE id = ?";
        String insertOrderSql = "INSERT INTO orders (product_id, quantity, total_amount) VALUES (?, ?, ?)";
        
        try (Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD)) {
            
            // 自動コミットを無効化
            connection.setAutoCommit(false);
            
            try {
                // 1. 在庫確認
                int currentStock;
                double price;
                try (PreparedStatement checkStmt = connection.prepareStatement(checkStockSql)) {
                    checkStmt.setInt(1, productId);
                    try (ResultSet rs = checkStmt.executeQuery()) {
                        if (!rs.next()) {
                            System.err.println("商品ID " + productId + " が見つかりません");
                            return false;
                        }
                        currentStock = rs.getInt("stock");
                        price = rs.getDouble("price");
                    }
                }
                
                // 2. 在庫チェック
                if (currentStock < quantity) {
                    System.err.println("在庫不足です。現在の在庫: " + currentStock + ", 要求数: " + quantity);
                    return false;
                }
                
                // 3. 在庫更新
                try (PreparedStatement updateStmt = connection.prepareStatement(updateStockSql)) {
                    updateStmt.setInt(1, quantity);
                    updateStmt.setInt(2, productId);
                    int updated = updateStmt.executeUpdate();
                    if (updated == 0) {
                        throw new SQLException("在庫更新に失敗しました");
                    }
                }
                
                // 4. 注文記録
                double totalAmount = price * quantity;
                try (PreparedStatement insertStmt = connection.prepareStatement(insertOrderSql)) {
                    insertStmt.setInt(1, productId);
                    insertStmt.setInt(2, quantity);
                    insertStmt.setDouble(3, totalAmount);
                    int inserted = insertStmt.executeUpdate();
                    if (inserted == 0) {
                        throw new SQLException("注文記録に失敗しました");
                    }
                }
                
                // すべて成功した場合はコミット
                connection.commit();
                System.out.println("購入処理が完了しました。商品ID: " + productId + ", 数量: " + quantity);
                return true;
                
            } catch (SQLException e) {
                // エラーが発生した場合はロールバック
                connection.rollback();
                System.err.println("購入処理でエラーが発生しました: " + e.getMessage());
                return false;
            }
            
        } catch (SQLException e) {
            System.err.println("データベース接続エラー: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * 商品在庫確認メソッド
     */
    public void checkStock() {
        String sql = "SELECT id, name, stock, price FROM products ORDER BY id";
        
        try (Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
             PreparedStatement statement = connection.prepareStatement(sql);
             ResultSet resultSet = statement.executeQuery()) {
            
            System.out.println("\n=== 現在の在庫状況 ===");
            System.out.println("ID\t商品名\t\t在庫\t価格");
            System.out.println("--------------------------------------------");
            
            while (resultSet.next()) {
                System.out.printf("%d\t%s\t%d\t%.2f円\n",
                    resultSet.getInt("id"),
                    resultSet.getString("name"),
                    resultSet.getInt("stock"),
                    resultSet.getDouble("price")
                );
            }
            
        } catch (SQLException e) {
            System.err.println("在庫確認エラー: " + e.getMessage());
        }
    }
}</code></pre>

                        <h6>使用例</h6>
                        <pre class="code-block"><code class="language-java">public class TransactionDemo {
    public static void main(String[] args) {
        InventoryManager manager = new InventoryManager();
        
        // 初期在庫確認
        manager.checkStock();
        
        // 購入処理テスト
        System.out.println("\n=== 購入テスト ===");
        
        // 正常な購入
        manager.purchaseProduct(1, 2); // ノートPC 2台
        
        // 在庫不足での購入試行
        manager.purchaseProduct(1, 20); // ノートPC 20台（在庫不足）
        
        // 結果確認
        manager.checkStock();
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>正常な購入処理では在庫が減り注文が記録されます。在庫不足の場合は処理が中止され、データベースの状態は変更されません。</p>
                    </div>

                    <!-- セクション3: ストアドプロシージャ -->
                    <h3 class="section-title">5.3 ストアドプロシージャとファンクションの活用</h3>
                    <p>ストアドプロシージャは、データベースサーバー側で実行される事前定義されたSQL処理の集合です。複雑なビジネスロジックをデータベース側で実行でき、性能向上とセキュリティ強化を実現できます。</p>

                    <div class="mermaid">
                        flowchart LR
                            A[Javaアプリケーション] --> B[ストアドプロシージャ呼出]
                            B --> C[データベースサーバー]
                            C --> D[複雑なSQL処理実行]
                            D --> E[結果返却]
                            E --> A
                    </div>

                    <h4>ストアドプロシージャの利点</h4>
                    <ul>
                        <li><strong>性能向上</strong>：データベースサーバー側で実行されるため高速</li>
                        <li><strong>セキュリティ</strong>：SQLインジェクション攻撃を防ぎやすい</li>
                        <li><strong>再利用性</strong>：複数のアプリケーションから共通利用可能</li>
                        <li><strong>保守性</strong>：複雑なビジネスロジックの集中管理</li>
                    </ul>

                    <!-- 実習3: ストアドプロシージャ -->
                    <div class="exercise-container">
                        <h5>実習 5-3: ストアドプロシージャの作成と呼び出し</h5>
                        <p>月別売上レポートを生成するストアドプロシージャを作成し、Javaから呼び出す方法を学習します。</p>

                        <h6>ストアドプロシージャ作成</h6>
                        <pre class="code-block"><code class="language-sql">-- 月別売上レポート用ストアドプロシージャ
CREATE OR REPLACE FUNCTION get_monthly_sales_report(
    target_year INTEGER,
    target_month INTEGER
) 
RETURNS TABLE (
    product_name VARCHAR,
    total_quantity BIGINT,
    total_sales NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.name::VARCHAR as product_name,
        SUM(o.quantity) as total_quantity,
        SUM(o.total_amount) as total_sales
    FROM orders o
    JOIN products p ON o.product_id = p.id
    WHERE EXTRACT(YEAR FROM o.order_date) = target_year
    AND EXTRACT(MONTH FROM o.order_date) = target_month
    GROUP BY p.name
    ORDER BY total_sales DESC;
END;
$$ LANGUAGE plpgsql;</code></pre>

                        <h6>Java側からの呼び出し</h6>
                        <pre class="code-block"><code class="language-java">public class StoredProcedureExample {
    private static final String DB_URL = "jdbc:postgresql://localhost:5432/testdb";
    private static final String DB_USER = "user";
    private static final String DB_PASSWORD = "password";
    
    /**
     * 月別売上レポートを取得
     * @param year 対象年
     * @param month 対象月
     */
    public void getMonthlySalesReport(int year, int month) {
        // CallableStatementを使用してストアドプロシージャを呼び出し
        String sql = "SELECT * FROM get_monthly_sales_report(?, ?)";
        
        try (Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
             PreparedStatement statement = connection.prepareStatement(sql)) {
            
            statement.setInt(1, year);
            statement.setInt(2, month);
            
            try (ResultSet resultSet = statement.executeQuery()) {
                System.out.printf("\n=== %d年%d月 売上レポート ===\n", year, month);
                System.out.println("商品名\t\t販売数量\t売上金額");
                System.out.println("----------------------------------------");
                
                boolean hasData = false;
                while (resultSet.next()) {
                    hasData = true;
                    System.out.printf("%s\t%d\t%.2f円\n",
                        resultSet.getString("product_name"),
                        resultSet.getLong("total_quantity"),
                        resultSet.getDouble("total_sales")
                    );
                }
                
                if (!hasData) {
                    System.out.println("指定された期間にデータがありません。");
                }
            }
            
        } catch (SQLException e) {
            System.err.println("レポート取得エラー: " + e.getMessage());
        }
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>指定された月の商品別売上集計が、売上金額の降順で表示されます。データがない場合は適切なメッセージが表示されます。</p>
                    </div>

                    <!-- セクション4: パフォーマンス考慮事項 -->
                    <h3 class="section-title">5.4 高度JDBC機能のパフォーマンス考慮事項</h3>
                    <p>高度なJDBC機能を使用する際は、パフォーマンスへの影響を理解し、適切に使い分けることが重要です。</p>

                    <div class="highlight">
                        <h5>パフォーマンス最適化のポイント</h5>
                        <ul>
                            <li><strong>バッチサイズの最適化</strong>：メモリ使用量との兼ね合いで調整（通常1000-5000件）</li>
                            <li><strong>適切なトランザクション境界</strong>：必要最小限のスコープでトランザクションを管理</li>
                            <li><strong>インデックスの活用</strong>：WHERE句で使用される列にインデックスを設定</li>
                            <li><strong>結果セットのサイズ制限</strong>：LIMITクローズを使用して必要なデータのみを取得</li>
                        </ul>
                    </div>

                    <!-- 理解度確認クイズ -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <p><strong>バッチ処理の主な利点を3つ説明してください。</strong></p>
                            </li>
                            
                            <li>
                                <p><strong>ACIDプロパティの4つの要素とその意味を説明してください。</strong></p>
                            </li>
                            
                            <li>
                                <p><strong>以下の状況でトランザクションが必要な理由を説明してください：</strong></p>
                                <p>銀行で口座Aから口座Bに10万円を送金する処理</p>
                            </li>
                            
                            <li>
                                <p><strong>ストアドプロシージャの利点を4つ挙げ、それぞれ簡潔に説明してください。</strong></p>
                            </li>
                            
                            <li>
                                <p><strong>以下のコードで、バッチ処理を使用しない場合とした場合の性能差について説明してください：</strong></p>
                                <pre class="code-block"><code class="language-java">// 1000件のデータを挿入する場合
for (int i = 0; i < 1000; i++) {
    statement.setString(1, "user" + i);
    statement.executeUpdate(); // 通常処理
    // vs statement.addBatch(); // バッチ処理
}</code></pre>
                            </li>
                        </ol>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="jdbc-learning-material-04.html" class="btn btn-secondary">← 前の章</a>
                        <a href="jdbc-learning-material-06.html" class="btn btn-primary">次の章 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js 初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>