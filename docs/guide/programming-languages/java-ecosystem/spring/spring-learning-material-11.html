<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring学習教材 第11章 - さらに一歩進んだSpring開発へ②</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <!-- カスタムCSS -->
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #4caf50;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }

        /* タイトル */
        .chapter-title {
            color: #4caf50;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #4caf50;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #66bb6a;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e8f5e8;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #4caf50;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #4caf50 !important;
            color: white !important;
        }

        /* その他 */
        .card {
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand">
                <strong>Spring学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-1.html">
                                第1章: JavaとWebの基礎理解
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-2.html">
                                第2章: Spring Bootの導入と開発環境構築
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-3.html">
                                第3章: Spring Bootの基本構成とDI（依存性注入）
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-4.html">
                                第4章: Webアプリケーション開発の基礎（MVC）
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-5.html">
                                第5章: データベース連携（Spring Data JDBC）
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-6.html">
                                第6章: 入力バリデーションとエラーハンドリング
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-7.html">
                                第7章: Spring Securityによる認証・認可
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-8.html">
                                第8章: Spring MVCのテスト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-9.html">
                                第9章: Todoアプリケーション開発
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-10.html">
                                第10章: さらに一歩進んだSpring開発へ①
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="spring-learning-material-11.html">
                                第11章: さらに一歩進んだSpring開発へ②
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-ex-1.html">
                                補足①: Spring Data JPA入門
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <!-- 章ヘッダー -->
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第11章: さらに一歩進んだSpring開発へ②</h1>
                </div>

                <div id="chapter11">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">Java Records & 集約ルート設計</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>Java 17のRecordの基本概念と利点</li>
                            <li>Spring Data JDBCでのRecords活用方法</li>
                            <li>ドメイン駆動設計（DDD）の集約ルート概念</li>
                            <li>1対多関係の集約設計とモデリング</li>
                            <li>プロジェクト管理システムの実装例</li>
                            <li>不変オブジェクトとデータ整合性の確保</li>
                        </ul>
                    </div>

                    <!-- セクション11.1 -->
                    <h3 class="section-title">11.1 Java Recordsの基本概念</h3>
                    <p>
                        Java 14で導入され、Java 17で正式リリースされたRecord（記録）クラスは、不変データクラスを簡潔に定義するための機能です。従来のPOJO（Plain Old Java Object）に比べて、ボイラープレートコードを大幅に削減できます。
                    </p>

                    <div class="highlight">
                        <h6>Java Recordsの特徴と利点</h6>
                        <ul>
                            <li><strong>不変性</strong>: 全てのフィールドが自動的にfinalになる</li>
                            <li><strong>自動生成</strong>: コンストラクタ、getter、equals、hashCode、toStringが自動生成</li>
                            <li><strong>簡潔性</strong>: ボイラープレートコードが大幅に削減</li>
                            <li><strong>型安全性</strong>: コンパイル時の型チェックが強化</li>
                            <li><strong>パフォーマンス</strong>: 最適化された実装</li>
                        </ul>
                    </div>

                    <div class="mermaid">
                        graph LR
                            A["従来のPOJOクラス"] --> B["多くのボイラープレートコード<br/>・getter/setter<br/>・equals/hashCode<br/>・toString<br/>・コンストラクタ"]
                            
                            C["Java Record"] --> D["自動生成される機能<br/>・不変フィールド<br/>・自動コンストラクタ<br/>・自動getter<br/>・自動equals/hashCode<br/>・自動toString"]
                            
                            B -->|"問題点"| E["・冗長なコード<br/>・保守性の低下<br/>・バグの混入リスク"]
                            D -->|"利点"| F["・簡潔なコード<br/>・高い保守性<br/>・型安全性<br/>・不変性保証"]
                    </div>

                    <h4>従来のクラス vs Record の比較</h4>
                    <pre class="code-block"><code class="language-java">// 従来のPOJOクラス（約50行）
public class PersonPojo {
    private final String name;
    private final int age;
    private final String email;
    
    public PersonPojo(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
    public String getEmail() { return email; }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        PersonPojo person = (PersonPojo) obj;
        return age == person.age && 
               Objects.equals(name, person.name) && 
               Objects.equals(email, person.email);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, age, email);
    }
    
    @Override
    public String toString() {
        return "PersonPojo{name='" + name + "', age=" + age + ", email='" + email + "'}";
    }
}

// Java Record（1行！）
public record PersonRecord(String name, int age, String email) {}

// 使用例
PersonRecord person = new PersonRecord("Alice", 30, "alice@example.com");
System.out.println(person.name());     // Alice
System.out.println(person.age());      // 30
System.out.println(person.toString()); // PersonRecord[name=Alice, age=30, email=alice@example.com]</code></pre>

                    <!-- セクション11.2 -->
                    <h3 class="section-title">11.2 Spring Data JDBCでのRecords活用</h3>
                    <p>
                        Spring Data JDBCはJava Recordsをネイティブサポートしており、エンティティクラスとしてRecordを使用することで、より簡潔で安全なデータモデルを定義できます。
                    </p>

                    <!-- 実習11-1 -->
                    <div class="exercise-container">
                        <h5>実習 11-1: RecordベースのエンティティとDTO実装</h5>
                        <p>従来のクラスベースのエンティティをRecordで置き換え、DTOとしても活用してみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>Recordベースのエンティティクラス作成</li>
                            <li>バリデーションとカスタム機能の追加</li>
                            <li>DTOとしてのRecord活用</li>
                            <li>リポジトリとサービス層での動作確認</li>
                        </ol>

                        <h6>Recordベースのエンティティ定義</h6>
                        <pre class="code-block"><code class="language-java">package com.example.todoapp.entity;

import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Table;
import jakarta.validation.constraints.*;

import java.time.LocalDateTime;
import java.util.List;

/**
 * プロジェクトRecord（集約ルート）
 */
@Table("projects")
public record Project(
    @Id Long id,
    
    @NotBlank(message = "プロジェクト名は必須です")
    @Size(max = 200, message = "プロジェクト名は200文字以内で入力してください")
    String name,
    
    @Size(max = 1000, message = "説明は1000文字以内で入力してください")
    String description,
    
    @NotNull(message = "オーナーIDは必須です")
    Long ownerId,
    
    @Pattern(regexp = "^(PLANNING|ACTIVE|COMPLETED|CANCELLED)$", 
             message = "ステータスは PLANNING, ACTIVE, COMPLETED, CANCELLED のいずれかを選択してください")
    String status,
    
    @Future(message = "期限は未来の日付を設定してください")
    @NotNull(message = "期限は必須です")
    LocalDateTime deadline,
    
    LocalDateTime createdAt,
    LocalDateTime updatedAt
) {
    
    // カスタムコンストラクタ（新規作成用）
    public Project(String name, String description, Long ownerId, LocalDateTime deadline) {
        this(null, name, description, ownerId, "PLANNING", deadline, 
             LocalDateTime.now(), LocalDateTime.now());
    }
    
    // ステータス判定メソッド
    public boolean isActive() {
        return "ACTIVE".equals(status);
    }
    
    public boolean isCompleted() {
        return "COMPLETED".equals(status);
    }
    
    // ステータス更新（新しいRecordインスタンスを返す）
    public Project withStatus(String newStatus) {
        return new Project(id, name, description, ownerId, newStatus, 
                          deadline, createdAt, LocalDateTime.now());
    }
    
    // プロジェクト期限チェック
    public boolean isOverdue() {
        return !isCompleted() && deadline.isBefore(LocalDateTime.now());
    }
    
    // ステータス列挙型
    public enum Status {
        PLANNING("計画中"),
        ACTIVE("進行中"), 
        COMPLETED("完了"),
        CANCELLED("中止");
        
        private final String displayName;
        
        Status(String displayName) {
            this.displayName = displayName;
        }
        
        public String getDisplayName() {
            return displayName;
        }
    }
}

/**
 * プロジェクトタスクRecord
 */
@Table("project_tasks")
public record ProjectTask(
    @Id Long id,
    
    @NotNull(message = "プロジェクトIDは必須です")
    Long projectId,
    
    @NotBlank(message = "タスク名は必須です")
    @Size(max = 300, message = "タスク名は300文字以内で入力してください")
    String title,
    
    @Size(max = 2000, message = "詳細は2000文字以内で入力してください")
    String details,
    
    @NotNull(message = "担当者IDは必須です")
    Long assigneeId,
    
    @Pattern(regexp = "^(TODO|IN_PROGRESS|REVIEW|DONE)$",
             message = "ステータスは TODO, IN_PROGRESS, REVIEW, DONE のいずれかを選択してください")
    String status,
    
    @Min(value = 1, message = "優先度は1以上を設定してください")
    @Max(value = 5, message = "優先度は5以下を設定してください")
    Integer priority,
    
    LocalDateTime dueDate,
    LocalDateTime createdAt,
    LocalDateTime updatedAt
) {
    
    // 新規作成用コンストラクタ
    public ProjectTask(Long projectId, String title, String details, Long assigneeId, Integer priority) {
        this(null, projectId, title, details, assigneeId, "TODO", 
             priority, null, LocalDateTime.now(), LocalDateTime.now());
    }
    
    // ステータス更新
    public ProjectTask withStatus(String newStatus) {
        return new ProjectTask(id, projectId, title, details, assigneeId, 
                              newStatus, priority, dueDate, createdAt, LocalDateTime.now());
    }
    
    // 完了状態チェック
    public boolean isDone() {
        return "DONE".equals(status);
    }
    
    // 期限チェック
    public boolean isOverdue() {
        return !isDone() && dueDate != null && dueDate.isBefore(LocalDateTime.now());
    }
}</code></pre>

                        <h6>DTO用Records</h6>
                        <pre class="code-block"><code class="language-java">package com.example.todoapp.dto;

import java.time.LocalDateTime;
import java.util.List;

/**
 * プロジェクト詳細情報DTO
 */
public record ProjectDetailDto(
    Long id,
    String name,
    String description,
    String ownerName,
    String status,
    String statusDisplayName,
    LocalDateTime deadline,
    boolean isOverdue,
    int totalTasks,
    int completedTasks,
    double completionRate,
    LocalDateTime createdAt,
    List&lt;ProjectTaskDto&gt; tasks
) {
    
    // 計算プロパティ付きコンストラクタ
    public ProjectDetailDto(Project project, String ownerName, List&lt;ProjectTaskDto&gt; tasks) {
        this(
            project.id(),
            project.name(),
            project.description(),
            ownerName,
            project.status(),
            Project.Status.valueOf(project.status()).getDisplayName(),
            project.deadline(),
            project.isOverdue(),
            tasks.size(),
            (int) tasks.stream().filter(task -> "DONE".equals(task.status())).count(),
            calculateCompletionRate(tasks),
            project.createdAt(),
            tasks
        );
    }
    
    private static double calculateCompletionRate(List&lt;ProjectTaskDto&gt; tasks) {
        if (tasks.isEmpty()) return 0.0;
        long completedTasks = tasks.stream().filter(task -> "DONE".equals(task.status())).count();
        return (double) completedTasks / tasks.size() * 100;
    }
}

/**
 * プロジェクトタスクDTO
 */
public record ProjectTaskDto(
    Long id,
    Long projectId,
    String title,
    String details,
    String assigneeName,
    String status,
    String statusDisplayName,
    Integer priority,
    String priorityLabel,
    LocalDateTime dueDate,
    boolean isOverdue,
    LocalDateTime createdAt
) {
    
    public ProjectTaskDto(ProjectTask task, String assigneeName) {
        this(
            task.id(),
            task.projectId(),
            task.title(),
            task.details(),
            assigneeName,
            task.status(),
            getStatusDisplayName(task.status()),
            task.priority(),
            getPriorityLabel(task.priority()),
            task.dueDate(),
            task.isOverdue(),
            task.createdAt()
        );
    }
    
    private static String getStatusDisplayName(String status) {
        return switch (status) {
            case "TODO" -> "未着手";
            case "IN_PROGRESS" -> "進行中";
            case "REVIEW" -> "レビュー中";
            case "DONE" -> "完了";
            default -> status;
        };
    }
    
    private static String getPriorityLabel(Integer priority) {
        return switch (priority) {
            case 1 -> "低";
            case 2 -> "やや低";
            case 3 -> "普通";
            case 4 -> "やや高";
            case 5 -> "高";
            default -> "不明";
        };
    }
}

/**
 * プロジェクト作成・更新用DTO
 */
public record ProjectFormDto(
    @NotBlank(message = "プロジェクト名は必須です")
    @Size(max = 200, message = "プロジェクト名は200文字以内で入力してください")
    String name,
    
    @Size(max = 1000, message = "説明は1000文字以内で入力してください")
    String description,
    
    @Future(message = "期限は未来の日付を設定してください")
    @NotNull(message = "期限は必須です")
    LocalDateTime deadline
) {
    
    // エンティティ変換
    public Project toEntity(Long ownerId) {
        return new Project(name, description, ownerId, deadline);
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>Recordベースのエンティティが従来のクラスと同様に動作し、より簡潔で安全なコードが実現されることを確認できます。</p>
                    </div>

                    <!-- セクション11.3 -->
                    <h3 class="section-title">11.3 集約ルート（Aggregate Root）の概念</h3>
                    <p>
                        ドメイン駆動設計（DDD）における集約ルートは、関連するエンティティ群の整合性を保つための重要な概念です。Spring Data JDBCでは、この集約パターンを自然に実装できます。
                    </p>

                    <div class="highlight">
                        <h6>集約ルートの基本原則</h6>
                        <ul>
                            <li><strong>境界の明確化</strong>: 集約内部の整合性を保つ境界を定義</li>
                            <li><strong>外部アクセス制御</strong>: 集約外からは集約ルートを通してのみアクセス</li>
                            <li><strong>トランザクション境界</strong>: 一つの集約は一つのトランザクションで変更</li>
                            <li><strong>一意識別</strong>: 集約ルートのみがグローバルな識別子を持つ</li>
                        </ul>
                    </div>

                    <div class="mermaid">
                        graph TB
                            subgraph "プロジェクト集約"
                                A["Project<br/>(集約ルート)"] -->|"1対多"| B["ProjectTask"]
                                A --> C["ProjectTask"]
                                A --> D["ProjectTask"]
                                
                                B -.->|"参照のみ"| E["User<br/>(Assignee)"]
                                C -.->|"参照のみ"| F["User<br/>(Assignee)"]
                                D -.->|"参照のみ"| G["User<br/>(Assignee)"]
                            end
                            
                            subgraph "外部システム"
                                H["外部サービス"] -->|"集約ルート経由"| A
                                H -.->|"直接アクセス禁止"| B
                            end
                            
                            subgraph "データベース"
                                I[("projects table")]
                                J[("project_tasks table")]
                                K[("users table")]
                                
                                A -.-> I
                                B -.-> J
                                E -.-> K
                            end
                    </div>

                    <!-- 実習11-2 -->
                    <div class="exercise-container">
                        <h5>実習 11-2: 集約ルートを活用したプロジェクト管理システム</h5>
                        <p>Projectを集約ルートとして、関連するProjectTaskを管理するシステムを実装してみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>データベーススキーマの作成</li>
                            <li>集約ルート対応リポジトリの実装</li>
                            <li>集約を意識したサービス層の実装</li>
                            <li>集約整合性を保つビジネスロジック実装</li>
                        </ol>

                        <h6>データベーススキーマ</h6>
                        <pre class="code-block"><code class="language-sql">-- プロジェクトテーブル（集約ルート）
CREATE TABLE projects (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    owner_id BIGINT NOT NULL REFERENCES users(id),
    status VARCHAR(20) DEFAULT 'PLANNING' CHECK (status IN ('PLANNING', 'ACTIVE', 'COMPLETED', 'CANCELLED')),
    deadline TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- プロジェクトタスクテーブル（集約内エンティティ）
CREATE TABLE project_tasks (
    id BIGSERIAL PRIMARY KEY,
    project_id BIGINT NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    title VARCHAR(300) NOT NULL,
    details TEXT,
    assignee_id BIGINT NOT NULL REFERENCES users(id),
    status VARCHAR(20) DEFAULT 'TODO' CHECK (status IN ('TODO', 'IN_PROGRESS', 'REVIEW', 'DONE')),
    priority INTEGER DEFAULT 3 CHECK (priority BETWEEN 1 AND 5),
    due_date TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- インデックス作成
CREATE INDEX idx_projects_owner_id ON projects(owner_id);
CREATE INDEX idx_projects_status ON projects(status);
CREATE INDEX idx_projects_deadline ON projects(deadline);
CREATE INDEX idx_project_tasks_project_id ON project_tasks(project_id);
CREATE INDEX idx_project_tasks_assignee_id ON project_tasks(assignee_id);
CREATE INDEX idx_project_tasks_status ON project_tasks(status);

-- サンプルデータ
INSERT INTO projects (name, description, owner_id, status, deadline) VALUES
('Webアプリケーションリニューアル', '既存システムのモダン化プロジェクト', 2, 'ACTIVE', '2024-03-31 23:59:59'),
('新機能開発プロジェクト', 'ユーザー要望の高い機能の開発', 2, 'PLANNING', '2024-02-29 23:59:59'),
('システム保守・運用改善', 'パフォーマンス最適化とバグ修正', 3, 'ACTIVE', '2024-01-31 23:59:59');

INSERT INTO project_tasks (project_id, title, details, assignee_id, status, priority, due_date) VALUES
(1, 'フロントエンド設計', 'UIコンポーネントの設計と実装方針決定', 2, 'DONE', 4, '2024-01-15 17:00:00'),
(1, 'API仕様書作成', 'RESTful API の仕様書とOpenAPI定義', 2, 'IN_PROGRESS', 5, '2024-01-20 17:00:00'),
(1, 'データベース移行', '既存データの新スキーマへの移行', 3, 'TODO', 5, '2024-02-01 17:00:00'),
(2, '要件定義書レビュー', 'ステークホルダーとの要件確認', 2, 'TODO', 3, '2024-01-25 17:00:00'),
(2, '技術選定', '使用する技術スタックの選定と検証', 3, 'TODO', 4, '2024-01-30 17:00:00'),
(3, 'パフォーマンステスト', '負荷テストの実施と結果分析', 3, 'IN_PROGRESS', 3, '2024-01-22 17:00:00');</code></pre>

                        <h6>ProjectAggregateRepository.java（集約対応リポジトリ）</h6>
                        <pre class="code-block"><code class="language-java">package com.example.todoapp.repository;

import com.example.todoapp.entity.Project;
import com.example.todoapp.entity.ProjectTask;
import org.springframework.data.jdbc.repository.query.Modifying;
import org.springframework.data.jdbc.repository.query.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface ProjectRepository extends CrudRepository&lt;Project, Long&gt; {
    
    /**
     * オーナーIDでプロジェクト一覧を取得
     */
    List&lt;Project&gt; findByOwnerIdOrderByCreatedAtDesc(Long ownerId);
    
    /**
     * プロジェクト取得（権限チェック付き）
     */
    Optional&lt;Project&gt; findByIdAndOwnerId(Long id, Long ownerId);
    
    /**
     * ステータス別プロジェクト取得
     */
    List&lt;Project&gt; findByOwnerIdAndStatusOrderByDeadlineAsc(Long ownerId, String status);
    
    /**
     * 期限切れプロジェクト取得
     */
    @Query("SELECT * FROM projects WHERE owner_id = :ownerId AND status NOT IN ('COMPLETED', 'CANCELLED') AND deadline &lt; CURRENT_TIMESTAMP ORDER BY deadline")
    List&lt;Project&gt; findOverdueProjects(@Param("ownerId") Long ownerId);
    
    /**
     * プロジェクトのステータス更新
     */
    @Modifying
    @Query("UPDATE projects SET status = :status, updated_at = CURRENT_TIMESTAMP WHERE id = :id AND owner_id = :ownerId")
    int updateProjectStatus(@Param("id") Long id, @Param("ownerId") Long ownerId, @Param("status") String status);
}

@Repository
public interface ProjectTaskRepository extends CrudRepository&lt;ProjectTask, Long&gt; {
    
    /**
     * プロジェクトIDでタスク一覧取得（集約内アクセス）
     */
    List&lt;ProjectTask&gt; findByProjectIdOrderByPriorityDescCreatedAtAsc(Long projectId);
    
    /**
     * プロジェクトとタスクID で取得（集約境界チェック）
     */
    Optional&lt;ProjectTask&gt; findByIdAndProjectId(Long id, Long projectId);
    
    /**
     * 担当者別タスク取得
     */
    List&lt;ProjectTask&gt; findByAssigneeIdAndStatusOrderByDueDateAsc(Long assigneeId, String status);
    
    /**
     * プロジェクト内の完了タスク数カウント
     */
    @Query("SELECT COUNT(*) FROM project_tasks WHERE project_id = :projectId AND status = 'DONE'")
    long countCompletedTasksByProjectId(@Param("projectId") Long projectId);
    
    /**
     * プロジェクト内の総タスク数カウント
     */
    @Query("SELECT COUNT(*) FROM project_tasks WHERE project_id = :projectId")
    long countTotalTasksByProjectId(@Param("projectId") Long projectId);
    
    /**
     * タスクステータス一括更新（集約内操作）
     */
    @Modifying
    @Query("UPDATE project_tasks SET status = :status, updated_at = CURRENT_TIMESTAMP WHERE project_id = :projectId AND status = :currentStatus")
    int bulkUpdateTaskStatus(@Param("projectId") Long projectId, @Param("currentStatus") String currentStatus, @Param("status") String status);
}</code></pre>

                        <h6>ProjectAggregateService.java（集約サービス）</h6>
                        <pre class="code-block"><code class="language-java">package com.example.todoapp.service;

import com.example.todoapp.entity.Project;
import com.example.todoapp.entity.ProjectTask;
import com.example.todoapp.dto.ProjectDetailDto;
import com.example.todoapp.dto.ProjectTaskDto;
import com.example.todoapp.repository.ProjectRepository;
import com.example.todoapp.repository.ProjectTaskRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class ProjectAggregateService {
    
    private final ProjectRepository projectRepository;
    private final ProjectTaskRepository projectTaskRepository;
    private final UserService userService; // ユーザー情報取得用
    
    @Autowired
    public ProjectAggregateService(ProjectRepository projectRepository, 
                                 ProjectTaskRepository projectTaskRepository,
                                 UserService userService) {
        this.projectRepository = projectRepository;
        this.projectTaskRepository = projectTaskRepository;
        this.userService = userService;
    }
    
    /**
     * プロジェクト作成（集約ルートを作成）
     */
    public Project createProject(Project project) {
        // ビジネスルール検証
        validateProjectBusinessRules(project);
        
        return projectRepository.save(project);
    }
    
    /**
     * プロジェクト詳細取得（集約全体を取得）
     */
    @Transactional(readOnly = true)
    public Optional&lt;ProjectDetailDto&gt; getProjectDetail(Long projectId, Long ownerId) {
        Optional&lt;Project&gt; project = projectRepository.findByIdAndOwnerId(projectId, ownerId);
        
        if (project.isEmpty()) {
            return Optional.empty();
        }
        
        List&lt;ProjectTask&gt; tasks = projectTaskRepository.findByProjectIdOrderByPriorityDescCreatedAtAsc(projectId);
        List&lt;ProjectTaskDto&gt; taskDtos = tasks.stream()
                .map(task -> {
                    String assigneeName = userService.findById(task.assigneeId())
                            .map(user -> user.getDisplayName())
                            .orElse("不明");
                    return new ProjectTaskDto(task, assigneeName);
                })
                .toList();
        
        String ownerName = userService.findById(project.get().ownerId())
                .map(user -> user.getDisplayName())
                .orElse("不明");
        
        return Optional.of(new ProjectDetailDto(project.get(), ownerName, taskDtos));
    }
    
    /**
     * プロジェクトにタスクを追加（集約内エンティティ追加）
     */
    public ProjectTask addTaskToProject(Long projectId, ProjectTask task, Long ownerId) {
        // プロジェクトの存在確認と権限チェック
        Project project = projectRepository.findByIdAndOwnerId(projectId, ownerId)
                .orElseThrow(() -> new IllegalArgumentException("プロジェクトが見つからないか、権限がありません"));
        
        // プロジェクトが完了・中止状態でないことを確認
        if ("COMPLETED".equals(project.status()) || "CANCELLED".equals(project.status())) {
            throw new IllegalStateException("完了または中止されたプロジェクトにはタスクを追加できません");
        }
        
        // タスクにプロジェクトIDを設定
        ProjectTask newTask = new ProjectTask(
            task.id(), projectId, task.title(), task.details(), 
            task.assigneeId(), task.status(), task.priority(), 
            task.dueDate(), LocalDateTime.now(), LocalDateTime.now()
        );
        
        return projectTaskRepository.save(newTask);
    }
    
    /**
     * プロジェクトステータス更新（集約のビジネスルール適用）
     */
    public Project updateProjectStatus(Long projectId, String newStatus, Long ownerId) {
        Project project = projectRepository.findByIdAndOwnerId(projectId, ownerId)
                .orElseThrow(() -> new IllegalArgumentException("プロジェクトが見つからないか、権限がありません"));
        
        // ステータス変更のビジネスルール検証
        validateStatusTransition(project.status(), newStatus);
        
        // プロジェクト完了時の特別処理
        if ("COMPLETED".equals(newStatus)) {
            completeProject(projectId);
        }
        
        Project updatedProject = project.withStatus(newStatus);
        return projectRepository.save(updatedProject);
    }
    
    /**
     * タスク更新（集約内整合性を保つ）
     */
    public ProjectTask updateTask(Long projectId, Long taskId, ProjectTask updatedTask, Long ownerId) {
        // プロジェクトの権限チェック
        Project project = projectRepository.findByIdAndOwnerId(projectId, ownerId)
                .orElseThrow(() -> new IllegalArgumentException("プロジェクトが見つからないか、権限がありません"));
        
        // タスクの存在確認（集約境界内）
        ProjectTask existingTask = projectTaskRepository.findByIdAndProjectId(taskId, projectId)
                .orElseThrow(() -> new IllegalArgumentException("タスクが見つかりません"));
        
        // 更新されたタスクを保存
        ProjectTask taskToUpdate = new ProjectTask(
            taskId, projectId, updatedTask.title(), updatedTask.details(),
            updatedTask.assigneeId(), updatedTask.status(), updatedTask.priority(),
            updatedTask.dueDate(), existingTask.createdAt(), LocalDateTime.now()
        );
        
        ProjectTask savedTask = projectTaskRepository.save(taskToUpdate);
        
        // プロジェクトの進捗状況を自動更新
        updateProjectProgressBasedOnTasks(projectId);
        
        return savedTask;
    }
    
    /**
     * プロジェクト削除（集約全体の削除）
     */
    public void deleteProject(Long projectId, Long ownerId) {
        Project project = projectRepository.findByIdAndOwnerId(projectId, ownerId)
                .orElseThrow(() -> new IllegalArgumentException("プロジェクトが見つからないか、権限がありません"));
        
        // 進行中プロジェクトの削除制限
        if ("ACTIVE".equals(project.status())) {
            throw new IllegalStateException("進行中のプロジェクトは削除できません。先にステータスを変更してください。");
        }
        
        // 集約全体を削除（カスケード削除でタスクも削除される）
        projectRepository.delete(project);
    }
    
    // ビジネスルール検証
    private void validateProjectBusinessRules(Project project) {
        if (project.deadline().isBefore(LocalDateTime.now())) {
            throw new IllegalArgumentException("期限は現在時刻より後に設定してください");
        }
        
        if (project.name().trim().isEmpty()) {
            throw new IllegalArgumentException("プロジェクト名は必須です");
        }
    }
    
    // ステータス変更の妥当性チェック
    private void validateStatusTransition(String currentStatus, String newStatus) {
        boolean isValidTransition = switch (currentStatus) {
            case "PLANNING" -> List.of("ACTIVE", "CANCELLED").contains(newStatus);
            case "ACTIVE" -> List.of("COMPLETED", "CANCELLED").contains(newStatus);
            case "COMPLETED", "CANCELLED" -> false; // 最終状態からは変更不可
            default -> false;
        };
        
        if (!isValidTransition) {
            throw new IllegalStateException(String.format("ステータスを %s から %s に変更することはできません", currentStatus, newStatus));
        }
    }
    
    // プロジェクト完了処理
    private void completeProject(Long projectId) {
        // 未完了タスクを強制完了
        projectTaskRepository.bulkUpdateTaskStatus(projectId, "TODO", "DONE");
        projectTaskRepository.bulkUpdateTaskStatus(projectId, "IN_PROGRESS", "DONE");
        projectTaskRepository.bulkUpdateTaskStatus(projectId, "REVIEW", "DONE");
    }
    
    // タスク状況に基づくプロジェクト進捗更新
    private void updateProjectProgressBasedOnTasks(Long projectId) {
        long totalTasks = projectTaskRepository.countTotalTasksByProjectId(projectId);
        long completedTasks = projectTaskRepository.countCompletedTasksByProjectId(projectId);
        
        // 全タスク完了時の自動ステータス更新
        if (totalTasks > 0 && completedTasks == totalTasks) {
            Optional&lt;Project&gt; project = projectRepository.findById(projectId);
            if (project.isPresent() && "ACTIVE".equals(project.get().status())) {
                projectRepository.updateProjectStatus(projectId, project.get().ownerId(), "COMPLETED");
            }
        }
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>集約ルートパターンによって、プロジェクトとタスクの整合性が保たれ、ビジネスルールが適切に適用されることを確認できます。</p>
                    </div>

                    <!-- セクション11.4 -->
                    <h3 class="section-title">11.4 不変性とデータ整合性の活用</h3>
                    <p>
                        Java Recordsの不変性を活かして、データの整合性とスレッドセーフティを向上させる方法を学習します。不変オブジェクトは副作用のない安全なプログラミングを実現します。
                    </p>

                    <div class="mermaid">
                        graph LR
                            A["可変オブジェクト"] --> B["サイドエフェクト<br/>・予期しない値変更<br/>・スレッドセーフ性の問題<br/>・バグの温床"]
                            
                            C["不変オブジェクト<br/>(Record)"] --> D["安全性<br/>・値の変更不可<br/>・スレッドセーフ<br/>・予測可能な動作<br/>・キャッシュ可能"]
                            
                            E["ビジネス操作"] --> F["新しいインスタンス<br/>を返す"]
                            F --> C
                    </div>

                    <!-- 実習11-3 -->
                    <div class="exercise-container">
                        <h5>実習 11-3: 不変性を活用したイベント駆動プログラミング</h5>
                        <p>Recordsの不変性を活用して、イベント駆動のプロジェクト状態管理システムを実装してみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>イベントRecord の定義</li>
                            <li>イベント駆動のドメインモデル実装</li>
                            <li>イベントストリームの処理</li>
                            <li>状態変更の追跡とログ機能</li>
                        </ol>

                        <h6>イベントRecord定義</h6>
                        <pre class="code-block"><code class="language-java">package com.example.todoapp.event;

import java.time.LocalDateTime;
import java.util.Map;

/**
 * ドメインイベントの基底Record
 */
public sealed interface DomainEvent 
    permits ProjectEvent, TaskEvent {
    
    String eventId();
    String eventType();
    LocalDateTime occurredAt();
    Long aggregateId();
    Map&lt;String, Object&gt; eventData();
}

/**
 * プロジェクト関連イベント
 */
public sealed interface ProjectEvent extends DomainEvent
    permits ProjectCreated, ProjectStatusChanged, ProjectCompleted {
}

/**
 * プロジェクト作成イベント
 */
public record ProjectCreated(
    String eventId,
    LocalDateTime occurredAt,
    Long aggregateId,
    String projectName,
    String description,
    Long ownerId,
    LocalDateTime deadline
) implements ProjectEvent {
    
    @Override
    public String eventType() {
        return "PROJECT_CREATED";
    }
    
    @Override
    public Map&lt;String, Object&gt; eventData() {
        return Map.of(
            "projectName", projectName,
            "description", description,
            "ownerId", ownerId,
            "deadline", deadline
        );
    }
}

/**
 * プロジェクトステータス変更イベント
 */
public record ProjectStatusChanged(
    String eventId,
    LocalDateTime occurredAt,
    Long aggregateId,
    String previousStatus,
    String newStatus,
    String reason
) implements ProjectEvent {
    
    @Override
    public String eventType() {
        return "PROJECT_STATUS_CHANGED";
    }
    
    @Override
    public Map&lt;String, Object&gt; eventData() {
        return Map.of(
            "previousStatus", previousStatus,
            "newStatus", newStatus,
            "reason", reason
        );
    }
}

/**
 * プロジェクト完了イベント
 */
public record ProjectCompleted(
    String eventId,
    LocalDateTime occurredAt,
    Long aggregateId,
    int totalTasks,
    int completedTasks,
    LocalDateTime completedAt
) implements ProjectEvent {
    
    @Override
    public String eventType() {
        return "PROJECT_COMPLETED";
    }
    
    @Override
    public Map&lt;String, Object&gt; eventData() {
        return Map.of(
            "totalTasks", totalTasks,
            "completedTasks", completedTasks,
            "completedAt", completedAt
        );
    }
}

/**
 * タスク関連イベント
 */
public sealed interface TaskEvent extends DomainEvent
    permits TaskCreated, TaskAssigned, TaskCompleted {
}

/**
 * タスク作成イベント
 */
public record TaskCreated(
    String eventId,
    LocalDateTime occurredAt,
    Long aggregateId,
    Long projectId,
    String taskTitle,
    Long assigneeId,
    int priority
) implements TaskEvent {
    
    @Override
    public String eventType() {
        return "TASK_CREATED";
    }
    
    @Override
    public Map&lt;String, Object&gt; eventData() {
        return Map.of(
            "projectId", projectId,
            "taskTitle", taskTitle,
            "assigneeId", assigneeId,
            "priority", priority
        );
    }
}

/**
 * タスク割り当てイベント
 */
public record TaskAssigned(
    String eventId,
    LocalDateTime occurredAt,
    Long aggregateId,
    Long projectId,
    Long previousAssigneeId,
    Long newAssigneeId
) implements TaskEvent {
    
    @Override
    public String eventType() {
        return "TASK_ASSIGNED";
    }
    
    @Override
    public Map&lt;String, Object&gt; eventData() {
        return Map.of(
            "projectId", projectId,
            "previousAssigneeId", previousAssigneeId,
            "newAssigneeId", newAssigneeId
        );
    }
}

/**
 * タスク完了イベント
 */
public record TaskCompleted(
    String eventId,
    LocalDateTime occurredAt,
    Long aggregateId,
    Long projectId,
    String taskTitle,
    Long assigneeId,
    LocalDateTime completedAt
) implements TaskEvent {
    
    @Override
    public String eventType() {
        return "TASK_COMPLETED";
    }
    
    @Override
    public Map&lt;String, Object&gt; eventData() {
        return Map.of(
            "projectId", projectId,
            "taskTitle", taskTitle,
            "assigneeId", assigneeId,
            "completedAt", completedAt
        );
    }
}</code></pre>

                        <h6>イベント駆動ドメインサービス</h6>
                        <pre class="code-block"><code class="language-java">package com.example.todoapp.service;

import com.example.todoapp.event.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.CopyOnWriteArrayList;

@Service
public class EventDrivenProjectService {
    
    private final List&lt;DomainEvent&gt; eventStore = new CopyOnWriteArrayList&lt;&gt;();
    private final ProjectAggregateService projectService;
    
    @Autowired
    public EventDrivenProjectService(ProjectAggregateService projectService) {
        this.projectService = projectService;
    }
    
    /**
     * プロジェクト作成（イベント発行）
     */
    public Project createProjectWithEvent(Project project) {
        // プロジェクト作成
        Project savedProject = projectService.createProject(project);
        
        // イベント作成・発行
        ProjectCreated event = new ProjectCreated(
            UUID.randomUUID().toString(),
            LocalDateTime.now(),
            savedProject.id(),
            savedProject.name(),
            savedProject.description(),
            savedProject.ownerId(),
            savedProject.deadline()
        );
        
        publishEvent(event);
        return savedProject;
    }
    
    /**
     * プロジェクトステータス変更（イベント発行）
     */
    public Project changeProjectStatusWithEvent(Long projectId, String newStatus, Long ownerId, String reason) {
        // 現在のプロジェクト状態取得
        Project currentProject = projectService.getProjectDetail(projectId, ownerId)
                .map(dto -> new Project(dto.id(), dto.name(), dto.description(), 
                                      ownerId, dto.status(), dto.deadline(), 
                                      dto.createdAt(), LocalDateTime.now()))
                .orElseThrow(() -> new IllegalArgumentException("プロジェクトが見つかりません"));
        
        // ステータス更新
        Project updatedProject = projectService.updateProjectStatus(projectId, newStatus, ownerId);
        
        // ステータス変更イベント発行
        ProjectStatusChanged event = new ProjectStatusChanged(
            UUID.randomUUID().toString(),
            LocalDateTime.now(),
            projectId,
            currentProject.status(),
            newStatus,
            reason
        );
        
        publishEvent(event);
        
        // 完了イベントの追加発行
        if ("COMPLETED".equals(newStatus)) {
            publishProjectCompletedEvent(updatedProject);
        }
        
        return updatedProject;
    }
    
    /**
     * タスク作成（イベント発行）
     */
    public ProjectTask createTaskWithEvent(Long projectId, ProjectTask task, Long ownerId) {
        // タスク作成
        ProjectTask savedTask = projectService.addTaskToProject(projectId, task, ownerId);
        
        // イベント作成・発行
        TaskCreated event = new TaskCreated(
            UUID.randomUUID().toString(),
            LocalDateTime.now(),
            savedTask.id(),
            projectId,
            savedTask.title(),
            savedTask.assigneeId(),
            savedTask.priority()
        );
        
        publishEvent(event);
        return savedTask;
    }
    
    /**
     * タスク完了（イベント発行）
     */
    public ProjectTask completeTaskWithEvent(Long projectId, Long taskId, Long ownerId) {
        // タスクを完了状態に更新
        ProjectTask task = projectService.updateTask(
            projectId, 
            taskId, 
            getCurrentTask(projectId, taskId).withStatus("DONE"), 
            ownerId
        );
        
        // タスク完了イベント発行
        TaskCompleted event = new TaskCompleted(
            UUID.randomUUID().toString(),
            LocalDateTime.now(),
            taskId,
            projectId,
            task.title(),
            task.assigneeId(),
            LocalDateTime.now()
        );
        
        publishEvent(event);
        return task;
    }
    
    /**
     * イベントの発行
     */
    private void publishEvent(DomainEvent event) {
        // イベントをストアに保存
        eventStore.add(event);
        
        // イベントハンドラーの実行
        handleEvent(event);
        
        // ログ出力
        System.out.printf("[EVENT] %s: %s at %s%n", 
                         event.eventType(), 
                         event.aggregateId(), 
                         event.occurredAt());
    }
    
    /**
     * イベントハンドラー
     */
    private void handleEvent(DomainEvent event) {
        switch (event) {
            case ProjectCreated created -> handleProjectCreated(created);
            case ProjectStatusChanged changed -> handleProjectStatusChanged(changed);
            case ProjectCompleted completed -> handleProjectCompleted(completed);
            case TaskCreated taskCreated -> handleTaskCreated(taskCreated);
            case TaskCompleted taskCompleted -> handleTaskCompleted(taskCompleted);
            default -> System.out.println("未対応のイベント: " + event.eventType());
        }
    }
    
    // イベントハンドラー実装
    private void handleProjectCreated(ProjectCreated event) {
        // 通知送信、メトリクス更新など
        System.out.println("新しいプロジェクトが作成されました: " + event.projectName());
    }
    
    private void handleProjectStatusChanged(ProjectStatusChanged event) {
        System.out.printf("プロジェクト %d のステータスが %s から %s に変更されました%n",
                         event.aggregateId(), event.previousStatus(), event.newStatus());
    }
    
    private void handleProjectCompleted(ProjectCompleted event) {
        System.out.printf("プロジェクト %d が完了しました。タスク完了率: %d/%d%n",
                         event.aggregateId(), event.completedTasks(), event.totalTasks());
    }
    
    private void handleTaskCreated(TaskCreated event) {
        System.out.printf("プロジェクト %d に新しいタスクが追加されました: %s%n",
                         event.projectId(), event.taskTitle());
    }
    
    private void handleTaskCompleted(TaskCompleted event) {
        System.out.printf("タスク '%s' が完了しました（担当者ID: %d）%n",
                         event.taskTitle(), event.assigneeId());
    }
    
    /**
     * イベントストリーム取得
     */
    public List&lt;DomainEvent&gt; getEventStream() {
        return List.copyOf(eventStore);
    }
    
    /**
     * 特定集約のイベント履歴取得
     */
    public List&lt;DomainEvent&gt; getEventHistory(Long aggregateId) {
        return eventStore.stream()
                .filter(event -> event.aggregateId().equals(aggregateId))
                .toList();
    }
    
    // プライベートヘルパーメソッド
    private void publishProjectCompletedEvent(Project project) {
        ProjectCompleted event = new ProjectCompleted(
            UUID.randomUUID().toString(),
            LocalDateTime.now(),
            project.id(),
            0, // 実際の実装では適切にカウント
            0, // 実際の実装では適切にカウント
            LocalDateTime.now()
        );
        publishEvent(event);
    }
    
    private ProjectTask getCurrentTask(Long projectId, Long taskId) {
        // 実際の実装では適切にタスクを取得
        return new ProjectTask(taskId, projectId, "", "", 1L, "IN_PROGRESS", 3, 
                              null, LocalDateTime.now(), LocalDateTime.now());
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>不変なRecordベースのイベントによって、システムの状態変更が追跡可能になり、デバッグやモニタリングが向上することを確認できます。</p>
                    </div>

                    <!-- 理解度確認テスト -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <strong>Java Recordsの主な利点として正しくないものは？</strong>
                                <ul>
                                    <li>a) ボイラープレートコードの削減</li>
                                    <li>b) 不変性の保証</li>
                                    <li>c) 継承機能の強化</li>
                                    <li>d) 自動的なequals/hashCode生成</li>
                                </ul>
                            </li>
                            <li>
                                <strong>集約ルート（Aggregate Root）の基本原則として正しくないものは？</strong>
                                <ul>
                                    <li>a) 集約外からは集約ルートを通してのみアクセス</li>
                                    <li>b) 集約内の全エンティティが独立したトランザクション境界を持つ</li>
                                    <li>c) 集約ルートのみがグローバルな識別子を持つ</li>
                                    <li>d) 集約内部の整合性を保つ境界を定義</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Recordで状態変更を行う適切な方法は？</strong>
                                <ul>
                                    <li>a) フィールドに直接値を代入</li>
                                    <li>b) setterメソッドを使用</li>
                                    <li>c) 新しいRecordインスタンスを作成して返す</li>
                                    <li>d) Reflectionで内部フィールドを変更</li>
                                </ul>
                            </li>
                            <li>
                                <strong>イベント駆動アーキテクチャでRecordsを使用する利点は？</strong>
                                <ul>
                                    <li>a) イベントの可変性向上</li>
                                    <li>b) パフォーマンスの劣化</li>
                                    <li>c) イベントの不変性とスレッドセーフティ</li>
                                    <li>d) 複雑性の増加</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Spring Data JDBCでRecordを使用する際の注意点は？</strong>
                                <ul>
                                    <li>a) @Idアノテーションが使用できない</li>
                                    <li>b) バリデーションアノテーションが適用されない</li>
                                    <li>c) カスタムコンストラクタを追加する場合の制約</li>
                                    <li>d) JPAでしか使用できない</li>
                                </ul>
                            </li>
                        </ol>
                        <details>
                            <summary>解答と解説</summary>
                            <ol>
                                <li><strong>c) 継承機能の強化</strong><br>
                                Recordは継承をサポートしておらず（implemenetsは可能）、シンプルなデータクラスとしての機能に特化しています。</li>
                                <li><strong>b) 集約内の全エンティティが独立したトランザクション境界を持つ</strong><br>
                                集約は一つのトランザクション境界を形成し、集約内の整合性を保つことが重要な原則です。</li>
                                <li><strong>c) 新しいRecordインスタンスを作成して返す</strong><br>
                                Recordは不変なので、状態変更時は新しいインスタンスを作成して返すのが正しいアプローチです。</li>
                                <li><strong>c) イベントの不変性とスレッドセーフティ</strong><br>
                                不変なRecordベースのイベントは、並行処理においても安全で、予期しない変更を防ぐことができます。</li>
                                <li><strong>c) カスタムコンストラクタを追加する場合の制約</strong><br>
                                Recordでカスタムコンストラクタを追加する場合、最終的に正規コンストラクタを呼び出す必要があるという制約があります。</li>
                            </ol>
                        </details>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="spring-learning-material-10.html" class="btn btn-secondary">← 前の章</a>
                        <a href="spring-learning-material-ex-1.html" class="btn btn-primary">次の章 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js 初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>