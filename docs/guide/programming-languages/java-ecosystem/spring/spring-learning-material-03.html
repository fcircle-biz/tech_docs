<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring学習教材 第3章 - Spring Bootの基本構成とDI（依存性注入）</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <!-- カスタムCSS -->
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #4caf50;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }

        /* タイトル */
        .chapter-title {
            color: #4caf50;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #4caf50;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #66bb6a;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e8f5e8;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #4caf50;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #4caf50 !important;
            color: white !important;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand">
                <strong>Spring学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-01.html">
                                第1章: JavaとWebの基礎理解
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-02.html">
                                第2章: Spring Bootの導入と開発環境構築
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="spring-learning-material-03.html">
                                第3章: Spring Bootの基本構成とDI
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-04.html">
                                第4章: Webアプリケーション開発の基礎
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-05.html">
                                第5章: データベース連携
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-06.html">
                                第6章: 入力バリデーションとエラーハンドリング
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-07.html">
                                第7章: Spring Securityによる認証・認可
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-08.html">
                                第8章: Spring MVCのテスト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-09.html">
                                第9章: Todoアプリケーション開発
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-10.html">
                                第10章: さらに一歩進んだSpring開発へ①
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-11.html">
                                第11章: さらに一歩進んだSpring開発へ②
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-ex-01.html">
                                補足①: Spring Data JPA入門
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <!-- 章ヘッダー -->
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第3章: Spring Bootの基本構成とDI（依存性注入）</h1>
                </div>

                <div id="chapter3">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">依存性注入とSpringコンポーネントの基礎</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>依存性注入（Dependency Injection）の概念と必要性を理解する</li>
                            <li>Spring Bootの自動設定（Auto Configuration）の仕組み</li>
                            <li>コンポーネントスキャンとステレオタイプアノテーションの使い方</li>
                            <li>DIの種類（コンストラクタ注入、セッター注入、フィールド注入）</li>
                            <li>Javaコンフィグによる設定とapplication.ymlの基本</li>
                        </ul>
                    </div>

                    <!-- 依存性注入の概念 -->
                    <h3 class="section-title">3.1 依存性注入（Dependency Injection）とは</h3>
                    
                    <p>依存性注入（Dependency Injection, DI）は、オブジェクト間の依存関係を外部から注入する設計パターンです。従来のプログラミングでは、オブジェクトが必要な依存オブジェクトを自分で作成していましたが、DIでは外部からそれらを提供します。</p>

                    <h4>DIを使わない従来のアプローチ</h4>
                    <p>まず、DIを使わない場合の問題点を確認しましょう。</p>

                    <pre class="code-block"><code class="language-java">// DIを使わない例（問題のあるコード）
public class UserService {
    private UserRepository userRepository;
    
    public UserService() {
        // 依存オブジェクトを直接作成
        this.userRepository = new UserRepository();
    }
    
    public User findById(Long id) {
        return userRepository.findById(id);
    }
}

public class UserRepository {
    public User findById(Long id) {
        // データベースアクセス処理
        return new User(id, "ユーザー" + id);
    }
}</code></pre>

                    <div class="warning">
                        <h6>従来のアプローチの問題点</h6>
                        <ul>
                            <li><strong>密結合</strong>：UserServiceがUserRepositoryの具体的な実装に依存</li>
                            <li><strong>テストしにくい</strong>：モックオブジェクトに置き換えることができない</li>
                            <li><strong>再利用しにくい</strong>：異なるUserRepository実装を使いたい場合にコード変更が必要</li>
                            <li><strong>設定が複雑</strong>：依存関係が深くなると、初期化順序が複雑になる</li>
                        </ul>
                    </div>

                    <h4>DIを使ったアプローチ</h4>
                    <p>DIを使うことで、これらの問題を解決できます。</p>

                    <pre class="code-block"><code class="language-java">// DIを使った例（改善されたコード）
@Service
public class UserService {
    private final UserRepository userRepository;
    
    // コンストラクタで依存性を注入
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public User findById(Long id) {
        return userRepository.findById(id);
    }
}

@Repository
public class UserRepository {
    public User findById(Long id) {
        // データベースアクセス処理
        return new User(id, "ユーザー" + id);
    }
}</code></pre>

                    <div class="highlight">
                        <h6>DIのメリット</h6>
                        <ul>
                            <li><strong>疎結合</strong>：具体的な実装ではなく、インターフェースに依存</li>
                            <li><strong>テストしやすい</strong>：簡単にモックオブジェクトに置き換え可能</li>
                            <li><strong>再利用性</strong>：異なる実装を簡単に差し替え可能</li>
                            <li><strong>保守性</strong>：依存関係の管理をフレームワークに委譲</li>
                        </ul>
                    </div>

                    <div class="mermaid">
                        flowchart TD
                            A["従来のアプローチ"] --> B["UserService"]
                            B --> C["new UserRepository()"]
                            C --> D["密結合・テスト困難"]
                            
                            E["DIを使ったアプローチ"] --> F["UserService"]
                            G["Spring Container"] --> H["UserRepository"]
                            H --> F
                            F --> I["疎結合・テスト容易"]
                            
                            class A,D fill:#ffebee
                            class E,I fill:#e8f5e8
                            class G fill:#e3f2fd
                    </div>

                    <!-- Springコンテナの仕組み -->
                    <h3 class="section-title">3.2 SpringコンテナとBean管理</h3>

                    <p>Springでは、DIコンテナ（ApplicationContext）がオブジェクトのライフサイクルと依存関係を管理します。このコンテナによって管理されるオブジェクトを「Bean」と呼びます。</p>

                    <div class="mermaid">
                        flowchart TB
                            A["Spring Container<br/>(ApplicationContext)"] --> B["Bean定義の読み込み"]
                            B --> C["Beanインスタンスの作成"]
                            C --> D["依存関係の注入"]
                            D --> E["初期化処理の実行"]
                            E --> F["Beanの使用準備完了"]
                            
                            G["@Component"] --> B
                            H["@Service"] --> B
                            I["@Repository"] --> B
                            J["@Controller"] --> B
                            
                            class A fill:#e3f2fd
                            class F fill:#e8f5e8
                    </div>

                    <h4>Beanのライフサイクル</h4>
                    <p>Spring Beanは以下のライフサイクルを持ちます：</p>

                    <div class="highlight">
                        <h6>Beanライフサイクルの段階</h6>
                        <ol>
                            <li><strong>Bean定義の読み込み</strong>：アノテーションやJavaConfigからBean定義を収集</li>
                            <li><strong>Beanインスタンス化</strong>：コンストラクタを呼び出してオブジェクト作成</li>
                            <li><strong>依存関係注入</strong>：他のBeanを注入</li>
                            <li><strong>初期化処理</strong>：@PostConstructメソッドの実行</li>
                            <li><strong>Bean使用可能</strong>：アプリケーションで使用可能</li>
                            <li><strong>破棄処理</strong>：@PreDestroyメソッドの実行（アプリケーション終了時）</li>
                        </ol>
                    </div>

                    <!-- ステレオタイプアノテーション -->
                    <h3 class="section-title">3.3 ステレオタイプアノテーション</h3>

                    <p>Springでは、クラスの役割に応じて異なるステレオタイプアノテーションを使用します。これらのアノテーションにより、Springが自動的にBeanとして登録します。</p>

                    <h4>主要なステレオタイプアノテーション</h4>

                    <div class="row">
                        <div class="col-md-6">
                            <h5>@Component</h5>
                            <div class="highlight">
                                <p><strong>用途</strong>：汎用的なSpring管理コンポーネント</p>
                                <p><strong>使用場面</strong>：他のステレオタイプに当てはまらない場合</p>
                                <pre class="code-block"><code class="language-java">@Component
public class EmailService {
    public void sendEmail(String message) {
        System.out.println("送信: " + message);
    }
}</code></pre>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <h5>@Service</h5>
                            <div class="highlight">
                                <p><strong>用途</strong>：ビジネスロジック層</p>
                                <p><strong>使用場面</strong>：サービスクラス、ビジネス処理</p>
                                <pre class="code-block"><code class="language-java">@Service
public class UserService {
    public void processUser(User user) {
        // ビジネスロジック処理
    }
}</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-md-6">
                            <h5>@Repository</h5>
                            <div class="highlight">
                                <p><strong>用途</strong>：データアクセス層</p>
                                <p><strong>使用場面</strong>：データベースアクセス、DAO</p>
                                <pre class="code-block"><code class="language-java">@Repository
public class UserRepository {
    public User findById(Long id) {
        // データアクセス処理
        return user;
    }
}</code></pre>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <h5>@Controller</h5>
                            <div class="highlight">
                                <p><strong>用途</strong>：プレゼンテーション層</p>
                                <p><strong>使用場面</strong>：Webコントローラー、リクエスト処理</p>
                                <pre class="code-block"><code class="language-java">@Controller
public class UserController {
    @GetMapping("/users")
    public String listUsers() {
        return "users";
    }
}</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="mermaid">
                        classDiagram
                            class Component {
                                &lt;&lt;annotation&gt;&gt;
                                +汎用コンポーネント
                            }
                            class Service {
                                &lt;&lt;annotation&gt;&gt;
                                +ビジネスロジック層
                            }
                            class Repository {
                                &lt;&lt;annotation&gt;&gt;
                                +データアクセス層
                            }
                            class Controller {
                                &lt;&lt;annotation&gt;&gt;
                                +プレゼンテーション層
                            }
                            
                            Component <|-- Service
                            Component <|-- Repository
                            Component <|-- Controller
                    </div>

                    <!-- DIの種類 -->
                    <h3 class="section-title">3.4 依存性注入の種類</h3>

                    <p>Springでは、3種類の依存性注入方法をサポートしています。それぞれにメリットとデメリットがあります。</p>

                    <h4>1. コンストラクタ注入（推奨）</h4>
                    <p>コンストラクタの引数として依存関係を注入します。Spring 4.3以降では、単一コンストラクタの場合は@Autowiredアノテーションを省略できます。</p>

                    <pre class="code-block"><code class="language-java">@Service
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    // コンストラクタ注入（@Autowired省略可能）
    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
    
    public void createUser(User user) {
        userRepository.save(user);
        emailService.sendWelcomeEmail(user.getEmail());
    }
}</code></pre>

                    <div class="highlight">
                        <h6>コンストラクタ注入のメリット</h6>
                        <ul>
                            <li><strong>不変性</strong>：final修飾子を使用でき、オブジェクトが不変</li>
                            <li><strong>必須依存関係</strong>：必要な依存関係が確実に注入される</li>
                            <li><strong>テストしやすい</strong>：テスト時に依存関係を簡単に提供できる</li>
                            <li><strong>循環依存の検出</strong>：循環依存がある場合は起動時に検出される</li>
                        </ul>
                    </div>

                    <h4>2. セッター注入</h4>
                    <p>セッターメソッドを通じて依存関係を注入します。</p>

                    <pre class="code-block"><code class="language-java">@Service
public class UserService {
    private UserRepository userRepository;
    private EmailService emailService;
    
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Autowired
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
}</code></pre>

                    <div class="highlight">
                        <h6>セッター注入の特徴</h6>
                        <ul>
                            <li><strong>オプション依存関係</strong>：必須でない依存関係に適している</li>
                            <li><strong>再設定可能</strong>：実行時に依存関係を変更可能</li>
                            <li><strong>循環依存の解決</strong>：循環依存がある場合の回避策</li>
                        </ul>
                    </div>

                    <h4>3. フィールド注入（非推奨）</h4>
                    <p>フィールドに直接@Autowiredアノテーションを付けて注入します。</p>

                    <pre class="code-block"><code class="language-java">@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
}</code></pre>

                    <div class="warning">
                        <h6>フィールド注入が非推奨の理由</h6>
                        <ul>
                            <li><strong>テストが困難</strong>：リフレクションを使わないと依存関係を設定できない</li>
                            <li><strong>immutableでない</strong>：final修飾子を使用できない</li>
                            <li><strong>循環依存が隠れやすい</strong>：実行時まで問題に気付かない可能性</li>
                            <li><strong>Springに依存</strong>：フレームワークに強く依存したコードになる</li>
                        </ul>
                    </div>

                    <!-- 実習 -->
                    <div class="exercise-container">
                        <h5>実習 3-1: ステレオタイプアノテーションとDIの実装</h5>
                        <p>簡単な図書管理システムを作成して、DIの動作を確認しましょう。</p>
                        
                        <h6>手順1: Bookエンティティの作成</h6>
                        <pre class="code-block"><code class="language-java">public class Book {
    private Long id;
    private String title;
    private String author;
    
    public Book(Long id, String title, String author) {
        this.id = id;
        this.title = title;
        this.author = author;
    }
    
    // getter/setterメソッド
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }
    
    public String getAuthor() { return author; }
    public void setAuthor(String author) { this.author = author; }
    
    @Override
    public String toString() {
        return String.format("Book{id=%d, title='%s', author='%s'}", 
                           id, title, author);
    }
}</code></pre>

                        <h6>手順2: BookRepositoryの作成</h6>
                        <pre class="code-block"><code class="language-java">@Repository
public class BookRepository {
    private final List&lt;Book&gt; books = new ArrayList&lt;&gt;();
    
    public BookRepository() {
        // 初期データ
        books.add(new Book(1L, "Springの教科書", "山田太郎"));
        books.add(new Book(2L, "Java実践入門", "田中花子"));
    }
    
    public List&lt;Book&gt; findAll() {
        return new ArrayList&lt;&gt;(books);
    }
    
    public Optional&lt;Book&gt; findById(Long id) {
        return books.stream()
                   .filter(book -&gt; book.getId().equals(id))
                   .findFirst();
    }
    
    public void save(Book book) {
        books.add(book);
        System.out.println("書籍を保存しました: " + book);
    }
}</code></pre>

                        <h6>手順3: BookServiceの作成</h6>
                        <pre class="code-block"><code class="language-java">@Service
public class BookService {
    private final BookRepository bookRepository;
    
    // コンストラクタ注入
    public BookService(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
        System.out.println("BookService が作成されました");
    }
    
    public List&lt;Book&gt; getAllBooks() {
        System.out.println("全ての書籍を取得します");
        return bookRepository.findAll();
    }
    
    public Book getBookById(Long id) {
        return bookRepository.findById(id)
                           .orElse(null);
    }
    
    public void addBook(String title, String author) {
        Long newId = (long) (bookRepository.findAll().size() + 1);
        Book book = new Book(newId, title, author);
        bookRepository.save(book);
    }
}</code></pre>

                        <h6>手順4: BookControllerの作成</h6>
                        <pre class="code-block"><code class="language-java">@RestController
public class BookController {
    private final BookService bookService;
    
    // コンストラクタ注入
    public BookController(BookService bookService) {
        this.bookService = bookService;
        System.out.println("BookController が作成されました");
    }
    
    @GetMapping("/books")
    public List&lt;Book&gt; getAllBooks() {
        return bookService.getAllBooks();
    }
    
    @GetMapping("/books/{id}")
    public Book getBook(@PathVariable Long id) {
        return bookService.getBookById(id);
    }
    
    @PostMapping("/books")
    public String addBook(@RequestParam String title, 
                         @RequestParam String author) {
        bookService.addBook(title, author);
        return "書籍を追加しました: " + title + " by " + author;
    }
}</code></pre>

                        <h6>手順5: 動作確認</h6>
                        <p>アプリケーションを起動し、以下のURLでテスト：</p>
                        <ul>
                            <li>GET http://localhost:8080/books - 全書籍取得</li>
                            <li>GET http://localhost:8080/books/1 - ID=1の書籍取得</li>
                            <li>POST http://localhost:8080/books?title=新しい本&author=新しい著者 - 書籍追加</li>
                        </ul>
                    </div>

                    <!-- コンポーネントスキャン -->
                    <h3 class="section-title">3.5 コンポーネントスキャンの仕組み</h3>

                    <p>@SpringBootApplicationアノテーションは、同じパッケージおよびサブパッケージに対してコンポーネントスキャンを実行します。</p>

                    <div class="mermaid">
                        flowchart TD
                            A["@SpringBootApplication"] --> B["com.example.demo"]
                            B --> C["コンポーネントスキャン開始"]
                            C --> D["com.example.demo.*"]
                            C --> E["com.example.demo.service.*"]
                            C --> F["com.example.demo.repository.*"]
                            C --> G["com.example.demo.controller.*"]
                            
                            D --> H["@Component"]
                            E --> I["@Service"]
                            F --> J["@Repository"]
                            G --> K["@Controller"]
                            
                            H --> L["Springコンテナに登録"]
                            I --> L
                            J --> L
                            K --> L
                    </div>

                    <h4>カスタムコンポーネントスキャンの設定</h4>
                    <p>デフォルトのスキャン範囲を変更したい場合は、@ComponentScanアノテーションを使用します。</p>

                    <pre class="code-block"><code class="language-java">@SpringBootApplication
@ComponentScan(basePackages = {"com.example.demo", "com.external.library"})
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}</code></pre>

                    <!-- JavaConfig -->
                    <h3 class="section-title">3.6 Javaコンフィグによる設定</h3>

                    <p>アノテーションだけでなく、Javaクラスを使用して明示的にBeanを定義することも可能です。</p>

                    <h4>@Configurationと@Bean</h4>

                    <pre class="code-block"><code class="language-java">@Configuration
public class AppConfig {
    
    @Bean
    public DatabaseConfig databaseConfig() {
        DatabaseConfig config = new DatabaseConfig();
        config.setUrl("jdbc:postgresql://localhost:5432/mydb");
        config.setUsername("user");
        config.setPassword("password");
        return config;
    }
    
    @Bean
    public DataSource dataSource(DatabaseConfig config) {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(config.getUrl());
        dataSource.setUsername(config.getUsername());
        dataSource.setPassword(config.getPassword());
        return dataSource;
    }
}</code></pre>

                    <div class="highlight">
                        <h6>@Configurationクラスの用途</h6>
                        <ul>
                            <li><strong>外部ライブラリのBean設定</strong>：自分でアノテーションを付けられないクラス</li>
                            <li><strong>複雑な初期化処理</strong>：コンストラクタだけでは完結しない設定</li>
                            <li><strong>条件付きBean作成</strong>：環境に応じた異なるBean実装</li>
                            <li><strong>ファクトリーメソッド</strong>：複雑なオブジェクト作成ロジック</li>
                        </ul>
                    </div>

                    <!-- application.yml -->
                    <h3 class="section-title">3.7 設定外部化とapplication.yml</h3>

                    <p>Spring Bootでは、アプリケーションの設定を外部化できます。application.propertiesよりもapplication.ymlの方が階層的で読みやすい設定ファイルを作成できます。</p>

                    <h4>application.ymlの基本構造</h4>

                    <pre class="code-block"><code class="language-yaml"># サーバー設定
server:
  port: 8080
  servlet:
    context-path: /api

# Spring設定
spring:
  application:
    name: book-management-system
  
  # データベース設定
  datasource:
    url: jdbc:postgresql://localhost:5432/bookdb
    username: bookuser
    password: bookpass
    driver-class-name: org.postgresql.Driver
  
  # JPA設定
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true

# ログ設定
logging:
  level:
    com.example.demo: DEBUG
    org.springframework.web: INFO
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"

# カスタム設定
app:
  book:
    max-count: 1000
    default-author: "不明"</code></pre>

                    <h4>@ConfigurationPropertiesを使った設定値の読み込み</h4>

                    <pre class="code-block"><code class="language-java">@ConfigurationProperties(prefix = "app.book")
@Component
public class BookProperties {
    private int maxCount = 100;
    private String defaultAuthor = "不明";
    
    // getter/setter
    public int getMaxCount() { return maxCount; }
    public void setMaxCount(int maxCount) { this.maxCount = maxCount; }
    
    public String getDefaultAuthor() { return defaultAuthor; }
    public void setDefaultAuthor(String defaultAuthor) { 
        this.defaultAuthor = defaultAuthor; 
    }
}</code></pre>

                    <h4>設定値の使用例</h4>

                    <pre class="code-block"><code class="language-java">@Service
public class BookService {
    private final BookRepository bookRepository;
    private final BookProperties bookProperties;
    
    public BookService(BookRepository bookRepository, 
                      BookProperties bookProperties) {
        this.bookRepository = bookRepository;
        this.bookProperties = bookProperties;
    }
    
    public void addBook(String title, String author) {
        if (bookRepository.findAll().size() >= bookProperties.getMaxCount()) {
            throw new RuntimeException("書籍数の上限に達しています");
        }
        
        String finalAuthor = (author == null || author.isEmpty()) 
                           ? bookProperties.getDefaultAuthor() 
                           : author;
        
        // 書籍追加処理...
    }
}</code></pre>

                    <!-- 実習 -->
                    <div class="exercise-container">
                        <h5>実習 3-2: プロファイル別設定の活用</h5>
                        <p>開発環境と本番環境で異なる設定を使用する方法を学習しましょう。</p>
                        
                        <h6>手順1: application-dev.ymlの作成</h6>
                        <pre class="code-block"><code class="language-yaml"># 開発環境用設定
server:
  port: 8081

logging:
  level:
    com.example.demo: DEBUG
    
app:
  book:
    max-count: 10
    default-author: "開発者"</code></pre>

                        <h6>手順2: application-prod.ymlの作成</h6>
                        <pre class="code-block"><code class="language-yaml"># 本番環境用設定
server:
  port: 80

logging:
  level:
    com.example.demo: INFO
    
app:
  book:
    max-count: 10000
    default-author: "システム"</code></pre>

                        <h6>手順3: プロファイルの指定方法</h6>
                        <ul>
                            <li>IDE実行時：VM options に <code>-Dspring.profiles.active=dev</code></li>
                            <li>JAR実行時：<code>java -jar app.jar --spring.profiles.active=prod</code></li>
                            <li>環境変数：<code>SPRING_PROFILES_ACTIVE=dev</code></li>
                        </ul>
                    </div>

                    <!-- 理解度確認 -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <strong>依存性注入（DI）の主なメリットを3つ挙げてください。</strong>
                                <details>
                                    <summary>解答を見る</summary>
                                    <p>1. 疎結合：クラス間の依存関係が減り、保守性が向上<br>
                                    2. テストしやすさ：モックオブジェクトに簡単に置き換え可能<br>
                                    3. 再利用性：異なる実装を簡単に差し替え可能</p>
                                </details>
                            </li>
                            <li>
                                <strong>4つの主要なステレオタイプアノテーションとその用途を説明してください。</strong>
                                <details>
                                    <summary>解答を見る</summary>
                                    <p>@Component：汎用的なSpring管理コンポーネント<br>
                                    @Service：ビジネスロジック層のクラス<br>
                                    @Repository：データアクセス層のクラス<br>
                                    @Controller：プレゼンテーション層、Webリクエスト処理</p>
                                </details>
                            </li>
                            <li>
                                <strong>コンストラクタ注入が推奨される理由を説明してください。</strong>
                                <details>
                                    <summary>解答を見る</summary>
                                    <p>1. 不変性：final修飾子を使用でき、オブジェクトが不変<br>
                                    2. 必須依存関係の保証：必要な依存関係が確実に注入される<br>
                                    3. テストしやすさ：テスト時に依存関係を簡単に提供できる<br>
                                    4. 循環依存の早期検出：起動時に問題を発見できる</p>
                                </details>
                            </li>
                            <li>
                                <strong>@ConfigurationPropertiesアノテーションの用途は何ですか？</strong>
                                <details>
                                    <summary>解答を見る</summary>
                                    <p>application.ymlやapplication.propertiesファイルの設定値を、タイプセーフにJavaオブジェクトにバインドするために使用します。これにより、設定値をコードで安全に扱うことができます。</p>
                                </details>
                            </li>
                            <li>
                                <strong>Spring Bootのコンポーネントスキャンはデフォルトでどの範囲を対象としますか？</strong>
                                <details>
                                    <summary>解答を見る</summary>
                                    <p>@SpringBootApplicationアノテーションが付けられたクラスと同じパッケージ、およびそのサブパッケージが対象となります。例えば、com.example.demoパッケージにメインクラスがある場合、com.example.demo.*のパッケージがスキャン対象です。</p>
                                </details>
                            </li>
                        </ol>
                    </div>

                    <!-- まとめ -->
                    <h3 class="section-title">3.8 まとめ</h3>
                    <p>この章では、Spring Bootの核心機能である依存性注入（DI）について詳しく学習しました。</p>

                    <div class="highlight">
                        <h6>重要なポイント</h6>
                        <ul>
                            <li>DIは、オブジェクト間の依存関係を外部から注入する設計パターン</li>
                            <li>Springコンテナ（ApplicationContext）がBeanのライフサイクルを管理</li>
                            <li>ステレオタイプアノテーション（@Component、@Service、@Repository、@Controller）でBeanを定義</li>
                            <li>コンストラクタ注入が最も推奨される依存性注入方法</li>
                            <li>@ConfigurationクラスでJava設定ベースのBean定義が可能</li>
                            <li>application.ymlで設定を外部化し、プロファイル別に管理できる</li>
                        </ul>
                    </div>

                    <p>次の章では、これらのDIの概念を活用して、実際のWebアプリケーション開発（Spring MVC）を学習します。MVCアーキテクチャのコントローラー、サービス、リポジトリ各層でのDI活用方法を実践的に理解できます。</p>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="spring-learning-material-02.html" class="btn btn-secondary">← 前の章</a>
                        <a href="spring-learning-material-04.html" class="btn btn-primary">次の章 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js 初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>