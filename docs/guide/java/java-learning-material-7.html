<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java入出力操作の学習教材</title>
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        .navbar {
            background-color: #1565c0;
        }
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        .chapter-title {
            color: #1565c0;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #1565c0;
            padding-bottom: 0.5rem;
        }
        .section-title {
            color: #1976d2;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        code {
            display: block;
            background-color: #f5f5f5;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            white-space: pre;
            overflow-x: auto;
        }
        .quiz-container {
            background-color: #e3f2fd;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }
        .quiz-question {
            font-weight: 500;
            margin-bottom: 1rem;
        }
        .diagram {
            max-width: 100%;
            height: auto;
            margin: 1.5rem 0;
            text-align: center;
        }
        .exercise {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        .note {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        #table-of-contents .list-group-item {
            border: none;
            padding: 0.5rem 1rem;
        }
        #table-of-contents .list-group-item-action {
            color: #1976d2;
        }
        /* 選択された目次項目のスタイル */
        #table-of-contents .list-group-item-action.active,
        .list-group-item.active {
            color: white !important; /* テキストを白色にして青い背景に対してコントラストをつける */
            background-color: #1976d2;
            border-color: #1976d2;
        }
        .section-nav {
            padding-left: 1rem;
        }
        .comparison-table {
            width: 100%;
            margin: 1.5rem 0;
        }
        .comparison-table th {
            background-color: #e3f2fd;
        }
        .comparison-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        .comparison-table td, .comparison-table th {
            padding: 0.75rem;
            border: 1px solid #dee2e6;
        }
        .inline-code {
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            background-color: #f5f5f5;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9em;
        }
    </style>
</head>
<body data-bs-spy="scroll" data-bs-target="#tableOfContents">
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="#">Java入出力操作の学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="#introduction">はじめに</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#chapter7">第7章: 入出力操作</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container my-4">
        <div class="row">
            <!-- Sidebar - Table of Contents -->
            <div class="col-lg-3">
                <div class="sidebar">
                    <div class="card">
                        <div class="card-header bg-primary text-white">
                            <h5 class="mb-0">目次</h5>
                        </div>
                        <div id="table-of-contents" class="list-group list-group-flush">
                            <a href="#introduction" class="list-group-item list-group-item-action">はじめに</a>
                            <a href="#chapter7" class="list-group-item list-group-item-action">第7章: 入出力操作</a>
                            <div class="section-nav">
                                <a href="#io-basics" class="list-group-item list-group-item-action">7.1 ファイル入出力の基本</a>
                                <a href="#byte-char-streams" class="list-group-item list-group-item-action">7.2 バイトストリームとキャラクタストリーム</a>
                                <a href="#buffering" class="list-group-item list-group-item-action">7.3 バッファリング</a>
                                <a href="#serialization" class="list-group-item list-group-item-action">7.4 オブジェクトのシリアル化</a>
                                <a href="#nio" class="list-group-item list-group-item-action">7.5 NIO (New I/O)</a>
                                <a href="#chapter7-quiz" class="list-group-item list-group-item-action">7.6 理解度確認テスト</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Main Content -->
            <div class="col-lg-9">
                <section id="introduction">
                    <h1 class="display-5 mb-4">Java入出力操作の学習教材</h1>
                    <p class="lead">この教材では、Javaのファイル入出力操作について学びます。ファイル操作の基本から始まり、ストリーム、バッファリング、オブジェクトのシリアル化、そして新しいNIO APIまで、実践的な例と演習を通じて理解を深めていきましょう。</p>
                    <div class="note">
                        <h5>この章の学習目標</h5>
                        <ul>
                            <li>Javaのファイル入出力の基本概念と仕組みを理解する</li>
                            <li>バイトストリームとキャラクタストリームの違いと使い分けを学ぶ</li>
                            <li>バッファリングを使った効率的な入出力方法を習得する</li>
                            <li>オブジェクトのシリアル化/デシリアル化の方法を習得する</li>
                            <li>新しいNIO APIの特徴と基本的な使用方法を理解する</li>
                        </ul>
                    </div>
                </section>

                <section id="chapter7">
                    <h2 class="chapter-title">第7章：入出力操作</h2>
                    <p>入出力操作（I/O操作）は、プログラムが外部とデータをやり取りするための基本的な機能です。ファイルの読み書き、ネットワーク通信、データベースとの接続など、多くのアプリケーションで必要となる重要なスキルです。</p>

                    <section id="io-basics">
                        <h3 class="section-title">7.1 ファイル入出力の基本</h3>
                        <p>Javaでは、ファイルの入出力操作を行うために<span class="inline-code">java.io</span>パッケージを使用します。このパッケージには、ファイルの読み書きに必要なクラスが数多く含まれています。</p>
                        
                        <h4>File クラス</h4>
                        <p><span class="inline-code">File</span>クラスは、ファイルやディレクトリを表現するクラスです。ファイルの作成、削除、名前変更などの基本的な操作ができます。</p>
                        
                        <code>import java.io.File;

public class FileExample {
    public static void main(String[] args) {
        // Fileオブジェクトの作成
        File file = new File("example.txt");
        
        // ファイル情報の取得
        System.out.println("ファイル名: " + file.getName());
        System.out.println("絶対パス: " + file.getAbsolutePath());
        System.out.println("親ディレクトリ: " + file.getParent());
        System.out.println("存在するか: " + file.exists());
        System.out.println("ファイルか: " + file.isFile());
        System.out.println("ディレクトリか: " + file.isDirectory());
        
        // ファイル作成（存在しない場合）
        try {
            if (!file.exists()) {
                boolean created = file.createNewFile();
                System.out.println("ファイル作成: " + created);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code>
                        
                        <h4>ディレクトリ操作</h4>
                        <p><span class="inline-code">File</span>クラスを使用して、ディレクトリの作成や内容のリスト取得も行えます。</p>
                        
                        <code>import java.io.File;

public class DirectoryExample {
    public static void main(String[] args) {
        // ディレクトリの作成
        File dir = new File("myDirectory");
        if (!dir.exists()) {
            boolean created = dir.mkdir();
            System.out.println("ディレクトリ作成: " + created);
        }
        
        // 親ディレクトリを含む複数階層のディレクトリ作成
        File nestedDir = new File("parent/child/grandchild");
        if (!nestedDir.exists()) {
            boolean created = nestedDir.mkdirs();
            System.out.println("ネストしたディレクトリの作成: " + created);
        }
        
        // ディレクトリ内のファイル一覧の取得
        File currentDir = new File(".");
        File[] files = currentDir.listFiles();
        System.out.println("カレントディレクトリの内容:");
        for (File f : files) {
            System.out.println(f.getName() + (f.isDirectory() ? " [ディレクトリ]" : " [ファイル]"));
        }
    }
}</code>
                        
                        <div class="note">
                            <h5>Javaのファイルパス</h5>
                            <p>Javaでは、ファイルパスを指定する際に以下の点に注意が必要です：</p>
                            <ul>
                                <li>相対パス: カレントディレクトリからの相対的な位置を指定（例：<span class="inline-code">"data/config.txt"</span>）</li>
                                <li>絶対パス: ルートからの完全なパスを指定（例：<span class="inline-code">"/home/user/data/config.txt"</span>）</li>
                                <li>Windowsでは、バックスラッシュ（\）はエスケープ文字として扱われるため、<span class="inline-code">"C:\\Users\\name\\Documents"</span>のように二重にするか、<span class="inline-code">"C:/Users/name/Documents"</span>のように前方スラッシュ（/）を使用します</li>
                            </ul>
                        </div>
                        
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 300">
                                <rect x="50" y="20" width="500" height="260" fill="#f5f5f5" stroke="#1976d2" stroke-width="2" rx="10" />
                                <text x="300" y="50" text-anchor="middle" font-size="18" font-weight="bold">Javaファイル操作の基本フロー</text>
                                
                                <rect x="100" y="80" width="120" height="60" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="160" y="115" text-anchor="middle" font-size="10">File オブジェクト作成</text>
                                
                                <rect x="100" y="180" width="120" height="60" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="160" y="215" text-anchor="middle" font-size="14">ファイル情報取得</text>
                                
                                <rect x="240" y="80" width="120" height="60" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="300" y="115" text-anchor="middle" font-size="14">ファイル操作</text>
                                
                                <rect x="240" y="180" width="120" height="60" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="300" y="215" text-anchor="middle" font-size="14">例外処理</text>
                                
                                <rect x="380" y="80" width="120" height="60" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="440" y="115" text-anchor="middle" font-size="14">リソース解放</text>
                                
                                <!-- 矢印 -->
                                <line x1="160" y1="140" x2="160" y2="180" stroke="#1976d2" stroke-width="2" />
                                <polygon points="160,180 155,170 165,170" fill="#1976d2" />
                                
                                <line x1="220" y1="110" x2="240" y2="110" stroke="#1976d2" stroke-width="2" />
                                <polygon points="240,110 230,105 230,115" fill="#1976d2" />
                                
                                <line x1="300" y1="140" x2="300" y2="180" stroke="#1976d2" stroke-width="2" />
                                <polygon points="300,180 295,170 305,170" fill="#1976d2" />
                                
                                <line x1="360" y1="110" x2="380" y2="110" stroke="#1976d2" stroke-width="2" />
                                <polygon points="380,110 370,105 370,115" fill="#1976d2" />
                            </svg>
                            <p class="text-center">図7.1: Javaファイル操作の基本的なフロー</p>
                        </div>
                        
                        <div class="exercise">
                            <h5>練習問題 7.1: ファイル情報ユーティリティ</h5>
                            <p>以下の機能を持つユーティリティクラスを作成してください：</p>
                            <ol>
                                <li>指定されたディレクトリ内のすべてのファイルとサブディレクトリを再帰的にリストアップする</li>
                                <li>各ファイルについて、ファイル名、サイズ、最終更新日時を表示する</li>
                                <li>特定の拡張子（例：.java）を持つファイルのみをフィルタリングする機能を追加する</li>
                            </ol>
                            <p>ヒント: <span class="inline-code">File.listFiles()</span>メソッドと再帰処理を組み合わせて使用します。</p>
                        </div>
                    </section>

                    <section id="byte-char-streams">
                        <h3 class="section-title">7.2 バイトストリームとキャラクタストリーム</h3>
                        <p>Javaの入出力操作では、主に2種類のストリームがあります：</p>
                        <ul>
                            <li><strong>バイトストリーム</strong>：バイナリデータを扱うためのストリーム</li>
                            <li><strong>キャラクタストリーム</strong>：テキストデータを扱うためのストリーム</li>
                        </ul>
                        
                        <h4>バイトストリーム</h4>
                        <p>バイトストリームは、<span class="inline-code">InputStream</span>と<span class="inline-code">OutputStream</span>の2つの抽象クラスをベースにしています。これらのクラスは、バイト単位でデータを読み書きするための基本的なメソッドを提供します。</p>
                        
                        <h5>主なバイトストリームクラス</h5>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>入力ストリーム</th>
                                    <th>出力ストリーム</th>
                                    <th>説明</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>FileInputStream</td>
                                    <td>FileOutputStream</td>
                                    <td>ファイルからのバイト単位の読み書き</td>
                                </tr>
                                <tr>
                                    <td>ByteArrayInputStream</td>
                                    <td>ByteArrayOutputStream</td>
                                    <td>バイト配列のメモリ上での読み書き</td>
                                </tr>
                                <tr>
                                    <td>BufferedInputStream</td>
                                    <td>BufferedOutputStream</td>
                                    <td>バッファリングによる効率的な読み書き</td>
                                </tr>
                                <tr>
                                    <td>DataInputStream</td>
                                    <td>DataOutputStream</td>
                                    <td>プリミティブ型データの読み書き</td>
                                </tr>
                                <tr>
                                    <td>ObjectInputStream</td>
                                    <td>ObjectOutputStream</td>
                                    <td>オブジェクトのシリアル化と逆シリアル化</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <p>バイトストリームを使用したファイルのコピー例：</p>
                        
                        <code>import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class ByteStreamExample {
    public static void main(String[] args) {
        try (FileInputStream input = new FileInputStream("source.dat");
             FileOutputStream output = new FileOutputStream("destination.dat")) {
            
            byte[] buffer = new byte[1024]; // 1KBバッファ
            int bytesRead;
            
            // 入力ストリームからデータを読み込み、出力ストリームに書き込む
            while ((bytesRead = input.read(buffer)) != -1) {
                output.write(buffer, 0, bytesRead);
            }
            
            System.out.println("ファイルのコピーが完了しました。");
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code>
                        
                        <div class="note">
                            <h5>try-with-resources文</h5>
                            <p>Java 7以降では、<span class="inline-code">try-with-resources</span>文を使用して、自動的にリソースをクローズすることができます。<span class="inline-code">AutoCloseable</span>インターフェースを実装したクラスは、try-with-resources文で使用できます。</p>
                        </div>
                        
                        <h4>キャラクタストリーム</h4>
                        <p>キャラクタストリームは、<span class="inline-code">Reader</span>と<span class="inline-code">Writer</span>の2つの抽象クラスをベースにしています。これらのクラスは、文字単位でデータを読み書きするためのメソッドを提供します。キャラクタストリームはUnicodeなどの文字エンコーディングを適切に処理します。</p>
                        
                        <h5>主なキャラクタストリームクラス</h5>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>リーダー</th>
                                    <th>ライター</th>
                                    <th>説明</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>FileReader</td>
                                    <td>FileWriter</td>
                                    <td>デフォルトのエンコーディングでのテキストファイルの読み書き</td>
                                </tr>
                                <tr>
                                    <td>InputStreamReader</td>
                                    <td>OutputStreamWriter</td>
                                    <td>バイトストリームとキャラクタストリームの橋渡し</td>
                                </tr>
                                <tr>
                                    <td>BufferedReader</td>
                                    <td>BufferedWriter</td>
                                    <td>バッファリングによる効率的なテキスト読み書き</td>
                                </tr>
                                <tr>
                                    <td>StringReader</td>
                                    <td>StringWriter</td>
                                    <td>文字列のメモリ上での読み書き</td>
                                </tr>
                                <tr>
                                    <td>PrintReader</td>
                                    <td>PrintWriter</td>
                                    <td>書式設定された出力</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <p>キャラクタストリームを使用したテキストファイルの読み書き例：</p>
                        
                        <code>import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CharacterStreamExample {
    public static void main(String[] args) {
        // ファイルの書き込み
        try (BufferedWriter writer = new BufferedWriter(new FileWriter("sample.txt"))) {
            writer.write("こんにちは、Java I/O!");
            writer.newLine();
            writer.write("文字ストリームはテキスト処理に最適です。");
            writer.newLine();
            writer.write("特に日本語などの多バイト文字の扱いに便利です。");
            
            System.out.println("ファイルへの書き込みが完了しました。");
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // ファイルの読み込み
        try (BufferedReader reader = new BufferedReader(new FileReader("sample.txt"))) {
            String line;
            System.out.println("ファイルの内容:");
            
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code>
                        
                        <h4>文字エンコーディングの指定</h4>
                        <p>特定の文字エンコーディングを指定したい場合は、<span class="inline-code">InputStreamReader</span>や<span class="inline-code">OutputStreamWriter</span>を使用します。</p>
                        
                        <code>import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

public class EncodingExample {
    public static void main(String[] args) {
        // UTF-8エンコーディングでファイルに書き込む
        try (BufferedWriter writer = new BufferedWriter(
                new OutputStreamWriter(
                    new FileOutputStream("utf8.txt"), StandardCharsets.UTF_8))) {
            
            writer.write("これはUTF-8でエンコードされたテキストです。");
            System.out.println("UTF-8ファイルへの書き込みが完了しました。");
            
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // UTF-8エンコーディングでファイルから読み込む
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(
                    new FileInputStream("utf8.txt"), StandardCharsets.UTF_8))) {
            
            String line;
            System.out.println("UTF-8ファイルの内容:");
            
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code>
                        
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 400">
                                <rect x="50" y="20" width="500" height="360" fill="#f5f5f5" stroke="#1976d2" stroke-width="2" rx="10" />
                                <text x="300" y="50" text-anchor="middle" font-size="18" font-weight="bold">Javaストリーム階層</text>
                                
                                <rect x="150" y="80" width="300" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="2" />
                                <text x="300" y="100" text-anchor="middle" font-size="14">InputStream/OutputStream (抽象クラス)</text>
                                
                                <rect x="150" y="150" width="130" height="30" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" />
                                <text x="215" y="170" text-anchor="middle" font-size="14">FileInputStream</text>
                                
                                <rect x="320" y="150" width="130" height="30" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" />
                                <text x="385" y="170" text-anchor="middle" font-size="14">FileOutputStream</text>
                                
                                <rect x="150" y="200" width="300" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="2" />
                                <text x="300" y="220" text-anchor="middle" font-size="14">Reader/Writer (抽象クラス)</text>
                                
                                <rect x="150" y="270" width="130" height="30" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" />
                                <text x="215" y="290" text-anchor="middle" font-size="14">FileReader</text>
                                
                                <rect x="320" y="270" width="130" height="30" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" />
                                <text x="385" y="290" text-anchor="middle" font-size="14">FileWriter</text>
                                
                                <rect x="150" y="320" width="130" height="30" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" />
                                <text x="215" y="340" text-anchor="middle" font-size="14">BufferedReader</text>
                                
                                <rect x="320" y="320" width="130" height="30" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" />
                                <text x="385" y="340" text-anchor="middle" font-size="14">BufferedWriter</text>
                                
                                <!-- 矢印 -->
                                <line x1="300" y1="110" x2="300" y2="150" stroke="#1976d2" stroke-width="2" />
                                <polygon points="300,150 295,140 305,140" fill="#1976d2" />
                                
                                <line x1="215" y1="110" x2="215" y2="150" stroke="#1976d2" stroke-width="2" />
                                <polygon points="215,150 210,140 220,140" fill="#1976d2" />
                                
                                <line x1="385" y1="110" x2="385" y2="150" stroke="#1976d2" stroke-width="2" />
                                <polygon points="385,150 380,140 390,140" fill="#1976d2" />
                                
                                <line x1="300" y1="230" x2="300" y2="270" stroke="#1976d2" stroke-width="2" />
                                <polygon points="300,270 295,260 305,260" fill="#1976d2" />
                                
                                <line x1="215" y1="230" x2="215" y2="270" stroke="#1976d2" stroke-width="2" />
                                <polygon points="215,270 210,260 220,260" fill="#1976d2" />
                                
                                <line x1="385" y1="230" x2="385" y2="270" stroke="#1976d2" stroke-width="2" />
                                <polygon points="385,270 380,260 390,260" fill="#1976d2" />
                                
                                <line x1="215" y1="300" x2="215" y2="320" stroke="#1976d2" stroke-width="2" />
                                <polygon points="215,320 210,310 220,310" fill="#1976d2" />
                                
                                <line x1="385" y1="300" x2="385" y2="320" stroke="#1976d2" stroke-width="2" />
                                <polygon points="385,320 380,310 390,310" fill="#1976d2" />
                            </svg>
                            <p class="text-center">図7.2: Javaの入出力ストリーム階層</p>
                        </div>
                        
                        <div class="exercise">
                            <h5>練習問題 7.2: テキストファイル変換ツール</h5>
                            <p>ある文字エンコーディング（例：Shift-JIS）で保存されたテキストファイルを、別の文字エンコーディング（例：UTF-8）に変換するプログラムを作成してください。プログラムは以下の機能を持つようにしてください：</p>
                            <ol>
                                <li>コマンドライン引数で入力ファイル、出力ファイル、入力エンコーディング、出力エンコーディングを指定できる</li>
                                <li>変換処理の途中経過を表示する（例：処理した行数）</li>
                                <li>エラーハンドリングを適切に行う</li>
                            </ol>
                            <p>ヒント: <span class="inline-code">InputStreamReader</span>と<span class="inline-code">OutputStreamWriter</span>を使用し、<span class="inline-code">Charset.forName()</span>でエンコーディングを指定します。</p>
                        </div>
                    </section>

                    <section id="buffering">
                        <h3 class="section-title">7.3 バッファリング</h3>
                        <p>バッファリングは、入出力操作のパフォーマンスを向上させるための重要なテクニックです。バッファリングを使用すると、データを一度に大きなチャンクで読み書きすることで、頻繁なディスクアクセスやネットワーク通信を減らすことができます。</p>
                        
                        <h4>バッファリングの利点</h4>
                        <ul>
                            <li>入出力操作の効率が向上し、プログラムの実行速度が速くなる</li>
                            <li>ディスクやネットワークへのアクセス回数が減少する</li>
                            <li>システムリソースの使用効率が向上する</li>
                        </ul>
                        
                        <h4>バイトストリームのバッファリング</h4>
                        <p><span class="inline-code">BufferedInputStream</span>と<span class="inline-code">BufferedOutputStream</span>を使用して、バイトストリームにバッファリングを適用できます。</p>
                        
                        <code>import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class BufferedByteStreamExample {
    public static void main(String[] args) {
        // バッファリングなしでファイルをコピー
        long startTime = System.currentTimeMillis();
        copyWithoutBuffering("largeFile.dat", "copy1.dat");
        long endTime = System.currentTimeMillis();
        System.out.println("バッファリングなしでのコピー時間: " + (endTime - startTime) + "ms");
        
        // バッファリングありでファイルをコピー
        startTime = System.currentTimeMillis();
        copyWithBuffering("largeFile.dat", "copy2.dat");
        endTime = System.currentTimeMillis();
        System.out.println("バッファリングありでのコピー時間: " + (endTime - startTime) + "ms");
    }
    
    // バッファリングなしでファイルをコピー
    public static void copyWithoutBuffering(String source, String destination) {
        try (FileInputStream in = new FileInputStream(source);
             FileOutputStream out = new FileOutputStream(destination)) {
            
            int b;
            while ((b = in.read()) != -1) {
                out.write(b);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    // バッファリングありでファイルをコピー
    public static void copyWithBuffering(String source, String destination) {
        try (BufferedInputStream in = new BufferedInputStream(new FileInputStream(source));
             BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(destination))) {
            
            byte[] buffer = new byte[8192]; // 8KBバッファ
            int bytesRead;
            
            while ((bytesRead = in.read(buffer)) != -1) {
                out.write(buffer, 0, bytesRead);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code>
                        
                        <h4>キャラクタストリームのバッファリング</h4>
                        <p>同様に、<span class="inline-code">BufferedReader</span>と<span class="inline-code">BufferedWriter</span>を使用して、キャラクタストリームにバッファリングを適用できます。また、<span class="inline-code">BufferedReader</span>は、便利な<span class="inline-code">readLine()</span>メソッドを提供します。</p>
                        
                        <code>import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class BufferedCharacterStreamExample {
    public static void main(String[] args) {
        // ファイルの読み込みと行数カウント
        try (BufferedReader reader = new BufferedReader(new FileReader("largeText.txt"))) {
            int lineCount = 0;
            String line;
            
            while ((line = reader.readLine()) != null) {
                lineCount++;
            }
            
            System.out.println("ファイルの行数: " + lineCount);
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // 効率的なファイル書き込み
        try (BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))) {
            for (int i = 1; i <= 100000; i++) {
                writer.write("これは行番号 " + i + " のテキストです。");
                writer.newLine(); // プラットフォーム依存の改行コードを挿入
            }
            
            System.out.println("ファイルへの書き込みが完了しました。");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code>
                        
                        <h4>バッファリングの注意点</h4>
                        <div class="note">
                            <h5>バッファのフラッシュ</h5>
                            <p>バッファリングされた出力ストリームでは、バッファがいっぱいになるか、ストリームがクローズされるまでデータが実際に書き込まれないことがあります。明示的にデータをフラッシュする必要がある場合は、<span class="inline-code">flush()</span>メソッドを呼び出します。</p>
                            <code>bufferedWriter.write("重要なデータ");
bufferedWriter.flush(); // バッファの内容を即時に書き込む</code>
                        </div>
                        
                        <h4>適切なバッファサイズの選択</h4>
                        <p>バッファサイズは、入出力操作のパフォーマンスに影響します。一般的なガイドラインとしては：</p>
                        <ul>
                            <li>小さなファイルやメモリが制限された環境では、小さめのバッファ（例：1KB～4KB）</li>
                            <li>大きなファイルや高速なディスクI/Oが可能な環境では、大きめのバッファ（例：8KB～64KB）</li>
                            <li>ネットワーク転送では、ネットワークの特性に合わせたバッファサイズ</li>
                        </ul>
                        <p>ただし、バッファサイズを極端に大きくしても、一定以上のパフォーマンス向上は見込めないことがあります。実際のアプリケーションでは、異なるバッファサイズでベンチマークテストを行い、最適な値を見つけることが重要です。</p>
                        
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 300">
                                <rect x="50" y="20" width="500" height="260" fill="#f5f5f5" stroke="#1976d2" stroke-width="2" rx="10" />
                                <text x="300" y="50" text-anchor="middle" font-size="18" font-weight="bold">バッファリングの仕組み</text>
                                
                                <!-- データソース -->
                                <rect x="80" y="100" width="100" height="80" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="130" y="145" text-anchor="middle" font-size="14">データソース</text>
                                
                                <!-- バッファ -->
                                <rect x="250" y="100" width="100" height="80" fill="#bbdefb" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="300" y="145" text-anchor="middle" font-size="14">バッファ</text>
                                
                                <!-- プログラム -->
                                <rect x="420" y="100" width="100" height="80" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="470" y="145" text-anchor="middle" font-size="14">プログラム</text>
                                
                                <!-- 大きなデータ転送 -->
                                <line x1="180" y1="120" x2="250" y2="120" stroke="#1976d2" stroke-width="4" />
                                <polygon points="250,120 240,115 240,125" fill="#1976d2" />
                                <text x="215" y="105" text-anchor="middle" font-size="9">大きなチャンク</text>
                                
                                <!-- 小さなデータ転送 -->
                                <line x1="350" y1="120" x2="365" y2="120" stroke="#1976d2" stroke-width="1" />
                                <polygon points="365,120 360,118 360,122" fill="#1976d2" />
                                <line x1="365" y1="130" x2="380" y2="130" stroke="#1976d2" stroke-width="1" />
                                <polygon points="380,130 375,128 375,132" fill="#1976d2" />
                                <line x1="380" y1="140" x2="395" y2="140" stroke="#1976d2" stroke-width="1" />
                                <polygon points="395,140 390,138 390,142" fill="#1976d2" />
                                <line x1="395" y1="150" x2="410" y2="150" stroke="#1976d2" stroke-width="1" />
                                <polygon points="410,150 405,148 405,152" fill="#1976d2" />
                                <line x1="410" y1="160" x2="420" y2="160" stroke="#1976d2" stroke-width="1" />
                                <polygon points="420,160 415,158 415,162" fill="#1976d2" />
                                <text x="385" y="105" text-anchor="middle" font-size="9">小さなチャンク</text>
                                
                                <rect x="80" y="220" width="440" height="30" fill="#e1f5fe" stroke="#03a9f4" stroke-width="1" rx="5" />
                                <text x="300" y="240" text-anchor="middle" font-size="14">バッファはI/O操作の頻度を減らし、効率を向上させる</text>
                            </svg>
                            <p class="text-center">図7.3: バッファリングの仕組み</p>
                        </div>
                        
                        <div class="exercise">
                            <h5>練習問題 7.3: バッファサイズの最適化</h5>
                            <p>異なるバッファサイズ（例：1KB、4KB、16KB、64KB）を使用して、大きなファイルをコピーするプログラムを作成してください。各バッファサイズでのコピー時間を測定し、最も効率的なバッファサイズを特定してください。プログラムは以下の機能を持つようにしてください：</p>
                            <ol>
                                <li>コマンドライン引数で入力ファイル、出力ファイル、バッファサイズを指定できる</li>
                                <li>コピー時間とスループット（バイト/秒）を計算して表示する</li>
                                <li>複数回の試行を行い、平均値を計算する</li>
                            </ol>
                            <p>ヒント: <span class="inline-code">System.nanoTime()</span>を使用して、より精度の高い時間測定を行います。</p>
                        </div>
                    </section>

                    <section id="serialization">
                        <h3 class="section-title">7.4 オブジェクトのシリアル化</h3>
                        <p>シリアル化（Serialization）は、Javaオブジェクトをバイトシーケンスに変換してストリームに保存し、後で復元できるようにする機能です。これにより、オブジェクトをファイルに保存したり、ネットワーク経由で送信したりすることができます。</p>
                        
                        <h4>シリアル化の基本</h4>
                        <p>オブジェクトをシリアル化するには、そのクラスが<span class="inline-code">java.io.Serializable</span>インターフェースを実装している必要があります。</p>
                        
                        <code>import java.io.Serializable;

public class Person implements Serializable {
    // シリアルバージョンUID（クラスの互換性を保証）
    private static final long serialVersionUID = 1L;
    
    private String name;
    private int age;
    private String email;
    
    // トランジェント（一時的）フィールドはシリアル化されない
    private transient String temporaryData;
    
    public Person(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
        this.temporaryData = "この情報はシリアル化されません";
    }
    
    // getterとsetter
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getTemporaryData() { return temporaryData; }
    public void setTemporaryData(String temporaryData) { this.temporaryData = temporaryData; }
    
    @Override
    public String toString() {
        return "Person [name=" + name + ", age=" + age + ", email=" + email
                + ", temporaryData=" + temporaryData + "]";
    }
}</code>
                        
                        <h4>オブジェクトのシリアル化と逆シリアル化</h4>
                        <p><span class="inline-code">ObjectOutputStream</span>と<span class="inline-code">ObjectInputStream</span>を使用して、オブジェクトをシリアル化および逆シリアル化（デシリアル化）できます。</p>
                        
                        <code>import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class SerializationExample {
    public static void main(String[] args) {
        // オブジェクトのリストを作成
        List<Person> people = new ArrayList<>();
        people.add(new Person("田中太郎", 28, "tanaka@example.com"));
        people.add(new Person("山田花子", 32, "yamada@example.com"));
        people.add(new Person("佐藤次郎", 45, "sato@example.com"));
        
        // オブジェクトをシリアル化してファイルに保存
        try (ObjectOutputStream out = new ObjectOutputStream(
                new FileOutputStream("people.ser"))) {
            
            out.writeObject(people);
            System.out.println("オブジェクトがシリアル化されました。");
            
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // ファイルからオブジェクトを復元（逆シリアル化）
        try (ObjectInputStream in = new ObjectInputStream(
                new FileInputStream("people.ser"))) {
            
            @SuppressWarnings("unchecked")
            List<Person> restoredPeople = (List<Person>) in.readObject();
            
            System.out.println("逆シリアル化されたオブジェクト:");
            for (Person person : restoredPeople) {
                System.out.println(person);
                // 注意: temporaryDataはnullになる（transientのため）
            }
            
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}</code>
                        
                        <h4>シリアル化におけるバージョン互換性</h4>
                        <p><span class="inline-code">serialVersionUID</span>は、クラスのバージョン互換性を管理するための重要な要素です。シリアル化されたオブジェクトを逆シリアル化する際、JVMはオブジェクトと現在のクラス定義の<span class="inline-code">serialVersionUID</span>を比較します。一致しない場合、<span class="inline-code">InvalidClassException</span>がスローされます。</p>
                        
                        <div class="note">
                            <h5>serialVersionUIDの管理</h5>
                            <p>クラスの構造を変更する場合の選択肢：</p>
                            <ol>
                                <li><strong>互換性を維持</strong>: 同じ<span class="inline-code">serialVersionUID</span>を保持し、新しいフィールドにはデフォルト値を使用</li>
                                <li><strong>互換性を破棄</strong>: <span class="inline-code">serialVersionUID</span>を変更し、以前にシリアル化されたオブジェクトは使用不可に</li>
                            </ol>
                            <p>IDEの多くは、<span class="inline-code">serialVersionUID</span>を自動生成する機能を提供しています。</p>
                        </div>
                        
                        <h4>カスタムシリアル化</h4>
                        <p>デフォルトのシリアル化メカニズムをカスタマイズするには、以下のメソッドをオーバーライドします：</p>
                        
                        <code>import java.io.Serializable;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;

public class CustomSerializedPerson implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String firstName;
    private String lastName;
    private int age;
    private transient String fullName; // キャッシュされた計算結果
    
    public CustomSerializedPerson(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
        updateFullName();
    }
    
    private void updateFullName() {
        this.fullName = firstName + " " + lastName;
    }
    
    // getterとsetter（省略）
    
    // カスタムシリアル化ロジック
    private void writeObject(ObjectOutputStream out) throws IOException {
        // デフォルトのシリアル化を実行
        out.defaultWriteObject();
        
        // 追加のデータを書き込む（必要に応じて）
        out.writeInt(2023); // バージョン情報など
    }
    
    // カスタム逆シリアル化ロジック
    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        // デフォルトの逆シリアル化を実行
        in.defaultReadObject();
        
        // 追加のデータを読み込む
        int version = in.readInt();
        System.out.println("読み込まれたバージョン: " + version);
        
        // 派生データを再計算
        updateFullName();
    }
    
    @Override
    public String toString() {
        return "CustomSerializedPerson [fullName=" + fullName + ", age=" + age + "]";
    }
}</code>
                        
                        <h4>シリアル化の注意点</h4>
                        <ul>
                            <li>セキュリティ上の理由から、パスワードなどの機密情報は<span class="inline-code">transient</span>にマークし、シリアル化しないようにする</li>
                            <li>非常に大きなオブジェクトのシリアル化は、メモリ使用量やパフォーマンスの問題を引き起こす可能性がある</li>
                            <li>内部クラスやラムダ式のシリアル化には特別な注意が必要</li>
                            <li>長期保存用にシリアル化する場合、クラスの将来の変更と互換性について慎重に計画する</li>
                        </ul>
                        
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 300">
                                <rect x="50" y="20" width="500" height="260" fill="#f5f5f5" stroke="#1976d2" stroke-width="2" rx="10" />
                                <text x="300" y="50" text-anchor="middle" font-size="18" font-weight="bold">オブジェクトシリアル化のプロセス</text>
                                
                                <!-- Javaオブジェクト -->
                                <rect x="80" y="80" width="130" height="80" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="145" y="125" text-anchor="middle" font-size="14">Javaオブジェクト</text>
                                
                                <!-- シリアル化 -->
                                <rect x="260" y="100" width="100" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="310" y="125" text-anchor="middle" font-size="14">シリアル化</text>
                                
                                <!-- バイトシーケンス -->
                                <rect x="410" y="80" width="130" height="180" fill="#e1f5fe" stroke="#03a9f4" stroke-width="2" rx="5" />
                                <text x="475" y="115" text-anchor="middle" font-size="14">バイトシーケンス</text>
                                <text x="475" y="145" text-anchor="middle" font-family="monospace" font-size="12">01001101011...</text>
                                
                                <!-- 逆シリアル化 -->
                                <rect x="260" y="180" width="100" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="310" y="205" text-anchor="middle" font-size="14">逆シリアル化</text>
                                
                                <!-- 復元されたオブジェクト -->
                                <rect x="80" y="180" width="130" height="80" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="145" y="205" text-anchor="middle" font-size="14">復元された</text>
                                <text x="145" y="225" text-anchor="middle" font-size="14">オブジェクト</text>
                                
                                <!-- 矢印 -->
                                <!-- Javaオブジェクト → シリアル化 -->
                                <line x1="210" y1="120" x2="260" y2="120" stroke="#1976d2" stroke-width="2" />
                                <polygon points="260,120 250,115 250,125" fill="#1976d2" />
                                
                                <!-- シリアル化 → バイトシーケンス -->
                                <line x1="360" y1="120" x2="410" y2="120" stroke="#1976d2" stroke-width="2" />
                                <polygon points="410,120 400,115 400,125" fill="#1976d2" />
                                
                                <!-- バイトシーケンス → 逆シリアル化 -->
                                <line x1="410" y1="200" x2="360" y2="200" stroke="#1976d2" stroke-width="2" />
                                <polygon points="360,200 370,195 370,205" fill="#1976d2" />
                                
                                <!-- 逆シリアル化 → 復元されたオブジェクト -->
                                <line x1="260" y1="200" x2="210" y2="200" stroke="#1976d2" stroke-width="2" />
                                <polygon points="210,200 220,195 220,205" fill="#1976d2" />
                                
                            </svg>
                            <p class="text-center">図7.4: オブジェクトシリアル化と逆シリアル化のプロセス</p>
                        </div>
                        
                        <div class="exercise">
                            <h5>練習問題 7.4: アドレス帳アプリケーション</h5>
                            <p>シリアル化を使用して、連絡先情報を保存および読み込むシンプルなアドレス帳アプリケーションを作成してください。アプリケーションは以下の機能を持つようにしてください：</p>
                            <ol>
                                <li>連絡先情報（名前、電話番号、メールアドレスなど）を表すシリアル化可能なクラスを設計</li>
                                <li>連絡先の追加、表示、検索、削除を行うための基本的なメニューシステム</li>
                                <li>アプリケーションの終了時に連絡先リストをファイルに保存</li>
                                <li>アプリケーションの起動時にファイルから連絡先リストを読み込む</li>
                                <li><span class="inline-code">transient</span>修飾子を適切に使用</li>
                            </ol>
                            <p>発展課題: クラスに新しいフィールド（例：住所）を追加し、以前のバージョンでシリアル化されたデータとの互換性を維持する方法を実装してください。</p>
                        </div>
                    </section>

                    <section id="nio">
                        <h3 class="section-title">7.5 NIO (New I/O)</h3>
                        <p>Java NIO（New I/O）は、Java 1.4で導入された代替I/O APIです。従来の<span class="inline-code">java.io</span>パッケージと比較して、より高度で柔軟なI/O操作を提供します。特に、ノンブロッキングI/Oやメモリマッピングファイルなど、パフォーマンスが重要なアプリケーションに適した機能があります。</p>
                        
                        <h4>NIOの主な特徴</h4>
                        <ul>
                            <li><strong>チャネル（Channel）とバッファ（Buffer）</strong>: データ転送のための新しい抽象化</li>
                            <li><strong>セレクタ（Selector）</strong>: 複数のチャネルを監視し、準備ができたチャネルだけを処理</li>
                            <li><strong>メモリマッピングファイル</strong>: ファイルをメモリに直接マッピングして高速アクセス</li>
                            <li><strong>ファイルロック</strong>: ファイルの一部または全体をロックする機能</li>
                            <li><strong>文字セットエンコーダー/デコーダー</strong>: バイトとキャラクタの変換</li>
                        </ul>
                        
                        <h4>Path と Files</h4>
                        <p>Java 7で導入された<span class="inline-code">java.nio.file</span>パッケージは、ファイルとディレクトリの操作を簡素化します。</p>
                        
                        <code>import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.io.IOException;
import java.util.List;

public class PathAndFilesExample {
    public static void main(String[] args) {
        try {
            // パスの作成
            Path path1 = Paths.get("sample.txt");
            Path path2 = Paths.get("/home", "user", "documents", "file.txt");
            
            // パス情報の取得
            System.out.println("ファイル名: " + path1.getFileName());
            System.out.println("親ディレクトリ: " + path1.getParent());
            System.out.println("ルートディレクトリ: " + path1.getRoot());
            System.out.println("絶対パス: " + path1.toAbsolutePath());
            
            // ファイル操作
            Path newFile = Files.createFile(Paths.get("newFile.txt"));
            Files.write(newFile, "こんにちは、NIO!".getBytes());
            
            // ファイルの読み込み
            List<String> lines = Files.readAllLines(newFile);
            for (String line : lines) {
                System.out.println(line);
            }
            
            // ファイルのコピー
            Path copiedFile = Paths.get("copiedFile.txt");
            Files.copy(newFile, copiedFile, StandardCopyOption.REPLACE_EXISTING);
            
            // ファイルの移動/名前変更
            Path renamedFile = Paths.get("renamedFile.txt");
            Files.move(copiedFile, renamedFile, StandardCopyOption.REPLACE_EXISTING);
            
            // ファイルの削除
            Files.delete(renamedFile);
            
            // ファイル属性の取得
            System.out.println("サイズ: " + Files.size(newFile) + " バイト");
            System.out.println("最終更新時間: " + Files.getLastModifiedTime(newFile));
            System.out.println("所有者: " + Files.getOwner(newFile));
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code>
                        
                        <h4>チャネルとバッファ</h4>
                        <p>NIOの中心概念である「チャネル」は、データソースまたはデータシンクへの接続を表します。バッファはデータの読み書きに使用されます。</p>
                        
                        <code>import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class ChannelBufferExample {
    public static void main(String[] args) {
        try {
            // ファイルの書き込み
            FileOutputStream fos = new FileOutputStream("channel_test.txt");
            FileChannel outputChannel = fos.getChannel();
            
            // バッファの作成と書き込み
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            String text = "NIOチャネルとバッファのテスト";
            buffer.put(text.getBytes());
            
            // バッファを読み込みモードに切り替え
            buffer.flip();
            
            // バッファからチャネルに書き込み
            outputChannel.write(buffer);
            
            // リソースのクローズ
            outputChannel.close();
            fos.close();
            
            // ファイルの読み込み
            FileInputStream fis = new FileInputStream("channel_test.txt");
            FileChannel inputChannel = fis.getChannel();
            
            // 新しいバッファを作成
            ByteBuffer readBuffer = ByteBuffer.allocate(1024);
            
            // チャネルからバッファに読み込み
            int bytesRead = inputChannel.read(readBuffer);
            
            // バッファを読み込みモードに切り替え
            readBuffer.flip();
            
            // バッファからデータを取得
            byte[] bytes = new byte[bytesRead];
            readBuffer.get(bytes);
            
            // 結果の表示
            System.out.println(new String(bytes));
            
            // リソースのクローズ
            inputChannel.close();
            fis.close();
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code>
                        
                        <h4>メモリマッピングファイル</h4>
                        <p>メモリマッピングファイルは、ファイルの内容をメモリに直接マッピングして、高速なアクセスを可能にします。特に大きなファイルを効率的に処理する場合に有用です。</p>
                        
                        <code>import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileChannel.MapMode;

public class MemoryMappedFileExample {
    public static void main(String[] args) {
        try {
            // メモリマッピングファイルの作成
            RandomAccessFile file = new RandomAccessFile("mapped_file.txt", "rw");
            FileChannel channel = file.getChannel();
            
            // ファイルの内容をメモリにマッピング
            MappedByteBuffer buffer = channel.map(MapMode.READ_WRITE, 0, 1024);
            
            // データの書き込み
            buffer.put("メモリマッピングファイルのテストです。".getBytes());
            
            // 明示的なフラッシュ（オプション）
            buffer.force();
            
            // リソースのクローズ
            channel.close();
            file.close();
            
            // マッピングしたファイルの読み込み
            RandomAccessFile readFile = new RandomAccessFile("mapped_file.txt", "r");
            FileChannel readChannel = readFile.getChannel();
            MappedByteBuffer readBuffer = readChannel.map(MapMode.READ_ONLY, 0, readChannel.size());
            
            // データの読み込み
            byte[] data = new byte[(int) readChannel.size()];
            readBuffer.get(data);
            
            // 結果の表示
            System.out.println(new String(data).trim());
            
            // リソースのクローズ
            readChannel.close();
            readFile.close();
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code>
                        
                        <h4>非同期I/O（Java 7以降）</h4>
                        <p>Java 7では、<span class="inline-code">AsynchronousFileChannel</span>を使用した非同期ファイルI/Oがサポートされました。これにより、I/O操作を別のスレッドで実行しながら、メインスレッドで他の処理を続行できます。</p>
                        
                        <code>import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousFileChannel;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.concurrent.Future;

public class AsyncFileIOExample {
    public static void main(String[] args) {
        try {
            // 非同期ファイルチャネルを開く
            Path path = Paths.get("async_file.txt");
            AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(
                path, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);
            
            // データを書き込む
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            buffer.put("非同期I/Oのテストです。".getBytes());
            buffer.flip();
            
            // 非同期書き込み
            Future<Integer> writeResult = fileChannel.write(buffer, 0);
            
            // 他の処理を行いながら、書き込みの完了を待つ
            while (!writeResult.isDone()) {
                System.out.println("書き込み待機中...");
                Thread.sleep(100);
            }
            
            System.out.println("書き込み完了: " + writeResult.get() + " バイト");
            
            // データを読み込む
            ByteBuffer readBuffer = ByteBuffer.allocate(1024);
            
            // 非同期読み込み
            Future<Integer> readResult = fileChannel.read(readBuffer, 0);
            
            // 読み込みの完了を待つ
            while (!readResult.isDone()) {
                System.out.println("読み込み待機中...");
                Thread.sleep(100);
            }
            
            // 結果の表示
            readBuffer.flip();
            byte[] data = new byte[readResult.get()];
            readBuffer.get(data);
            System.out.println("読み込んだデータ: " + new String(data));
            
            // リソースのクローズ
            fileChannel.close();
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code>
                        
                        <h4>NIOとI/Oの比較</h4>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>機能</th>
                                    <th>従来のI/O (java.io)</th>
                                    <th>NIO (java.nio)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>データ転送モデル</td>
                                    <td>ストリームベース（逐次的）</td>
                                    <td>バッファベース（ブロック単位）</td>
                                </tr>
                                <tr>
                                    <td>処理モード</td>
                                    <td>ブロッキング</td>
                                    <td>ブロッキングおよびノンブロッキング</td>
                                </tr>
                                <tr>
                                    <td>バッファリング</td>
                                    <td>明示的に実装する必要あり</td>
                                    <td>APIの一部として組み込まれている</td>
                                </tr>
                                <tr>
                                    <td>メモリマッピング</td>
                                    <td>サポートなし</td>
                                    <td>サポートあり</td>
                                </tr>
                                <tr>
                                    <td>ファイルロック</td>
                                    <td>サポートなし</td>
                                    <td>サポートあり</td>
                                </tr>
                                <tr>
                                    <td>複数チャネルの監視</td>
                                    <td>サポートなし</td>
                                    <td>Selectorによるサポートあり</td>
                                </tr>
                                <tr>
                                    <td>使用シナリオ</td>
                                    <td>シンプルなI/O操作</td>
                                    <td>高性能I/O、ノンブロッキング操作が必要な場合</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 400">
                                <rect x="50" y="20" width="500" height="360" fill="#f5f5f5" stroke="#1976d2" stroke-width="2" rx="10" />
                                <text x="300" y="50" text-anchor="middle" font-size="18" font-weight="bold">NIOとI/Oの比較</text>
                                
                                <!-- 従来のI/O -->
                                <rect x="80" y="80" width="180" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="170" y="100" text-anchor="middle" font-size="14">従来のI/O (java.io)</text>
                                
                                <rect x="80" y="120" width="180" height="220" fill="#e3f2fd" stroke="#1976d2" stroke-width="1" rx="5" />
                                
                                <rect x="100" y="140" width="140" height="40" fill="#e1f5fe" stroke="#03a9f4" stroke-width="1" />
                                <text x="170" y="165" text-anchor="middle" font-size="12">InputStream</text>
                                
                                <rect x="100" y="190" width="140" height="40" fill="#e1f5fe" stroke="#03a9f4" stroke-width="1" />
                                <text x="170" y="215" text-anchor="middle" font-size="12">OutputStream</text>
                                
                                <rect x="100" y="240" width="140" height="40" fill="#e1f5fe" stroke="#03a9f4" stroke-width="1" />
                                <text x="170" y="265" text-anchor="middle" font-size="12">Reader</text>
                                
                                <rect x="100" y="290" width="140" height="40" fill="#e1f5fe" stroke="#03a9f4" stroke-width="1" />
                                <text x="170" y="315" text-anchor="middle" font-size="12">Writer</text>
                                
                                <!-- NIO -->
                                <rect x="340" y="80" width="180" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="430" y="100" text-anchor="middle" font-size="14">NIO (java.nio)</text>
                                
                                <rect x="340" y="120" width="180" height="220" fill="#e3f2fd" stroke="#1976d2" stroke-width="1" rx="5" />
                                
                                <rect x="360" y="140" width="140" height="40" fill="#e1f5fe" stroke="#03a9f4" stroke-width="1" />
                                <text x="430" y="165" text-anchor="middle" font-size="12">チャネル (Channel)</text>
                                
                                <rect x="360" y="190" width="140" height="40" fill="#e1f5fe" stroke="#03a9f4" stroke-width="1" />
                                <text x="430" y="215" text-anchor="middle" font-size="12">バッファ (Buffer)</text>
                                
                                <rect x="360" y="240" width="140" height="40" fill="#e1f5fe" stroke="#03a9f4" stroke-width="1" />
                                <text x="430" y="265" text-anchor="middle" font-size="12">セレクタ (Selector)</text>
                                
                                <rect x="360" y="290" width="140" height="40" fill="#e1f5fe" stroke="#03a9f4" stroke-width="1" />
                                <text x="430" y="315" text-anchor="middle" font-size="12">Path/Files API</text>
                            </svg>
                            <p class="text-center">図7.5: 従来のI/OとNIOの比較</p>
                        </div>
                        
                        <div class="exercise">
                            <h5>練習問題 7.5: NIOを使用したファイル検索ツール</h5>
                            <p>NIOを使用して、指定したディレクトリとそのサブディレクトリ内の特定のパターン（例：ファイル名や内容）に一致するファイルを検索するツールを作成してください。以下の機能を実装してください：</p>
                            <ol>
                                <li>コマンドライン引数で検索ディレクトリ、検索パターン、検索モード（ファイル名/内容）を指定</li>
                                <li>Files.walkFileTreeを使用したディレクトリの再帰的な探索</li>
                                <li>大きなファイルの内容検索にはメモリマッピングファイルを使用</li>
                                <li>検索結果を一覧表示（ファイルパス、サイズ、最終更新日時など）</li>
                                <li>検索処理の進捗状況を表示</li>
                            </ol>
                            <p>ヒント: <span class="inline-code">Files.walkFileTree()</span>と<span class="inline-code">SimpleFileVisitor</span>を組み合わせて使用し、大きなファイルの内容検索には<span class="inline-code">FileChannel.map()</span>を使用します。</p>
                        </div>
                    </section>

                    <section id="chapter7-quiz">
                        <h3 class="section-title">7.6 理解度確認テスト</h3>
                        <div class="quiz-container">
                            <h4>第7章の理解度チェック</h4>
                            <p>以下の問題に答えて、第7章の内容の理解度を確認しましょう。</p>
                            
                            <div class="quiz-question">
                                <p><strong>問題1:</strong> Javaでバイナリデータを扱う際に使用する基本的なストリームクラスはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1a" value="a">
                                    <label class="form-check-label" for="q1a">
                                        FileReader と FileWriter
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1b" value="b">
                                    <label class="form-check-label" for="q1b">
                                        InputStreamReader と OutputStreamWriter
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1c" value="c">
                                    <label class="form-check-label" for="q1c">
                                        FileInputStream と FileOutputStream
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1d" value="d">
                                    <label class="form-check-label" for="q1d">
                                        BufferedReader と BufferedWriter
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題2:</strong> バッファリングを使用する主な利点は何ですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2a" value="a">
                                    <label class="form-check-label" for="q2a">
                                        ファイルサイズを小さくできる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2b" value="b">
                                    <label class="form-check-label" for="q2b">
                                        入出力操作の効率が向上する
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2c" value="c">
                                        データの圧縮率が高くなる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2d" value="d">
                                    <label class="form-check-label" for="q2d">
                                        エラー検出機能が向上する
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題3:</strong> オブジェクトをシリアル化するために必要なインターフェースは何ですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3a" value="a">
                                    <label class="form-check-label" for="q3a">
                                        Cloneable
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3b" value="b">
                                    <label class="form-check-label" for="q3b">
                                        Comparable
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3c" value="c">
                                    <label class="form-check-label" for="q3c">
                                        Serializable
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3d" value="d">
                                    <label class="form-check-label" for="q3d">
                                        Externalizable
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題4:</strong> Java NIOとは何の略ですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4a" value="a">
                                    <label class="form-check-label" for="q4a">
                                        New Input/Output
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4b" value="b">
                                    <label class="form-check-label" for="q4b">
                                        Native Input/Output
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4c" value="c">
                                    <label class="form-check-label" for="q4c">
                                        Network Input/Output
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4d" value="d">
                                    <label class="form-check-label" for="q4d">
                                        Non-blocking Input/Output
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題5:</strong> 次のコードの実行結果として正しいものはどれですか？</p>
                                <pre class="bg-light p-2 rounded">
import java.io.*;

public class Test {
    public static void main(String[] args) {
        try (FileWriter fw = new FileWriter("test.txt")) {
            fw.write("Java");
            // fw.close(); // try-with-resourcesを使用しているため不要
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        try (FileReader fr = new FileReader("test.txt");
             BufferedReader br = new BufferedReader(fr)) {
            System.out.println(br.readLine());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</pre>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5a" value="a">
                                    <label class="form-check-label" for="q5a">
                                        Java
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5b" value="b">
                                    <label class="form-check-label" for="q5b">
                                        何も出力されない
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5c" value="c">
                                    <label class="form-check-label" for="q5c">
                                        コンパイルエラーが発生する
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5d" value="d">
                                    <label class="form-check-label" for="q5d">
                                        実行時例外が発生する
                                    </label>
                                </div>
                            </div>
                            
                            <button class="btn btn-primary mt-3" id="checkAnswers">回答を確認</button>
                            <div id="quizResults" class="mt-3 d-none">
                                <div class="alert alert-success">
                                    <h5>正解:</h5>
                                    <ol>
                                        <li>c) FileInputStream と FileOutputStream</li>
                                        <li>b) 入出力操作の効率が向上する</li>
                                        <li>c) Serializable</li>
                                        <li>a) New Input/Output</li>
                                        <li>a) Java</li>
                                    </ol>
                                    <h5 class="mt-3">解説:</h5>
                                    <ol>
                                        <li>バイナリデータを扱う基本的なストリームは、FileInputStreamとFileOutputStreamです。FileReaderとFileWriterはテキストデータ用のキャラクタストリームです。</li>
                                        <li>バッファリングの主な利点は、少ない回数の入出力操作でより多くのデータを転送できることにより、パフォーマンスが向上することです。</li>
                                        <li>オブジェクトをシリアル化するためには、そのクラスがSerializableインターフェースを実装している必要があります。Externalizableも可能ですが、より具体的なSerializableの拡張版です。</li>
                                        <li>NIOはNew Input/Outputの略で、より高度なI/O機能を提供するために導入されました。</li>
                                        <li>try-with-resourcesステートメントを使用すると、ストリームは自動的にクローズされます。FileWriterでファイルに「Java」を書き込み、FileReaderとBufferedReaderでそれを読み込み、出力しています。</li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </section>

                    <div class="mt-5 p-4 bg-light rounded">
                        <h4>まとめ</h4>
                        <p>この章では、Javaにおける入出力操作の基本から応用までを学びました。ファイル操作、バイトストリームとキャラクタストリーム、バッファリング、オブジェクトシリアル化、そしてNIOの概念を理解することで、効率的で堅牢なJavaアプリケーションを開発するための重要な基礎を身につけることができました。</p>
                        <p>次の章では、これらの知識を活用してデータベース操作やネットワークプログラミングなど、より高度なトピックに進んでいきます。</p>
                    </div>
                </section>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS and Popper.js -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 理解度テストの回答確認ボタンの処理
        document.getElementById('checkAnswers').addEventListener('click', function() {
            document.getElementById('quizResults').classList.remove('d-none');
        });
    </script>
</body>
</html>