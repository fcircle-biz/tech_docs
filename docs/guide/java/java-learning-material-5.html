<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java初心者向け学習教材 - 第5章: Java API基礎</title>
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        .navbar {
            background-color: #1565c0;
        }
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        .chapter-title {
            color: #1565c0;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #1565c0;
            padding-bottom: 0.5rem;
        }
        .section-title {
            color: #1976d2;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        code {
            display: block;
            background-color: #f5f5f5;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            white-space: pre;
            overflow-x: auto;
        }
        .quiz-container {
            background-color: #e3f2fd;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }
        .quiz-question {
            font-weight: 500;
            margin-bottom: 1rem;
        }
        .diagram {
            max-width: 100%;
            height: auto;
            margin: 1.5rem 0;
            text-align: center;
        }
        .exercise {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        .note {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        #table-of-contents .list-group-item {
            border: none;
            padding: 0.5rem 1rem;
        }
        #table-of-contents .list-group-item-action {
            color: #1976d2;
        }
        #table-of-contents .list-group-item-action.active,
        .list-group-item.active {
            color: white !important;
            background-color: #1976d2;
            border-color: #1976d2;
        }
        .section-nav {
            padding-left: 1rem;
        }
        .inline-code {
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            background-color: #f5f5f5;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-size: 0.9em;
            color: #e53935;
        }
        .method-table {
            width: 100%;
            margin-bottom: 1rem;
            background-color: transparent;
            border-collapse: collapse;
        }
        .method-table th {
            background-color: #e3f2fd;
            border: 1px solid #b3e5fc;
            padding: 0.75rem;
            text-align: left;
        }
        .method-table td {
            border: 1px solid #b3e5fc;
            padding: 0.75rem;
            vertical-align: top;
        }
        .output {
            background-color: #263238;
            color: #ECEFF1;
            border-radius: 4px;
            padding: 0.75rem;
            margin: 1rem 0;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            white-space: pre;
            overflow-x: auto;
        }
    </style>
</head>
<body data-bs-spy="scroll" data-bs-target="#tableOfContents">
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="#">Java初心者向け学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="#introduction">はじめに</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#chapter5">第5章: Java API基礎</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container my-4">
        <div class="row">
            <!-- Sidebar - Table of Contents -->
            <div class="col-lg-3">
                <div class="sidebar">
                    <div class="card">
                        <div class="card-header bg-primary text-white">
                            <h5 class="mb-0">目次</h5>
                        </div>
                        <div id="table-of-contents" class="list-group list-group-flush">
                            <a href="#introduction" class="list-group-item list-group-item-action">はじめに</a>
                            <a href="#chapter5" class="list-group-item list-group-item-action">第5章: Java API基礎</a>
                            <div class="section-nav">
                                <a href="#string-operations" class="list-group-item list-group-item-action">5.1 Stringクラスの操作</a>
                                <a href="#math-random" class="list-group-item list-group-item-action">5.2 Math, Randomクラス</a>
                                <a href="#date-time" class="list-group-item list-group-item-action">5.3 日付と時間 (java.time)</a>
                                <a href="#collection-framework" class="list-group-item list-group-item-action">5.4 コレクションフレームワーク入門</a>
                                <a href="#arraylist-linkedlist" class="list-group-item list-group-item-action">5.5 ArrayList, LinkedList</a>
                                <a href="#hashset-treeset" class="list-group-item list-group-item-action">5.6 HashSet, TreeSet</a>
                                <a href="#hashmap-treemap" class="list-group-item list-group-item-action">5.7 HashMap, TreeMap</a>
                                <a href="#chapter5-quiz" class="list-group-item list-group-item-action">5.8 理解度確認テスト</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Main Content -->
            <div class="col-lg-9">
                <section id="introduction">
                    <h1 class="display-5 mb-4">Java初心者向け学習教材 - 第5章: Java API基礎</h1>
                    <p class="lead">この章では、JavaのAPIの基本について学びます。API（アプリケーションプログラミングインターフェース）はJavaプログラミングの中核部分で、多くのクラスとメソッドが提供されています。ここでは文字列操作、数学関数、日付・時間処理、コレクションフレームワークなどの重要なAPI群について学んでいきましょう。</p>
                    <div class="note">
                        <h5>本章の学習目標</h5>
                        <ul>
                            <li>Stringクラスを使った効率的な文字列操作を習得する</li>
                            <li>MathクラスとRandomクラスを使った数値計算と乱数生成を理解する</li>
                            <li>java.timeパッケージを使った日付と時間の処理方法を学ぶ</li>
                            <li>コレクションフレームワークの基本概念と主要なインターフェースを理解する</li>
                            <li>さまざまなリスト、セット、マップの実装と使い分けを習得する</li>
                        </ul>
                    </div>
                </section>

                <section id="chapter5">
                    <h2 class="chapter-title">第5章：Java API基礎</h2>
                    <p>Javaは豊富なAPIを提供しており、これらを活用することで効率的にプログラミングを行うことができます。この章では、日常的に使用する重要なAPI群について詳しく見ていきましょう。</p>

                    <section id="string-operations">
                        <h3 class="section-title">5.1 Stringクラスの操作</h3>
                        <p>Javaでは文字列を<span class="inline-code">String</span>クラスとして扱います。<span class="inline-code">String</span>クラスは非常に多くのメソッドを提供しており、文字列の操作を効率的に行うことができます。</p>
                        
                        <h4>Stringの特徴</h4>
                        <div class="note">
                            <h5>Stringクラスの重要な特性</h5>
                            <ul>
                                <li><strong>イミュータブル（不変）</strong>：一度作成されたStringオブジェクトは変更できない</li>
                                <li><strong>スレッドセーフ</strong>：不変であるため、複数のスレッドから安全に参照できる</li>
                                <li><strong>文字列リテラルはStringプール</strong>で管理され、同じ文字列は再利用される</li>
                            </ul>
                        </div>
                        
                        <h4>Stringの作成</h4>
                        <p>Stringを作成する主な方法は以下の通りです：</p>
                        <code>// 文字列リテラルによる作成
String str1 = "こんにちは";

// コンストラクタによる作成
String str2 = new String("こんにちは");

// 文字配列からの作成
char[] chars = {'H', 'e', 'l', 'l', 'o'};
String str3 = new String(chars);

// StringBuilderからの作成
StringBuilder sb = new StringBuilder("Hello");
String str4 = sb.toString();</code>
                        
                        <div class="note">
                            <h5><span class="inline-code">String str1 = "こんにちは"</span> と <span class="inline-code">String str2 = new String("こんにちは")</span> の違い</h5>
                            <p>リテラルで作成した場合はStringプールを使用するため、同じ文字列を参照すると同じオブジェクトを指します。<span class="inline-code">new</span>を使うと、常に新しいオブジェクトが作成されます。</p>
                            <code>String s1 = "test";
String s2 = "test";
String s3 = new String("test");

System.out.println(s1 == s2);  // true（同じオブジェクトを参照）
System.out.println(s1 == s3);  // false（異なるオブジェクト）
System.out.println(s1.equals(s3));  // true（内容は同じ）</code>
                        </div>
                        
                        <h4>主なStringメソッド</h4>
                        <p>Stringクラスは多数のメソッドを提供しています。以下は特によく使われるメソッドです：</p>
                        
                        <table class="method-table">
                            <thead>
                                <tr>
                                    <th>メソッド</th>
                                    <th>説明</th>
                                    <th>使用例</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><span class="inline-code">length()</span></td>
                                    <td>文字列の長さを返す</td>
                                    <td><span class="inline-code">"Hello".length()</span> → 5</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">charAt(int index)</span></td>
                                    <td>指定位置の文字を返す</td>
                                    <td><span class="inline-code">"Hello".charAt(1)</span> → 'e'</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">substring(int beginIndex, int endIndex)</span></td>
                                    <td>部分文字列を取得</td>
                                    <td><span class="inline-code">"Hello".substring(1, 4)</span> → "ell"</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">indexOf(String str)</span></td>
                                    <td>部分文字列の位置を検索</td>
                                    <td><span class="inline-code">"Hello".indexOf("lo")</span> → 3</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">contains(CharSequence s)</span></td>
                                    <td>部分文字列を含むか確認</td>
                                    <td><span class="inline-code">"Hello".contains("el")</span> → true</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">replace(char old, char new)</span></td>
                                    <td>文字を置換</td>
                                    <td><span class="inline-code">"Hello".replace('l', 'L')</span> → "HeLLo"</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">toUpperCase()</span></td>
                                    <td>大文字に変換</td>
                                    <td><span class="inline-code">"Hello".toUpperCase()</span> → "HELLO"</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">toLowerCase()</span></td>
                                    <td>小文字に変換</td>
                                    <td><span class="inline-code">"Hello".toLowerCase()</span> → "hello"</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">trim()</span></td>
                                    <td>前後の空白を削除</td>
                                    <td><span class="inline-code">"  Hello  ".trim()</span> → "Hello"</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">split(String regex)</span></td>
                                    <td>正規表現で分割</td>
                                    <td><span class="inline-code">"a,b,c".split(",")</span> → ["a", "b", "c"]</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">equals(Object obj)</span></td>
                                    <td>文字列の内容を比較</td>
                                    <td><span class="inline-code">"Hello".equals("hello")</span> → false</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">equalsIgnoreCase(String str)</span></td>
                                    <td>大文字/小文字を区別せず比較</td>
                                    <td><span class="inline-code">"Hello".equalsIgnoreCase("hello")</span> → true</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h4>String結合と文字列ビルダー</h4>
                        <p>Stringはイミュータブルなので、結合や変更を繰り返す場合は<span class="inline-code">StringBuilder</span>や<span class="inline-code">StringBuffer</span>を使用するとパフォーマンスが向上します。</p>
                        
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 250">
                                <!-- String vs StringBuilder diagram -->
                                <rect x="50" y="30" width="500" height="90" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="10" />
                                <text x="300" y="55" text-anchor="middle" font-size="16" font-weight="bold">String結合</text>
                                
                                <rect x="70" y="70" width="80" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="110" y="90" text-anchor="middle" font-size="14">String s1</text>
                                
                                <rect x="200" y="70" width="80" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="240" y="90" text-anchor="middle" font-size="14">String s2</text>
                                
                                <rect x="330" y="70" width="80" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="370" y="90" text-anchor="middle" font-size="14">String s3</text>
                                
                                <rect x="460" y="70" width="80" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="500" y="90" text-anchor="middle" font-size="14">String s4</text>
                                
                                <line x1="150" y1="85" x2="200" y2="85" stroke="#1976d2" stroke-width="2" />
                                <line x1="280" y1="85" x2="330" y2="85" stroke="#1976d2" stroke-width="2" />
                                <line x1="410" y1="85" x2="460" y2="85" stroke="#1976d2" stroke-width="2" />
                                
                                <rect x="50" y="150" width="500" height="100" fill="#e8f5e9" stroke="#4caf50" stroke-width="2" rx="10" />
                                <text x="300" y="175" text-anchor="middle" font-size="16" font-weight="bold">StringBuilder結合</text>
                                
                                <rect x="70" y="190" width="460" height="30" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" rx="5" />
                                <text x="300" y="210" text-anchor="middle" font-size="14">StringBuilder sb（内部バッファが拡張される）</text>
                                
                                <text x="300" y="240" text-anchor="middle" font-size="14" fill="#4caf50">より効率的なメモリ使用</text>
                            </svg>
                        </div>
                        
                        <p>文字列を繰り返し結合する例：</p>
                        <code>// Stringを使った場合（非効率）
String result = "";
for (int i = 0; i < 10000; i++) {
    result += "文字列" + i; // 毎回新しいStringオブジェクトが作成される
}

// StringBuilderを使った場合（効率的）
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10000; i++) {
    sb.append("文字列").append(i); // 同じオブジェクトに追加される
}
String result = sb.toString();</code>
                        
                        <div class="note">
                            <h5>StringBuilderとStringBufferの違い</h5>
                            <ul>
                                <li><strong>StringBuilder</strong>：同期化されていないため、単一スレッドでの使用に適しています（より高速）</li>
                                <li><strong>StringBuffer</strong>：同期化されているため、マルチスレッド環境で安全に使用できます</li>
                            </ul>
                        </div>
                        
                        <h4>主要なStringBuilderメソッド</h4>
                        <ul>
                            <li><span class="inline-code">append(various types)</span>：文字列の追加</li>
                            <li><span class="inline-code">insert(int offset, various types)</span>：指定位置に挿入</li>
                            <li><span class="inline-code">delete(int start, int end)</span>：部分文字列の削除</li>
                            <li><span class="inline-code">replace(int start, int end, String str)</span>：部分文字列の置換</li>
                            <li><span class="inline-code">reverse()</span>：文字列の反転</li>
                            <li><span class="inline-code">toString()</span>：Stringへの変換</li>
                        </ul>
                        
                        <div class="exercise">
                            <h5>演習 5.1: Stringクラスの操作</h5>
                            <p>以下の問題に取り組み、Stringクラスの操作を練習しましょう：</p>
                            <ol>
                                <li>与えられた文字列が回文（前から読んでも後ろから読んでも同じ）かどうかを判定するメソッドを作成してください。</li>
                                <li>文字列から特定の文字の出現回数をカウントするメソッドを実装してください。</li>
                                <li>カンマ区切りの文字列をString配列に変換し、各要素を逆順にして再びカンマ区切り文字列に戻すプログラムを作成してください。</li>
                            </ol>
                        </div>
                    </section>

                    <section id="math-random">
                        <h3 class="section-title">5.2 Math, Randomクラス</h3>
                        <p>JavaのMathクラスは数学関数を提供し、Randomクラスは乱数生成のための機能を提供します。これらのクラスを使用することで、様々な数値計算や乱数を使った処理を行うことができます。</p>
                        
                        <h4>Mathクラス</h4>
                        <p>Mathクラスは<span class="inline-code">java.lang</span>パッケージに含まれる静的メソッドの集まりです。基本的な数学関数からより高度な関数まで幅広く提供しています。</p>
                        
                        <div class="note">
                            <h5>Mathクラスの特徴</h5>
                            <ul>
                                <li>全てのメソッドは<strong>静的(static)</strong>であり、インスタンス化せずに使用できます</li>
                                <li>数学定数（πやeなど）も静的フィールドとして提供されています</li>
                                <li><span class="inline-code">java.lang</span>パッケージのため、importなしで使用可能です</li>
                            </ul>
                        </div>
                        
                        <h4>主なMathクラスのメソッド</h4>
                        <table class="method-table">
                            <thead>
                                <tr>
                                    <th>メソッド/フィールド</th>
                                    <th>説明</th>
                                    <th>使用例</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><span class="inline-code">Math.PI</span></td>
                                    <td>円周率π</td>
                                    <td><span class="inline-code">double area = Math.PI * r * r;</span></td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">Math.E</span></td>
                                    <td>自然対数の底e</td>
                                    <td><span class="inline-code">double value = Math.E * x;</span></td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">abs(double/float/int/long)</span></td>
                                    <td>絶対値</td>
                                    <td><span class="inline-code">Math.abs(-10)</span> → 10</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">max(a, b)</span></td>
                                    <td>最大値</td>
                                    <td><span class="inline-code">Math.max(5, 10)</span> → 10</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">min(a, b)</span></td>
                                    <td>最小値</td>
                                    <td><span class="inline-code">Math.min(5, 10)</span> → 5</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">sqrt(double)</span></td>
                                    <td>平方根</td>
                                    <td><span class="inline-code">Math.sqrt(9)</span> → 3.0</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">pow(double a, double b)</span></td>
                                    <td>累乗（a^b）</td>
                                    <td><span class="inline-code">Math.pow(2, 3)</span> → 8.0</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">round(float/double)</span></td>
                                    <td>四捨五入</td>
                                    <td><span class="inline-code">Math.round(3.7)</span> → 4</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">floor(double)</span></td>
                                    <td>切り捨て</td>
                                    <td><span class="inline-code">Math.floor(3.7)</span> → 3.0</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">ceil(double)</span></td>
                                    <td>切り上げ</td>
                                    <td><span class="inline-code">Math.ceil(3.2)</span> → 4.0</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">sin(double)/cos(double)/tan(double)</span></td>
                                    <td>三角関数</td>
                                    <td><span class="inline-code">Math.sin(Math.PI/2)</span> → 1.0</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">log(double)</span></td>
                                    <td>自然対数</td>
                                    <td><span class="inline-code">Math.log(Math.E)</span> → 1.0</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">log10(double)</span></td>
                                    <td>底10の対数</td>
                                    <td><span class="inline-code">Math.log10(100)</span> → 2.0</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">random()</span></td>
                                    <td>0.0以上1.0未満の乱数</td>
                                    <td><span class="inline-code">Math.random()</span> → 0.0〜0.999...</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <p>使用例：</p>
                        <code>// 円の面積を計算
double radius = 5.0;
double area = Math.PI * Math.pow(radius, 2);
System.out.println("半径" + radius + "の円の面積: " + area);

// 2点間の距離を計算
double x1 = 0, y1 = 0;  // 点1の座標
double x2 = 3, y2 = 4;  // 点2の座標
double distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
System.out.println("2点間の距離: " + distance);

// 小数点以下の処理
double value = 3.14159;
System.out.println("切り捨て: " + Math.floor(value));
System.out.println("切り上げ: " + Math.ceil(value));
System.out.println("四捨五入: " + Math.round(value));</code>
                        
                        <h4>Randomクラス</h4>
                        <p><span class="inline-code">java.util.Random</span>クラスは、様々な種類の乱数を生成するためのクラスです。Mathクラスの<span class="inline-code">random()</span>メソッドよりも多機能で、整数や浮動小数点数など様々な型の乱数を生成できます。</p>
                        
                        <div class="note">
                            <h5>乱数生成の種類</h5>
                            <ol>
                                <li><strong>Math.random()</strong>：単純に0.0以上1.0未満の乱数を生成</li>
                                <li><strong>java.util.Random</strong>：様々な型の乱数を生成し、シード値の指定も可能</li>
                                <li><strong>ThreadLocalRandom</strong>：マルチスレッド環境に最適化された乱数生成（Java 7以降）</li>
                                <li><strong>SecureRandom</strong>：暗号化に使用可能な安全な乱数生成（パフォーマンスは低め）</li>
                            </ol>
                        </div>
                        
                        <p>Randomクラスの主なメソッド：</p>
                        <code>import java.util.Random;

// Randomオブジェクトの作成
Random random = new Random();  // デフォルトシード（システム時間）
Random seededRandom = new Random(42);  // シード値を指定

// 様々な型の乱数生成
boolean randomBoolean = random.nextBoolean();  // true または false
int randomInt = random.nextInt();  // 全整数範囲
int randomIntWithBound = random.nextInt(100);  // 0から99までの整数
long randomLong = random.nextLong();  // 全long範囲
float randomFloat = random.nextFloat();  // 0.0以上1.0未満
double randomDouble = random.nextDouble();  // 0.0以上1.0未満
double randomGaussian = random.nextGaussian();  // 平均0.0、標準偏差1.0の正規分布</code>
                        
                        <h4>実用的な乱数生成パターン</h4>
                        <p>以下は、一般的な乱数生成パターンの例です：</p>
                        <code>import java.util.Random;

public class RandomExample {
    public static void main(String[] args) {
        Random random = new Random();
        
        // 1. 範囲を指定した整数の乱数（min以上max以下）
        int min = 5;
        int max = 10;
        int randomInRange = random.nextInt(max - min + 1) + min;
        System.out.println(min + "から" + max + "までの乱数: " + randomInRange);
        
        // 2. 範囲を指定した浮動小数点数の乱数
        double minDouble = 5.0;
        double maxDouble = 10.0;
        double randomDouble = minDouble + (maxDouble - minDouble) * random.nextDouble();
        System.out.println(minDouble + "から" + maxDouble + "までの乱数: " + randomDouble);
        
        // 3. サイコロのシミュレーション（1から6の乱数）
        int dice = random.nextInt(6) + 1;
        System.out.println("サイコロの目: " + dice);
        
        // 4. コイントスのシミュレーション
        boolean heads = random.nextBoolean();
        System.out.println("コイントス: " + (heads ? "表" : "裏"));
    }
}</code>
                        
                        <div class="exercise">
                            <h5>演習 5.2: Math, Randomクラスの活用</h5>
                            <p>以下の問題に取り組み、MathクラスとRandomクラスの使い方を練習しましょう：</p>
                            <ol>
                                <li>1から100までの乱数を10個生成し、その平均値、最大値、最小値を計算するプログラムを作成してください。</li>
                                <li>ユーザーが入力した2つの正の整数の最大公約数(GCD)を求めるプログラムを作成してください。ヒント：ユークリッドの互除法を使用します。</li>
                                <li>サイコロを2つ振るシミュレーションを1000回行い、出た目の合計値の分布を表示するプログラムを作成してください。</li>
                            </ol>
                        </div>
                    </section>

                    <section id="date-time">
                        <h3 class="section-title">5.3 日付と時間 (java.time)</h3>
                        <p>Java 8から導入された<span class="inline-code">java.time</span>パッケージは、日付と時間を扱うための新しいAPIを提供しています。このAPIは従来の<span class="inline-code">java.util.Date</span>や<span class="inline-code">java.util.Calendar</span>に代わる、より使いやすく柔軟な仕組みを提供します。</p>
                        
                        <div class="note">
                            <h5>java.timeパッケージの特徴</h5>
                            <ul>
                                <li><strong>イミュータブル（不変）</strong>：すべてのクラスはスレッドセーフ</li>
                                <li><strong>分離された概念</strong>：日付のみ、時間のみ、日付と時間など用途に応じたクラスが提供されている</li>
                                <li><strong>国際標準の採用</strong>：ISO-8601形式の日付と時間表現を基本としている</li>
                                <li><strong>豊富な操作メソッド</strong>：加算、減算、比較などのメソッドが充実</li>
                            </ul>
                        </div>
                        
                        <h4>主要なjava.timeのクラス</h4>
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 450">
                                <!-- java.time classes diagram -->
                                <rect x="200" y="30" width="200" height="50" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="300" y="60" text-anchor="middle" font-size="16" font-weight="bold">java.time</text>
                                
                                <rect x="50" y="120" width="150" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="125" y="145" text-anchor="middle" font-size="14">LocalDate</text>
                                
                                <rect x="225" y="120" width="150" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="300" y="145" text-anchor="middle" font-size="14">LocalTime</text>
                                
                                <rect x="400" y="120" width="150" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="475" y="145" text-anchor="middle" font-size="14">LocalDateTime</text>
                                
                                <rect x="50" y="200" width="150" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="125" y="225" text-anchor="middle" font-size="14">ZonedDateTime</text>
                                
                                <rect x="225" y="200" width="150" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="300" y="225" text-anchor="middle" font-size="14">Instant</text>
                                
                                <rect x="400" y="200" width="150" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="475" y="225" text-anchor="middle" font-size="14">Duration</text>
                                
                                <rect x="125" y="280" width="150" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="200" y="305" text-anchor="middle" font-size="14">Period</text>
                                
                                <rect x="325" y="280" width="150" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="400" y="305" text-anchor="middle" font-size="14">DateTimeFormatter</text>
                                
                                <line x1="300" y1="80" x2="125" y2="120" stroke="#1976d2" stroke-width="1" />
                                <line x1="300" y1="80" x2="300" y2="120" stroke="#1976d2" stroke-width="1" />
                                <line x1="300" y1="80" x2="475" y2="120" stroke="#1976d2" stroke-width="1" />
                                <line x1="300" y1="80" x2="125" y2="200" stroke="#1976d2" stroke-width="1" />
                                <line x1="300" y1="80" x2="300" y2="200" stroke="#1976d2" stroke-width="1" />
                                <line x1="300" y1="80" x2="475" y2="200" stroke="#1976d2" stroke-width="1" />
                                <line x1="300" y1="80" x2="200" y2="280" stroke="#1976d2" stroke-width="1" />
                                <line x1="300" y1="80" x2="400" y2="280" stroke="#1976d2" stroke-width="1" />
                                
                                <rect x="50" y="340" width="500" height="80" fill="#e8f5e9" stroke="#4caf50" stroke-width="1" rx="5" />
                                <text x="300" y="365" text-anchor="middle" font-size="14">
                                    <tspan x="300" dy="0">LocalDate：日付のみ（2023-04-25）</tspan>
                                    <tspan x="300" dy="20">LocalTime：時間のみ（13:45:30）</tspan>
                                    <tspan x="300" dy="20">LocalDateTime：日付と時間（2023-04-25T13:45:30）</tspan>
                                </text>
                            </svg>
                        </div>
                        
                        <table class="method-table">
                            <thead>
                                <tr>
                                    <th>クラス</th>
                                    <th>説明</th>
                                    <th>主な用途</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><span class="inline-code">LocalDate</span></td>
                                    <td>日付のみ（年月日）</td>
                                    <td>誕生日、休日、予定日など</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">LocalTime</span></td>
                                    <td>時間のみ（時分秒ナノ秒）</td>
                                    <td>開店時間、閉店時間など</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">LocalDateTime</span></td>
                                    <td>日付と時間</td>
                                    <td>会議の日時、締め切りなど</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">ZonedDateTime</span></td>
                                    <td>タイムゾーン付きの日付と時間</td>
                                    <td>国際的な予定、フライト時間など</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">Instant</span></td>
                                    <td>エポック秒（1970-01-01T00:00:00Z からの経過時間）</td>
                                    <td>タイムスタンプ、システム時間</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">Duration</span></td>
                                    <td>時間ベースの時間量（秒、ナノ秒）</td>
                                    <td>処理時間、タイムアウトなど</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">Period</span></td>
                                    <td>日付ベースの時間量（年、月、日）</td>
                                    <td>年齢、契約期間など</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">DateTimeFormatter</span></td>
                                    <td>日付と時間の書式設定</td>
                                    <td>表示形式のカスタマイズ</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h4>基本的な使い方</h4>
                        <code>import java.time.*;
import java.time.format.*;

public class DateTimeExample {
    public static void main(String[] args) {
        // 現在の日付を取得
        LocalDate today = LocalDate.now();
        System.out.println("今日の日付: " + today);
        
        // 特定の日付を作成
        LocalDate birthday = LocalDate.of(1990, 1, 15);
        System.out.println("誕生日: " + birthday);
        
        // 現在の時間を取得
        LocalTime now = LocalTime.now();
        System.out.println("現在の時間: " + now);
        
        // 特定の時間を作成
        LocalTime meetingTime = LocalTime.of(13, 30, 0);
        System.out.println("会議時間: " + meetingTime);
        
        // 現在の日時を取得
        LocalDateTime dateTimeNow = LocalDateTime.now();
        System.out.println("現在の日時: " + dateTimeNow);
        
        // 日付と時間を組み合わせる
        LocalDateTime meeting = LocalDateTime.of(today, meetingTime);
        System.out.println("今日の会議: " + meeting);
        
        // タイムゾーン付きの日時
        ZonedDateTime tokyoTime = ZonedDateTime.now(ZoneId.of("Asia/Tokyo"));
        System.out.println("東京の現在時刻: " + tokyoTime);
        
        // エポック秒（Unixタイムスタンプ）
        Instant timestamp = Instant.now();
        System.out.println("現在のタイムスタンプ: " + timestamp);
    }
}</code>
                        
                        <h4>日付と時間の操作</h4>
                        <p>日付や時間の加算、減算、比較などの操作は非常に直感的に行えます：</p>
                        <code>// 日付の加算・減算
LocalDate today = LocalDate.now();
LocalDate tomorrow = today.plusDays(1);
LocalDate nextWeek = today.plusWeeks(1);
LocalDate lastMonth = today.minusMonths(1);

// 時間の加算・減算
LocalTime now = LocalTime.now();
LocalTime hourLater = now.plusHours(1);
LocalTime minutesBefore = now.minusMinutes(15);

// 年月日の個別取得
int year = today.getYear();
Month month = today.getMonth();  // 列挙型
int dayOfMonth = today.getDayOfMonth();
DayOfWeek dayOfWeek = today.getDayOfWeek();  // 列挙型

// 日付の比較
boolean isBefore = today.isBefore(tomorrow);  // true
boolean isAfter = today.isAfter(tomorrow);    // false
boolean isEqual = today.isEqual(today);       // true</code>
                        
                        <h4>期間と間隔</h4>
                        <p>二つの日付や時間の間の期間を計算することができます：</p>
                        <code>// 期間（日付ベース）
LocalDate start = LocalDate.of(2020, 1, 1);
LocalDate end = LocalDate.of(2023, 4, 15);

Period period = Period.between(start, end);
System.out.println("期間: " + period.getYears() + "年 " + 
                 period.getMonths() + "ヶ月 " + 
                 period.getDays() + "日");

// 時間間隔（時間ベース）
LocalTime startTime = LocalTime.of(9, 0);
LocalTime endTime = LocalTime.of(17, 30);

Duration duration = Duration.between(startTime, endTime);
System.out.println("時間間隔: " + duration.toHours() + "時間 " + 
                 (duration.toMinutes() % 60) + "分");

// Instantベースの時間計測（処理時間など）
Instant start = Instant.now();
// ... 何か処理 ...
Instant end = Instant.now();
Duration timeElapsed = Duration.between(start, end);
System.out.println("処理時間: " + timeElapsed.toMillis() + "ミリ秒");</code>
                        
                        <h4>日付と時間の書式設定</h4>
                        <p><span class="inline-code">DateTimeFormatter</span>を使って日付と時間の表示形式をカスタマイズできます：</p>
                        <code>// 組み込みフォーマッタを使用
LocalDate date = LocalDate.now();
String basic = date.format(DateTimeFormatter.BASIC_ISO_DATE);  // 20230425
String iso = date.format(DateTimeFormatter.ISO_DATE);         // 2023-04-25

// カスタムフォーマットを定義
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy年MM月dd日");
String formattedDate = date.format(formatter);                // 2023年04月25日

// ロケールを指定
DateTimeFormatter japaneseFormatter = DateTimeFormatter
    .ofPattern("yyyy年MM月dd日(E)")
    .withLocale(Locale.JAPANESE);
String japaneseDate = date.format(japaneseFormatter);        // 2023年04月25日(火)

// 文字列から日付に変換
String dateStr = "2023-04-25";
LocalDate parsedDate = LocalDate.parse(dateStr);              // ISO形式を自動認識

// カスタムフォーマットで解析
String customDateStr = "2023年04月25日";
LocalDate customParsedDate = LocalDate.parse(
    customDateStr, DateTimeFormatter.ofPattern("yyyy年MM月dd日"));</code>
                        
                        <div class="exercise">
                            <h5>演習 5.3: 日付と時間の操作</h5>
                            <p>以下の問題に取り組み、日付と時間の操作を練習しましょう：</p>
                            <ol>
                                <li>今日から100日後の日付を計算し、曜日と一緒に表示するプログラムを作成してください。</li>
                                <li>あなたの誕生日から今日までの年数、月数、日数を計算するプログラムを作成してください。</li>
                                <li>現在の日本時間と、ニューヨーク、ロンドン、シドニーの現在時刻を表示するプログラムを作成してください。</li>
                            </ol>
                        </div>
                    </section>

                    <section id="collection-framework">
                        <h3 class="section-title">5.4 コレクションフレームワーク入門</h3>
                        <p>Javaのコレクションフレームワークは、データを格納し操作するための統一された構造を提供するクラスとインターフェースの集まりです。これを使用することで、効率的にデータの格納、検索、操作を行うことができます。</p>
                        
                        <div class="note">
                            <h5>コレクションフレームワークの基本概念</h5>
                            <ul>
                                <li><strong>コレクション（Collection）</strong>：オブジェクトのグループを表すルートインターフェース</li>
                                <li><strong>セット（Set）</strong>：重複を許さない要素の集合</li>
                                <li><strong>リスト（List）</strong>：順序付けられ、重複を許す要素の集合</li>
                                <li><strong>キュー（Queue）</strong>：処理前の要素を保持する集合</li>
                                <li><strong>マップ（Map）</strong>：キーと値のペアを格納する構造（コレクションインターフェースを拡張していない）</li>
                            </ul>
                        </div>
                        
                        <h4>コレクションフレームワークの構造</h4>
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 300">
                                <!-- Collection Framework Hierarchy -->
                                <rect x="300" y="30" width="100" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="350" y="55" text-anchor="middle" font-size="14">Collection</text>
                                
                                <rect x="100" y="120" width="100" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="150" y="145" text-anchor="middle" font-size="14">List</text>
                                
                                <rect x="300" y="120" width="100" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="350" y="145" text-anchor="middle" font-size="14">Set</text>
                                
                                <rect x="500" y="120" width="100" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="550" y="145" text-anchor="middle" font-size="14">Queue</text>
                                
                                <rect x="600" y="30" width="100" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="650" y="55" text-anchor="middle" font-size="14">Map</text>
                                
                                <rect x="50" y="210" width="80" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" rx="5" />
                                <text x="90" y="235" text-anchor="middle" font-size="13">ArrayList</text>
                                
                                <rect x="150" y="210" width="80" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" rx="5" />
                                <text x="190" y="235" text-anchor="middle" font-size="13">LinkedList</text>
                                
                                <rect x="250" y="210" width="80" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" rx="5" />
                                <text x="290" y="235" text-anchor="middle" font-size="13">HashSet</text>
                                
                                <rect x="350" y="210" width="80" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" rx="5" />
                                <text x="390" y="235" text-anchor="middle" font-size="13">TreeSet</text>
                                
                                <rect x="450" y="210" width="80" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" rx="5" />
                                <text x="490" y="235" text-anchor="middle" font-size="13">PriorityQueue</text>
                                
                                <rect x="550" y="210" width="80" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" rx="5" />
                                <text x="590" y="235" text-anchor="middle" font-size="13">HashMap</text>
                                
                                <rect x="650" y="210" width="80" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" rx="5" />
                                <text x="690" y="235" text-anchor="middle" font-size="13">TreeMap</text>
                                
                                <!-- Connection lines -->
                                <line x1="350" y1="70" x2="150" y2="120" stroke="#1976d2" stroke-width="1" />
                                <line x1="350" y1="70" x2="350" y2="120" stroke="#1976d2" stroke-width="1" />
                                <line x1="350" y1="70" x2="550" y2="120" stroke="#1976d2" stroke-width="1" />
                                
                                <line x1="150" y1="160" x2="90" y2="210" stroke="#4caf50" stroke-width="1" />
                                <line x1="150" y1="160" x2="190" y2="210" stroke="#4caf50" stroke-width="1" />
                                <line x1="350" y1="160" x2="290" y2="210" stroke="#4caf50" stroke-width="1" />
                                <line x1="350" y1="160" x2="390" y2="210" stroke="#4caf50" stroke-width="1" />
                                <line x1="550" y1="160" x2="490" y2="210" stroke="#4caf50" stroke-width="1" />
                                <line x1="650" y1="70" x2="590" y2="210" stroke="#4caf50" stroke-width="1" />
                                <line x1="650" y1="70" x2="690" y2="210" stroke="#4caf50" stroke-width="1" />
                                
                                <!-- Note: LinkedList implements both List and Queue -->
                                <line x1="550" y1="160" x2="190" y2="210" stroke="#4caf50" stroke-width="1" stroke-dasharray="5,5" />
                                
                                <text x="70" y="200" font-size="14">
                                    <tspan x="70" dy="0"><strong>主なインターフェースの特徴：</strong></tspan><br>
                                    <tspan x="70" dy="25">・<strong>List</strong>: インデックスによるアクセス、重複要素を許可、順序を保持</tspan><br>
                                    <tspan x="70" dy="25">・<strong>Set</strong>: 重複要素を許可しない、一般的にインデックスアクセスなし</tspan><br>
                                    <tspan x="70" dy="25">・<strong>Queue</strong>: FIFO（先入れ先出し）の順序付けポリシー</tspan><br>
                                    <tspan x="70" dy="25">・<strong>Map</strong>: キーと値のペアを格納、キーは重複不可、値は重複可</tspan><br>
                                </text>
                            </svg>
                        </div>
                        
                        <h4>コレクションフレームワークの共通機能</h4>
                        <p>コレクションフレームワークのクラスは、次のような共通の機能を提供します：</p>
                        <table class="method-table">
                            <thead>
                                <tr>
                                    <th>操作</th>
                                    <th>説明</th>
                                    <th>使用例</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>追加</td>
                                    <td>要素を追加</td>
                                    <td><span class="inline-code">add(E e)</span>, <span class="inline-code">put(K k, V v)</span></td>
                                </tr>
                                <tr>
                                    <td>削除</td>
                                    <td>要素を削除</td>
                                    <td><span class="inline-code">remove(Object o)</span>, <span class="inline-code">remove(int index)</span></td>
                                </tr>
                                <tr>
                                    <td>検索</td>
                                    <td>要素の存在を確認</td>
                                    <td><span class="inline-code">contains(Object o)</span>, <span class="inline-code">containsKey(Object key)</span></td>
                                </tr>
                                <tr>
                                    <td>取得</td>
                                    <td>要素を取得</td>
                                    <td><span class="inline-code">get(int index)</span>, <span class="inline-code">get(Object key)</span></td>
                                </tr>
                                <tr>
                                    <td>サイズ</td>
                                    <td>コレクションのサイズを取得</td>
                                    <td><span class="inline-code">size()</span></td>
                                </tr>
                                <tr>
                                    <td>反復処理</td>
                                    <td>要素を順に処理</td>
                                    <td><span class="inline-code">iterator()</span>, 拡張for文</td>
                                </tr>
                                <tr>
                                    <td>ストリーム処理</td>
                                    <td>関数型スタイルで要素を処理</td>
                                    <td><span class="inline-code">stream()</span>, <span class="inline-code">filter()</span>, <span class="inline-code">map()</span> など</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h4>イテレータ（Iterator）の使用</h4>
                        <p>コレクションフレームワークは反復処理のための統一されたメカニズムを提供します：</p>
                        <code>import java.util.*;

// 例：ListのIterator
List<String> fruits = new ArrayList<>();
fruits.add("リンゴ");
fruits.add("バナナ");
fruits.add("オレンジ");

// Iterator を使用した反復処理
Iterator<String> iterator = fruits.iterator();
while (iterator.hasNext()) {
    String fruit = iterator.next();
    System.out.println(fruit);
    
    // 反復処理中の削除も可能
    if (fruit.equals("バナナ")) {
        iterator.remove();  // 安全に要素を削除
    }
}

// 拡張for文（for-each）を使用した反復処理
for (String fruit : fruits) {
    System.out.println(fruit);
    // 注意: 拡張for文の中では要素の削除ができない
}</code>
                        
                        <h4>ジェネリクス（Generics）の活用</h4>
                        <p>コレクションフレームワークはジェネリクスを活用して型安全なコレクションを作成できます：</p>
                        <code>// 型安全なリスト（整数のみ）
List<Integer> numbers = new ArrayList<>();
numbers.add(10);  // OK
numbers.add(20);  // OK
// numbers.add("文字列");  // コンパイルエラー

// 型安全なマップ（文字列キー、整数値）
Map<String, Integer> scores = new HashMap<>();
scores.put("Alice", 95);
scores.put("Bob", 87);
int aliceScore = scores.get("Alice");  // 型変換不要</code>
                        
                        <h4>比較とソート</h4>
                        <p>コレクションの要素を比較やソートするためには、<span class="inline-code">Comparable</span>インターフェースか<span class="inline-code">Comparator</span>インターフェースを使用します：</p>
                        <code>import java.util.*;

// Comparableを実装したクラス（自然順序付け）
class Person implements Comparable<Person> {
    private String name;
    private int age;
    
    // コンストラクタ、ゲッター、セッターなど
    
    @Override
    public int compareTo(Person other) {
        // 年齢で比較（昇順）
        return this.age - other.age;
    }
}

// Comparatorを使用した外部比較（カスタム順序付け）
public class CollectionSortingExample {
    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        // リストに人を追加
        
        // 自然順序（年齢）でソート
        Collections.sort(people);
        
        // 名前でソートするComparator
        Comparator<Person> byName = new Comparator<Person>() {
            @Override
            public int compare(Person p1, Person p2) {
                return p1.getName().compareTo(p2.getName());
            }
        };
        
        // 名前でソート（Java 8ラムダ式）
        Collections.sort(people, (p1, p2) -> p1.getName().compareTo(p2.getName()));
        
        // Java 8以降の機能を使用
        people.sort(Comparator.comparing(Person::getName));
    }
}</code>
                        
                        <div class="note">
                            <h5>コレクション選択のガイドライン</h5>
                            <p>適切なコレクションを選ぶ際の一般的なガイドラインです：</p>
                            <ul>
                                <li><strong>ArrayList</strong>：ランダムアクセスが必要で、主に読み取り操作が多い場合</li>
                                <li><strong>LinkedList</strong>：頻繁な挿入/削除操作が必要な場合</li>
                                <li><strong>HashSet</strong>：重複のない高速なルックアップが必要な場合</li>
                                <li><strong>TreeSet</strong>：要素を自然順序またはカスタム順序で保持する必要がある場合</li>
                                <li><strong>HashMap</strong>：キーによる高速なルックアップが必要な場合</li>
                                <li><strong>TreeMap</strong>：キーをソートされた順序で保持する必要がある場合</li>
                            </ul>
                        </div>
                        
                        <div class="exercise">
                            <h5>演習 5.4: コレクションフレームワークの基本</h5>
                            <p>以下の問題に取り組み、コレクションフレームワークの基本を練習しましょう：</p>
                            <ol>
                                <li>文字列のリストを作成し、重複を削除して、アルファベット順にソートするプログラムを作成してください。</li>
                                <li>整数の配列から偶数のみを抽出し、新しいリストに格納するプログラムを作成してください。</li>
                                <li>3つの異なるコレクション（ArrayList、HashSet、TreeSet）に同じデータを追加し、その違いを確認するプログラムを作成してください。</li>
                            </ol>
                        </div>
                    </section>

                    <section id="arraylist-linkedlist">
                        <h3 class="section-title">5.5 ArrayList, LinkedList</h3>
                        <p><span class="inline-code">ArrayList</span>と<span class="inline-code">LinkedList</span>は、Javaの<span class="inline-code">List</span>インターフェースの代表的な実装です。どちらも要素の順序を保持し、重複要素を許可しますが、内部構造と性能特性が異なります。</p>
                        
                        <h4>ArrayListの特徴</h4>
                        <div class="note">
                            <h5>ArrayListの主な特性</h5>
                            <ul>
                                <li><strong>内部構造</strong>：可変サイズの配列を使用</li>
                                <li><strong>ランダムアクセス</strong>：インデックスによる要素へのアクセスが高速（O(1)）</li>
                                <li><strong>追加/削除</strong>：末尾への追加は通常高速、中間への挿入/削除は要素のシフトが必要で低速（O(n)）</li>
                                <li><strong>メモリ</strong>：連続したメモリブロックを使用するため、効率的なメモリ使用</li>
                                <li><strong>サイズ</strong>：内部配列がいっぱいになると、より大きな配列を作成してデータをコピー</li>
                            </ul>
                        </div>
                        
                        <h4>基本的なArrayListの使用法</h4>
                        <code>import java.util.ArrayList;
import java.util.List;

public class ArrayListExample {
    public static void main(String[] args) {
        // ArrayListの作成
        List<String> fruits = new ArrayList<>();
        
        // 要素の追加
        fruits.add("リンゴ");
        fruits.add("バナナ");
        fruits.add("オレンジ");
        
        // 指定位置に要素を追加
        fruits.add(1, "ぶどう");  // [リンゴ, ぶどう, バナナ, オレンジ]
        
        // 要素へのアクセス
        String firstFruit = fruits.get(0);  // リンゴ
        System.out.println("最初の果物: " + firstFruit);
        
        // 要素の変更
        fruits.set(0, "いちご");  // [いちご, ぶどう, バナナ, オレンジ]
        
        // リストのサイズ
        int size = fruits.size();  // 4
        System.out.println("果物の数: " + size);
        
        // 要素の検索
        int position = fruits.indexOf("バナナ");  // 2
        boolean contains = fruits.contains("オレンジ");  // true
        
        // 要素の削除
        fruits.remove("バナナ");  // 値で削除
        fruits.remove(0);  // インデックスで削除 [ぶどう, オレンジ]
        
        // リストの反復処理
        for (String fruit : fruits) {
            System.out.println(fruit);
        }
        
        // リストの全要素をクリア
        fruits.clear();
        System.out.println("クリア後のサイズ: " + fruits.size());  // 0
    }
}</code>
                        
                        <h4>LinkedListの特徴</h4>
                        <div class="note">
                            <h5>LinkedListの主な特性</h5>
                            <ul>
                                <li><strong>内部構造</strong>：双方向リンクリスト（各要素が前後の要素への参照を保持）</li>
                                <li><strong>ランダムアクセス</strong>：遅い（O(n)）、先頭から順番に走査する必要がある</li>
                                <li><strong>追加/削除</strong>：ポインタの変更のみで、中間への挿入/削除が高速（O(1)、ただし位置の検索は O(n)）</li>
                                <li><strong>メモリ</strong>：各要素に追加のポインタが必要なため、ArrayListよりも多くのメモリを使用</li>
                                <li><strong>特別な機能</strong>：Queue, Dequeインターフェースも実装しているため、キューやスタックとしても使用可能</li>
                            </ul>
                        </div>
                        
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 300">
                                <!-- ArrayList vs LinkedList Visualization -->
                                <rect x="50" y="30" width="500" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="300" y="55" text-anchor="middle" font-size="16" font-weight="bold">ArrayList vs LinkedList</text>
                                
                                <rect x="50" y="90" width="500" height="90" fill="#e8f5e9" stroke="#4caf50" stroke-width="1" rx="5" />
                                <text x="300" y="110" text-anchor="middle" font-size="14" font-weight="bold">ArrayList</text>
                                
                                <rect x="100" y="120" width="50" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="125" y="145" text-anchor="middle" font-size="14">A</text>
                                
                                <rect x="150" y="120" width="50" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="175" y="145" text-anchor="middle" font-size="14">B</text>
                                
                                <rect x="200" y="120" width="50" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="225" y="145" text-anchor="middle" font-size="14">C</text>
                                
                                <rect x="250" y="120" width="50" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="275" y="145" text-anchor="middle" font-size="14">D</text>
                                
                                <rect x="300" y="120" width="50" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="325" y="145" text-anchor="middle" font-size="14">E</text>
                                
                                <rect x="350" y="120" width="50" height="40" fill="#f5f5f5" stroke="#4caf50" stroke-width="1" stroke-dasharray="5,5" />
                                <rect x="400" y="120" width="50" height="40" fill="#f5f5f5" stroke="#4caf50" stroke-width="1" stroke-dasharray="5,5" />
                                <rect x="450" y="120" width="50" height="40" fill="#f5f5f5" stroke="#4caf50" stroke-width="1" stroke-dasharray="5,5" />
                                
                                <rect x="50" y="200" width="500" height="90" fill="#e3f2fd" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="300" y="220" text-anchor="middle" font-size="14" font-weight="bold">LinkedList</text>
                                
                                <rect x="100" y="240" width="50" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="125" y="265" text-anchor="middle" font-size="14">A</text>
                                
                                <rect x="200" y="240" width="50" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="225" y="265" text-anchor="middle" font-size="14">B</text>
                                
                                <rect x="300" y="240" width="50" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="325" y="265" text-anchor="middle" font-size="14">C</text>
                                
                                <rect x="400" y="240" width="50" height="40" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="425" y="265" text-anchor="middle" font-size="14">D</text>
                                
                                <line x1="150" y1="260" x2="200" y2="260" stroke="#1976d2" stroke-width="2" marker-end="url(#arrowhead)" />
                                <line x1="250" y1="260" x2="300" y2="260" stroke="#1976d2" stroke-width="2" marker-end="url(#arrowhead)" />
                                <line x1="350" y1="260" x2="400" y2="260" stroke="#1976d2" stroke-width="2" marker-end="url(#arrowhead)" />
                                
                                <line x1="200" y1="240" x2="150" y2="240" stroke="#1976d2" stroke-width="2" marker-end="url(#arrowhead)" />
                                <line x1="300" y1="240" x2="250" y2="240" stroke="#1976d2" stroke-width="2" marker-end="url(#arrowhead)" />
                                <line x1="400" y1="240" x2="350" y2="240" stroke="#1976d2" stroke-width="2" marker-end="url(#arrowhead)" />
                                
                                <defs>
                                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#1976d2" />
                                    </marker>
                                </defs>
                            </svg>
                        </div>
                        
                        <h4>基本的なLinkedListの使用法</h4>
                        <code>import java.util.LinkedList;

public class LinkedListExample {
    public static void main(String[] args) {
        // LinkedListの作成
        LinkedList<String> languages = new LinkedList<>();
        
        // 要素の追加（Listとしての基本操作）
        languages.add("Java");
        languages.add("Python");
        languages.add("JavaScript");
        
        // LinkedList固有のメソッド
        languages.addFirst("C++");  // リストの先頭に追加
        languages.addLast("Ruby");  // リストの末尾に追加（add()と同じ）
        
        // 先頭と末尾の要素を取得
        String first = languages.getFirst();  // C++
        String last = languages.getLast();    // Ruby
        
        System.out.println("最初の言語: " + first);
        System.out.println("最後の言語: " + last);
        
        // 先頭と末尾の要素を削除
        languages.removeFirst();  // C++を削除
        languages.removeLast();   // Rubyを削除
        
        // キューとしての使用（FIFO: First-In-First-Out）
        languages.offer("Go");  // 末尾に追加（addと似ている）
        String head = languages.poll();  // 先頭を取得して削除（Java）
        
        // スタックとしての使用（LIFO: Last-In-First-Out）
        languages.push("Rust");  // 先頭に追加（addFirstと同じ）
        String popped = languages.pop();  // 先頭を取得して削除（Rust）
        
        // 現在のリストを表示
        System.out.println("現在のリスト:");
        for (String lang : languages) {
            System.out.println(lang);
        }
    }
}</code>
                        
                        <h4>ArrayListとLinkedListの性能比較</h4>
                        <table class="method-table">
                            <thead>
                                <tr>
                                    <th>操作</th>
                                    <th>ArrayList</th>
                                    <th>LinkedList</th>
                                    <th>推奨される使用場面</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>末尾への追加</td>
                                    <td>O(1) *</td>
                                    <td>O(1)</td>
                                    <td>両方</td>
                                </tr>
                                <tr>
                                    <td>中間への挿入</td>
                                    <td>O(n)</td>
                                    <td>O(n) **</td>
                                    <td>LinkedList</td>
                                </tr>
                                <tr>
                                    <td>中間からの削除</td>
                                    <td>O(n)</td>
                                    <td>O(n) **</td>
                                    <td>LinkedList</td>
                                </tr>
                                <tr>
                                    <td>先頭への挿入</td>
                                    <td>O(n)</td>
                                    <td>O(1)</td>
                                    <td>LinkedList</td>
                                </tr>
                                <tr>
                                    <td>インデックスアクセス</td>
                                    <td>O(1)</td>
                                    <td>O(n)</td>
                                    <td>ArrayList</td>
                                </tr>
                                <tr>
                                    <td>イテレーション</td>
                                    <td>高速</td>
                                    <td>低速</td>
                                    <td>ArrayList</td>
                                </tr>
                                <tr>
                                    <td>メモリ使用量</td>
                                    <td>少ない</td>
                                    <td>多い</td>
                                    <td>ArrayList</td>
                                </tr>
                            </tbody>
                        </table>
                        <p class="small">* 再割り当てが必要な場合はO(n)<br>** 挿入/削除位置が分かっている場合はO(1)だが、位置を見つけるのにO(n)</p>
                        
                        <div class="note">
                            <h5>ArrayList vs LinkedList：選択のガイドライン</h5>
                            <p><strong>ArrayListの使用が適している場合：</strong></p>
                            <ul>
                                <li>ランダムアクセス（get/set）が頻繁に必要な場合</li>
                                <li>主に読み取り操作が多い場合</li>
                                <li>リストの末尾に対する追加/削除が主な操作の場合</li>
                                <li>メモリ効率が重要な場合</li>
                            </ul>
                            <p><strong>LinkedListの使用が適している場合：</strong></p>
                            <ul>
                                <li>リストの先頭や中間での頻繁な挿入/削除が必要な場合</li>
                                <li>キューやスタックとして使用する場合</li>
                                <li>ランダムアクセスがほとんどない場合</li>
                                <li>リストのサイズが大きく変動する場合</li>
                            </ul>
                        </div>
                        
                        <h4>ArrayList/LinkedListの実践的な使用例</h4>
                        <code>import java.util.*;

public class ListPerformanceExample {
    public static void main(String[] args) {
        // 様々なリスト操作の性能を比較
        List<Integer> arrayList = new ArrayList<>();
        List<Integer> linkedList = new LinkedList<>();
        
        // 末尾への追加（ArrayList有利）
        long startTime = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            arrayList.add(i);
        }
        long endTime = System.nanoTime();
        System.out.println("ArrayList 末尾追加時間: " + (endTime - startTime) / 1000000 + "ms");
        
        startTime = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            linkedList.add(i);
        }
        endTime = System.nanoTime();
        System.out.println("LinkedList 末尾追加時間: " + (endTime - startTime) / 1000000 + "ms");
        
        // 先頭への追加（LinkedList有利）
        arrayList.clear();
        linkedList.clear();
        
        startTime = System.nanoTime();
        for (int i = 0; i < 10000; i++) {
            arrayList.add(0, i);  // 毎回要素をシフトする必要がある
        }
        endTime = System.nanoTime();
        System.out.println("ArrayList 先頭追加時間: " + (endTime - startTime) / 1000000 + "ms");
        
        startTime = System.nanoTime();
        for (int i = 0; i < 10000; i++) {
            linkedList.add(0, i);  // ポインタの変更のみ
        }
        endTime = System.nanoTime();
        System.out.println("LinkedList 先頭追加時間: " + (endTime - startTime) / 1000000 + "ms");
        
        // ランダムアクセス（ArrayList有利）
        arrayList.clear();
        linkedList.clear();
        for (int i = 0; i < 100000; i++) {
            arrayList.add(i);
            linkedList.add(i);
        }
        
        startTime = System.nanoTime();
        for (int i = 0; i < 10000; i++) {
            int index = (int)(Math.random() * 100000);
            arrayList.get(index);  // O(1)
        }
        endTime = System.nanoTime();
        System.out.println("ArrayList ランダムアクセス時間: " + (endTime - startTime) / 1000000 + "ms");
        
        startTime = System.nanoTime();
        for (int i = 0; i < 10000; i++) {
            int index = (int)(Math.random() * 100000);
            linkedList.get(index);  // O(n)
        }
        endTime = System.nanoTime();
        System.out.println("LinkedList ランダムアクセス時間: " + (endTime - startTime) / 1000000 + "ms");
    }
}</code>
                        
                        <div class="exercise">
                            <h5>演習 5.5: ArrayListとLinkedListの使用</h5>
                            <p>以下の問題に取り組み、ArrayListとLinkedListの使い方を練習しましょう：</p>
                            <ol>
                                <li>ArrayListを使って100万個の整数を格納し、その合計と平均を計算するプログラムを作成してください。</li>
                                <li>ArrayListとLinkedListをそれぞれ使用して、リストの先頭に1000個の要素を追加し、実行時間を比較するプログラムを作成してください。</li>
                                <li>LinkedListをキューとして使用し、簡単なタスク管理システム（タスクの追加、完了、表示）を実装してください。</li>
                            </ol>
                        </div>
                    </section>

                    <section id="hashset-treeset">
                        <h3 class="section-title">5.6 HashSet, TreeSet</h3>
                        <p><span class="inline-code">HashSet</span>と<span class="inline-code">TreeSet</span>は、Javaの<span class="inline-code">Set</span>インターフェースの代表的な実装です。どちらも重複要素を許可しない集合を表しますが、内部構造とパフォーマンス特性が異なります。</p>
                        
                        <h4>HashSetの特徴</h4>
                        <div class="note">
                            <h5>HashSetの主な特性</h5>
                            <ul>
                                <li><strong>内部構造</strong>：ハッシュテーブル（実際にはHashMapを使用）</li>
                                <li><strong>順序</strong>：要素の挿入順序を保持しない</li>
                                <li><strong>パフォーマンス</strong>：追加、削除、検索がほぼ一定時間O(1)</li>
                                <li><strong>nullの許容</strong>：nullを要素として1つ保持可能</li>
                                <li><strong>使用場面</strong>：高速な検索と重複排除が必要な場合</li>
                            </ul>
                        </div>
                        
                        <p>HashSetの基本的な使用例：</p>
                        <code>import java.util.HashSet;
import java.util.Set;

public class HashSetExample {
    public static void main(String[] args) {
        // HashSetの作成
        Set<String> fruits = new HashSet<>();
        
        // 要素の追加
        fruits.add("リンゴ");
        fruits.add("バナナ");
        fruits.add("オレンジ");
        
        // 重複要素の追加（無視される）
        boolean added = fruits.add("リンゴ");  // falseが返される
        System.out.println("リンゴが追加されたか: " + added);
        System.out.println("フルーツの数: " + fruits.size());  // 3
        
        // 要素の存在確認
        boolean contains = fruits.contains("バナナ");  // true
        System.out.println("バナナを含むか: " + contains);
        
        // 要素の削除
        fruits.remove("バナナ");
        
        // 全要素の表示
        System.out.println("HashSetの全要素:");
        for (String fruit : fruits) {
            System.out.println(fruit);  // 順序は保証されない
        }
        
        // 集合演算
        Set<String> moreFruits = new HashSet<>();
        moreFruits.add("ぶどう");
        moreFruits.add("いちご");
        moreFruits.add("リンゴ");  // 重複
        
        // 和集合 (変更はfruitsに反映)
        fruits.addAll(moreFruits);
        System.out.println("和集合後の要素数: " + fruits.size());  // 4
        
        // 新しいHashSetの作成
        Set<String> tropicalFruits = new HashSet<>();
        tropicalFruits.add("マンゴー");
        tropicalFruits.add("パイナップル");
        tropicalFruits.add("バナナ");
        
        // 積集合 (共通要素)
        Set<String> commonFruits = new HashSet<>(fruits);
        commonFruits.retainAll(tropicalFruits);
        System.out.println("共通フルーツ: " + commonFruits);  // []
        
        // 差集合
        Set<String> difference = new HashSet<>(fruits);
        difference.removeAll(tropicalFruits);
        System.out.println("差集合: " + difference);  // [リンゴ, オレンジ, ぶどう, いちご]
    }
}</code>
                        
                        <h4>TreeSetの特徴</h4>
                        <div class="note">
                            <h5>TreeSetの主な特性</h5>
                            <ul>
                                <li><strong>内部構造</strong>：赤黒木（Red-Black Tree、TreeMapを使用）</li>
                                <li><strong>順序</strong>：要素を自然順序（Comparable）またはカスタム順序（Comparator）でソート</li>
                                <li><strong>パフォーマンス</strong>：追加、削除、検索がO(log n)</li>
                                <li><strong>nullの許容</strong>：Java 7以降ではnullを許容しない</li>
                                <li><strong>使用場面</strong>：ソートされた要素のセットが必要な場合</li>
                            </ul>
                        </div>
                        
                        <p>TreeSetの基本的な使用例：</p>
                        <code>import java.util.TreeSet;
import java.util.Set;
import java.util.Comparator;

public class TreeSetExample {
    public static void main(String[] args) {
        // 自然順序（アルファベット順）のTreeSet
        TreeSet<String> sortedFruits = new TreeSet<>();
        
        // 要素の追加
        sortedFruits.add("Orange");
        sortedFruits.add("Apple");
        sortedFruits.add("Banana");
        sortedFruits.add("Grapes");
        
        // 全要素の表示（ソート済み）
        System.out.println("ソート済みフルーツ:");
        for (String fruit : sortedFruits) {
            System.out.println(fruit);  // Apple, Banana, Grapes, Orange
        }
        
        // TreeSet固有のナビゲーションメソッド
        System.out.println("最初の要素: " + sortedFruits.first());  // Apple
        System.out.println("最後の要素: " + sortedFruits.last());   // Orange
        
        // 特定の要素より小さい/大きい要素を取得
        System.out.println("Grapesより前: " + sortedFruits.headSet("Grapes"));  // [Apple, Banana]
        System.out.println("Grapesを含む以降: " + sortedFruits.tailSet("Grapes"));  // [Grapes, Orange]
        
        // 部分集合を取得
        System.out.println("BからGの間: " + sortedFruits.subSet("B", "H"));  // [Banana, Grapes]
        
        // カスタム順序（文字列長でソート）のTreeSet
        TreeSet<String> lengthSorted = new TreeSet<>(new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                // まず長さで比較
                int result = Integer.compare(s1.length(), s2.length());
                // 長さが同じなら文字列内容で比較（重複を避けるため）
                return result != 0 ? result : s1.compareTo(s2);
            }
        });
        
        // 要素の追加
        lengthSorted.add("Orange");  // 6文字
        lengthSorted.add("Apple");   // 5文字
        lengthSorted.add("Banana");  // 6文字
        lengthSorted.add("Kiwi");    // 4文字
        
        // ソート順の確認
        System.out.println("文字列長でソート:");
        for (String fruit : lengthSorted) {
            System.out.println(fruit + " (" + fruit.length() + "文字)");
            // Kiwi(4), Apple(5), Banana(6), Orange(6)
        }
    }
}</code>
                        
                        <h4>HashSetとTreeSetの比較</h4>
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 350">
                                <!-- HashSet vs TreeSet Visualization -->
                                <rect x="50" y="30" width="500" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="300" y="55" text-anchor="middle" font-size="16" font-weight="bold">HashSet vs TreeSet</text>
                                
                                <rect x="50" y="90" width="240" height="250" fill="#e8f5e9" stroke="#4caf50" stroke-width="1" rx="5" />
                                <text x="170" y="110" text-anchor="middle" font-size="14" font-weight="bold">HashSet</text>
                                
                                <!-- HashSet buckets visualization -->
                                <rect x="70" y="120" width="200" height="30" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="170" y="140" text-anchor="middle" font-size="12">ハッシュテーブル</text>
                                
                                <rect x="70" y="150" width="30" height="30" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="85" y="170" text-anchor="middle" font-size="12">0</text>
                                <rect x="100" y="150" width="50" height="30" fill="#e8f5e9" stroke="#4caf50" stroke-width="1" />
                                <text x="125" y="170" text-anchor="middle" font-size="12">null</text>
                                
                                <rect x="70" y="180" width="30" height="30" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="85" y="200" text-anchor="middle" font-size="12">1</text>
                                <rect x="100" y="180" width="50" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="125" y="200" text-anchor="middle" font-size="12">Apple</text>
                                
                                <rect x="70" y="210" width="30" height="30" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="85" y="230" text-anchor="middle" font-size="12">2</text>
                                <rect x="100" y="210" width="50" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="125" y="230" text-anchor="middle" font-size="12">Kiwi</text>
                                
                                <rect x="70" y="240" width="30" height="30" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="85" y="260" text-anchor="middle" font-size="12">3</text>
                                <rect x="100" y="240" width="50" height="30" fill="#e8f5e9" stroke="#4caf50" stroke-width="1" />
                                <text x="125" y="260" text-anchor="middle" font-size="12">null</text>
                                
                                <rect x="70" y="270" width="30" height="30" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="85" y="290" text-anchor="middle" font-size="12">4</text>
                                <rect x="100" y="270" width="50" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="125" y="290" text-anchor="middle" font-size="12">Orange</text>
                                
                                <rect x="150" y="270" width="50" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="175" y="290" text-anchor="middle" font-size="12">Banana</text>
                                <line x1="150" y1="285" x2="200" y2="285" stroke="#1976d2" stroke-width="1" />
                                
                                <rect x="310" y="90" width="240" height="250" fill="#e3f2fd" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="430" y="110" text-anchor="middle" font-size="14" font-weight="bold">TreeSet</text>
                                
                                <!-- TreeSet binary tree visualization -->
                                <circle cx="430" cy="140" r="20" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="430" y="145" text-anchor="middle" font-size="12">Kiwi</text>
                                
                                <circle cx="370" cy="190" r="20" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="370" y="195" text-anchor="middle" font-size="12">Apple</text>
                                
                                <circle cx="490" cy="190" r="20" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="490" y="195" text-anchor="middle" font-size="12">Orange</text>
                                
                                <circle cx="460" cy="240" r="20" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="460" y="245" text-anchor="middle" font-size="12">Banana</text>
                                
                                <line x1="430" y1="160" x2="370" y2="170" stroke="#1976d2" stroke-width="1" />
                                <line x1="430" y1="160" x2="490" y2="170" stroke="#1976d2" stroke-width="1" />
                                <line x1="490" y1="210" x2="460" y2="220" stroke="#1976d2" stroke-width="1" />
                                
                                <rect x="50" y="350" width="500" height="40" fill="#f5f5f5" stroke="#9e9e9e" stroke-width="1" rx="5" />
                                <text x="300" y="375" text-anchor="middle" font-size="12">
                                    HashSet: 順序なし、O(1)操作、高速 | TreeSet: ソート済み、O(log n)操作、ナビゲーション機能
                                </text>
                            </svg>
                        </div>
                        
                        <table class="method-table">
                            <thead>
                                <tr>
                                    <th>特性</th>
                                    <th>HashSet</th>
                                    <th>TreeSet</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>内部実装</td>
                                    <td>ハッシュテーブル (HashMap)</td>
                                    <td>赤黒木 (TreeMap)</td>
                                </tr>
                                <tr>
                                    <td>要素の順序</td>
                                    <td>順序なし (挿入順序を保持しない)</td>
                                    <td>ソート済み (自然順序またはカスタム順)</td>
                                </tr>
                                <tr>
                                    <td>追加/削除/検索</td>
                                    <td>O(1)</td>
                                    <td>O(log n)</td>
                                </tr>
                                <tr>
                                    <td>nullの許容</td>
                                    <td>1つのnull要素を許容</td>
                                    <td>許容しない (Java 7以降)</td>
                                </tr>
                                <tr>
                                    <td>必要な実装</td>
                                    <td>hashCode()とequals()メソッド</td>
                                    <td>compareTo()またはComparator</td>
                                </tr>
                                <tr>
                                    <td>特別な機能</td>
                                    <td>高速なルックアップ</td>
                                    <td>範囲検索、ナビゲーション (first, last, floor, ceiling)</td>
                                </tr>
                                <tr>
                                    <td>推奨される使用場面</td>
                                    <td>要素の存在を高速にチェック</td>
                                    <td>ソート順で要素を取得する必要がある場合</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h4>HashSetとTreeSetの使い分け</h4>
                        <p>以下のガイドラインはSet実装の選択に役立ちます：</p>
                        <div class="note">
                            <h5>HashSetを選ぶべき場合：</h5>
                            <ul>
                                <li>要素の順序が重要でない場合</li>
                                <li>要素の存在確認を高速に行いたい場合</li>
                                <li>メモリ効率を優先する場合</li>
                                <li>大量のデータを扱う場合</li>
                            </ul>
                            
                            <h5>TreeSetを選ぶべき場合：</h5>
                            <ul>
                                <li>要素を常にソートされた状態で保持したい場合</li>
                                <li>範囲クエリを実行する必要がある場合 (subSet(), headSet(), tailSet())</li>
                                <li>最大/最小要素に頻繁にアクセスする場合 (first(), last())</li>
                                <li>要素数が比較的少ない場合</li>
                            </ul>
                        </div>
                        
                        <h4>オブジェクトをSetで使用する際の注意点</h4>
                        <p>独自のクラスをSetで使用する場合、適切なメソッドをオーバーライドする必要があります：</p>
                        <code>import java.util.*;

class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
    
    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
    
    // HashSetで正しく動作させるためのメソッド
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}

// TreeSetで使用する場合はComparableを実装
class Student implements Comparable<Student> {
    private String name;
    private int id;
    
    public Student(String name, int id) {
        this.name = name;
        this.id = id;
    }
    
    public String getName() { return name; }
    public int getId() { return id; }
    
    @Override
    public String toString() {
        return name + " (ID: " + id + ")";
    }
    
    @Override
    public int compareTo(Student other) {
        // ID番号で比較
        return Integer.compare(this.id, other.id);
    }
    
    // HashSetでも使用できるようにequalsとhashCodeもオーバーライド
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return id == student.id && Objects.equals(name, student.name);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, id);
    }
}

public class CustomObjectSetExample {
    public static void main(String[] args) {
        // HashSetでのPersonオブジェクトの使用
        Set<Person> people = new HashSet<>();
        people.add(new Person("田中", 30));
        people.add(new Person("鈴木", 25));
        people.add(new Person("田中", 30));  // equals()により重複と判断される
        
        System.out.println("HashSetのサイズ: " + people.size());  // 2
        System.out.println("HashSetの内容: " + people);
        
        // TreeSetでのStudentオブジェクトの使用（Comparableインターフェースを実装）
        Set<Student> students = new TreeSet<>();
        students.add(new Student("佐藤", 1003));
        students.add(new Student("伊藤", 1001));
        students.add(new Student("渡辺", 1002));
        
        System.out.println("TreeSetの内容（ID順）:");
        for (Student student : students) {
            System.out.println(student);
        }
        
        // Comparatorを使った別の順序付け
        Set<Student> studentsByName = new TreeSet<>(new Comparator<Student>() {
            @Override
            public int compare(Student s1, Student s2) {
                return s1.getName().compareTo(s2.getName());
            }
        });
        
        studentsByName.addAll(students);  // 既存のコレクションから要素を追加
        
        System.out.println("TreeSetの内容（名前順）:");
        for (Student student : studentsByName) {
            System.out.println(student);
        }
    }
}</code>
                        
                        <div class="exercise">
                            <h5>演習 5.6: HashSetとTreeSetの活用</h5>
                            <p>以下の問題に取り組み、HashSetとTreeSetの使い方を練習しましょう：</p>
                            <ol>
                                <li>文字列の配列から重複を除いた単語リストを作成し、アルファベット順でソートするプログラムを作成してください。</li>
                                <li>HashSetとTreeSetの追加・検索操作の性能を比較するベンチマークプログラムを作成してください。</li>
                                <li>独自の図形クラス（円、三角形、四角形など）をTreeSetで管理し、面積順にソートするプログラムを作成してください。</li>
                            </ol>
                        </div>
                    </section>

                    <section id="hashmap-treemap">
                        <h3 class="section-title">5.7 HashMap, TreeMap</h3>
                        <p><span class="inline-code">HashMap</span>と<span class="inline-code">TreeMap</span>は、Javaの<span class="inline-code">Map</span>インターフェースの代表的な実装です。どちらもキーと値のペアを格納しますが、内部構造とパフォーマンス特性が異なります。</p>
                        
                        <h4>HashMapの特徴</h4>
                        <div class="note">
                            <h5>HashMapの主な特性</h5>
                            <ul>
                                <li><strong>内部構造</strong>：ハッシュテーブル（ハッシュ関数を使用）</li>
                                <li><strong>順序</strong>：キーの挿入順序を保持しない</li>
                                <li><strong>パフォーマンス</strong>：追加、削除、検索がほぼ一定時間O(1)</li>
                                <li><strong>null許容</strong>：nullキー1つとnull値複数を許容</li>
                                <li><strong>使用場面</strong>：キーによる高速なデータ検索が必要な場合</li>
                            </ul>
                        </div>
                        
                        <p>HashMapの基本的な使用例：</p>
                        <code>import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
    public static void main(String[] args) {
        // HashMapの作成
        Map<String, Integer> scores = new HashMap<>();
        
        // キーと値のペアを追加
        scores.put("Alice", 95);
        scores.put("Bob", 85);
        scores.put("Charlie", 90);
        
        // 特定のキーに対する値を取得
        int aliceScore = scores.get("Alice");  // 95
        System.out.println("Aliceのスコア: " + aliceScore);
        
        // 存在しないキーの場合はnullが返される
        Integer davidScore = scores.get("David");  // null
        System.out.println("Davidのスコア: " + davidScore);
        
        // キーの存在確認
        boolean hasKey = scores.containsKey("Bob");  // true
        System.out.println("Bobのスコアがあるか: " + hasKey);
        
        // 値の存在確認
        boolean hasValue = scores.containsValue(100);  // false
        System.out.println("100点の学生がいるか: " + hasValue);
        
        // 既存のキーの値を更新
        scores.put("Bob", 92);  // 上書き
        System.out.println("Bobの更新後スコア: " + scores.get("Bob"));  // 92
        
        // キーが存在しない場合のみ追加
        scores.putIfAbsent("Bob", 75);  // 既に存在するので無視
        scores.putIfAbsent("David", 88);  // 新規追加
        System.out.println("Davidのスコア: " + scores.get("David"));  // 88
        
        // キーと値のペアを削除
        scores.remove("Charlie");
        
        // マップのサイズ
        System.out.println("学生数: " + scores.size());  // 3
        
        // すべてのキーと値のペアを表示
        System.out.println("全スコア:");
        for (Map.Entry<String, Integer> entry : scores.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // すべてのキーを取得
        System.out.println("全学生:");
        for (String name : scores.keySet()) {
            System.out.println(name);
        }
        
        // すべての値を取得
        System.out.println("全スコア値:");
        for (Integer score : scores.values()) {
            System.out.println(score);
        }
        
        // マップをクリア
        scores.clear();
        System.out.println("クリア後のサイズ: " + scores.size());  // 0
    }
}</code>
                        
                        <h4>Java 8のMap機能拡張</h4>
                        <p>Java 8で追加された便利なMapメソッド：</p>
                        <code>// Java 8のMap拡張メソッド
Map<String, Integer> inventory = new HashMap<>();
inventory.put("リンゴ", 10);
inventory.put("バナナ", 5);

// getOrDefault - キーが存在しない場合にデフォルト値を返す
int orangeCount = inventory.getOrDefault("オレンジ", 0);  // 0
System.out.println("オレンジの数: " + orangeCount);

// putIfAbsent - キーが存在しない場合のみ追加
inventory.putIfAbsent("バナナ", 15);  // 既存の値(5)が保持される
inventory.putIfAbsent("オレンジ", 8);  // 新しい値が追加される

// merge - キー存在する場合は値を結合し、なければ追加
inventory.merge("リンゴ", 5, (oldValue, newValue) -> oldValue + newValue);  // 10 + 5 = 15
inventory.merge("ぶどう", 12, (oldValue, newValue) -> oldValue + newValue);  // 新規追加: 12

// compute - キーに対して関数を適用
inventory.compute("リンゴ", (key, value) -> value == null ? 1 : value * 2);  // 15 * 2 = 30

// computeIfPresent - キーが存在する場合のみ関数を適用
inventory.computeIfPresent("バナナ", (key, value) -> value - 2);  // 5 - 2 = 3

// computeIfAbsent - キーが存在しない場合のみ関数を適用
inventory.computeIfAbsent("いちご", key -> 10);  // 新規追加: 10

// forEach - キーと値のペアに対してアクションを実行
inventory.forEach((key, value) -> 
    System.out.println(key + ": " + value + "個"));

// replaceAll - すべての値を置き換え
inventory.replaceAll((key, value) -> value * 2);  // すべての値を2倍</code>
                        
                        <h4>TreeMapの特徴</h4>
                        <div class="note">
                            <h5>TreeMapの主な特性</h5>
                            <ul>
                                <li><strong>内部構造</strong>：赤黒木（自己平衡二分探索木）</li>
                                <li><strong>順序</strong>：キーを自然順序（Comparable）またはカスタム順序（Comparator）でソート</li>
                                <li><strong>パフォーマンス</strong>：追加、削除、検索がO(log n)</li>
                                <li><strong>null許容</strong>：Java 7以降はnullキーを許容しない</li>
                                <li><strong>使用場面</strong>：キーをソートされた順序で取得する必要がある場合</li>
                            </ul>
                        </div>
                        
                        <p>TreeMapの基本的な使用例：</p>
                        <code>import java.util.TreeMap;
import java.util.Map;
import java.util.Comparator;

public class TreeMapExample {
    public static void main(String[] args) {
        // 自然順序（キーがComparableを実装）のTreeMap
        TreeMap<String, Integer> sortedScores = new TreeMap<>();
        
        // キーと値のペアを追加
        sortedScores.put("Charlie", 90);
        sortedScores.put("Alice", 95);
        sortedScores.put("Bob", 85);
        sortedScores.put("David", 88);
        
        // ソートされた順序でエントリを表示
        System.out.println("アルファベット順のスコア:");
        for (Map.Entry<String, Integer> entry : sortedScores.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
            // Alice: 95, Bob: 85, Charlie: 90, David: 88
        }
        
        // TreeMap固有のナビゲーションメソッド
        System.out.println("最初のエントリ: " + sortedScores.firstEntry());  // Alice=95
        System.out.println("最後のエントリ: " + sortedScores.lastEntry());   // David=88
        
        // 特定のキーより小さい/大きいキーのマップを取得
        System.out.println("C以前のエントリ: " + sortedScores.headMap("C"));
        System.out.println("C以降のエントリ: " + sortedScores.tailMap("C"));
        
        // 範囲のマップを取得
        System.out.println("BからD（除く）までのエントリ: " + 
                        sortedScores.subMap("B", "D"));
        
        // フロア/シーリングエントリ（指定キー以下/以上の最大/最小のエントリ）
        System.out.println("B以下の最大のエントリ: " + sortedScores.floorEntry("B"));  // Bob=85
        System.out.println("C以上の最小のエントリ: " + sortedScores.ceilingEntry("C"));  // Charlie=90
        
        // カスタム順序のTreeMap（値でソート）
        TreeMap<String, Integer> valueSort = new TreeMap<>(new Comparator<String>() {
            @Override
            public int compare(String k1, String k2) {
                int val1 = sortedScores.get(k1);
                int val2 = sortedScores.get(k2);
                // 値が同じ場合はキーでソート
                return val1 != val2 ? Integer.compare(val1, val2) : k1.compareTo(k2);
            }
        });
        
        // 同じデータを追加
        valueSort.putAll(sortedScores);
        
        // スコア順に表示
        System.out.println("スコア順（昇順）:");
        for (Map.Entry<String, Integer> entry : valueSort.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
            // Bob: 85, David: 88, Charlie: 90, Alice: 95
        }
    }
}</code>
                        
                        <h4>HashMapとTreeMapの比較</h4>
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 300">
                                <!-- HashMap vs TreeMap Visualization -->
                                <rect x="50" y="30" width="500" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="300" y="55" text-anchor="middle" font-size="16" font-weight="bold">HashMap vs TreeMap</text>
                                
                                <rect x="50" y="90" width="240" height="190" fill="#e8f5e9" stroke="#4caf50" stroke-width="1" rx="5" />
                                <text x="170" y="110" text-anchor="middle" font-size="14" font-weight="bold">HashMap</text>
                                
                                <!-- HashMap buckets visualization simplified -->
                                <rect x="70" y="130" width="60" height="30" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="100" y="150" text-anchor="middle" font-size="12">Alice</text>
                                <rect x="130" y="130" width="30" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="145" y="150" text-anchor="middle" font-size="12">95</text>
                                
                                <rect x="70" y="170" width="60" height="30" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="100" y="190" text-anchor="middle" font-size="12">Bob</text>
                                <rect x="130" y="170" width="30" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="145" y="190" text-anchor="middle" font-size="12">85</text>
                                
                                <rect x="70" y="210" width="60" height="30" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="100" y="230" text-anchor="middle" font-size="12">Charlie</text>
                                <rect x="130" y="210" width="30" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="145" y="230" text-anchor="middle" font-size="12">90</text>
                                
                                <rect x="180" y="130" width="60" height="30" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="210" y="150" text-anchor="middle" font-size="12">David</text>
                                <rect x="240" y="130" width="30" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="255" y="150" text-anchor="middle" font-size="12">88</text>
                                
                                <rect x="310" y="90" width="240" height="190" fill="#e3f2fd" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="430" y="110" text-anchor="middle" font-size="14" font-weight="bold">TreeMap</text>
                                
                                <!-- TreeMap visualization simplified -->
                                <line x1="430" y1="130" x2="370" y2="150" stroke="#1976d2" stroke-width="1" />
                                <line x1="430" y1="130" x2="490" y2="150" stroke="#1976d2" stroke-width="1" />
                                <line x1="370" y1="170" x2="340" y2="190" stroke="#1976d2" stroke-width="1" />
                                <line x1="370" y1="170" x2="400" y2="190" stroke="#1976d2" stroke-width="1" />
                                
                                <rect x="400" y="120" width="60" height="20" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="430" y="135" text-anchor="middle" font-size="12">Bob</text>
                                <rect x="400" y="140" width="60" height="20" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="430" y="155" text-anchor="middle" font-size="12">85</text>
                                
                                <rect x="340" y="160" width="60" height="20" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="370" y="175" text-anchor="middle" font-size="12">Alice</text>
                                <rect x="340" y="180" width="60" height="20" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="370" y="195" text-anchor="middle" font-size="12">95</text>
                                
                                <rect x="460" y="160" width="60" height="20" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="490" y="175" text-anchor="middle" font-size="12">Charlie</text>
                                <rect x="460" y="180" width="60" height="20" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="490" y="195" text-anchor="middle" font-size="12">90</text>
                                
                                <rect x="310" y="180" width="60" height="20" fill="#c8e6c9" stroke="#4caf50" stroke-width="1" />
                                <text x="340" y="195" text-anchor="middle" font-size="12">David</text>
                                <rect x="310" y="200" width="60" height="20" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="340" y="215" text-anchor="middle" font-size="12">88</text>
                                
                                <rect x="50" y="300" width="500" height="40" fill="#f5f5f5" stroke="#9e9e9e" stroke-width="1" rx="5" />
                                <text x="300" y="325" text-anchor="middle" font-size="12">
                                    HashMap: 順序なし、O(1)操作、高速 | TreeMap: ソート済み、O(log n)操作、ナビゲーション機能
                                </text>
                            </svg>
                        </div>
                        
                        <table class="method-table">
                            <thead>
                                <tr>
                                    <th>特性</th>
                                    <th>HashMap</th>
                                    <th>TreeMap</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>内部実装</td>
                                    <td>ハッシュテーブル</td>
                                    <td>赤黒木（自己平衡二分探索木）</td>
                                </tr>
                                <tr>
                                    <td>キーの順序</td>
                                    <td>順序なし（挿入順序を保持しない）</td>
                                    <td>ソート済み（自然順序またはカスタム順序）</td>
                                </tr>
                                <tr>
                                    <td>追加/削除/検索</td>
                                    <td>O(1)</td>
                                    <td>O(log n)</td>
                                </tr>
                                <tr>
                                    <td>nullキー</td>
                                    <td>1つのnullキーを許容</td>
                                    <td>許容しない（Java 7以降）</td>
                                </tr>
                                <tr>
                                    <td>必要な実装</td>
                                    <td>キーのhashCode()とequals()メソッド</td>
                                    <td>キーのcompareTo()またはComparator</td>
                                </tr>
                                <tr>
                                    <td>特別な機能</td>
                                    <td>高速なルックアップ</td>
                                    <td>範囲検索、ナビゲーション（firstKey, lastKey, floorKey, ceilingKey）</td>
                                </tr>
                                <tr>
                                    <td>推奨される使用場面</td>
                                    <td>高速なキーベースのルックアップ</td>
                                    <td>キーをソートされた順序で取得する必要がある場合</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h4>LinkedHashMap - 挿入順序を保持するMap</h4>
                        <p>HashMapとTreeMapの中間的な特性を持つ<span class="inline-code">LinkedHashMap</span>も便利です：</p>
                        <code>import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapExample {
    public static void main(String[] args) {
        // LinkedHashMapは挿入順序を保持
        Map<String, Integer> orderedMap = new LinkedHashMap<>();
        
        orderedMap.put("One", 1);
        orderedMap.put("Two", 2);
        orderedMap.put("Three", 3);
        orderedMap.put("Four", 4);
        
        // 挿入順序で表示
        for (Map.Entry<String, Integer> entry : orderedMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
            // One: 1, Two: 2, Three: 3, Four: 4
        }
        
        // アクセス順序を保持するLinkedHashMap（LRUキャッシュ用）
        Map<String, Integer> accessOrderMap = new LinkedHashMap<>(16, 0.75f, true);
        accessOrderMap.put("A", 1);
        accessOrderMap.put("B", 2);
        accessOrderMap.put("C", 3);
        
        // Bにアクセスすると、順序が変わる
        accessOrderMap.get("B");
        
        // アクセス順序で表示（最後にアクセスされたものが最後に表示）
        System.out.println("アクセス順序:");
        for (Map.Entry<String, Integer> entry : accessOrderMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
            // A: 1, C: 3, B: 2
        }
    }
}</code>
                        
                        <div class="note">
                            <h5>Map実装の選択ガイドライン</h5>
                            <p><strong>HashMapを選ぶべき場合：</strong></p>
                            <ul>
                                <li>キーの順序が重要でない場合</li>
                                <li>高速なルックアップが必要な場合</li>
                                <li>大量のデータを扱う場合</li>
                            </ul>
                            
                            <h5>TreeMapを選ぶべき場合：</h5>
                            <ul>
                                <li>キーを常にソートされた状態で保持したい場合</li>
                                <li>範囲クエリを実行する必要がある場合（subMap, headMap, tailMap）</li>
                                <li>最小/最大キーに頻繁にアクセスする場合</li>
                            </ul>
                            
                            <h5>LinkedHashMapを選ぶべき場合：</h5>
                            <ul>
                                <li>キーの挿入順序を保持したい場合</li>
                                <li>予測可能な反復順序が必要な場合</li>
                                <li>LRU（Least Recently Used）キャッシュを実装する場合（アクセス順序モード）</li>
                            </ul>
                        </div>
                        
                        <div class="exercise">
                            <h5>演習 5.7: HashMapとTreeMapの活用</h5>
                            <p>以下の問題に取り組み、HashMapとTreeMapの使い方を練習しましょう：</p>
                            <ol>
                                <li>テキストファイルから単語を読み込み、各単語の出現回数をカウントするプログラムを作成してください。結果は出現頻度の高い順にソートして表示してください。</li>
                                <li>学生の名前と複数の科目のスコアを管理するプログラムを作成してください。TreeMapを使用して学生を名前順にソートし、各学生の平均点を計算してください。</li>
                                <li>HashMapとTreeMapのlookup操作の性能を比較するベンチマークプログラムを作成してください。</li>
                            </ol>
                        </div>
                    </section>

                    <section id="chapter5-quiz">
                        <h3 class="section-title">5.8 理解度確認テスト</h3>
                        <div class="quiz-container">
                            <h4>第5章の理解度チェック</h4>
                            <p>以下の問題に答えて、第5章の内容の理解度を確認しましょう。</p>
                            
                            <div class="quiz-question">
                                <p><strong>問題1:</strong> 次のコードの実行結果を選んでください。</p>
                                <pre class="bg-light p-2 rounded">
String s1 = "Java";
String s2 = "Java";
String s3 = new String("Java");

System.out.println(s1 == s2);
System.out.println(s1 == s3);
System.out.println(s1.equals(s3));</pre>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1a" value="a">
                                    <label class="form-check-label" for="q1a">
                                        true, true, true
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1b" value="b">
                                    <label class="form-check-label" for="q1b">
                                        true, false, true
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1c" value="c">
                                    <label class="form-check-label" for="q1c">
                                        false, false, true
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1d" value="d">
                                    <label class="form-check-label" for="q1d">
                                        true, false, false
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題2:</strong> 次のコードで得られる結果を選んでください。</p>
                                <pre class="bg-light p-2 rounded">
String str = "Hello, World!";
String result = str.substring(7, 12);</pre>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2a" value="a">
                                    <label class="form-check-label" for="q2a">
                                        World
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2b" value="b">
                                    <label class="form-check-label" for="q2b">
                                        World!
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2c" value="c">
                                    <label class="form-check-label" for="q2c">
                                        Hello
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2d" value="d">
                                    <label class="form-check-label" for="q2d">
                                        , Worl
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題3:</strong> 100以下のランダムな整数を生成するための正しいコードはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3a" value="a">
                                    <label class="form-check-label" for="q3a">
                                        <code>int num = Math.random() * 100;</code>
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3b" value="b">
                                    <label class="form-check-label" for="q3b">
                                        <code>int num = (int)(Math.random() * 100);</code>
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3c" value="c">
                                    <label class="form-check-label" for="q3c">
                                        <code>int num = new Random().nextInt(100);</code>
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3d" value="d">
                                    <label class="form-check-label" for="q3d">
                                        <code>int num = Random.nextInt(100);</code>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題4:</strong> 現在の日付から1ヶ月後の日付を取得するための正しいコードはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4a" value="a">
                                    <label class="form-check-label" for="q4a">
                                        <code>LocalDate next = LocalDate.now().add(1, ChronoUnit.MONTHS);</code>
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4b" value="b">
                                    <label class="form-check-label" for="q4b">
                                        <code>LocalDate next = LocalDate.now().plusMonths(1);</code>
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4c" value="c">
                                        <label class="form-check-label" for="q4c">
                                        <code>LocalDate next = LocalDate.now() + 1;</code>
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4d" value="d">
                                    <label class="form-check-label" for="q4d">
                                        <code>LocalDate next = LocalDate.now().addMonths(1);</code>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題5:</strong> ArrayListとLinkedListの違いとして正しいのはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5a" value="a">
                                    <label class="form-check-label" for="q5a">
                                        ArrayListはインデックスによるアクセスが遅く、LinkedListは速い
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5b" value="b">
                                    <label class="form-check-label" for="q5b">
                                        ArrayListは先頭への要素追加が速く、LinkedListは遅い
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5c" value="c">
                                    <label class="form-check-label" for="q5c">
                                        ArrayListはランダムアクセスが速く、LinkedListは中間への挿入/削除が速い
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5d" value="d">
                                    <label class="form-check-label" for="q5d">
                                        ArrayListはスレッドセーフで、LinkedListはスレッドセーフでない
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題6:</strong> HashSetに関する記述で正しいものはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q6" id="q6a" value="a">
                                    <label class="form-check-label" for="q6a">
                                        要素の挿入順序を保持する
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q6" id="q6b" value="b">
                                    <label class="form-check-label" for="q6b">
                                        要素を自動的にソートする
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q6" id="q6c" value="c">
                                    <label class="form-check-label" for="q6c">
                                        重複要素を許可しない
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q6" id="q6d" value="d">
                                    <label class="form-check-label" for="q6d">
                                        インデックスによるアクセスをサポートする
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題7:</strong> TreeMapの特徴として正しいものはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q7" id="q7a" value="a">
                                    <label class="form-check-label" for="q7a">
                                        キーによるルックアップがO(1)の時間複雑度を持つ
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q7" id="q7b" value="b">
                                    <label class="form-check-label" for="q7b">
                                        キーが自然順序またはComparatorでソートされる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q7" id="q7c" value="c">
                                    <label class="form-check-label" for="q7c">
                                        キーの挿入順序を保持する
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q7" id="q7d" value="d">
                                    <label class="form-check-label" for="q7d">
                                        複数のnullキーを許容する
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題8:</strong> 次のコードの出力として正しいものを選んでください。</p>
                                <pre class="bg-light p-2 rounded">
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World").insert(5, ',');
System.out.println(sb.toString());</pre>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q8" id="q8a" value="a">
                                    <label class="form-check-label" for="q8a">
                                        Hello, World
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q8" id="q8b" value="b">
                                    <label class="form-check-label" for="q8b">
                                        Hello World,
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q8" id="q8c" value="c">
                                    <label class="form-check-label" for="q8c">
                                        Hello, World
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q8" id="q8d" value="d">
                                    <label class="form-check-label" for="q8d">
                                        ,Hello World
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題9:</strong> Java 8以降の日付時間APIについて正しい記述はどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q9" id="q9a" value="a">
                                    <label class="form-check-label" for="q9a">
                                        java.util.DateとCalendarクラスを拡張している
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q9" id="q9b" value="b">
                                    <label class="form-check-label" for="q9b">
                                        java.time.LocalDateクラスはミュータブル（変更可能）である
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q9" id="q9c" value="c">
                                    <label class="form-check-label" for="q9c">
                                        java.time.LocalTimeは日付情報も扱える
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q9" id="q9d" value="d">
                                    <label class="form-check-label" for="q9d">
                                        イミュータブルなクラスで構成されており、スレッドセーフである
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題10:</strong> 次のうち、コレクションフレームワークに関する正しい記述はどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q10" id="q10a" value="a">
                                    <label class="form-check-label" for="q10a">
                                        Mapインターフェースはコレクションインターフェースを拡張している
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q10" id="q10b" value="b">
                                    <label class="form-check-label" for="q10b">
                                        ListインターフェースはSetインターフェースを拡張している
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q10" id="q10c" value="c">
                                    <label class="form-check-label" for="q10c">
                                        LinkedListはListインターフェースのみを実装している
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q10" id="q10d" value="d">
                                    <label class="form-check-label" for="q10d">
                                        LinkedListはListとQueueインターフェースの両方を実装している
                                    </label>
                                </div>
                            </div>
                            
                            <button class="btn btn-primary mt-3" id="checkAnswers">回答を確認</button>
                            <div id="quizResults" class="mt-3 d-none">
                                <div class="alert alert-success">
                                    <h5>正解:</h5>
                                    <ol>
                                        <li>b) true, false, true</li>
                                        <li>a) World</li>
                                        <li>c) int num = new Random().nextInt(100);</li>
                                        <li>b) LocalDate next = LocalDate.now().plusMonths(1);</li>
                                        <li>c) ArrayListはランダムアクセスが速く、LinkedListは中間への挿入/削除が速い</li>
                                        <li>c) 重複要素を許可しない</li>
                                        <li>b) キーが自然順序またはComparatorでソートされる</li>
                                        <li>a) Hello, World</li>
                                        <li>d) イミュータブルなクラスで構成されており、スレッドセーフである</li>
                                        <li>d) LinkedListはListとQueueインターフェースの両方を実装している</li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </section>
                </section>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS and Popper.js -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 理解度テストの回答確認ボタンの処理
        document.getElementById('checkAnswers').addEventListener('click', function() {
            document.getElementById('quizResults').classList.remove('d-none');
        });
    </script>
</body>
</html>