<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java学習教材 - 第4章：オブジェクト指向プログラミング応用</title>
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        .navbar {
            background-color: #1565c0;
        }
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        .chapter-title {
            color: #1565c0;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #1565c0;
            padding-bottom: 0.5rem;
        }
        .section-title {
            color: #1976d2;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        code {
            display: block;
            background-color: #f5f5f5;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            white-space: pre;
            overflow-x: auto;
        }
        .quiz-container {
            background-color: #e3f2fd;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }
        .quiz-question {
            font-weight: 500;
            margin-bottom: 1rem;
        }
        .diagram {
            max-width: 100%;
            height: auto;
            margin: 1.5rem 0;
            text-align: center;
        }
        .exercise {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        .note {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        #table-of-contents .list-group-item {
            border: none;
            padding: 0.5rem 1rem;
        }
        #table-of-contents .list-group-item-action {
            color: #1976d2;
        }
        /* 選択された目次項目のスタイル */
        #table-of-contents .list-group-item-action.active,
        .list-group-item.active {
            color: white !important; /* テキストを白色にして青い背景に対してコントラストをつける */
            background-color: #1976d2;
            border-color: #1976d2;
        }
        .section-nav {
            padding-left: 1rem;
        }
        .inline-code {
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
            color: #d32f2f;
        }
    </style>
</head>
<body data-bs-spy="scroll" data-bs-target="#tableOfContents">
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="#">Java学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="#introduction">はじめに</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#chapter4">第4章: OOP応用</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container my-4">
        <div class="row">
            <!-- Sidebar - Table of Contents -->
            <div class="col-lg-3">
                <div class="sidebar">
                    <div class="card">
                        <div class="card-header bg-primary text-white">
                            <h5 class="mb-0">目次</h5>
                        </div>
                        <div id="table-of-contents" class="list-group list-group-flush">
                            <a href="#introduction" class="list-group-item list-group-item-action">はじめに</a>
                            <a href="#chapter4" class="list-group-item list-group-item-action">第4章: オブジェクト指向プログラミング応用</a>
                            <div class="section-nav">
                                <a href="#inheritance" class="list-group-item list-group-item-action">4.1 継承の概念と実装</a>
                                <a href="#method-override" class="list-group-item list-group-item-action">4.2 メソッドのオーバーライド</a>
                                <a href="#super-keyword" class="list-group-item list-group-item-action">4.3 superキーワード</a>
                                <a href="#polymorphism" class="list-group-item list-group-item-action">4.4 ポリモーフィズム</a>
                                <a href="#abstract-class" class="list-group-item list-group-item-action">4.5 抽象クラス</a>
                                <a href="#interface" class="list-group-item list-group-item-action">4.6 インターフェース</a>
                                <a href="#package" class="list-group-item list-group-item-action">4.7 パッケージ</a>
                                <a href="#chapter4-quiz" class="list-group-item list-group-item-action">4.8 理解度確認テスト</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Main Content -->
            <div class="col-lg-9">
                <section id="introduction">
                    <h1 class="display-5 mb-4">Java学習教材 - オブジェクト指向プログラミング応用</h1>
                    <p class="lead">この章では、Javaのオブジェクト指向プログラミングの応用概念について学習していきます。継承やポリモーフィズムなどの概念を理解し、より複雑で拡張性の高いソフトウェアを設計できるようになりましょう。</p>
                    <img src="img/java_04.png" class="img-fluid mt-3 mb-4" style="max-width: 50%; height: auto;">
                    <div class="note">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>クラスの継承とその実装方法</li>
                            <li>メソッドのオーバーライドと多態性</li>
                            <li>抽象クラスとインターフェースの違いと使い分け</li>
                            <li>パッケージによるコードの整理</li>
                        </ul>
                    </div>
                </section>

                <section id="chapter4">
                    <h2 class="chapter-title">第4章：オブジェクト指向プログラミング応用</h2>
                    <p>オブジェクト指向プログラミングの基本概念を理解したところで、より高度なOOPの概念を学んでいきましょう。これらの概念を理解することで、柔軟で再利用可能なコードを書くことができるようになります。</p>

                    <section id="inheritance">
                        <h3 class="section-title">4.1 継承の概念と実装</h3>
                        <p>継承は、既存のクラス（親クラスまたはスーパークラス）の特性や機能を新しいクラス（子クラスまたはサブクラス）に引き継ぐことができるオブジェクト指向プログラミングの重要な概念です。</p>
                        
                        <h4>継承の基本概念</h4>
                        <p>継承を使用することで、次のようなメリットがあります：</p>
                        <ul>
                            <li>コードの再利用性の向上</li>
                            <li>階層的なクラス設計が可能</li>
                            <li>既存のコードを拡張しやすくなる</li>
                        </ul>
                        
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 280">
                                <!-- 継承の図 -->
                                <rect x="175" y="20" width="150" height="80" fill="#bbdefb" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="250" y="45" text-anchor="middle" font-size="16" font-weight="bold">動物 (Animal)</text>
                                <text x="250" y="70" text-anchor="middle" font-size="14">- 名前</text>
                                <text x="250" y="90" text-anchor="middle" font-size="14">+ 鳴く()</text>
                                
                                <!-- 継承線 -->
                                <line x1="250" y1="100" x2="250" y2="140" stroke="#1976d2" stroke-width="2" />
                                <polygon points="250,140 245,130 255,130" fill="#1976d2" />
                                
                                <!-- 犬クラス -->
                                <rect x="50" y="140" width="170" height="100" fill="#c8e6c9" stroke="#388e3c" stroke-width="2" rx="5" />
                                <text x="135" y="165" text-anchor="middle" font-size="16" font-weight="bold">犬 (Dog)</text>
                                <text x="135" y="190" text-anchor="middle" font-size="14">- 犬種</text>
                                <text x="135" y="210" text-anchor="middle" font-size="14">+ 鳴く() [オーバーライド]</text>
                                <text x="135" y="230" text-anchor="middle" font-size="14">+ 散歩する()</text>
                                
                                <!-- 継承線 -->
                                <line x1="250" y1="100" x2="250" y2="140" stroke="#1976d2" stroke-width="2" />
                                
                                <!-- 猫クラス -->
                                <rect x="300" y="140" width="170" height="100" fill="#c8e6c9" stroke="#388e3c" stroke-width="2" rx="5" />
                                <text x="385" y="165" text-anchor="middle" font-size="16" font-weight="bold">猫 (Cat)</text>
                                <text x="385" y="190" text-anchor="middle" font-size="14">- 猫種</text>
                                <text x="385" y="210" text-anchor="middle" font-size="14">+ 鳴く() [オーバーライド]</text>
                                <text x="385" y="230" text-anchor="middle" font-size="14">+ 毛づくろいする()</text>
                            </svg>
                            <p class="text-center">図4.1: 継承の概念図 - 動物クラスを継承した犬クラスと猫クラス</p>
                        </div>
                        
                        <h4>Javaでの継承の実装</h4>
                        <p>Javaでは、<span class="inline-code">extends</span> キーワードを使用してクラスの継承を実装します。</p>
                        
                        <code>// 親クラス（スーパークラス）
public class Animal {
    private String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
    public void makeSound() {
        System.out.println("動物が鳴いています");
    }
}

// 子クラス（サブクラス）
public class Dog extends Animal {
    private String breed;
    
    public Dog(String name, String breed) {
        super(name);  // 親クラスのコンストラクタを呼び出す
        this.breed = breed;
    }
    
    public String getBreed() {
        return breed;
    }
    
    @Override
    public void makeSound() {
        System.out.println("ワンワン！");
    }
    
    public void walk() {
        System.out.println(getName() + "が散歩しています");
    }
}</code>
                        
                        <div class="note">
                            <h5>Javaの継承に関する重要な点</h5>
                            <ul>
                                <li>Javaでは単一継承のみサポートされています（一つのクラスは一つの親クラスしか持てません）</li>
                                <li>すべてのクラスは暗黙的に<span class="inline-code">Object</span>クラスを継承しています</li>
                                <li><span class="inline-code">private</span>メンバは継承されますが、子クラスから直接アクセスはできません</li>
                                <li><span class="inline-code">final</span>クラスは継承できません</li>
                            </ul>
                        </div>
                        
                        <div class="exercise">
                            <h5>練習問題 4.1: 継承の実装</h5>
                            <p>以下の要件を満たす継承関係のクラスを実装してください：</p>
                            <ol>
                                <li><span class="inline-code">Shape</span>クラス（親クラス）に面積を計算する<span class="inline-code">calculateArea()</span>メソッドを作成</li>
                                <li><span class="inline-code">Rectangle</span>クラス（子クラス）を作成し、幅と高さをフィールドとして持たせる</li>
                                <li><span class="inline-code">calculateArea()</span>メソッドをオーバーライドして長方形の面積を計算できるようにする</li>
                                <li><span class="inline-code">Circle</span>クラス（子クラス）を作成し、半径をフィールドとして持たせる</li>
                                <li><span class="inline-code">calculateArea()</span>メソッドをオーバーライドして円の面積を計算できるようにする</li>
                            </ol>
                        </div>
                    </section>

                    <section id="method-override">
                        <h3 class="section-title">4.2 メソッドのオーバーライド</h3>
                        <p>メソッドのオーバーライドとは、親クラスで定義されたメソッドを子クラスで再定義することです。これにより、子クラスは親クラスのメソッドを独自の実装で置き換えることができます。</p>
                        
                        <h4>オーバーライドの基本ルール</h4>
                        <ul>
                            <li>メソッド名、引数リスト、戻り値の型が親クラスのメソッドと同じでなければならない</li>
                            <li>アクセス修飾子は親クラスのメソッドと同じか、より緩い（より広いアクセス範囲を持つ）ものでなければならない</li>
                            <li>子クラスのメソッドは、親クラスのメソッドよりも制限の強い例外をスローしてはならない</li>
                            <li><span class="inline-code">@Override</span>アノテーションを使用することが推奨される（オーバーライドの意図を明示し、コンパイル時のチェックを強化）</li>
                        </ul>
                        
                        <h4>オーバーライドの例</h4>
                        <code>public class Vehicle {
    public void start() {
        System.out.println("車両のエンジンを始動します");
    }
    
    public void stop() {
        System.out.println("車両を停止します");
    }
}

public class Car extends Vehicle {
    @Override
    public void start() {
        System.out.println("キーを回してエンジンを始動します");
    }
    
    // stopメソッドはオーバーライドされていないため、親クラスの実装が使用される
}

public class ElectricCar extends Vehicle {
    @Override
    public void start() {
        System.out.println("静かに電気モーターを始動します");
    }
    
    @Override
    public void stop() {
        System.out.println("電気モーターを停止して回生ブレーキを作動させます");
    }
}</code>
                        
                        <div class="note">
                            <h5>オーバーライドとオーバーロードの違い</h5>
                            <p><strong>オーバーライド</strong>は継承関係にあるクラス間で同じシグネチャのメソッドを再定義することですが、<strong>オーバーロード</strong>は同じクラス内で同じ名前でも異なるパラメータリストを持つメソッドを定義することです。</p>
                            <p>例（オーバーロード）:</p>
                            <pre>
public void display(int num) { ... }
public void display(String text) { ... }
public void display(int num, String text) { ... }</pre>
                        </div>
                        
                        <h4>オーバーライドできないメソッド</h4>
                        <ul>
                            <li><span class="inline-code">final</span>メソッド: 変更できないよう明示的に宣言されたメソッド</li>
                            <li><span class="inline-code">static</span>メソッド: クラスに属するメソッド（オーバーライドではなく「隠蔽」と呼ばれる）</li>
                            <li><span class="inline-code">private</span>メソッド: 子クラスからアクセスできないため、オーバーライドできない</li>
                        </ul>
                        
                        <div class="exercise">
                            <h5>練習問題 4.2: メソッドのオーバーライド</h5>
                            <p>以下のクラス設計に基づいて、適切なオーバーライドを行ってください：</p>
                            <ol>
                                <li><span class="inline-code">Employee</span>クラス（親クラス）に<span class="inline-code">calculateSalary()</span>と<span class="inline-code">getDetails()</span>メソッドを作成</li>
                                <li><span class="inline-code">Manager</span>クラス（子クラス）を作成し、追加のボーナスフィールドを持たせる</li>
                                <li>両方のメソッドをオーバーライドして、マネージャーの給与計算（基本給とボーナスの合計）と詳細情報を取得できるようにする</li>
                                <li><span class="inline-code">Programmer</span>クラス（子クラス）を作成し、追加の時間外労働時間フィールドを持たせる</li>
                                <li>両方のメソッドをオーバーライドして、プログラマーの給与計算（基本給と時間外労働の報酬）と詳細情報を取得できるようにする</li>
                            </ol>
                        </div>
                    </section>

                    <section id="super-keyword">
                        <h3 class="section-title">4.3 superキーワード</h3>
                        <p><span class="inline-code">super</span>キーワードは、子クラスから親クラスのメンバ（フィールドやメソッド）にアクセスするために使用されます。これは特に親クラスのメソッドをオーバーライドした場合や、親クラスのコンストラクタを呼び出す場合に重要です。</p>
                        
                        <h4>superキーワードの用途</h4>
                        <ol>
                            <li><strong>親クラスのコンストラクタの呼び出し</strong>: <span class="inline-code">super()</span>または<span class="inline-code">super(パラメータ)</span></li>
                            <li><strong>親クラスのメソッドの呼び出し</strong>: <span class="inline-code">super.メソッド名()</span></li>
                            <li><strong>親クラスのフィールドへのアクセス</strong>: <span class="inline-code">super.フィールド名</span></li>
                        </ol>
                        
                        <h4>superを使ったコンストラクタの呼び出し</h4>
                        <code>public class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // ゲッターとセッター
}

public class Student extends Person {
    private String studentId;
    private String major;
    
    public Student(String name, int age, String studentId, String major) {
        super(name, age);  // 親クラスのコンストラクタを呼び出す
        this.studentId = studentId;
        this.major = major;
    }
    
    // ゲッターとセッター
}</code>
                        
                        <div class="note">
                            <h5>superキーワードに関する重要なポイント</h5>
                            <ul>
                                <li>コンストラクタの最初のステートメントとして<span class="inline-code">super()</span>を呼び出す必要がある</li>
                                <li>明示的に<span class="inline-code">super()</span>を呼び出さない場合、コンパイラは自動的に親クラスのデフォルトコンストラクタ（引数なし）の呼び出しを挿入する</li>
                                <li>親クラスにデフォルトコンストラクタがない場合、子クラスは明示的に親クラスの適切なコンストラクタを呼び出す必要がある</li>
                            </ul>
                        </div>
                        
                        <h4>superを使ったメソッドの呼び出し</h4>
                        <p>オーバーライドしたメソッド内で親クラスの同名メソッドを呼び出す場合にも<span class="inline-code">super</span>キーワードを使用します。</p>
                        <code>public class Animal {
    public void eat() {
        System.out.println("動物が食事をしています");
    }
}

public class Cat extends Animal {
    @Override
    public void eat() {
        super.eat();  // 親クラスのeatメソッドを呼び出す
        System.out.println("猫はおいしそうに魚を食べています");
    }
}</code>
                        
                        <div class="exercise">
                            <h5>練習問題 4.3: superキーワードの活用</h5>
                            <p>以下の要件を満たすクラス設計を実装してください：</p>
                            <ol>
                                <li><span class="inline-code">Product</span>クラス（親クラス）に名前、価格、在庫数のフィールドとコンストラクタを作成</li>
                                <li><span class="inline-code">displayInfo()</span>メソッドを作成し、商品の基本情報を表示する</li>
                                <li><span class="inline-code">DiscountedProduct</span>クラス（子クラス）を作成し、通常の<span class="inline-code">Product</span>クラスに割引率のフィールドを追加</li>
                                <li><span class="inline-code">super</span>キーワードを使用して親クラスのコンストラクタを呼び出す</li>
                                <li><span class="inline-code">displayInfo()</span>をオーバーライドし、<span class="inline-code">super.displayInfo()</span>を呼び出した後に割引後の価格も表示するようにする</li>
                            </ol>
                        </div>
                    </section>

                    <section id="polymorphism">
                        <h3 class="section-title">4.4 ポリモーフィズム</h3>
                        <p>ポリモーフィズム（多態性）とは、同じインターフェースを使って異なる型のオブジェクトを操作できる能力を指します。Javaでは主に継承とインターフェースを通じてポリモーフィズムを実現します。</p>
                        
                        <h4>ポリモーフィズムの種類</h4>
                        <ol>
                            <li><strong>コンパイル時ポリモーフィズム（静的バインディング）</strong>: メソッドのオーバーロードなど</li>
                            <li><strong>実行時ポリモーフィズム（動的バインディング）</strong>: メソッドのオーバーライドと親クラスの参照変数での子クラスオブジェクトの参照</li>
                        </ol>
                        
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 340">
                                <!-- ポリモーフィズムの図 -->
                                <rect x="225" y="20" width="150" height="80" fill="#bbdefb" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="300" y="50" text-anchor="middle" font-size="16" font-weight="bold">形状 (Shape)</text>
                                <text x="300" y="75" text-anchor="middle" font-size="14">+ 描画()</text>
                                
                                <!-- 継承線 -->
                                <line x1="300" y1="100" x2="150" y2="150" stroke="#1976d2" stroke-width="2" />
                                <line x1="300" y1="100" x2="300" y2="150" stroke="#1976d2" stroke-width="2" />
                                <line x1="300" y1="100" x2="450" y2="150" stroke="#1976d2" stroke-width="2" />
                                
                                <!-- 円クラス -->
                                <rect x="75" y="150" width="150" height="80" fill="#c8e6c9" stroke="#388e3c" stroke-width="2" rx="5" />
                                <text x="150" y="180" text-anchor="middle" font-size="16" font-weight="bold">円 (Circle)</text>
                                <text x="150" y="205" text-anchor="middle" font-size="12">+ 描画() [オーバーライド]</text>
                                
                                <!-- 長方形クラス -->
                                <rect x="225" y="150" width="150" height="80" fill="#c8e6c9" stroke="#388e3c" stroke-width="2" rx="5" />
                                <text x="300" y="180" text-anchor="middle" font-size="16" font-weight="bold">長方形 (Rectangle)</text>
                                <text x="300" y="205" text-anchor="middle" font-size="12">+ 描画() [オーバーライド]</text>
                                
                                <!-- 三角形クラス -->
                                <rect x="375" y="150" width="150" height="80" fill="#c8e6c9" stroke="#388e3c" stroke-width="2" rx="5" />
                                <text x="450" y="180" text-anchor="middle" font-size="16" font-weight="bold">三角形 (Triangle)</text>
                                <text x="450" y="205" text-anchor="middle" font-size="12">+ 描画() [オーバーライド]</text>
                                
                                <!-- コード例 -->
                                <rect x="100" y="250" width="400" height="60" fill="#f5f5f5" stroke="#9e9e9e" stroke-width="1" rx="5" />
                                <text x="300" y="275" text-anchor="middle" font-size="14">Shape shape = new Circle(); // ポリモーフィズム</text>
                                <text x="300" y="295" text-anchor="middle" font-size="14">shape.draw(); // 実行時に Circle の描画メソッドが呼ばれる</text>
                            </svg>
                            <p class="text-center">図4.2: ポリモーフィズムの概念図 - 異なる形状クラスが同じインターフェースを実装</p>
                        </div>
                        
                        <h4>実行時ポリモーフィズムの例</h4>
                        <code>// 親クラス
public class Shape {
    public void draw() {
        System.out.println("形を描画します");
    }
}

// 子クラス1
public class Circle extends Shape {
    @Override
    public void draw() {
        System.out.println("円を描画します");
    }
}

// 子クラス2
public class Rectangle extends Shape {
    @Override
    public void draw() {
        System.out.println("長方形を描画します");
    }
}

// ポリモーフィズムの使用例
public class DrawingApp {
    public static void main(String[] args) {
        // 親クラスの型で子クラスのオブジェクトを参照
        Shape shape1 = new Circle();
        Shape shape2 = new Rectangle();
        
        // 同じメソッド呼び出しでも、実際のオブジェクトの型に応じた挙動を示す
        shape1.draw();  // 円を描画します
        shape2.draw();  // 長方形を描画します
        
        // ポリモーフィズムを活用した配列
        Shape[] shapes = new Shape[3];
        shapes[0] = new Circle();
        shapes[1] = new Rectangle();
        shapes[2] = new Circle();
        
        // すべての形状を描画
        for (Shape shape : shapes) {
            shape.draw();  // 各オブジェクトのdrawメソッドが呼ばれる
        }
    }
}</code>
                        
                        <div class="note">
                            <h5>ポリモーフィズムのメリット</h5>
                            <ul>
                                <li><strong>コードの再利用性</strong>: 同じコードで異なる型のオブジェクトを処理できる</li>
                                <li><strong>メンテナンス性の向上</strong>: 新しい子クラスを追加しても既存のコードを変更する必要がない</li>
                                <li><strong>柔軟な設計</strong>: クラス間の結合度を下げ、より拡張しやすいシステムを構築できる</li>
                                <li><strong>実行時の動的な振る舞い</strong>: プログラムの実行時に適切なメソッドが選択される</li>
                            </ul>
                        </div>
                        
                        <h4>型キャスト</h4>
                        <p>ポリモーフィズムを使用する際、時には親クラス型の参照変数から子クラス特有のメソッドやフィールドにアクセスするために型キャストが必要になることがあります。</p>
                        <code>Shape shape = new Circle();
shape.draw();  // Circleのdrawメソッドが呼ばれる

// 子クラス特有のメソッドを呼び出す場合は型キャストが必要
// Circle circleObj = shape;  // コンパイルエラー
Circle circleObj = (Circle) shape;  // ダウンキャスト
circleObj.drawRadius();  // Circleクラス特有のメソッド

// 安全なキャスト
if (shape instanceof Circle) {
    Circle c = (Circle) shape;
    c.drawRadius();
}</code>
                        
                        <div class="exercise">
                            <h5>練習問題 4.4: ポリモーフィズムの実装</h5>
                            <p>以下の要件を満たすアプリケーションを実装してください：</p>
                            <ol>
                                <li><span class="inline-code">Vehicle</span>クラス（親クラス）に<span class="inline-code">startEngine()</span>と<span class="inline-code">stopEngine()</span>メソッドを作成</li>
                                <li>少なくとも3つの異なる子クラス（<span class="inline-code">Car</span>、<span class="inline-code">Motorcycle</span>、<span class="inline-code">Truck</span>など）を作成し、それぞれでエンジン始動・停止メソッドをオーバーライド</li>
                                <li>各子クラスに特有のメソッドを追加（<span class="inline-code">Car</span>には<span class="inline-code">honk()</span>など）</li>
                                <li><span class="inline-code">VehicleTest</span>クラスのmainメソッドで、異なる車両オブジェクトを<span class="inline-code">Vehicle</span>型の配列に格納</li>
                                <li>配列内のすべての車両のエンジンを始動し、その後停止するコードを実装</li>
                                <li><span class="inline-code">instanceof</span>を使用して特定の車両タイプを識別し、その特有のメソッドを呼び出す処理を追加</li>
                            </ol>
                        </div>
                    </section>

                    <section id="abstract-class">
                        <h3 class="section-title">4.5 抽象クラス</h3>
                        <p>抽象クラスは、直接インスタンス化できないクラスで、抽象メソッド（実装のないメソッド）を持つことができます。抽象クラスは主に共通の振る舞いを定義し、子クラスに特定の実装を強制するために使用されます。</p>
                        
                        <h4>抽象クラスの特徴</h4>
                        <ul>
                            <li><span class="inline-code">abstract</span>キーワードを使用して宣言される</li>
                            <li>抽象メソッド（実装なし）と具象メソッド（実装あり）の両方を持つことができる</li>
                            <li>抽象クラスはインスタンス化できない（<span class="inline-code">new</span>演算子で直接オブジェクトを作成できない）</li>
                            <li>抽象クラスを継承する子クラスは、すべての抽象メソッドを実装するか、自身も抽象クラスとして宣言する必要がある</li>
                            <li>コンストラクタ、フィールド、静的メソッドを持つことができる</li>
                        </ul>
                        
                        <h4>抽象クラスの例</h4>
                        <code>// 抽象クラス
public abstract class Database {
    // フィールド
    protected String connectionString;
    protected boolean isConnected;
    
    // コンストラクタ
    public Database(String connectionString) {
        this.connectionString = connectionString;
        this.isConnected = false;
    }
    
    // 抽象メソッド（実装なし）
    public abstract void connect();
    public abstract void disconnect();
    public abstract ResultSet executeQuery(String query);
    
    // 具象メソッド（実装あり）
    public boolean isConnected() {
        return isConnected;
    }
    
    public void printConnectionInfo() {
        System.out.println("接続文字列: " + connectionString);
        System.out.println("接続状態: " + (isConnected ? "接続済み" : "未接続"));
    }
}

// 抽象クラスを継承した具象クラス
public class MySQLDatabase extends Database {
    public MySQLDatabase(String connectionString) {
        super(connectionString);
    }
    
    @Override
    public void connect() {
        // MySQLデータベースへの接続実装
        System.out.println("MySQLデータベースに接続しています...");
        // 接続処理
        isConnected = true;
    }
    
    @Override
    public void disconnect() {
        // MySQLデータベースからの切断実装
        System.out.println("MySQLデータベースとの接続を切断しています...");
        // 切断処理
        isConnected = false;
    }
    
    @Override
    public ResultSet executeQuery(String query) {
        // MySQLでクエリを実行する実装
        System.out.println("MySQLデータベースでクエリを実行: " + query);
        // クエリ実行処理
        return null;  // 実際はResultSetを返す
    }
}</code>
                        
                        <div class="note">
                            <h5>抽象クラスを使うべき状況</h5>
                            <ul>
                                <li>関連するクラスで共有される機能を提供したい場合</li>
                                <li>サブクラスで特定のメソッドの実装を強制したい場合</li>
                                <li>非公開のメンバや実装済みのメソッドにアクセスさせたい場合</li>
                                <li>クラス階層で共通の状態や振る舞いを定義したい場合</li>
                                <li>複数のクラスで共有される処理を一元管理したい場合</li>
                            </ul>
                        </div>
                        
                        <div class="exercise">
                            <h5>練習問題 4.5: 抽象クラスの実装</h5>
                            <p>以下の要件を満たす抽象クラスとその実装クラスを作成してください：</p>
                            <ol>
                                <li><span class="inline-code">Game</span>という抽象クラスを作成し、ゲームの基本機能を定義する</li>
                                <li>抽象メソッドとして<span class="inline-code">initialize()</span>、<span class="inline-code">play()</span>、<span class="inline-code">end()</span>を定義</li>
                                <li>具象メソッドとして<span class="inline-code">start()</span>を実装し、内部で<span class="inline-code">initialize()</span>、<span class="inline-code">play()</span>、<span class="inline-code">end()</span>メソッドを順番に呼び出す</li>
                                <li>任意のゲームを表す2つの具象クラス（例：<span class="inline-code">CardGame</span>と<span class="inline-code">BoardGame</span>）を作成し、<span class="inline-code">Game</span>クラスを継承する</li>
                                <li>それぞれの具象クラスで抽象メソッドを実装し、ゲーム固有の処理を行うようにする</li>
                                <li><span class="inline-code">GameTest</span>クラスのmainメソッドで両方のゲームをインスタンス化し、<span class="inline-code">start()</span>メソッドを呼び出して実行する</li>
                            </ol>
                        </div>
                    </section>

                    <section id="interface">
                        <h3 class="section-title">4.6 インターフェース</h3>
                        <p>インターフェースは、クラスが実装すべきメソッドを定義する「契約」のようなものです。Javaのインターフェースは、完全な抽象化を提供し、多重継承の一形態を可能にします。</p>
                        
                        <h4>インターフェースの特徴</h4>
                        <ul>
                            <li><span class="inline-code">interface</span>キーワードを使用して宣言される</li>
                            <li>すべてのメソッドは暗黙的に<span class="inline-code">public</span>かつ<span class="inline-code">abstract</span>（Java 8以前）</li>
                            <li>定数（<span class="inline-code">public static final</span>フィールド）を持つことができる</li>
                            <li>Java 8以降では、デフォルトメソッド（<span class="inline-code">default</span>キーワード）と静的メソッドも持つことができる</li>
                            <li>クラスは複数のインターフェースを実装できる（多重継承の一形態）</li>
                            <li>インターフェースは他のインターフェースを継承（extends）できる</li>
                        </ul>
                        
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 420">
                                <!-- インターフェースの図 -->
                                <rect x="50" y="20" width="240" height="100" fill="#ffecb3" stroke="#ffa000" stroke-width="2" rx="5" />
                                <text x="170" y="50" text-anchor="middle" font-size="16" font-weight="bold">[interface]</text>
                                <text x="170" y="75" text-anchor="middle" font-size="16" font-weight="bold">飛行可能 (Flyable)</text>
                                <text x="170" y="100" text-anchor="middle" font-size="14">+ 飛ぶ()</text>
                                
                                <rect x="310" y="20" width="240" height="100" fill="#ffecb3" stroke="#ffa000" stroke-width="2" rx="5" />
                                <text x="430" y="50" text-anchor="middle" font-size="16" font-weight="bold">[interface]</text>
                                <text x="430" y="75" text-anchor="middle" font-size="16" font-weight="bold">泳ぎ可能 (Swimmable)</text>
                                <text x="430" y="100" text-anchor="middle" font-size="14">+ 泳ぐ()</text>
                                
                                <!-- 実装線 -->
                                <line x1="170" y1="120" x2="170" y2="170" stroke="#ffa000" stroke-width="2" stroke-dasharray="5,5" />
                                <line x1="430" y1="120" x2="300" y2="170" stroke="#ffa000" stroke-width="2" stroke-dasharray="5,5" />
                                <line x1="170" y1="120" x2="430" y2="170" stroke="#ffa000" stroke-width="2" stroke-dasharray="5,5" />
                                
                                <!-- 実装クラス -->
                                <rect x="50" y="170" width="240" height="100" fill="#c8e6c9" stroke="#388e3c" stroke-width="2" rx="5" />
                                <text x="170" y="200" text-anchor="middle" font-size="16" font-weight="bold">鳥 (Bird)</text>
                                <text x="170" y="225" text-anchor="middle" font-size="14">+ 飛ぶ() [Flyableの実装]</text>
                                <text x="170" y="250" text-anchor="middle" font-size="14">+ 鳴く()</text>
                                
                                <rect x="310" y="170" width="240" height="100" fill="#c8e6c9" stroke="#388e3c" stroke-width="2" rx="5" />
                                <text x="430" y="200" text-anchor="middle" font-size="16" font-weight="bold">魚 (Fish)</text>
                                <text x="430" y="225" text-anchor="middle" font-size="14">+ 泳ぐ() [Swimmableの実装]</text>
                                <text x="430" y="250" text-anchor="middle" font-size="14">+ 呼吸する()</text>
                                
                                <rect x="175" y="290" width="240" height="120" fill="#c8e6c9" stroke="#388e3c" stroke-width="2" rx="5" />
                                <text x="295" y="320" text-anchor="middle" font-size="16" font-weight="bold">アヒル (Duck)</text>
                                <text x="295" y="345" text-anchor="middle" font-size="14">+ 飛ぶ() [Flyableの実装]</text>
                                <text x="295" y="370" text-anchor="middle" font-size="14">+ 泳ぐ() [Swimmableの実装]</text>
                                <text x="295" y="395" text-anchor="middle" font-size="14">+ 鳴く()</text>
                            </svg>
                            <p class="text-center">図4.3: インターフェースと多重実装の概念図</p>
                        </div>
                        
                        <h4>インターフェースの例</h4>
                        <code>// インターフェース
public interface Playable {
    // 抽象メソッド（暗黙的にpublic abstract）
    void play();
    void stop();
    
    // 定数（暗黙的にpublic static final）
    int MAX_VOLUME = 100;
    
    // デフォルトメソッド（Java 8以降）
    default void pause() {
        System.out.println("再生を一時停止します");
    }
    
    // 静的メソッド（Java 8以降）
    static void printInfo() {
        System.out.println("これは再生可能なメディアのインターフェースです");
    }
}

// 別のインターフェース
public interface Recordable {
    void record();
    void stopRecording();
}

// インターフェースを実装するクラス
public class MusicPlayer implements Playable {
    private boolean isPlaying;
    
    @Override
    public void play() {
        isPlaying = true;
        System.out.println("音楽を再生しています");
    }
    
    @Override
    public void stop() {
        isPlaying = false;
        System.out.println("音楽の再生を停止しました");
    }
    
    // デフォルトメソッドのオーバーライド（オプション）
    @Override
    public void pause() {
        System.out.println("音楽の再生を一時停止しました");
    }
}

// 複数のインターフェースを実装するクラス
public class VideoPlayer implements Playable, Recordable {
    private boolean isPlaying;
    private boolean isRecording;
    
    @Override
    public void play() {
        isPlaying = true;
        System.out.println("動画を再生しています");
    }
    
    @Override
    public void stop() {
        isPlaying = false;
        System.out.println("動画の再生を停止しました");
    }
    
    @Override
    public void record() {
        isRecording = true;
        System.out.println("録画を開始しました");
    }
    
    @Override
    public void stopRecording() {
        isRecording = false;
        System.out.println("録画を停止しました");
    }
}</code>
                        
                        <div class="note">
                            <h5>インターフェースと抽象クラスの比較</h5>
                            <table class="table table-bordered">
                                <thead class="table-primary">
                                    <tr>
                                        <th>特性</th>
                                        <th>インターフェース</th>
                                        <th>抽象クラス</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>継承</td>
                                        <td>複数のインターフェースを実装可能</td>
                                        <td>単一継承のみ</td>
                                    </tr>
                                    <tr>
                                        <td>メソッド</td>
                                        <td>抽象メソッド、デフォルトメソッド、静的メソッド</td>
                                        <td>抽象メソッドと具象メソッド</td>
                                    </tr>
                                    <tr>
                                        <td>フィールド</td>
                                        <td>定数のみ（public static final）</td>
                                        <td>すべての種類のフィールド</td>
                                    </tr>
                                    <tr>
                                        <td>コンストラクタ</td>
                                        <td>持てない</td>
                                        <td>持てる</td>
                                    </tr>
                                    <tr>
                                        <td>アクセス修飾子</td>
                                        <td>すべてpublic（暗黙的）</td>
                                        <td>任意のアクセス修飾子</td>
                                    </tr>
                                    <tr>
                                        <td>使用目的</td>
                                        <td>「何ができるか」を定義（機能）</td>
                                        <td>「何であるか」を定義（本質）</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        
                        <h4>Java 8以降のインターフェースの進化</h4>
                        <p>Java 8でインターフェースにデフォルトメソッドと静的メソッドが追加され、Java 9ではプライベートメソッドも追加されました。</p>
                        <code>// Java 9以降のインターフェース
public interface ModernInterface {
    // 抽象メソッド
    void abstractMethod();
    
    // デフォルトメソッド（Java 8以降）
    default void defaultMethod() {
        // 共通の実装
        privateMethod();  // プライベートメソッドを呼び出し
        System.out.println("デフォルトの実装");
    }
    
    // 静的メソッド（Java 8以降）
    static void staticMethod() {
        System.out.println("静的メソッド");
    }
    
    // プライベートメソッド（Java 9以降）
    private void privateMethod() {
        System.out.println("プライベートヘルパーメソッド");
    }
}</code>
                        
                        <div class="exercise">
                            <h5>練習問題 4.6: インターフェースの実装</h5>
                            <p>以下の要件を満たすインターフェースとクラスを実装してください：</p>
                            <ol>
                                <li><span class="inline-code">Payable</span>というインターフェースを作成し、支払い機能を定義する</li>
                                <li>インターフェースに<span class="inline-code">calculatePayment()</span>と<span class="inline-code">processPayment()</span>メソッドを宣言</li>
                                <li>デフォルトメソッドとして<span class="inline-code">printReceipt()</span>を実装</li>
                                <li>静的メソッドとして<span class="inline-code">validatePayment(double amount)</span>を実装（金額が正の値かチェック）</li>
                                <li><span class="inline-code">Payable</span>インターフェースを実装する2つのクラス（<span class="inline-code">CreditCardPayment</span>と<span class="inline-code">PayPalPayment</span>）を作成</li>
                                <li>それぞれのクラスで支払い処理の具体的な実装を行う</li>
                                <li><span class="inline-code">Notifiable</span>という別のインターフェースを作成し、通知機能（<span class="inline-code">sendNotification()</span>）を定義</li>
                                <li><span class="inline-code">PayPalPayment</span>クラスで<span class="inline-code">Notifiable</span>インターフェースも実装し、支払い完了時にメール通知を送信する機能を追加</li>
                            </ol>
                        </div>
                    </section>

                    <section id="package">
                        <h3 class="section-title">4.7 パッケージ</h3>
                        <p>パッケージは、関連するクラスやインターフェースをグループ化するためのメカニズムです。パッケージはコードの整理と名前空間の管理に役立ち、クラス間の潜在的な名前の衝突を防ぎます。</p>
                        
                        <h4>パッケージの利点</h4>
                        <ul>
                            <li>名前の衝突を回避する（名前空間）</li>
                            <li>関連するクラスを論理的にグループ化する</li>
                            <li>アクセス制御を提供する（パッケージプライベートアクセス）</li>
                            <li>コードの再利用性と保守性を高める</li>
                        </ul>
                        
                        <h4>パッケージの宣言と使用</h4>
                        <code>// パッケージの宣言（ファイルの最初に記述）
package com.example.banking;

// クラスの定義
public class Account {
    // クラスの内容
}

// 別のファイル
package com.example.banking;

// 同じパッケージのクラスはインポートなしで使用可能
public class Transaction {
    private Account account;
    
    public Transaction(Account account) {
        this.account = account;
    }
}

// さらに別のファイル
package com.example.reporting;

// 異なるパッケージのクラスを使用するにはインポートが必要
import com.example.banking.Account;

public class AccountReport {
    private Account account;
    
    public AccountReport(Account account) {
        this.account = account;
    }
}</code>
                        
                        <h4>パッケージの命名規則</h4>
                        <p>パッケージ名には通常、ドメイン名を逆にした形式を使用します。これにより、世界中で一意のパッケージ名を作成できます。</p>
                        <ul>
                            <li>すべて小文字を使用</li>
                            <li>ドメイン名を逆順に使用（例：<span class="inline-code">com.example.project</span>）</li>
                            <li>Javaの予約語を避ける</li>
                            <li>意味のある階層構造を作成する</li>
                        </ul>
                        
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 350">
                                <!-- パッケージ構造の図 -->
                                <rect x="50" y="20" width="500" height="80" fill="#e8eaf6" stroke="#3f51b5" stroke-width="2" rx="5" />
                                <text x="300" y="60" text-anchor="middle" font-size="18" font-weight="bold">com.example.bookstore</text>
                                
                                <rect x="75" y="120" width="150" height="200" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="150" y="145" text-anchor="middle" font-size="16" font-weight="bold">model</text>
                                <text x="150" y="175" text-anchor="middle" font-size="14">Book.java</text>
                                <text x="150" y="200" text-anchor="middle" font-size="14">Author.java</text>
                                <text x="150" y="225" text-anchor="middle" font-size="14">Publisher.java</text>
                                <text x="150" y="250" text-anchor="middle" font-size="14">Category.java</text>
                                
                                <rect x="250" y="120" width="150" height="200" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="325" y="145" text-anchor="middle" font-size="16" font-weight="bold">service</text>
                                <text x="325" y="175" text-anchor="middle" font-size="14">BookService.java</text>
                                <text x="325" y="200" text-anchor="middle" font-size="14">OrderService.java</text>
                                <text x="325" y="225" text-anchor="middle" font-size="14">UserService.java</text>
                                <text x="325" y="250" text-anchor="middle" font-size="14">PaymentService.java</text>
                                
                                <rect x="425" y="120" width="150" height="200" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="500" y="145" text-anchor="middle" font-size="16" font-weight="bold">util</text>
                                <text x="500" y="175" text-anchor="middle" font-size="14">DateUtils.java</text>
                                <text x="500" y="200" text-anchor="middle" font-size="14">StringUtils.java</text>
                                <text x="500" y="225" text-anchor="middle" font-size="14">Logger.java</text>
                                <text x="500" y="250" text-anchor="middle" font-size="14">ConfigLoader.java</text>
                            </svg>
                            <p class="text-center">図4.4: パッケージ構造の例 - オンライン書店システム</p>
                        </div>
                        
                        <h4>importステートメント</h4>
                        <p>他のパッケージのクラスを使用するには、<span class="inline-code">import</span>ステートメントを使用します。</p>
                        <ul>
                            <li>特定のクラスをインポート: <span class="inline-code">import java.util.ArrayList;</span></li>
                            <li>パッケージ内のすべてのクラスをインポート: <span class="inline-code">import java.util.*;</span></li>
                            <li>静的インポート（フィールドやメソッドに直接アクセス）: <span class="inline-code">import static java.lang.Math.PI;</span></li>
                        </ul>
                        
                        <div class="note">
                            <h5>Java標準パッケージ</h5>
                            <p>Javaには、よく使われる機能を提供する多くの標準パッケージがあります：</p>
                            <ul>
                                <li><span class="inline-code">java.lang</span>: 基本的なクラス（String, Object, Mathなど）- 自動的にインポートされる</li>
                                <li><span class="inline-code">java.util</span>: ユーティリティクラス（コレクション、日付、乱数など）</li>
                                <li><span class="inline-code">java.io</span>: 入出力操作</li>
                                <li><span class="inline-code">java.net</span>: ネットワーク操作</li>
                                <li><span class="inline-code">java.sql</span>: データベース接続</li>
                                <li><span class="inline-code">java.time</span>: 日付と時間（Java 8以降）</li>
                                <li><span class="inline-code">javax.*</span>: 標準拡張パッケージ</li>
                            </ul>
                        </div>
                        
                        <h4>アクセス修飾子とパッケージ</h4>
                        <p>Javaのアクセス修飾子はパッケージレベルの可視性にも影響します。</p>
                        <table class="table table-bordered">
                            <thead class="table-primary">
                                <tr>
                                    <th>修飾子</th>
                                    <th>同じクラス</th>
                                    <th>同じパッケージ</th>
                                    <th>サブクラス</th>
                                    <th>他のパッケージ</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><span class="inline-code">private</span></td>
                                    <td>○</td>
                                    <td>×</td>
                                    <td>×</td>
                                    <td>×</td>
                                </tr>
                                <tr>
                                    <td>（なし/デフォルト）</td>
                                    <td>○</td>
                                    <td>○</td>
                                    <td>×（別パッケージの場合）</td>
                                    <td>×</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">protected</span></td>
                                    <td>○</td>
                                    <td>○</td>
                                    <td>○</td>
                                    <td>×</td>
                                </tr>
                                <tr>
                                    <td><span class="inline-code">public</span></td>
                                    <td>○</td>
                                    <td>○</td>
                                    <td>○</td>
                                    <td>○</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <div class="exercise">
                            <h5>練習問題 4.7: パッケージとアクセス制御</h5>
                            <p>以下の要件を満たす小規模な銀行アプリケーションを設計してください：</p>
                            <ol>
                                <li>次のパッケージ構造を作成：
                                    <ul>
                                        <li><span class="inline-code">com.example.banking.model</span>: データモデルクラス</li>
                                        <li><span class="inline-code">com.example.banking.service</span>: サービスクラス</li>
                                        <li><span class="inline-code">com.example.banking.util</span>: ユーティリティクラス</li>
                                    </ul>
                                </li>
                                <li><span class="inline-code">model</span>パッケージに<span class="inline-code">Account</span>クラスと<span class="inline-code">Transaction</span>クラスを作成</li>
                                <li><span class="inline-code">service</span>パッケージに<span class="inline-code">AccountService</span>クラスを作成し、アカウント操作のメソッドを実装</li>
                                <li><span class="inline-code">util</span>パッケージに<span class="inline-code">DateUtil</span>と<span class="inline-code">CurrencyFormatter</span>クラスを作成</li>
                                <li>適切なアクセス修飾子を使用して、各クラスのフィールドとメソッドのアクセス制御を実装</li>
                                <li><span class="inline-code">com.example.banking.app</span>パッケージに<span class="inline-code">BankingApp</span>クラスを作成し、mainメソッドで他のパッケージのクラスを使用する例を示す</li>
                            </ol>
                        </div>
                    </section>

                    <section id="chapter4-quiz">
                        <h3 class="section-title">4.8 理解度確認テスト</h3>
                        <div class="quiz-container">
                            <h4>第4章の理解度チェック</h4>
                            <p>以下の問題に答えて、第4章の内容の理解度を確認しましょう。</p>
                            
                            <div class="quiz-question">
                                <p><strong>問題1:</strong> Javaにおける継承に関する記述で正しいものはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1a" value="a">
                                    <label class="form-check-label" for="q1a">
                                        Javaでは複数のクラスから継承できる（多重継承）
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1b" value="b">
                                    <label class="form-check-label" for="q1b">
                                        privateメンバは子クラスから直接アクセスできる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1c" value="c">
                                    <label class="form-check-label" for="q1c">
                                        継承にはextendsキーワードを使用する
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1d" value="d">
                                        <label class="form-check-label" for="q1d">
                                        finalクラスは継承して拡張できる
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題2:</strong> メソッドのオーバーライドについて正しい説明はどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2a" value="a">
                                    <label class="form-check-label" for="q2a">
                                        オーバーライドするメソッドは、親クラスのメソッドとは異なる名前でなければならない
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2b" value="b">
                                    <label class="form-check-label" for="q2b">
                                        オーバーライドするメソッドは、親クラスのメソッドより制限の強いアクセス修飾子を使用できる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2c" value="c">
                                        <label class="form-check-label" for="q2c">
                                        @Overrideアノテーションは、コンパイル時にオーバーライドの正確性をチェックするために使用される
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2d" value="d">
                                    <label class="form-check-label" for="q2d">
                                        privateメソッドはオーバーライドできる
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題3:</strong> superキーワードの正しい使用法はどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3a" value="a">
                                    <label class="form-check-label" for="q3a">
                                        子クラスのコンストラクタで、親クラスの静的メソッドを呼び出す
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3b" value="b">
                                    <label class="form-check-label" for="q3b">
                                        子クラスのオーバーライドしたメソッド内で、親クラスの同名メソッドを呼び出す
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3c" value="c">
                                    <label class="form-check-label" for="q3c">
                                        親クラスから子クラスのメソッドを呼び出す
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3d" value="d">
                                    <label class="form-check-label" for="q3d">
                                        コンストラクタの最後のステートメントとしてsuper()を呼び出す
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題4:</strong> 次のコードの出力として正しいのはどれですか？</p>
                                <pre class="bg-light p-2 rounded">
public class Animal {
    public void makeSound() {
        System.out.println("動物が鳴いています");
    }
}

public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("ワンワン");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal animal = new Dog();
        animal.makeSound();
    }
}</pre>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4a" value="a">
                                    <label class="form-check-label" for="q4a">
                                        動物が鳴いています
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4b" value="b">
                                    <label class="form-check-label" for="q4b">
                                        ワンワン
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4c" value="c">
                                    <label class="form-check-label" for="q4c">
                                        動物が鳴いていますワンワン
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4d" value="d">
                                    <label class="form-check-label" for="q4d">
                                        コンパイルエラー
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題5:</strong> 抽象クラスに関する説明で正しいものはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5a" value="a">
                                    <label class="form-check-label" for="q5a">
                                        抽象クラスは直接インスタンス化できる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5b" value="b">
                                    <label class="form-check-label" for="q5b">
                                        抽象クラスには抽象メソッドのみを含めることができる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5c" value="c">
                                    <label class="form-check-label" for="q5c">
                                        抽象クラスはコンストラクタを持つことができる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5d" value="d">
                                    <label class="form-check-label" for="q5d">
                                        抽象クラスを継承するクラスは、抽象メソッドを実装しなくてもよい
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題6:</strong> インターフェースについて正しい説明はどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q6" id="q6a" value="a">
                                    <label class="form-check-label" for="q6a">
                                        インターフェースは実装を持つメソッドを定義できない
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q6" id="q6b" value="b">
                                    <label class="form-check-label" for="q6b">
                                        クラスは1つのインターフェースのみを実装できる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q6" id="q6c" value="c">
                                    <label class="form-check-label" for="q6c">
                                        インターフェースはフィールドを持つことができるが、それらは暗黙的にpublic static finalになる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q6" id="q6d" value="d">
                                    <label class="form-check-label" for="q6d">
                                        インターフェースはコンストラクタを定義できる
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題7:</strong> パッケージに関する説明で正しいものはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q7" id="q7a" value="a">
                                    <label class="form-check-label" for="q7a">
                                        パッケージ宣言はソースファイルの任意の場所に記述できる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q7" id="q7b" value="b">
                                    <label class="form-check-label" for="q7b">
                                        デフォルトアクセス修飾子（修飾子なし）を持つメンバは、同じパッケージ内のクラスからアクセスできる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q7" id="q7c" value="c">
                                    <label class="form-check-label" for="q7c">
                                        java.lang.*パッケージは明示的にインポートする必要がある
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q7" id="q7d" value="d">
                                    <label class="form-check-label" for="q7d">
                                        パッケージ名には大文字を使用することが推奨されている
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題8:</strong> 次のコードの実行結果は何ですか？</p>
                                <pre class="bg-light p-2 rounded">
interface A {
    default void show() {
        System.out.println("A");
    }
}

interface B {
    default void show() {
        System.out.println("B");
    }
}

class C implements A, B {
    public void show() {
        B.super.show();
    }
    
    public static void main(String[] args) {
        new C().show();
    }
}</pre>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q8" id="q8a" value="a">
                                    <label class="form-check-label" for="q8a">
                                        A
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q8" id="q8b" value="b">
                                    <label class="form-check-label" for="q8b">
                                        B
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q8" id="q8c" value="c">
                                    <label class="form-check-label" for="q8c">
                                        AB
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q8" id="q8d" value="d">
                                    <label class="form-check-label" for="q8d">
                                        コンパイルエラー
                                    </label>
                                </div>
                            </div>
                            
                            <button class="btn btn-primary mt-3" id="checkAnswers">回答を確認</button>
                            <div id="quizResults" class="mt-3 d-none">
                                <div class="alert alert-success">
                                    <h5>正解:</h5>
                                    <ol>
                                        <li>c) 継承にはextendsキーワードを使用する</li>
                                        <li>c) @Overrideアノテーションは、コンパイル時にオーバーライドの正確性をチェックするために使用される</li>
                                        <li>b) 子クラスのオーバーライドしたメソッド内で、親クラスの同名メソッドを呼び出す</li>
                                        <li>b) ワンワン</li>
                                        <li>c) 抽象クラスはコンストラクタを持つことができる</li>
                                        <li>c) インターフェースはフィールドを持つことができるが、それらは暗黙的にpublic static finalになる</li>
                                        <li>b) デフォルトアクセス修飾子（修飾子なし）を持つメンバは、同じパッケージ内のクラスからアクセスできる</li>
                                        <li>b) B</li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </section>
                </section>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS and Popper.js -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 理解度テストの回答確認ボタンの処理
        document.getElementById('checkAnswers').addEventListener('click', function() {
            document.getElementById('quizResults').classList.remove('d-none');
        });
    </script>
</body>
</html>
