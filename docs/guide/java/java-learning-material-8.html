<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java中級者向け学習教材 - コレクションフレームワーク応用</title>
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        .navbar {
            background-color: #1565c0;
        }
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        .chapter-title {
            color: #1565c0;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #1565c0;
            padding-bottom: 0.5rem;
        }
        .section-title {
            color: #1976d2;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        code {
            display: block;
            background-color: #f5f5f5;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            white-space: pre;
            overflow-x: auto;
        }
        .quiz-container {
            background-color: #e3f2fd;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }
        .quiz-question {
            font-weight: 500;
            margin-bottom: 1rem;
        }
        .diagram {
            max-width: 100%;
            height: auto;
            margin: 1.5rem 0;
            text-align: center;
        }
        .exercise {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        .note {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        #table-of-contents .list-group-item {
            border: none;
            padding: 0.5rem 1rem;
        }
        #table-of-contents .list-group-item-action {
            color: #1976d2;
        }
        /* 選択された目次項目のスタイル */
        #table-of-contents .list-group-item-action.active,
        .list-group-item.active {
            color: white !important; /* テキストを白色にして青い背景に対してコントラストをつける */
            background-color: #1976d2;
            border-color: #1976d2;
        }
        .section-nav {
            padding-left: 1rem;
        }
        .inline-code {
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .method-signature {
            font-weight: bold;
            color: #0d47a1;
        }
        .code-highlight {
            background-color: #ffecb3;
        }
        table {
            width: 100%;
            margin-bottom: 1rem;
            border-collapse: collapse;
        }
        table th, table td {
            padding: 0.75rem;
            border: 1px solid #dee2e6;
        }
        table thead th {
            background-color: #e3f2fd;
            border-bottom: 2px solid #1976d2;
        }
    </style>
</head>
<body data-bs-spy="scroll" data-bs-target="#tableOfContents">
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="#">Java中級者向け学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="#introduction">はじめに</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#chapter8">第8章: コレクションフレームワーク応用</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container my-4">
        <div class="row">
            <!-- Sidebar - Table of Contents -->
            <div class="col-lg-3">
                <div class="sidebar">
                    <div class="card">
                        <div class="card-header bg-primary text-white">
                            <h5 class="mb-0">目次</h5>
                        </div>
                        <div id="table-of-contents" class="list-group list-group-flush">
                            <a href="#introduction" class="list-group-item list-group-item-action">はじめに</a>
                            <a href="#chapter8" class="list-group-item list-group-item-action">第8章: コレクションフレームワーク応用</a>
                            <div class="section-nav">
                                <a href="#iterator" class="list-group-item list-group-item-action">8.1 イテレータ</a>
                                <a href="#generics" class="list-group-item list-group-item-action">8.2 ジェネリクス</a>
                                <a href="#comparable" class="list-group-item list-group-item-action">8.3 コンパラブルとコンパレータ</a>
                                <a href="#lambda-stream" class="list-group-item list-group-item-action">8.4 ラムダ式とStream API</a>
                                <a href="#optional" class="list-group-item list-group-item-action">8.5 Optional</a>
                                <a href="#chapter8-quiz" class="list-group-item list-group-item-action">8.6 理解度確認テスト</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Main Content -->
            <div class="col-lg-9">
                <section id="introduction">
                    <h1 class="display-5 mb-4">コレクションフレームワーク応用</h1>
                    <p class="lead">このコースでは、Javaのコレクションフレームワークの応用的な機能について学びます。イテレータ、ジェネリクス、コンパラブル、コンパレータ、ラムダ式、Stream API、そしてOptionalクラスの使い方を習得し、効率的で堅牢なコードを書けるようになりましょう。</p>
                    <div class="note">
                        <h5>この章の学習目標</h5>
                        <ul>
                            <li>イテレータを使ってコレクションの要素を統一的に処理する方法を理解する</li>
                            <li>ジェネリクスを活用して型安全なコードを書く方法を学ぶ</li>
                            <li>オブジェクトの比較方法（Comparable、Comparator）を理解する</li>
                            <li>ラムダ式とStream APIを使った関数型プログラミングの基本を習得する</li>
                            <li>Optionalクラスを使ってnull安全なコードを書く方法を学ぶ</li>
                        </ul>
                    </div>
                </section>

                <section id="chapter8">
                    <h2 class="chapter-title">第8章：コレクションフレームワーク応用</h2>
                    <p>この章では、Javaコレクションフレームワークの応用的な機能と、それに関連する重要な概念について学びます。これらの知識は、より高度なJavaアプリケーションを開発するために必須のものです。</p>

                    <section id="iterator">
                        <h3 class="section-title">8.1 イテレータ (Iterator)</h3>
                        <p>イテレータは、コレクション内の要素を順番に処理するためのインターフェースです。コレクションの種類に関係なく、統一された方法で要素にアクセスすることができます。</p>
                        
                        <h4>Iteratorインターフェース</h4>
                        <p>Iteratorインターフェースは以下の主要なメソッドを提供しています：</p>
                        <ul>
                            <li><span class="method-signature">boolean hasNext()</span> - コレクションに次の要素があるかどうかを判定します。</li>
                            <li><span class="method-signature">E next()</span> - コレクションの次の要素を返します。</li>
                            <li><span class="method-signature">void remove()</span> - 最後に返された要素をコレクションから削除します（オプション操作）。</li>
                            <li><span class="method-signature">default void forEachRemaining(Consumer&lt;? super E&gt; action)</span> - 残りのすべての要素に対して指定されたアクションを実行します（Java 8以降）。</li>
                        </ul>
                        
                        <h4>イテレータの基本的な使い方</h4>
                        <p>以下は、ArrayListの要素をイテレータを使って処理する例です：</p>
                        <code>import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class IteratorExample {
    public static void main(String[] args) {
        // ArrayListの作成
        List<String> fruits = new ArrayList<>();
        fruits.add("りんご");
        fruits.add("バナナ");
        fruits.add("オレンジ");
        fruits.add("ぶどう");
        
        // イテレータの取得
        Iterator<String> iterator = fruits.iterator();
        
        // イテレータを使った要素の表示
        System.out.println("=== イテレータでの表示 ===");
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            System.out.println(fruit);
        }
        
        // 新しいイテレータを取得（前のイテレータは最後まで進んでいるため）
        iterator = fruits.iterator();
        
        // 条件付き削除: "り"で始まる果物を削除
        System.out.println("\n=== 「り」で始まる果物を削除 ===");
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            if (fruit.startsWith("り")) {
                iterator.remove(); // 要素の安全な削除
                System.out.println(fruit + "を削除しました");
            }
        }
        
        // 結果の表示
        System.out.println("\n=== 削除後のリスト ===");
        for (String fruit : fruits) {
            System.out.println(fruit);
        }
    }
}</code>

                        <div class="note">
                            <h5>イテレータの特徴と利点</h5>
                            <ul>
                                <li><strong>統一的なアクセス方法</strong> - 異なる種類のコレクション（List, Set, Mapなど）でも同じ方法で要素にアクセスできます。</li>
                                <li><strong>安全な要素の削除</strong> - ループ中に<span class="inline-code">remove()</span>メソッドを使うことで、ConcurrentModificationExceptionを避けて安全に要素を削除できます。</li>
                                <li><strong>コレクション内部構造の隠蔽</strong> - コレクションの実装詳細を気にせずに要素を処理できます。</li>
                            </ul>
                        </div>
                        
                        <h4>ListIterator</h4>
                        <p>Listインターフェースは、より高度な機能を持つListIteratorも提供しています。ListIteratorはIteratorを拡張し、双方向の移動、要素の追加、要素の置換などの機能を追加しています。</p>
                        <code>import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

public class ListIteratorExample {
    public static void main(String[] args) {
        List<String> colors = new ArrayList<>();
        colors.add("赤");
        colors.add("緑");
        colors.add("青");
        
        // ListIteratorの取得
        ListIterator<String> listIterator = colors.listIterator();
        
        // 前から後ろへの走査
        System.out.println("=== 前から後ろへ ===");
        while (listIterator.hasNext()) {
            int index = listIterator.nextIndex();
            String color = listIterator.next();
            System.out.println("インデックス " + index + ": " + color);
        }
        
        // 後ろから前への走査
        System.out.println("\n=== 後ろから前へ ===");
        while (listIterator.hasPrevious()) {
            int index = listIterator.previousIndex();
            String color = listIterator.previous();
            System.out.println("インデックス " + index + ": " + color);
        }
        
        // 要素の置換
        System.out.println("\n=== 「緑」を「黄」に置換 ===");
        while (listIterator.hasNext()) {
            String color = listIterator.next();
            if (color.equals("緑")) {
                listIterator.set("黄");
                System.out.println("「緑」を「黄」に置換しました");
            }
        }
        
        // 結果の表示
        System.out.println("\n=== 置換後のリスト ===");
        for (String color : colors) {
            System.out.println(color);
        }
    }
}</code>

                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 220">
                                <!-- Iterator Diagram -->
                                <!-- Collection -->
                                <rect x="50" y="50" width="500" height="80" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="10" />
                                <text x="300" y="85" text-anchor="middle" font-size="16" font-weight="bold">Collection</text>
                                <rect x="100" y="100" width="60" height="20" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="130" y="115" text-anchor="middle" font-size="14">要素1</text>
                                <rect x="180" y="100" width="60" height="20" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="210" y="115" text-anchor="middle" font-size="14">要素2</text>
                                <rect x="260" y="100" width="60" height="20" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="290" y="115" text-anchor="middle" font-size="14">要素3</text>
                                <rect x="340" y="100" width="60" height="20" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="370" y="115" text-anchor="middle" font-size="14">要素4</text>
                                <rect x="420" y="100" width="60" height="20" fill="#bbdefb" stroke="#1976d2" stroke-width="1" />
                                <text x="450" y="115" text-anchor="middle" font-size="14">要素5</text>
                                
                                <!-- Iterator -->
                                <rect x="200" y="160" width="200" height="40" fill="#c8e6c9" stroke="#388e3c" stroke-width="2" rx="5" />
                                <text x="300" y="185" text-anchor="middle" font-size="16" font-weight="bold">Iterator</text>
                                
                                <!-- Connection Lines -->
                                <line x1="300" y1="130" x2="300" y2="160" stroke="#388e3c" stroke-width="2" stroke-dasharray="5,5" />
                                <text x="315" y="150" text-anchor="middle" font-size="12">iterator()</text>
                                
                                <!-- Cursor -->
                                <polygon points="130,130 120,140 140,140" fill="#f44336" />
                                <text x="150" y="155" text-anchor="middle" font-size="12">現在の位置</text>
                                
                                <!-- Next pointer -->
                                <line x1="140" y1="135" x2="180" y2="135" stroke="#f44336" stroke-width="2" />
                                <polygon points="180,135 170,130 170,140" fill="#f44336" />
                                <text x="160" y="130" text-anchor="middle" font-size="10">next()</text>
                            </svg>
                            <p class="text-center">図8.1: イテレータの概念図</p>
                        </div>
                        
                        <div class="exercise">
                            <h5>演習 8.1: イテレータを使った要素の処理</h5>
                            <p>以下の要件を満たすプログラムを作成してください：</p>
                            <ol>
                                <li>整数のリスト（1から10）を作成する</li>
                                <li>イテレータを使って、リスト内の偶数をすべて削除する</li>
                                <li>結果のリストを表示する</li>
                                <li>（発展）ListIteratorを使って、リスト内の奇数をすべて2倍にする</li>
                            </ol>
                        </div>
                    </section>

                    <section id="generics">
                        <h3 class="section-title">8.2 ジェネリクス (Generics)</h3>
                        <p>ジェネリクスはJava 5から導入された機能で、クラスやメソッドが特定の型に縛られることなく、様々な型で動作できるようにする仕組みです。コンパイル時の型チェックによって、実行時のエラーを防ぎながら柔軟性を提供します。</p>
                        
                        <h4>ジェネリクスの基本</h4>
                        <p>ジェネリクスを使うことで、コレクションに格納する要素の型を指定できます：</p>
                        <code>// ジェネリクスなし（Java 5以前）
List numberList = new ArrayList();
numberList.add(10);
numberList.add("文字列"); // コンパイルは通るが論理的に間違い
int number = (Integer) numberList.get(0); // キャストが必要
String text = (String) numberList.get(1);

// ジェネリクスあり（Java 5以降）
List<Integer> numberList = new ArrayList<>();
numberList.add(10);
// numberList.add("文字列"); // コンパイルエラー
int number = numberList.get(0); // キャストが不要</code>
                        
                        <h4>ジェネリッククラスの定義</h4>
                        <p>独自のジェネリッククラスを定義することもできます：</p>
                        <code>public class Box<T> {
    private T content;
    
    public void set(T content) {
        this.content = content;
    }
    
    public T get() {
        return content;
    }
}

// 使用例
Box<String> stringBox = new Box<>();
stringBox.set("Hello");
String str = stringBox.get();

Box<Integer> intBox = new Box<>();
intBox.set(100);
Integer num = intBox.get();</code>
                        
                        <h4>型パラメータの命名規則</h4>
                        <p>ジェネリクスの型パラメータには慣例的に以下の文字が使用されます：</p>
                        <ul>
                            <li><strong>E</strong> - Element（要素）、コレクションで使用</li>
                            <li><strong>T</strong> - Type（型）、一般的な型</li>
                            <li><strong>K</strong> - Key（キー）、マップのキー</li>
                            <li><strong>V</strong> - Value（値）、マップの値</li>
                            <li><strong>N</strong> - Number（数）、数値型</li>
                            <li><strong>S, U, V など</strong> - 2つ目、3つ目の型パラメータ</li>
                        </ul>
                        
                        <h4>ワイルドカード</h4>
                        <p>ジェネリクスでは、ワイルドカード「?」を使用して柔軟な型パラメータを表現できます：</p>
                        <code>// 非制限ワイルドカード
public void printList(List<?> list) {
    for (Object item : list) {
        System.out.println(item);
    }
}

// 上限付きワイルドカード（Numberまたはその子クラス）
public double sum(List<? extends Number> list) {
    double sum = 0.0;
    for (Number number : list) {
        sum += number.doubleValue();
    }
    return sum;
}

// 下限付きワイルドカード（Integerまたはその親クラス）
public void addNumbers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
    list.add(3);
}</code>
                        
                        <div class="note">
                            <h5>PECS原則 (Producer Extends, Consumer Super)</h5>
                            <p>ジェネリクスのワイルドカードを使う際の重要な原則です：</p>
                            <ul>
                                <li><strong>Producer Extends</strong> - データを取り出す（生産する）場合は <span class="inline-code">&lt;? extends T&gt;</span> を使う</li>
                                <li><strong>Consumer Super</strong> - データを追加する（消費する）場合は <span class="inline-code">&lt;? super T&gt;</span> を使う</li>
                            </ul>
                        </div>
                        
                        <h4>ジェネリックメソッド</h4>
                        <p>メソッドレベルでもジェネリクスを定義できます：</p>
                        <code>public class Utilities {
    // ジェネリックメソッド
    public static <T> void swap(T[] array, int i, int j) {
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    
    // 複数の型パラメータを持つジェネリックメソッド
    public static <K, V> boolean compareMap(Map<K, V> map1, Map<K, V> map2) {
        return map1.equals(map2);
    }
}

// 使用例
Integer[] numbers = {1, 2, 3, 4, 5};
Utilities.swap(numbers, 0, 4); // [5, 2, 3, 4, 1]</code>
                        
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 300">
                                <!-- Generics Hierarchy Diagram -->
                                <!-- Box<T> Class -->
                                <rect x="200" y="20" width="200" height="50" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="300" y="50" text-anchor="middle" font-size="16" font-weight="bold">Box&lt;T&gt;</text>
                                
                                <!-- Instances -->
                                <rect x="50" y="120" width="200" height="50" fill="#c8e6c9" stroke="#388e3c" stroke-width="2" rx="5" />
                                <text x="150" y="150" text-anchor="middle" font-size="16">Box&lt;Integer&gt;</text>
                                
                                <rect x="350" y="120" width="200" height="50" fill="#ffecb3" stroke="#ffa000" stroke-width="2" rx="5" />
                                <text x="450" y="150" text-anchor="middle" font-size="16">Box&lt;String&gt;</text>
                                
                                <!-- Connection Lines -->
                                <line x1="150" y1="120" x2="280" y2="70" stroke="#388e3c" stroke-width="2" stroke-dasharray="5,5" />
                                <line x1="450" y1="120" x2="320" y2="70" stroke="#ffa000" stroke-width="2" stroke-dasharray="5,5" />
                                
                                <!-- Content examples -->
                                <rect x="75" y="200" width="150" height="80" fill="#e8f5e9" stroke="#388e3c" stroke-width="1" rx="5" />
                                <text x="150" y="230" text-anchor="middle" font-size="14">content: 100</text>
                                <text x="150" y="260" text-anchor="middle" font-size="14" font-style="italic">(Integer)</text>
                                
                                <rect x="375" y="200" width="150" height="80" fill="#fff8e1" stroke="#ffa000" stroke-width="1" rx="5" />
                                <text x="450" y="230" text-anchor="middle" font-size="14">content: "Hello"</text>
                                <text x="450" y="260" text-anchor="middle" font-size="14" font-style="italic">(String)</text>
                                
                                <!-- Connection to content -->
                                <line x1="150" y1="170" x2="150" y2="200" stroke="#388e3c" stroke-width="1" />
                                <line x1="450" y1="170" x2="450" y2="200" stroke="#ffa000" stroke-width="1" />
                            </svg>
                            <p class="text-center">図8.2: ジェネリッククラスと型パラメータの概念図</p>
                        </div>
                        
                        <div class="exercise">
                            <h5>演習 8.2: カスタムジェネリッククラスの作成</h5>
                            <p>以下の要件を満たすジェネリッククラスを作成してください：</p>
                            <ol>
                                <li>ペア（二つの値）を保持する<span class="inline-code">Pair&lt;K, V&gt;</span>クラスを定義する</li>
                                <li>コンストラクタで二つの値を受け取る</li>
                                <li>各値のゲッターとセッターを実装する</li>
                                <li>値が等しいかどうかを比較する<span class="inline-code">equals</span>メソッドをオーバーライドする</li>
                                <li>テストコードで、<span class="inline-code">Pair&lt;String, Integer&gt;</span>と<span class="inline-code">Pair&lt;Integer, String&gt;</span>を作成して使用する</li>
                            </ol>
                        </div>
                    </section>

                    <section id="comparable">
                        <h3 class="section-title">8.3 コンパラブルとコンパレータ (Comparable & Comparator)</h3>
                        <p>Javaでオブジェクトを比較するには、主に2つのインターフェース（ComparableとComparator）を使用します。これらは、ソートやコレクション内での検索など、オブジェクトの順序付けに不可欠です。</p>
                        
                        <h4>Comparable&lt;T&gt;インターフェース</h4>
                        <p>Comparableは「自然順序付け」を実現するためのインターフェースです。クラス自体に比較ロジックを組み込みます。</p>
                        <code>public interface Comparable<T> {
    // このオブジェクトと指定されたオブジェクトを比較
    int compareTo(T o);
}</code>
                        
                        <p><span class="inline-code">compareTo</span>メソッドは以下の規則で結果を返します：</p>
                        <ul>
                            <li>このオブジェクトが指定されたオブジェクトより<strong>小さい</strong>場合：<strong>負の値</strong></li>
                            <li>このオブジェクトが指定されたオブジェクトと<strong>等しい</strong>場合：<strong>0</strong></li>
                            <li>このオブジェクトが指定されたオブジェクトより<strong>大きい</strong>場合：<strong>正の値</strong></li>
                        </ul>
                        
                        <p>Comparableを実装したクラスの例：</p>
                        <code>public class Student implements Comparable<Student> {
    private String name;
    private int id;
    private double gpa;
    
    public Student(String name, int id, double gpa) {
        this.name = name;
        this.id = id;
        this.gpa = gpa;
    }
    
    // getterとsetter（省略）
    
    @Override
    public String toString() {
        return "Student [id=" + id + ", name=" + name + ", gpa=" + gpa + "]";
    }
    
    @Override
    public int compareTo(Student other) {
        // 学生IDで昇順に並べる
        return this.id - other.id;
        
        // GPA（小数点）の比較の場合
        // return Double.compare(this.gpa, other.gpa);
        
        // 名前で比較する場合
        // return this.name.compareTo(other.name);
    }
}

// 使用例
List<Student> students = new ArrayList<>();
students.add(new Student("田中", 103, 3.8));
students.add(new Student("鈴木", 101, 3.5));
students.add(new Student("佐藤", 102, 4.0));

// 自然順序（compareTo実装）でソート
Collections.sort(students);
// Java 8以降
// students.sort(null);

for (Student student : students) {
    System.out.println(student);
}</code>
                        
                        <h4>Comparator&lt;T&gt;インターフェース</h4>
                        <p>Comparatorは「カスタム順序付け」を実現するためのインターフェースです。クラス外部に比較ロジックを定義し、異なる比較方法を柔軟に切り替えられます。</p>
                        <code>public interface Comparator<T> {
    // 2つのオブジェクトを比較
    int compare(T o1, T o2);
}</code>
                        
                        <p>Comparatorの例：</p>
                        <code>import java.util.Comparator;

// 名前で比較するComparator
public class StudentNameComparator implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        return s1.getName().compareTo(s2.getName());
    }
}

// GPAで比較するComparator
public class StudentGpaComparator implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        return Double.compare(s2.getGpa(), s1.getGpa()); // 降順（高いGPAが先）
    }
}

// 使用例
List<Student> students = new ArrayList<>();
students.add(new Student("田中", 103, 3.8));
students.add(new Student("鈴木", 101, 3.5));
students.add(new Student("佐藤", 102, 4.0));

// 名前でソート
Collections.sort(students, new StudentNameComparator());
// Java 8以降
// students.sort(new StudentNameComparator());

System.out.println("=== 名前順 ===");
for (Student student : students) {
    System.out.println(student);
}

// GPAでソート
Collections.sort(students, new StudentGpaComparator());
// Java 8以降
// students.sort(new StudentGpaComparator());

System.out.println("\n=== GPA順（降順） ===");
for (Student student : students) {
    System.out.println(student);
}</code>
                        
                        <h4>Java 8以降の簡潔な書き方</h4>
                        <p>Java 8のラムダ式を使用すると、Comparatorをより簡潔に記述できます：</p>
                        <code>// 名前でソート（ラムダ式）
students.sort((s1, s2) -> s1.getName().compareTo(s2.getName()));

// GPAでソート（ラムダ式）
students.sort((s1, s2) -> Double.compare(s2.getGpa(), s1.getGpa()));

// Comparator.comparingメソッドを使用して更に簡潔に
students.sort(Comparator.comparing(Student::getName));

// 降順にする場合
students.sort(Comparator.comparing(Student::getGpa).reversed());

// 複数のフィールドでソート（まずGPAで降順、同じ場合はIDで昇順）
students.sort(
    Comparator.comparing(Student::getGpa).reversed()
              .thenComparing(Student::getId)
);</code>
                        
                        <div class="note">
                            <h5>ComparableとComparatorの違い</h5>
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th>特性</th>
                                        <th>Comparable</th>
                                        <th>Comparator</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>定義場所</td>
                                        <td>クラス内部に実装</td>
                                        <td>外部クラスとして実装</td>
                                    </tr>
                                    <tr>
                                        <td>メソッド</td>
                                        <td>compareTo(T o)</td>
                                        <td>compare(T o1, T o2)</td>
                                    </tr>
                                    <tr>
                                        <td>用途</td>
                                        <td>デフォルトの自然順序</td>
                                        <td>カスタム順序、複数の順序基準</td>
                                    </tr>
                                    <tr>
                                        <td>ソート方法</td>
                                        <td>Collections.sort(list)</td>
                                        <td>Collections.sort(list, comparator)</td>
                                    </tr>
                                    <tr>
                                        <td>クラス修正</td>
                                        <td>必要（クラスを変更）</td>
                                        <td>不要（外部定義）</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        
                        <div class="exercise">
                            <h5>演習 8.3: 複数の条件でソートする</h5>
                            <p>以下の要件を満たすプログラムを作成してください：</p>
                            <ol>
                                <li><span class="inline-code">Product</span>クラスを作成（フィールド：名前、カテゴリ、価格、在庫数）</li>
                                <li>Comparableを実装して、デフォルトでは価格の昇順でソートされるようにする</li>
                                <li>以下のComparatorを作成し、適用する：
                                    <ul>
                                        <li>在庫数の降順</li>
                                        <li>カテゴリ名のアルファベット順、同じカテゴリ内では価格の昇順</li>
                                    </ul>
                                </li>
                                <li>ラムダ式とComparator.comparingを使った方法も実装すること</li>
                            </ol>
                        </div>
                    </section>

                    <section id="lambda-stream">
                        <h3 class="section-title">8.4 ラムダ式とStream API</h3>
                        <p>Java 8から導入されたラムダ式とStream APIは、関数型プログラミングのパラダイムをJavaにもたらし、コレクションの処理を簡潔かつ効率的に行うことができるようになりました。</p>
                        
                        <h4>ラムダ式</h4>
                        <p>ラムダ式は、匿名関数を簡潔に表現する方法です。特に関数型インターフェース（単一の抽象メソッドを持つインターフェース）の実装に役立ちます。</p>
                        
                        <p>基本構文：</p>
                        <code>(parameters) -> expression
(parameters) -> { statements; }</code>
                        
                        <p>例：</p>
                        <code>// 従来の匿名クラス
Runnable runnable1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello World");
    }
};

// ラムダ式
Runnable runnable2 = () -> System.out.println("Hello World");

// パラメータを持つラムダ式
Comparator<String> comparator = (s1, s2) -> s1.compareTo(s2);

// 複数の文を持つラムダ式
Consumer<String> consumer = s -> {
    String result = s.toUpperCase();
    System.out.println(result);
};</code>
                        
                        <h4>関数型インターフェース</h4>
                        <p>Java 8では、<span class="inline-code">java.util.function</span>パッケージに多くの関数型インターフェースが導入されました：</p>
                        <ul>
                            <li><span class="method-signature">Predicate&lt;T&gt;</span> - 条件判定 (T -> boolean)</li>
                            <li><span class="method-signature">Consumer&lt;T&gt;</span> - 値を消費する処理 (T -> void)</li>
                            <li><span class="method-signature">Function&lt;T, R&gt;</span> - 値を変換する処理 (T -> R)</li>
                            <li><span class="method-signature">Supplier&lt;T&gt;</span> - 値を供給する処理 (() -> T)</li>
                            <li><span class="method-signature">UnaryOperator&lt;T&gt;</span> - 同じ型の値を変換 (T -> T)</li>
                            <li><span class="method-signature">BinaryOperator&lt;T&gt;</span> - 同じ型の2つの値を1つに結合 ((T, T) -> T)</li>
                        </ul>
                        
                        <p>例：</p>
                        <code>import java.util.function.*;

// Predicate - 条件判定
Predicate<String> isEmpty = s -> s.isEmpty();
System.out.println(isEmpty.test("")); // true
System.out.println(isEmpty.test("Hello")); // false

// Consumer - 値を消費
Consumer<String> printer = s -> System.out.println(s);
printer.accept("Hello Consumer"); // "Hello Consumer"を出力

// Function - 値を変換
Function<String, Integer> length = s -> s.length();
System.out.println(length.apply("Hello")); // 5

// Supplier - 値を供給
Supplier<Double> random = () -> Math.random();
System.out.println(random.get()); // 0.0～1.0のランダムな値

// UnaryOperator - 同じ型の値を変換
UnaryOperator<String> toUpperCase = s -> s.toUpperCase();
System.out.println(toUpperCase.apply("hello")); // "HELLO"

// BinaryOperator - 同じ型の2つの値を結合
BinaryOperator<String> concat = (s1, s2) -> s1 + s2;
System.out.println(concat.apply("Hello ", "World")); // "Hello World"</code>
                        
                        <h4>Stream API</h4>
                        <p>Stream APIは、コレクションに対して一連の操作を宣言的に行うための機能です。SQLのようなクエリに似た処理を記述でき、並列処理も容易になります。</p>
                        
                        <p>基本的なStream操作：</p>
                        <ul>
                            <li><strong>中間操作（Intermediate Operations）</strong> - 別のStreamを返し、複数回実行可能</li>
                            <li><strong>終端操作（Terminal Operations）</strong> - Streamを消費し、結果を生成（一度しか実行できない）</li>
                        </ul>
                        
                        <p>Stream APIの例：</p>
                        <code>import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

List<String> names = Arrays.asList("山田", "鈴木", "田中", "佐藤", "山本", "高橋");

// フィルタリング：「山」で始まる名前を選択
List<String> yamaNamed = names.stream()
    .filter(name -> name.startsWith("山"))
    .collect(Collectors.toList());
System.out.println(yamaNamed); // [山田, 山本]

// マッピング：各名前に「さん」を追加
List<String> politeNames = names.stream()
    .map(name -> name + "さん")
    .collect(Collectors.toList());
System.out.println(politeNames); // [山田さん, 鈴木さん, ...]

// ソート
List<String> sortedNames = names.stream()
    .sorted()
    .collect(Collectors.toList());
System.out.println(sortedNames); // [佐藤, 山本, 山田, ...]

// 数値の処理
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// 偶数の合計を計算
int sumOfEvens = numbers.stream()
    .filter(n -> n % 2 == 0)
    .mapToInt(Integer::intValue) // IntStreamに変換
    .sum();
System.out.println("偶数の合計: " + sumOfEvens); // 30

// 最大値
int max = numbers.stream()
    .mapToInt(Integer::intValue)
    .max()
    .orElse(0); // 値がない場合のデフォルト値
System.out.println("最大値: " + max); // 10

// 統計情報
IntSummaryStatistics stats = numbers.stream()
    .mapToInt(Integer::intValue)
    .summaryStatistics();
System.out.println("統計: " + stats); // count, sum, min, max, averageを含む

// グループ化
List<Person> people = Arrays.asList(
    new Person("山田", 30, "東京"),
    new Person("鈴木", 25, "大阪"),
    new Person("田中", 35, "東京"),
    new Person("佐藤", 28, "名古屋"),
    new Person("山本", 32, "大阪")
);

// 都市別にグループ化
Map<String, List<Person>> peopleByCity = people.stream()
    .collect(Collectors.groupingBy(Person::getCity));
peopleByCity.forEach((city, cityPeople) -> {
    System.out.println(city + ": " + cityPeople.size() + "人");
});</code>
                        
                        <h4>並列処理</h4>
                        <p>Stream APIを使うと、並列処理も簡単に実装できます：</p>
                        <code>// 並列ストリームを作成
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// 並列処理で各要素を2倍
List<Integer> doubled = numbers.parallelStream()
    .map(n -> n * 2)
    .collect(Collectors.toList());
System.out.println(doubled); // [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</code>
                        
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 700 200">
                                <!-- Stream Pipeline Diagram -->
                                <!-- Source -->
                                <rect x="50" y="80" width="120" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" />
                                <text x="110" y="105" text-anchor="middle" font-size="14">Collection</text>
                                
                                <!-- Stream Creation -->
                                <rect x="50" y="130" width="120" height="30" fill="#e1f5fe" stroke="#03a9f4" stroke-width="1" />
                                <text x="110" y="150" text-anchor="middle" font-size="12">.stream()</text>
                                
                                <!-- Arrow -->
                                <line x1="170" y1="100" x2="210" y2="100" stroke="#1976d2" stroke-width="2" />
                                <polygon points="210,100 200,95 200,105" fill="#1976d2" />
                                
                                <!-- Intermediate Operations -->
                                <rect x="210" y="80" width="120" height="40" fill="#c8e6c9" stroke="#388e3c" stroke-width="2" rx="5" />
                                <text x="270" y="105" text-anchor="middle" font-size="14">filter</text>
                                
                                <!-- Arrow -->
                                <line x1="330" y1="100" x2="370" y2="100" stroke="#388e3c" stroke-width="2" />
                                <polygon points="370,100 360,95 360,105" fill="#388e3c" />
                                
                                <rect x="370" y="80" width="120" height="40" fill="#c8e6c9" stroke="#388e3c" stroke-width="2" rx="5" />
                                <text x="430" y="105" text-anchor="middle" font-size="14">map</text>
                                
                                <!-- Arrow -->
                                <line x1="490" y1="100" x2="530" y2="100" stroke="#388e3c" stroke-width="2" />
                                <polygon points="530,100 520,95 520,105" fill="#388e3c" />
                                
                                <!-- Terminal Operation -->
                                <rect x="530" y="80" width="120" height="40" fill="#ffecb3" stroke="#ffa000" stroke-width="2" rx="5" />
                                <text x="590" y="105" text-anchor="middle" font-size="14">collect</text>
                                
                                <!-- Result -->
                                <rect x="530" y="130" width="120" height="30" fill="#fff8e1" stroke="#ffa000" stroke-width="1" />
                                <text x="590" y="150" text-anchor="middle" font-size="12">Result</text>
                                
                                <!-- Labels -->
                                <text x="110" y="50" text-anchor="middle" font-size="12">ソース</text>
                                <text x="320" y="50" text-anchor="middle" font-size="12">中間操作（複数可）</text>
                                <text x="590" y="50" text-anchor="middle" font-size="12">終端操作</text>
                            </svg>
                            <p class="text-center">図8.3: Stream APIの処理パイプライン</p>
                        </div>
                        
                        <div class="exercise">
                            <h5>演習 8.4: Stream APIを使ったデータ処理</h5>
                            <p>以下の要件を満たすプログラムを作成してください：</p>
                            <ol>
                                <li><span class="inline-code">Employee</span>クラスを作成（フィールド：名前、部署、年齢、給与）</li>
                                <li>少なくとも10人の従業員データを含むリストを作成</li>
                                <li>Stream APIを使用して以下の処理を行う：
                                    <ul>
                                        <li>給与が30万円以上の従業員のリストを取得</li>
                                        <li>部署ごとの平均給与を計算</li>
                                        <li>最も若い従業員と最も年齢が高い従業員を見つける</li>
                                        <li>給与の高い順に従業員の名前を3人取得</li>
                                        <li>部署ごとの従業員数をマップで取得</li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </section>

                    <section id="optional">
                        <h3 class="section-title">8.5 Optional</h3>
                        <p>Java 8から導入された<span class="inline-code">Optional&lt;T&gt;</span>は、値の存在/不在を表現するためのコンテナクラスです。これにより、null参照の問題を回避し、より安全で読みやすいコードを書くことができます。</p>
                        
                        <h4>Optionalの基本</h4>
                        <p>Optionalの主な目的は、nullを返す可能性のあるメソッドを明示的にマークし、それに対処するコードを強制することです。</p>
                        <code>// Optionalなし（従来のアプローチ）
public String getNameById(int id) {
    User user = findUserById(id);
    if (user == null) {
        return "Unknown";
    }
    return user.getName();
}

// Optionalあり
public Optional<User> findUserById(int id) {
    // ユーザーが見つかった場合
    if (userExists(id)) {
        return Optional.of(new User(id, "User " + id));
    }
    // ユーザーが見つからなかった場合
    return Optional.empty();
}

public String getNameById(int id) {
    return findUserById(id)
        .map(User::getName)
        .orElse("Unknown");
}</code>
                        
                        <h4>Optionalの作成方法</h4>
                        <p>Optionalを作成するには、主に3つの方法があります：</p>
                        <code>// 値がある場合
Optional<String> present = Optional.of("Hello");

// 値が存在しないかもしれない場合（nullを許容）
Optional<String> nullable = Optional.ofNullable(getValue());

// 値が存在しないと確定している場合
Optional<String> empty = Optional.empty();</code>
                        
                        <h4>Optionalの操作</h4>
                        <p>Optionalには、値を安全に処理するための様々なメソッドが用意されています：</p>
                        <code>Optional<String> optional = Optional.of("Hello World");

// 値の存在確認
boolean isPresent = optional.isPresent(); // true
boolean isEmpty = optional.isEmpty(); // false（Java 11以降）

// 値の取得
String value = optional.get(); // 値が存在しない場合例外をスロー

// 値を取得するより安全な方法
String result1 = optional.orElse("Default Value"); // 値があれば値、なければデフォルト値
String result2 = optional.orElseGet(() -> computeDefaultValue()); // 値があれば値、なければSupplierの結果
String result3 = optional.orElseThrow(() -> new NoSuchElementException()); // 値がなければ例外をスロー

// 値の変換
Optional<Integer> length = optional.map(String::length); // 文字列の長さ（存在する場合）

// 条件付き処理
optional.ifPresent(s -> System.out.println(s)); // 値が存在する場合のみ実行
// Java 9以降
optional.ifPresentOrElse(
    s -> System.out.println(s), // 値が存在する場合
    () -> System.out.println("Empty") // 値が存在しない場合
);</code>
                        
                        <h4>flatMapの使用</h4>
                        <p><span class="inline-code">flatMap</span>は、ネストしたOptionalを扱う場合に特に便利です：</p>
                        <code>public class User {
    private String name;
    private Optional<Address> address;
    
    // getterとsetter（省略）
}

public class Address {
    private String street;
    private Optional<City> city;
    
    // getterとsetter（省略）
}

public class City {
    private String name;
    
    // getterとsetter（省略）
}

// ネストしたOptionalの使用例
Optional<User> user = findUser();

// 通常のmapでは、Optional<Optional<Address>>が返される
Optional<Optional<Address>> addressOption = user.map(User::getAddress);

// flatMapを使用すると、Optional<Address>が返される
Optional<Address> address = user.flatMap(User::getAddress);

// 市の名前を取得するチェーン（flatMapで連結）
String cityName = user
    .flatMap(User::getAddress)
    .flatMap(Address::getCity)
    .map(City::getName)
    .orElse("Unknown City");</code>
                        
                        <h4>Optionalのベストプラクティス</h4>
                        <div class="note">
                            <h5>Optionalの効果的な使い方</h5>
                            <ol>
                                <li><strong>戻り値として使用する</strong> - Optionalは主にメソッドの戻り値として使用し、nullを返す可能性があることを明示的に示します。</li>
                                <li><strong>フィールドとして使用しない</strong> - Optionalはシリアライズされないため、クラスのフィールドとしては避けるべきです。</li>
                                <li><strong>メソッドパラメータとして使用しない</strong> - パラメータの型としてOptionalを使用するのは避け、オーバーロードや代替メソッドを検討します。</li>
                                <li><strong>コレクションではなくOptionalを使用する</strong> - 空のコレクションには空のコレクションを返し、Optionalは使用しません。</li>
                                <li><strong>orElse()とorElseGet()の違いを理解する</strong> - orElse()は常に代替値を評価しますが、orElseGet()は必要な場合のみ評価します。</li>
                                <li><strong>getの使用を避ける</strong> - get()は値が存在しない場合に例外をスローするため、より安全な代替手段（orElse, orElseGet, orElseThrow）を使用します。</li>
                            </ol>
                        </div>
                        
                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 310">
                                <!-- Optional Diagram -->
                                <!-- Title -->
                                <text x="300" y="30" text-anchor="middle" font-size="18" font-weight="bold">Optional&lt;T&gt;の動作</text>
                                
                                <!-- Optional Present -->
                                <rect x="50" y="60" width="200" height="80" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="10" />
                                <text x="150" y="90" text-anchor="middle" font-size="16">Optional.of(value)</text>
                                <rect x="80" y="100" width="140" height="30" fill="#bbdefb" stroke="#1976d2" stroke-width="1" rx="5" />
                                <text x="150" y="120" text-anchor="middle" font-size="14">Value Present</text>
                                
                                <!-- Optional Empty -->
                                <rect x="350" y="60" width="200" height="80" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="10" />
                                <text x="450" y="90" text-anchor="middle" font-size="16">Optional.empty()</text>
                                <rect x="380" y="100" width="140" height="30" fill="#ffcdd2" stroke="#d32f2f" stroke-width="1" rx="5" />
                                <text x="450" y="120" text-anchor="middle" font-size="14">No Value</text>
                                
                                <!-- Operations -->
                                <line x1="150" y1="140" x2="150" y2="180" stroke="#1976d2" stroke-width="1" />
                                <line x1="450" y1="140" x2="450" y2="180" stroke="#1976d2" stroke-width="1" />
                                
                                <!-- Present Operations -->
                                <rect x="50" y="180" width="200" height="120" fill="#e8f5e9" stroke="#388e3c" stroke-width="1" rx="5" />
                                <text x="150" y="200" text-anchor="middle" font-size="14" font-weight="bold">値が存在する場合</text>
                                <text x="150" y="225" text-anchor="middle" font-size="12">get() → 値を返す</text>
                                <text x="150" y="245" text-anchor="middle" font-size="12">orElse(default) → 値を返す</text>
                                <text x="150" y="265" text-anchor="middle" font-size="12">map(function) → 変換された値</text>
                                <text x="150" y="285" text-anchor="middle" font-size="12">ifPresent() → アクションを実行</text>
                                
                                <!-- Empty Operations -->
                                <rect x="350" y="180" width="200" height="120" fill="#ffebee" stroke="#d32f2f" stroke-width="1" rx="5" />
                                <text x="450" y="200" text-anchor="middle" font-size="14" font-weight="bold">値が存在しない場合</text>
                                <text x="450" y="225" text-anchor="middle" font-size="12">get() → NoSuchElementException</text>
                                <text x="450" y="245" text-anchor="middle" font-size="12">orElse(default) → デフォルト値</text>
                                <text x="450" y="265" text-anchor="middle" font-size="12">map(function) → Empty Optional</text>
                                <text x="450" y="285" text-anchor="middle" font-size="12">ifPresent() → 何もしない</text>
                            </svg>
                            <p class="text-center">図8.4: Optionalの動作と主な操作</p>
                        </div>
                        
                        <div class="exercise">
                            <h5>演習 8.5: Optionalを使った安全なコードの実装</h5>
                            <p>以下の要件を満たすプログラムを作成してください：</p>
                            <ol>
                                <li>ユーザー情報を表す以下のクラスを作成します：
                                    <ul>
                                        <li><span class="inline-code">User</span>（フィールド：id、名前、Optionalとしてのメールアドレス、Optionalとしての住所）</li>
                                        <li><span class="inline-code">Address</span>（フィールド：郵便番号、都道府県、市区町村、Optionalとしての建物名）</li>
                                    </ul>
                                </li>
                                <li>ユーザーリストと以下のメソッドを持つ<span class="inline-code">UserService</span>クラスを実装します：
                                    <ul>
                                        <li>IDによるユーザー検索（Optional&lt;User&gt;を返す）</li>
                                        <li>メールアドレスでユーザーを検索（Optional&lt;User&gt;を返す）</li>
                                        <li>ユーザーの完全な住所を取得するメソッド（建物名があれば含める）</li>
                                    </ul>
                                </li>
                                <li>作成したクラスとメソッドを使用したメインプログラムで、Optionalの様々な操作（map, flatMap, orElse, ifPresent）を実演してください。</li>
                            </ol>
                        </div>
                    </section>

                    <section id="chapter8-quiz">
                        <h3 class="section-title">8.6 理解度確認テスト</h3>
                        <div class="quiz-container">
                            <h4>第8章の理解度チェック</h4>
                            <p>以下の問題に答えて、第8章の内容の理解度を確認しましょう。</p>
                            
                            <div class="quiz-question">
                                <p><strong>問題1:</strong> コレクション内の要素をループ中に安全に削除するには、次のうちどの方法が最も適切ですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1a" value="a">
                                    <label class="form-check-label" for="q1a">
                                        for-eachループ内でcollection.remove()を呼び出す
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1b" value="b">
                                    <label class="form-check-label" for="q1b">
                                        Iteratorを取得し、ループ内でiterator.remove()を呼び出す
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1c" value="c">
                                        Streamを使用し、filter().collect()で新しいコレクションを作成する
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1d" value="d">
                                    <label class="form-check-label" for="q1d">
                                        for (int i = 0; i < list.size(); i++)でループし、collection.remove(i)を呼び出す
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題2:</strong> ジェネリックスを使う主な利点は次のうちどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2a" value="a">
                                    <label class="form-check-label" for="q2a">
                                        プログラムの実行速度が向上する
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2b" value="b">
                                    <label class="form-check-label" for="q2b">
                                        コンパイル時の型チェックによりランタイムエラーを減らせる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2c" value="c">
                                        メモリ使用量が削減される
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2d" value="d">
                                    <label class="form-check-label" for="q2d">
                                        継承の必要性が減る
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題3:</strong> ComparableとComparatorの違いについて、正しい説明はどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3a" value="a">
                                    <label class="form-check-label" for="q3a">
                                        Comparableは外部クラスとして実装し、Comparatorはクラス内部に実装する
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3b" value="b">
                                    <label class="form-check-label" for="q3b">
                                        Comparableはクラス内部に実装して自然順序を定義し、Comparatorは外部クラスとして様々な順序付けを提供する
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3c" value="c">
                                    <label class="form-check-label" for="q3c">
                                        ComparableはプリミティブCSV型のみをサポートし、Comparatorはオブジェクト型のみをサポートする
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3d" value="d">
                                    <label class="form-check-label" for="q3d">
                                        ComparableはJava 8以前の古い仕組みで、ComparatorはJava 8以降の新しい仕組み
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題4:</strong> 次のStreamのコードの実行結果として正しいのはどれですか？</p>
                                <pre class="bg-light p-2 rounded">
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * n)
    .reduce(0, Integer::sum);</pre>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4a" value="a">
                                    <label class="form-check-label" for="q4a">
                                        15
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4b" value="b">
                                    <label class="form-check-label" for="q4b">
                                        20
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4c" value="c">
                                    <label class="form-check-label" for="q4c">
                                        55
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4d" value="d">
                                    <label class="form-check-label" for="q4d">
                                        30
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題5:</strong> Optionalを使用する最も適切な場面はどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5a" value="a">
                                    <label class="form-check-label" for="q5a">
                                        クラスのフィールドとして値が存在しない可能性を示す
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5b" value="b">
                                    <label class="form-check-label" for="q5b">
                                        メソッドのパラメータとして値がnullかもしれないことを示す
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5c" value="c">
                                    <label class="form-check-label" for="q5c">
                                        メソッドの戻り値として値が存在しない可能性を示す
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5d" value="d">
                                    <label class="form-check-label" for="q5d">
                                        空のコレクションを表現するため
                                    </label>
                                </div>
                            </div>
                            
                            <button class="btn btn-primary mt-3" id="checkAnswers">回答を確認</button>
                            <div id="quizResults" class="mt-3 d-none">
                                <div class="alert alert-success">
                                    <h5>正解:</h5>
                                    <ol>
                                        <li>b) Iteratorを取得し、ループ内でiterator.remove()を呼び出す</li>
                                        <li>b) コンパイル時の型チェックによりランタイムエラーを減らせる</li>
                                        <li>b) Comparableはクラス内部に実装して自然順序を定義し、Comparatorは外部クラスとして様々な順序付けを提供する</li>
                                        <li>b) 20（偶数は2と4、それぞれの二乗は4と16、合計は20）</li>
                                        <li>c) メソッドの戻り値として値が存在しない可能性を示す</li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </section>
                </section>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS and Popper.js -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 理解度テストの回答確認ボタンの処理
        document.getElementById('checkAnswers').addEventListener('click', function() {
            document.getElementById('quizResults').classList.remove('d-none');
        });
    </script>
</body>
</html>
