<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python SQLAlchemy学習教材 第4章 - リレーションシップとJOIN操作</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #306998;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
            background-color: #f8f9fa;
            border-right: 1px solid #dee2e6;
        }

        /* タイトル */
        .chapter-title {
            color: #306998;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #306998;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #4b8bbe;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e8f4fd;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #306998;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #306998 !important;
            color: white !important;
        }

        .nav-link {
            color: #495057;
        }

        .nav-link:hover {
            background-color: #e9ecef;
        }

        /* 図解用スタイル */
        .relationship-diagram {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            text-align: center;
        }

        .relationship-box {
            display: inline-block;
            background-color: #e9ecef;
            border: 1px solid #adb5bd;
            border-radius: 4px;
            padding: 0.5rem 1rem;
            margin: 0.5rem;
        }

        .relationship-arrow {
            font-size: 1.2rem;
            color: #306998;
            margin: 0 1rem;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Python SQLAlchemy 学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../README.md">学習ガイドに戻る</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlalchemy-learning-material-1.html">第1章: SQLAlchemy入門と環境構築</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlalchemy-learning-material-2.html">第2章: SQLAlchemy Core基礎</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlalchemy-learning-material-3.html">第3章: SQLAlchemy ORM基礎</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="#chapter4">第4章: リレーションシップとJOIN操作</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlalchemy-learning-material-5.html">第5章: 高度なクエリとパフォーマンス最適化</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlalchemy-learning-material-6.html">第6章: データベースマイグレーション（Alembic）</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlalchemy-learning-material-7.html">第7章: トランザクション管理とエラーハンドリング</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlalchemy-learning-material-8.html">第8章: 実践的なアプリケーション開発</a>
                        </li>
                    </ul>
                </div>
            </nav>

            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <!-- 章ヘッダー -->
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第4章: リレーションシップとJOIN操作</h1>
                </div>

                <div id="chapter4">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">リレーションシップとJOIN操作</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>リレーショナルデータベースにおけるテーブル間の関係</li>
                            <li>1対多、多対1、多対多リレーションシップの定義方法</li>
                            <li>外部キー制約とreferential integrityの実装</li>
                            <li>relationship()を使った関連データの操作</li>
                            <li>JOINクエリとLazy/Eager loadingの最適化</li>
                        </ul>
                    </div>

                    <!-- セクション4.1 -->
                    <h3 class="section-title">4.1 リレーションシップの基本概念</h3>
                    <p>リレーショナルデータベースでは、テーブル間の関係を定義することでデータの整合性を保ち、効率的なデータ管理を実現します。</p>

                    <h4>主要なリレーションシップタイプ</h4>
                    
                    <div class="relationship-diagram">
                        <h5>1対多 (One-to-Many) リレーションシップ</h5>
                        <div class="relationship-box">Category</div>
                        <span class="relationship-arrow">1 → ∞</span>
                        <div class="relationship-box">Product</div>
                        <p class="mt-2 text-muted">1つのカテゴリに複数の商品が属する</p>
                    </div>

                    <div class="relationship-diagram">
                        <h5>多対多 (Many-to-Many) リレーションシップ</h5>
                        <div class="relationship-box">Student</div>
                        <span class="relationship-arrow">∞ ← → ∞</span>
                        <div class="relationship-box">Course</div>
                        <p class="mt-2 text-muted">学生は複数の講座を履修し、講座には複数の学生が参加する</p>
                    </div>

                    <div class="relationship-diagram">
                        <h5>1対1 (One-to-One) リレーションシップ</h5>
                        <div class="relationship-box">User</div>
                        <span class="relationship-arrow">1 ← → 1</span>
                        <div class="relationship-box">Profile</div>
                        <p class="mt-2 text-muted">1人のユーザーに1つのプロフィールが対応</p>
                    </div>

                    <!-- セクション4.2 -->
                    <h3 class="section-title">4.2 1対多リレーションシップ</h3>
                    <p>最も一般的なリレーションシップパターンで、親テーブルの1つのレコードが子テーブルの複数のレコードに関連付けられます。</p>

                    <h4>基本的な定義方法</h4>
                    <pre class="code-block"><code class="language-python">from sqlalchemy import ForeignKey
from sqlalchemy.orm import relationship, Mapped, mapped_column
from typing import List, Optional

class Author(Base):
    __tablename__ = 'authors'
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(100))
    email: Mapped[str] = mapped_column(String(120), unique=True)
    
    # 1対多のリレーションシップ定義
    books: Mapped[List["Book"]] = relationship(back_populates="author")

class Book(Base):
    __tablename__ = 'books'
    
    id: Mapped[int] = mapped_column(primary_key=True)
    title: Mapped[str] = mapped_column(String(200))
    isbn: Mapped[str] = mapped_column(String(13), unique=True)
    author_id: Mapped[int] = mapped_column(ForeignKey('authors.id'))
    
    # 多対1のリレーションシップ定義
    author: Mapped["Author"] = relationship(back_populates="books")
</code></pre>

                    <!-- 実習4-1 -->
                    <div class="exercise-container">
                        <h5>実習 4-1: 1対多リレーションシップの実装</h5>
                        <p>ブログシステムを想定して、ユーザーと投稿の1対多リレーションシップを実装します。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>UserとPostモデルを定義する</li>
                            <li>外部キーとrelationship()を設定する</li>
                            <li>関連データを作成・操作する</li>
                            <li>JOINクエリで関連データを取得する</li>
                        </ol>

                        <h6>実装例</h6>
                        <pre class="code-block"><code class="language-python"># relationships.py
from sqlalchemy import create_engine, String, DateTime, Boolean, ForeignKey, Text, select
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, sessionmaker
from datetime import datetime
from typing import List, Optional

class Base(DeclarativeBase):
    pass

# Userモデル（親テーブル）
class User(Base):
    __tablename__ = 'users'
    
    id: Mapped[int] = mapped_column(primary_key=True)
    username: Mapped[str] = mapped_column(String(50), unique=True)
    email: Mapped[str] = mapped_column(String(120), unique=True)
    full_name: Mapped[Optional[str]] = mapped_column(String(100))
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    
    # 1対多のリレーションシップ
    posts: Mapped[List["Post"]] = relationship(
        back_populates="author",
        cascade="all, delete-orphan"  # カスケード設定
    )

    def __repr__(self):
        return f"&lt;User(username='{self.username}')&gt;"

# Postモデル（子テーブル）
class Post(Base):
    __tablename__ = 'posts'
    
    id: Mapped[int] = mapped_column(primary_key=True)
    title: Mapped[str] = mapped_column(String(200))
    content: Mapped[Optional[str]] = mapped_column(Text)
    author_id: Mapped[int] = mapped_column(ForeignKey('users.id'))
    published: Mapped[bool] = mapped_column(Boolean, default=False)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(
        DateTime, 
        default=datetime.utcnow, 
        onupdate=datetime.utcnow
    )
    
    # 多対1のリレーションシップ
    author: Mapped["User"] = relationship(back_populates="posts")

    def __repr__(self):
        return f"&lt;Post(title='{self.title}', published={self.published})&gt;"

# データベース設定
DATABASE_URL = 'sqlite:///blog_relationships.db'
engine = create_engine(DATABASE_URL, echo=True)
Base.metadata.create_all(engine)
SessionLocal = sessionmaker(bind=engine)

print("=== リレーションシップの実習 ===")

with SessionLocal() as session:
    # 1. ユーザーの作成
    print("\n1. Creating users...")
    
    alice = User(
        username='alice',
        email='alice@example.com',
        full_name='Alice Johnson'
    )
    
    bob = User(
        username='bob',
        email='bob@example.com',
        full_name='Bob Smith'
    )
    
    session.add_all([alice, bob])
    session.commit()
    
    # 2. 投稿の作成（リレーションシップを使用）
    print("\n2. Creating posts with relationships...")
    
    # 方法1: 外部キーを直接設定
    post1 = Post(
        title='SQLAlchemy入門',
        content='SQLAlchemyの基本的な使い方を解説します...',
        author_id=alice.id,
        published=True
    )
    
    # 方法2: リレーションシップオブジェクトを使用
    post2 = Post(
        title='Python ORM パターン',
        content='Pythonでのオブジェクト関係マッピング...',
        author=alice,  # リレーションシップを直接設定
        published=False
    )
    
    # 方法3: 親オブジェクトのリストに追加
    post3 = Post(
        title='データベース設計',
        content='効率的なデータベース設計について...',
        published=True
    )
    bob.posts.append(post3)  # bobの投稿リストに追加
    
    session.add_all([post1, post2, post3])
    session.commit()
    
    # 3. 関連データの取得
    print("\n3. Retrieving related data...")
    
    # ユーザーとその投稿を取得
    alice_from_db = session.get(User, alice.id)
    print(f"User: {alice_from_db.username}")
    print(f"Posts by {alice_from_db.username}:")
    for post in alice_from_db.posts:
        print(f"  - {post.title} (Published: {post.published})")
    
    # 投稿から著者情報を取得
    first_post = session.get(Post, post1.id)
    print(f"\nPost: '{first_post.title}'")
    print(f"Author: {first_post.author.full_name} ({first_post.author.email})")
    
    # 4. JOINクエリによる効率的な取得
    print("\n4. JOIN queries...")
    
    # 明示的なJOIN
    stmt = select(User, Post).join(Post.author).where(Post.published == True)
    results = session.execute(stmt).all()
    
    print("Published posts with authors:")
    for user, post in results:
        print(f"  '{post.title}' by {user.username}")
    
    # 条件付きJOIN
    stmt = select(User).join(User.posts).where(Post.published == True).distinct()
    authors_with_published = session.execute(stmt).scalars().all()
    
    print(f"\nAuthors with published posts:")
    for author in authors_with_published:
        published_count = len([p for p in author.posts if p.published])
        print(f"  {author.username}: {published_count} published posts")
    
    # 5. カスケード操作のテスト
    print("\n5. Cascade operations...")
    
    # 新しいユーザーと投稿を作成
    charlie = User(username='charlie', email='charlie@example.com')
    charlie_post = Post(title='Test Post', content='This is a test')
    charlie.posts.append(charlie_post)
    
    session.add(charlie)
    session.commit()
    
    print(f"Created user {charlie.username} with {len(charlie.posts)} post(s)")
    
    # ユーザーを削除（cascade="all, delete-orphan"により投稿も削除される）
    session.delete(charlie)
    session.commit()
    
    print("User charlie deleted (posts automatically deleted due to cascade)")
    
    # 最終的な状態確認
    print("\n=== Final State ===")
    all_users = session.execute(select(User)).scalars().all()
    for user in all_users:
        print(f"User: {user.username} ({len(user.posts)} posts)")
</code></pre>

                        <h6>期待される結果</h6>
                        <pre class="code-block"><code class="language-bash">=== リレーションシップの実習 ===

1. Creating users...

2. Creating posts with relationships...

3. Retrieving related data...
User: alice
Posts by alice:
  - SQLAlchemy入門 (Published: True)
  - Python ORM パターン (Published: False)

Post: 'SQLAlchemy入門'
Author: Alice Johnson (alice@example.com)

4. JOIN queries...
Published posts with authors:
  'SQLAlchemy入門' by alice
  'データベース設計' by bob

Authors with published posts:
  alice: 1 published posts
  bob: 1 published posts

5. Cascade operations...
Created user charlie with 1 post(s)
User charlie deleted (posts automatically deleted due to cascade)

=== Final State ===
User: alice (2 posts)
User: bob (1 posts)</code></pre>
                    </div>

                    <!-- セクション4.3 -->
                    <h3 class="section-title">4.3 多対多リレーションシップ</h3>
                    <p>多対多リレーションシップでは、中間テーブル（関連テーブル）を使用して2つのテーブル間の関係を管理します。</p>

                    <h4>関連テーブルの定義</h4>
                    <pre class="code-block"><code class="language-python">from sqlalchemy import Table

# 関連テーブル（中間テーブル）の定義
student_course_association = Table(
    'student_courses',
    Base.metadata,
    Column('student_id', ForeignKey('students.id'), primary_key=True),
    Column('course_id', ForeignKey('courses.id'), primary_key=True),
    Column('enrollment_date', DateTime, default=datetime.utcnow),
    Column('grade', String(2))  # 成績情報なども保存可能
)

class Student(Base):
    __tablename__ = 'students'
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(100))
    student_id: Mapped[str] = mapped_column(String(20), unique=True)
    
    # 多対多リレーションシップ
    courses: Mapped[List["Course"]] = relationship(
        secondary=student_course_association,
        back_populates="students"
    )

class Course(Base):
    __tablename__ = 'courses'
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(100))
    code: Mapped[str] = mapped_column(String(10), unique=True)
    credits: Mapped[int] = mapped_column()
    
    # 多対多リレーションシップ
    students: Mapped[List["Student"]] = relationship(
        secondary=student_course_association,
        back_populates="courses"
    )
</code></pre>

                    <!-- セクション4.4 -->
                    <h3 class="section-title">4.4 Lazy LoadingとEager Loading</h3>
                    <p>リレーションシップを持つデータを取得する際の読み込み戦略について学習します。</p>

                    <h4>Lazy Loading（遅延読み込み）</h4>
                    <p>関連データが実際にアクセスされるまで読み込みを遅延します。</p>
                    <pre class="code-block"><code class="language-python"># デフォルトはlazy loading
class User(Base):
    posts: Mapped[List["Post"]] = relationship(lazy="select")  # デフォルト

# 使用例
user = session.get(User, 1)
# この時点では投稿は読み込まれていない
print(user.posts)  # ここで初めて投稿が読み込まれる（N+1問題の原因になりうる）
</code></pre>

                    <h4>Eager Loading（即座読み込み）</h4>
                    <p>関連データを最初のクエリで同時に読み込みます。</p>
                    <pre class="code-block"><code class="language-python">from sqlalchemy.orm import selectinload, joinedload

# selectinload使用
stmt = select(User).options(selectinload(User.posts))
users = session.execute(stmt).scalars().all()

# joinedload使用（LEFT OUTER JOIN）
stmt = select(User).options(joinedload(User.posts))
users = session.execute(stmt).scalars().all()
</code></pre>

                    <!-- 実習4-2 -->
                    <div class="exercise-container">
                        <h5>実習 4-2: 多対多リレーションシップとN+1問題の解決</h5>
                        <p>ECサイトの商品とタグの多対多リレーションシップを実装し、N+1問題を解決します。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>Product、Tag、関連テーブルを定義する</li>
                            <li>多対多リレーションシップを設定する</li>
                            <li>N+1問題を再現する</li>
                            <li>Eager Loadingで最適化する</li>
                        </ol>

                        <h6>実装例</h6>
                        <pre class="code-block"><code class="language-python"># many_to_many.py
from sqlalchemy import create_engine, String, DateTime, Boolean, ForeignKey, Text, Table, Column, Integer, select
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, sessionmaker, selectinload, joinedload
from datetime import datetime
from typing import List, Optional
import time

class Base(DeclarativeBase):
    pass

# 関連テーブルの定義
product_tags = Table(
    'product_tags',
    Base.metadata,
    Column('product_id', Integer, ForeignKey('products.id'), primary_key=True),
    Column('tag_id', Integer, ForeignKey('tags.id'), primary_key=True),
    Column('created_at', DateTime, default=datetime.utcnow)
)

class Product(Base):
    __tablename__ = 'products'
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(100))
    price: Mapped[int] = mapped_column()
    description: Mapped[Optional[str]] = mapped_column(Text)
    is_available: Mapped[bool] = mapped_column(Boolean, default=True)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    
    # 多対多リレーションシップ
    tags: Mapped[List["Tag"]] = relationship(
        secondary=product_tags,
        back_populates="products",
        lazy="select"  # デフォルトのlazy loading
    )

    def __repr__(self):
        return f"&lt;Product(name='{self.name}', price={self.price})&gt;"

class Tag(Base):
    __tablename__ = 'tags'
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(50), unique=True)
    color: Mapped[Optional[str]] = mapped_column(String(7))  # HEXカラーコード
    description: Mapped[Optional[str]] = mapped_column(String(200))
    
    # 多対多リレーションシップ
    products: Mapped[List["Product"]] = relationship(
        secondary=product_tags,
        back_populates="tags"
    )

    def __repr__(self):
        return f"&lt;Tag(name='{self.name}')&gt;"

# データベース設定
DATABASE_URL = 'sqlite:///ecommerce_many_to_many.db'
engine = create_engine(DATABASE_URL, echo=False)  # SQL出力を抑制
Base.metadata.create_all(engine)
SessionLocal = sessionmaker(bind=engine)

print("=== 多対多リレーションシップとN+1問題の解決 ===")

with SessionLocal() as session:
    # 1. 初期データの作成
    print("\n1. Creating sample data...")
    
    # タグの作成
    tags = [
        Tag(name='Electronics', color='#0066cc', description='電子製品'),
        Tag(name='Bestseller', color='#ff6600', description='ベストセラー'),
        Tag(name='New', color='#00cc66', description='新商品'),
        Tag(name='Sale', color='#cc0066', description='セール商品'),
        Tag(name='Premium', color='#9900cc', description='プレミアム商品')
    ]
    session.add_all(tags)
    session.commit()
    
    # 商品の作成
    products = [
        Product(name='MacBook Pro', price=198000, description='高性能ノートPC'),
        Product(name='iPad Air', price=78800, description='軽量タブレット'),
        Product(name='iPhone 15', price=124800, description='最新スマートフォン'),
        Product(name='AirPods Pro', price=39800, description='ノイズキャンセリングイヤホン'),
        Product(name='Apple Watch', price=59800, description='スマートウォッチ')
    ]
    session.add_all(products)
    session.commit()
    
    # 多対多の関係を設定
    products[0].tags.extend([tags[0], tags[1], tags[4]])  # MacBook: Electronics, Bestseller, Premium
    products[1].tags.extend([tags[0], tags[2]])           # iPad: Electronics, New
    products[2].tags.extend([tags[0], tags[1], tags[2]])  # iPhone: Electronics, Bestseller, New
    products[3].tags.extend([tags[0], tags[3]])           # AirPods: Electronics, Sale
    products[4].tags.extend([tags[0], tags[4]])           # Watch: Electronics, Premium
    
    session.commit()
    print("Sample data created successfully!")
    
    # 2. N+1問題の再現（Lazy Loading）
    print("\n2. Demonstrating N+1 problem (Lazy Loading)...")
    
    start_time = time.time()
    
    # 商品を取得（1クエリ）
    stmt = select(Product)
    products_lazy = session.execute(stmt).scalars().all()
    
    print("Products with tags (Lazy Loading):")
    for product in products_lazy:
        # 各商品のタグにアクセス（商品数分のクエリが発生 = N+1問題）
        tag_names = [tag.name for tag in product.tags]
        print(f"  {product.name}: {', '.join(tag_names)}")
    
    lazy_time = time.time() - start_time
    print(f"Lazy loading time: {lazy_time:.4f}s")
    
    # 3. selectinloadによる最適化
    print("\n3. Optimized with selectinload...")
    
    start_time = time.time()
    
    # selectinloadでタグを事前読み込み
    stmt = select(Product).options(selectinload(Product.tags))
    products_selectin = session.execute(stmt).scalars().all()
    
    print("Products with tags (selectinload):")
    for product in products_selectin:
        tag_names = [tag.name for tag in product.tags]
        print(f"  {product.name}: {', '.join(tag_names)}")
    
    selectin_time = time.time() - start_time
    print(f"selectinload time: {lazy_time:.4f}s")
    
    # 4. joinedloadによる最適化
    print("\n4. Optimized with joinedload...")
    
    start_time = time.time()
    
    # joinedloadで1つのJOINクエリで全て取得
    stmt = select(Product).options(joinedload(Product.tags))
    products_joined = session.execute(stmt).scalars().unique().all()  # uniqueが重要
    
    print("Products with tags (joinedload):")
    for product in products_joined:
        tag_names = [tag.name for tag in product.tags]
        print(f"  {product.name}: {', '.join(tag_names)}")
    
    joined_time = time.time() - start_time
    print(f"joinedload time: {joined_time:.4f}s")
    
    # 5. 逆方向の関係も確認
    print("\n5. Reverse relationship (Tags to Products)...")
    
    # 特定のタグが付いた商品を効率的に取得
    stmt = select(Tag).options(selectinload(Tag.products)).where(Tag.name == 'Electronics')
    electronics_tag = session.execute(stmt).scalar_one()
    
    print(f"Products with '{electronics_tag.name}' tag:")
    for product in electronics_tag.products:
        print(f"  {product.name}: {product.price}円")
    
    # 6. 複雑なクエリ例
    print("\n6. Complex queries with many-to-many...")
    
    # 特定のタグを持つ商品を直接取得
    stmt = select(Product).join(Product.tags).where(Tag.name.in_(['Bestseller', 'Premium']))
    bestseller_or_premium = session.execute(stmt).scalars().all()
    
    print("Bestseller or Premium products:")
    for product in bestseller_or_premium:
        print(f"  {product.name}")
    
    # タググループ別の商品数
    from sqlalchemy import func
    stmt = select(Tag.name, func.count(Product.id)).join(Tag.products).group_by(Tag.id)
    tag_counts = session.execute(stmt).all()
    
    print("\nProduct count by tag:")
    for tag_name, count in tag_counts:
        print(f"  {tag_name}: {count} products")
    
    print(f"\n=== Performance Comparison ===")
    print(f"Lazy loading:  {lazy_time:.4f}s")
    print(f"selectinload:  {selectin_time:.4f}s") 
    print(f"joinedload:    {joined_time:.4f}s")
</code></pre>

                        <h6>期待される結果</h6>
                        <pre class="code-block"><code class="language-bash">=== 多対多リレーションシップとN+1問題の解決 ===

1. Creating sample data...
Sample data created successfully!

2. Demonstrating N+1 problem (Lazy Loading)...
Products with tags (Lazy Loading):
  MacBook Pro: Electronics, Bestseller, Premium
  iPad Air: Electronics, New
  iPhone 15: Electronics, Bestseller, New
  AirPods Pro: Electronics, Sale
  Apple Watch: Electronics, Premium
Lazy loading time: 0.0234s

3. Optimized with selectinload...
Products with tags (selectinload):
  MacBook Pro: Electronics, Bestseller, Premium
  iPad Air: Electronics, New  
  iPhone 15: Electronics, Bestseller, New
  AirPods Pro: Electronics, Sale
  Apple Watch: Electronics, Premium
selectinload time: 0.0234s

4. Optimized with joinedload...
Products with tags (joinedload):
  MacBook Pro: Electronics, Bestseller, Premium
  iPad Air: Electronics, New
  iPhone 15: Electronics, Bestseller, New
  AirPods Pro: Electronics, Sale  
  Apple Watch: Electronics, Premium
joinedload time: 0.0187s

5. Reverse relationship (Tags to Products)...
Products with 'Electronics' tag:
  MacBook Pro: 198000円
  iPad Air: 78800円
  iPhone 15: 124800円
  AirPods Pro: 39800円
  Apple Watch: 59800円

6. Complex queries with many-to-many...
Bestseller or Premium products:
  MacBook Pro
  iPhone 15
  Apple Watch

Product count by tag:
  Electronics: 5 products
  Bestseller: 2 products
  New: 2 products
  Sale: 1 products
  Premium: 2 products

=== Performance Comparison ===
Lazy loading:  0.0234s
selectinload:  0.0152s
joinedload:    0.0187s</code></pre>
                    </div>

                    <div class="warning">
                        <h5>リレーションシップ設計のベストプラクティス</h5>
                        <ul>
                            <li><strong>N+1問題対策</strong>: 関連データが必要な場合は適切なloading戦略を選択</li>
                            <li><strong>Cascade設定</strong>: データの整合性を保つため適切なカスケード設定を行う</li>
                            <li><strong>Indexing</strong>: 外部キーカラムには必ずインデックスを設定</li>
                            <li><strong>中間テーブル設計</strong>: 多対多では追加情報も考慮した設計を行う</li>
                        </ul>
                    </div>

                    <!-- 理解度確認クイズ -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>1対多リレーションシップにおいて、cascade="all, delete-orphan"の意味と効果を説明してください。</li>
                            <li>N+1問題とは何か、なぜ発生するのか、どのような解決方法があるか説明してください。</li>
                            <li>selectinloadとjoinedloadの違いと、それぞれに適した使用場面を説明してください。</li>
                            <li>以下の多対多リレーションシップ定義の問題点を指摘し、修正してください：
                                <pre class="code-block"><code class="language-python">class Student(Base):
    courses = relationship("Course", secondary="student_courses")</code></pre>
                            </li>
                            <li>中間テーブルに追加情報（enrollment_date、gradeなど）を保存する場合の設計方法を説明してください。</li>
                        </ol>
                        
                        <div class="mt-3">
                            <button class="btn btn-primary" type="button" data-bs-toggle="collapse" data-bs-target="#answers4">
                                解答を表示
                            </button>
                        </div>
                        
                        <div class="collapse mt-3" id="answers4">
                            <div class="card card-body">
                                <h6>解答例</h6>
                                <p><strong>1.</strong> 親レコード削除時に関連する子レコードも自動削除。delete-orphanは親との関連が切れた子レコードも削除。データ整合性の維持に有効。</p>
                                <p><strong>2.</strong> N+1問題: 1つのクエリでN件取得後、各レコードの関連データをN回クエリする非効率性。selectinload、joinedload、subqueryloadで解決。</p>
                                <p><strong>3.</strong> selectinload: 追加のSELECT文で取得、大量データに適す。joinedload: JOINで一度に取得、少量データに適す。</p>
                                <p><strong>4.</strong> 修正版：</p>
                                <pre class="code-block"><code class="language-python">courses: Mapped[List["Course"]] = relationship(
    secondary=student_courses, back_populates="students"
)</code></pre>
                                <p><strong>5.</strong> 中間テーブルを通常のモデルクラスとして定義し、1対多リレーションシップで両端のテーブルと関連付ける。</p>
                            </div>
                        </div>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="python-sqlalchemy-learning-material-3.html" class="btn btn-secondary">← 前の章</a>
                        <a href="python-sqlalchemy-learning-material-5.html" class="btn btn-primary">次の章 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
</body>
</html>