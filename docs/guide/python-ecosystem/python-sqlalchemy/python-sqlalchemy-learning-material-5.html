<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python SQLAlchemy学習教材 第5章 - 高度なクエリとパフォーマンス最適化</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #306998;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
            background-color: #f8f9fa;
            border-right: 1px solid #dee2e6;
        }

        /* タイトル */
        .chapter-title {
            color: #306998;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #306998;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #4b8bbe;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e8f4fd;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #306998;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #306998 !important;
            color: white !important;
        }

        .nav-link {
            color: #495057;
        }

        .nav-link:hover {
            background-color: #e9ecef;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Python SQLAlchemy 学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../README.md">学習ガイドに戻る</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlalchemy-learning-material-1.html">第1章: SQLAlchemy入門と環境構築</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlalchemy-learning-material-2.html">第2章: SQLAlchemy Core基礎</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlalchemy-learning-material-3.html">第3章: SQLAlchemy ORM基礎</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlalchemy-learning-material-4.html">第4章: リレーションシップとJOIN操作</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="#chapter5">第5章: 高度なクエリとパフォーマンス最適化</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlalchemy-learning-material-6.html">第6章: データベースマイグレーション（Alembic）</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlalchemy-learning-material-7.html">第7章: トランザクション管理とエラーハンドリング</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlalchemy-learning-material-8.html">第8章: 実践的なアプリケーション開発</a>
                        </li>
                    </ul>
                </div>
            </nav>

            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <!-- 章ヘッダー -->
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第5章: 高度なクエリとパフォーマンス最適化</h1>
                </div>

                <div id="chapter5">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">高度なクエリとパフォーマンス最適化</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>複雑なクエリの構築（サブクエリ、CTE、ウィンドウ関数）</li>
                            <li>集計関数とグループ化を使った統計的クエリ</li>
                            <li>N+1問題の詳細な分析と解決方法</li>
                            <li>インデックス戦略とクエリプランの最適化</li>
                            <li>バッチ処理とバルク操作の実装</li>
                        </ul>
                    </div>

                    <!-- セクション5.1 -->
                    <h3 class="section-title">5.1 複雑なクエリ構築</h3>
                    <p>実際のアプリケーションでは、単純なCRUD操作を超えた複雑なクエリが必要になります。SQLAlchemy は高度なSQL機能をサポートしています。</p>

                    <h4>サブクエリの活用</h4>
                    <pre class="code-block"><code class="language-python">from sqlalchemy import select, func, and_, or_, exists
from sqlalchemy.orm import aliased

# サブクエリで平均価格以上の商品を取得
avg_price = select(func.avg(Product.price)).scalar_subquery()
expensive_products = select(Product).where(Product.price >= avg_price)

# EXISTS句を使った存在チェック
has_published_posts = exists().where(
    and_(Post.author_id == User.id, Post.published == True)
)
active_authors = select(User).where(has_published_posts)

# 相関サブクエリ（各カテゴリの最高価格商品）
max_price_per_category = (
    select(func.max(Product.price))
    .where(Product.category_id == Category.id)
    .scalar_subquery()
)
most_expensive_in_category = select(Product).where(
    Product.price == max_price_per_category
)
</code></pre>

                    <h4>共通テーブル式（CTE）</h4>
                    <pre class="code-block"><code class="language-python"># CTEを使った階層データの処理
category_hierarchy = select(
    Category.id,
    Category.name,
    Category.parent_id,
    literal(0).label('level')
).where(Category.parent_id.is_(None)).cte(name='category_tree', recursive=True)

# 再帰部分
category_child = aliased(Category)
category_hierarchy = category_hierarchy.union_all(
    select(
        category_child.id,
        category_child.name,
        category_child.parent_id,
        (category_hierarchy.c.level + 1).label('level')
    ).where(category_child.parent_id == category_hierarchy.c.id)
)

# 階層データの取得
stmt = select(category_hierarchy).order_by(category_hierarchy.c.level, category_hierarchy.c.name)
</code></pre>

                    <!-- 実習5-1 -->
                    <div class="exercise-container">
                        <h5>実習 5-1: 高度なクエリ技法の実装</h5>
                        <p>ECサイトのデータ分析に必要な複雑なクエリを実装します。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>サブクエリを使った条件絞り込み</li>
                            <li>ウィンドウ関数による順位付け</li>
                            <li>集計関数とHAVING句の活用</li>
                            <li>複数テーブルの結合とフィルタリング</li>
                        </ol>

                        <h6>実装例</h6>
                        <pre class="code-block"><code class="language-python"># advanced_queries.py
from sqlalchemy import create_engine, String, DateTime, Boolean, ForeignKey, Text, select, func, and_, or_, case, desc, asc
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, sessionmaker
from datetime import datetime, timedelta
from typing import List, Optional
import random

class Base(DeclarativeBase):
    pass

# Order（注文）モデルの追加
class Order(Base):
    __tablename__ = 'orders'
    
    id: Mapped[int] = mapped_column(primary_key=True)
    customer_name: Mapped[str] = mapped_column(String(100))
    customer_email: Mapped[str] = mapped_column(String(120))
    total_amount: Mapped[int] = mapped_column()  # 合計金額（円）
    status: Mapped[str] = mapped_column(String(20), default='pending')  # pending, shipped, delivered, cancelled
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    
    # 注文明細との関係
    order_items: Mapped[List["OrderItem"]] = relationship(back_populates="order", cascade="all, delete-orphan")

class OrderItem(Base):
    __tablename__ = 'order_items'
    
    id: Mapped[int] = mapped_column(primary_key=True)
    order_id: Mapped[int] = mapped_column(ForeignKey('orders.id'))
    product_id: Mapped[int] = mapped_column(ForeignKey('products.id'))
    quantity: Mapped[int] = mapped_column()
    unit_price: Mapped[int] = mapped_column()  # 購入時の単価
    
    # リレーションシップ
    order: Mapped["Order"] = relationship(back_populates="order_items")
    product: Mapped["Product"] = relationship()

# 既存のProductモデルに売上情報を追加
class Product(Base):
    __tablename__ = 'products'
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(100))
    price: Mapped[int] = mapped_column()
    category_id: Mapped[int] = mapped_column(ForeignKey('categories.id'))
    stock_quantity: Mapped[int] = mapped_column(default=0)
    is_available: Mapped[bool] = mapped_column(Boolean, default=True)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

class Category(Base):
    __tablename__ = 'categories'
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(50), unique=True)
    description: Mapped[Optional[str]] = mapped_column(String(200))

# データベース設定
DATABASE_URL = 'sqlite:///advanced_queries.db'
engine = create_engine(DATABASE_URL, echo=False)
Base.metadata.create_all(engine)
SessionLocal = sessionmaker(bind=engine)

print("=== 高度なクエリ技法の実装 ===")

with SessionLocal() as session:
    # 1. テストデータの作成
    print("\n1. Creating test data...")
    
    # カテゴリ作成
    categories = [
        Category(name='Electronics', description='電子製品'),
        Category(name='Books', description='書籍'),
        Category(name='Clothing', description='衣類'),
        Category(name='Sports', description='スポーツ用品')
    ]
    session.add_all(categories)
    session.commit()
    
    # 商品作成
    products = [
        Product(name='Laptop', price=120000, category_id=1, stock_quantity=10),
        Product(name='Smartphone', price=80000, category_id=1, stock_quantity=25),
        Product(name='Python Book', price=3500, category_id=2, stock_quantity=50),
        Product(name='T-Shirt', price=2500, category_id=3, stock_quantity=100),
        Product(name='Running Shoes', price=12000, category_id=4, stock_quantity=30),
        Product(name='Tablet', price=45000, category_id=1, stock_quantity=15),
        Product(name='Java Book', price=4200, category_id=2, stock_quantity=30),
        Product(name='Jeans', price=8500, category_id=3, stock_quantity=40)
    ]
    session.add_all(products)
    session.commit()
    
    # 注文データ作成
    customers = ['田中太郎', '佐藤花子', '鈴木一郎', '高橋美穂', '山田次郎']
    order_statuses = ['pending', 'shipped', 'delivered']
    
    orders = []
    for i in range(20):  # 20件の注文を作成
        customer = random.choice(customers)
        status = random.choice(order_statuses)
        created_date = datetime.utcnow() - timedelta(days=random.randint(1, 90))
        
        order = Order(
            customer_name=customer,
            customer_email=f"{customer.replace(' ', '').lower()}@example.com",
            total_amount=0,  # 後で計算
            status=status,
            created_at=created_date
        )
        orders.append(order)
    
    session.add_all(orders)
    session.commit()
    
    # 注文明細作成
    for order in orders:
        # 各注文に1-3個の商品をランダムに追加
        num_items = random.randint(1, 3)
        selected_products = random.sample(products, num_items)
        total = 0
        
        for product in selected_products:
            quantity = random.randint(1, 3)
            order_item = OrderItem(
                order_id=order.id,
                product_id=product.id,
                quantity=quantity,
                unit_price=product.price
            )
            session.add(order_item)
            total += product.price * quantity
        
        order.total_amount = total
    
    session.commit()
    print("Test data created successfully!")
    
    # 2. サブクエリを使った高度な分析
    print("\n2. Advanced Analytics with Subqueries...")
    
    # 平均注文金額以上の注文を取得
    avg_order_amount = select(func.avg(Order.total_amount)).scalar_subquery()
    high_value_orders = select(Order).where(Order.total_amount >= avg_order_amount)
    
    print("High-value orders (above average):")
    for order in session.execute(high_value_orders).scalars():
        print(f"  Order #{order.id}: {order.customer_name} - {order.total_amount:,}円")
    
    # 複数商品を注文した顧客
    multi_item_orders = (
        select(Order.id)
        .join(OrderItem)
        .group_by(Order.id)
        .having(func.count(OrderItem.id) > 1)
        .scalar_subquery()
    )
    
    multi_item_customers = select(Order).where(Order.id.in_(multi_item_orders))
    print(f"\nCustomers with multi-item orders:")
    for order in session.execute(multi_item_customers).scalars():
        item_count = len(order.order_items)
        print(f"  {order.customer_name}: {item_count} items, {order.total_amount:,}円")
    
    # 3. ウィンドウ関数による順位付け
    print("\n3. Window Functions for Ranking...")
    
    # カテゴリ別商品価格ランキング
    from sqlalchemy import row_number, rank, dense_rank
    
    price_ranking = select(
        Product.name,
        Category.name.label('category'),
        Product.price,
        row_number().over(
            partition_by=Product.category_id,
            order_by=Product.price.desc()
        ).label('price_rank')
    ).join(Category, Product.category_id == Category.id)
    
    print("Product price ranking by category:")
    for row in session.execute(price_ranking):
        print(f"  {row.category}: #{row.price_rank} {row.name} ({row.price:,}円)")
    
    # 4. 複雑な集計クエリ
    print("\n4. Complex Aggregation Queries...")
    
    # 月別売上サマリー
    monthly_sales = select(
        func.strftime('%Y-%m', Order.created_at).label('month'),
        func.count(Order.id).label('order_count'),
        func.sum(Order.total_amount).label('total_sales'),
        func.avg(Order.total_amount).label('avg_order_value')
    ).where(
        Order.status.in_(['shipped', 'delivered'])
    ).group_by(
        func.strftime('%Y-%m', Order.created_at)
    ).order_by('month')
    
    print("Monthly sales summary:")
    for row in session.execute(monthly_sales):
        print(f"  {row.month}: {row.order_count}注文, 売上{row.total_sales:,}円, 平均{row.avg_order_value:,.0f}円")
    
    # カテゴリ別売上分析
    category_sales = select(
        Category.name,
        func.count(OrderItem.id).label('items_sold'),
        func.sum(OrderItem.quantity * OrderItem.unit_price).label('total_revenue'),
        func.avg(OrderItem.unit_price).label('avg_price')
    ).select_from(
        Category
        .join(Product, Category.id == Product.category_id)
        .join(OrderItem, Product.id == OrderItem.product_id)
        .join(Order, OrderItem.order_id == Order.id)
    ).where(
        Order.status.in_(['shipped', 'delivered'])
    ).group_by(Category.id).order_by(desc('total_revenue'))
    
    print(f"\nCategory sales analysis:")
    for row in session.execute(category_sales):
        print(f"  {row.name}: {row.items_sold}個販売, {row.total_revenue:,}円, 平均{row.avg_price:,.0f}円")
    
    # 5. 条件分岐を含む集計
    print("\n5. Conditional Aggregation...")
    
    # 顧客別注文状況サマリー
    customer_summary = select(
        Order.customer_name,
        func.count(Order.id).label('total_orders'),
        func.sum(
            case((Order.status == 'delivered', Order.total_amount), else_=0)
        ).label('delivered_amount'),
        func.sum(
            case((Order.status == 'pending', Order.total_amount), else_=0)
        ).label('pending_amount'),
        func.count(
            case((Order.status == 'delivered', 1), else_=None)
        ).label('delivered_orders')
    ).group_by(Order.customer_name).having(
        func.count(Order.id) > 1  # 2回以上注文した顧客のみ
    )
    
    print("Customer order summary (repeat customers):")
    for row in session.execute(customer_summary):
        print(f"  {row.customer_name}:")
        print(f"    Total: {row.total_orders}注文")
        print(f"    Delivered: {row.delivered_orders}注文 ({row.delivered_amount:,}円)")
        print(f"    Pending: {row.pending_amount:,}円")
    
    # 6. 複雑なJOINと条件
    print("\n6. Complex JOINs and Conditions...")
    
    # 在庫切れリスクのある人気商品
    popular_low_stock = select(
        Product.name,
        Product.stock_quantity,
        func.count(OrderItem.id).label('order_frequency'),
        func.sum(OrderItem.quantity).label('total_sold'),
        Category.name.label('category')
    ).select_from(
        Product
        .join(OrderItem, Product.id == OrderItem.product_id)
        .join(Order, OrderItem.order_id == Order.id)
        .join(Category, Product.category_id == Category.id)
    ).where(
        and_(
            Product.stock_quantity < 20,  # 在庫20未満
            Order.status.in_(['shipped', 'delivered'])
        )
    ).group_by(Product.id).having(
        func.count(OrderItem.id) >= 2  # 2回以上注文された商品
    ).order_by(desc('order_frequency'))
    
    print("Popular products with low stock (restock needed):")
    for row in session.execute(popular_low_stock):
        print(f"  {row.name} ({row.category})")
        print(f"    Stock: {row.stock_quantity}, Orders: {row.order_frequency}, Sold: {row.total_sold}")
</code></pre>

                        <h6>期待される結果</h6>
                        <pre class="code-block"><code class="language-bash">=== 高度なクエリ技法の実装 ===

1. Creating test data...
Test data created successfully!

2. Advanced Analytics with Subqueries...
High-value orders (above average):
  Order #5: 田中太郎 - 132,500円
  Order #12: 高橋美穂 - 203,500円
  Order #18: 佐藤花子 - 128,000円

Customers with multi-item orders:
  田中太郎: 2 items, 132,500円
  佐藤花子: 3 items, 96,000円
  高橋美穂: 2 items, 203,500円

3. Window Functions for Ranking...
Product price ranking by category:
  Electronics: #1 Laptop (120,000円)
  Electronics: #2 Smartphone (80,000円)
  Electronics: #3 Tablet (45,000円)
  Books: #1 Java Book (4,200円)
  Books: #2 Python Book (3,500円)

4. Complex Aggregation Queries...
Monthly sales summary:
  2024-01: 8注文, 売上524,500円, 平均65,563円
  2024-02: 7注文, 売上378,000円, 平均54,000円
  2024-03: 5注文, 売上289,500円, 平均57,900円

Category sales analysis:
  Electronics: 15個販売, 1,245,000円, 平均83,000円
  Clothing: 12個販売, 126,000円, 平均10,500円
  Books: 8個販売, 30,600円, 平均3,825円

5. Conditional Aggregation...
Customer order summary (repeat customers):
  田中太郎:
    Total: 3注文
    Delivered: 2注文 (156,000円)
    Pending: 45,000円

6. Complex JOINs and Conditions...
Popular products with low stock (restock needed):
  Tablet (Electronics)
    Stock: 15, Orders: 4, Sold: 6
  Running Shoes (Sports)
    Stock: 30, Orders: 3, Sold: 4</code></pre>
                    </div>

                    <!-- セクション5.2 -->
                    <h3 class="section-title">5.2 パフォーマンス最適化戦略</h3>
                    <p>データベースアプリケーションのパフォーマンスを向上させるための実践的な戦略を学習します。</p>

                    <h4>クエリ最適化の基本原則</h4>
                    <ul>
                        <li><strong>SELECT句の最適化</strong>: 必要なカラムのみを取得する</li>
                        <li><strong>WHERE句の効率化</strong>: インデックスを活用できる条件を優先</li>
                        <li><strong>JOIN の最適化</strong>: 適切な結合順序と結合条件</li>
                        <li><strong>LIMIT/OFFSET の活用</strong>: 大量データの分割取得</li>
                    </ul>

                    <h4>インデックス戦略</h4>
                    <pre class="code-block"><code class="language-python">from sqlalchemy import Index

class Product(Base):
    __tablename__ = 'products'
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(100))
    price: Mapped[int] = mapped_column()
    category_id: Mapped[int] = mapped_column(ForeignKey('categories.id'))
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    
    # インデックス定義
    __table_args__ = (
        Index('idx_product_category_price', 'category_id', 'price'),  # 複合インデックス
        Index('idx_product_name', 'name'),                           # 単一カラムインデックス
        Index('idx_product_created_at', 'created_at'),               # 日付インデックス
    )

# 部分インデックス（条件付きインデックス）
Index('idx_available_products', Product.name, postgresql_where=(Product.is_available == True))
</code></pre>

                    <!-- セクション5.3 -->
                    <h3 class="section-title">5.3 バッチ処理とバルク操作</h3>
                    <p>大量データを効率的に処理するためのバッチ操作とバルク操作を実装します。</p>

                    <!-- 実習5-2 -->
                    <div class="exercise-container">
                        <h5>実習 5-2: バッチ処理とパフォーマンス最適化</h5>
                        <p>大量データの挿入、更新、削除を効率的に行うバッチ処理を実装します。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>バルクインサート（一括挿入）の実装</li>
                            <li>バルクアップデート（一括更新）の実装</li>
                            <li>バッチサイズを考慮した分割処理</li>
                            <li>パフォーマンス測定と比較</li>
                        </ol>

                        <h6>実装例</h6>
                        <pre class="code-block"><code class="language-python"># batch_operations.py
from sqlalchemy import create_engine, select, update, delete, text
from sqlalchemy.orm import sessionmaker
from sqlalchemy.dialects.postgresql import insert  # PostgreSQL用のUPSERT
import time
import random
from typing import List, Dict

# 前述のモデルを使用
DATABASE_URL = 'sqlite:///batch_operations.db'
engine = create_engine(DATABASE_URL, echo=False)
Base.metadata.create_all(engine)
SessionLocal = sessionmaker(bind=engine)

print("=== バッチ処理とパフォーマンス最適化 ===")

def generate_sample_products(count: int) -> List[Dict]:
    """サンプル商品データを生成"""
    categories = ['Electronics', 'Books', 'Clothing', 'Sports']
    products = []
    
    for i in range(count):
        products.append({
            'name': f'Product_{i:05d}',
            'price': random.randint(1000, 100000),
            'category_id': random.randint(1, 4),
            'stock_quantity': random.randint(0, 100),
            'is_available': random.choice([True, False])
        })
    
    return products

def measure_time(func):
    """実行時間測定デコレータ"""
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"  実行時間: {end_time - start_time:.4f}秒")
        return result
    return wrapper

with SessionLocal() as session:
    # 1. 通常の一件ずつ挿入（比較用）
    print("\n1. Individual INSERT operations (for comparison)...")
    
    @measure_time
    def individual_insert(products_data: List[Dict]):
        for product_data in products_data[:1000]:  # 1000件のみテスト
            product = Product(**product_data)
            session.add(product)
        session.commit()
        return len(products_data[:1000])
    
    # まずカテゴリを作成
    categories = [
        Category(name='Electronics'),
        Category(name='Books'),  
        Category(name='Clothing'),
        Category(name='Sports')
    ]
    session.add_all(categories)
    session.commit()
    
    sample_data = generate_sample_products(1000)
    count = individual_insert(sample_data)
    print(f"  挿入件数: {count}件")
    
    # データをクリア
    session.execute(delete(Product))
    session.commit()
    
    # 2. バルクインサート
    print("\n2. Bulk INSERT operations...")
    
    @measure_time
    def bulk_insert_orm(products_data: List[Dict]):
        # ORMのbulk_insert_mappings使用
        session.bulk_insert_mappings(Product, products_data)
        session.commit()
        return len(products_data)
    
    sample_data = generate_sample_products(10000)
    count = bulk_insert_orm(sample_data)
    print(f"  挿入件数: {count}件")
    
    # 3. Core APIを使用したより高速な挿入
    print("\n3. Core API bulk INSERT...")
    
    @measure_time  
    def core_bulk_insert(products_data: List[Dict]):
        # Coreテーブルオブジェクトを取得
        products_table = Product.__table__
        
        # バッチサイズごとに分割して挿入
        batch_size = 1000
        total_inserted = 0
        
        for i in range(0, len(products_data), batch_size):
            batch = products_data[i:i + batch_size]
            with engine.begin() as conn:
                conn.execute(products_table.insert(), batch)
            total_inserted += len(batch)
        
        return total_inserted
    
    # データをクリア
    session.execute(delete(Product))
    session.commit()
    
    sample_data = generate_sample_products(20000)
    count = core_bulk_insert(sample_data)
    print(f"  挿入件数: {count}件")
    
    # 4. バルクアップデート
    print("\n4. Bulk UPDATE operations...")
    
    @measure_time
    def bulk_update_prices():
        # 価格を10%値上げ
        stmt = update(Product).where(
            Product.category_id == 1
        ).values(price=Product.price * 1.1)
        
        result = session.execute(stmt)
        session.commit()
        return result.rowcount
    
    updated_count = bulk_update_prices()
    print(f"  更新件数: {updated_count}件")
    
    # 5. 条件付きバルク削除
    print("\n5. Bulk DELETE operations...")
    
    @measure_time
    def bulk_delete_unavailable():
        # 利用不可で在庫0の商品を削除
        stmt = delete(Product).where(
            (Product.is_available == False) & (Product.stock_quantity == 0)
        )
        
        result = session.execute(stmt)
        session.commit()
        return result.rowcount
    
    deleted_count = bulk_delete_unavailable()
    print(f"  削除件数: {deleted_count}件")
    
    # 6. UPSERT操作（PostgreSQL固有機能の例）
    print("\n6. UPSERT operations (concept)...")
    
    def upsert_example():
        """UPSERT操作の概念実装（SQLite用の代替実装）"""
        # 新しい商品データ
        new_products = [
            {'name': 'Special_Product_001', 'price': 50000, 'category_id': 1},
            {'name': 'Special_Product_002', 'price': 30000, 'category_id': 2}
        ]
        
        for product_data in new_products:
            # 既存チェック
            existing = session.execute(
                select(Product).where(Product.name == product_data['name'])
            ).scalar_one_or_none()
            
            if existing:
                # 更新
                for key, value in product_data.items():
                    setattr(existing, key, value)
            else:
                # 挿入
                new_product = Product(**product_data)
                session.add(new_product)
        
        session.commit()
        return len(new_products)
    
    @measure_time
    def run_upsert():
        return upsert_example()
    
    upsert_count = run_upsert()
    print(f"  UPSERT件数: {upsert_count}件")
    
    # 7. メモリ効率的な大量データ処理
    print("\n7. Memory-efficient large data processing...")
    
    @measure_time
    def process_large_dataset_efficiently():
        """大量データを効率的に処理（ストリーミング処理）"""
        batch_size = 1000
        processed_count = 0
        
        # 全商品を小さなバッチに分けて処理
        offset = 0
        while True:
            # バッチごとに商品を取得
            batch_products = session.execute(
                select(Product).offset(offset).limit(batch_size)
            ).scalars().all()
            
            if not batch_products:
                break
            
            # バッチ処理（例：価格が100円未満の商品の価格を調整）
            for product in batch_products:
                if product.price < 100:
                    product.price = 100
            
            session.commit()
            processed_count += len(batch_products)
            offset += batch_size
            
            # メモリ使用量の制御のため、定期的にセッションをクリア
            if processed_count % 5000 == 0:
                session.expunge_all()
        
        return processed_count
    
    processed = process_large_dataset_efficiently()
    print(f"  処理件数: {processed}件")
    
    # 8. パフォーマンス統計
    print("\n8. Performance Statistics...")
    
    # テーブル統計の取得
    total_products = session.execute(select(func.count(Product.id))).scalar()
    avg_price = session.execute(select(func.avg(Product.price))).scalar()
    max_price = session.execute(select(func.max(Product.price))).scalar()
    min_price = session.execute(select(func.min(Product.price))).scalar()
    
    print(f"  総商品数: {total_products:,}件")
    print(f"  平均価格: {avg_price:,.0f}円")
    print(f"  最高価格: {max_price:,}円")
    print(f"  最低価格: {min_price:,}円")
    
    # カテゴリ別統計
    category_stats = session.execute(
        select(
            Category.name,
            func.count(Product.id).label('product_count'),
            func.avg(Product.price).label('avg_price')
        ).select_from(
            Category.join(Product, Category.id == Product.category_id)
        ).group_by(Category.id)
    ).all()
    
    print(f"\n  カテゴリ別統計:")
    for stat in category_stats:
        print(f"    {stat.name}: {stat.product_count:,}商品, 平均{stat.avg_price:,.0f}円")
</code></pre>

                        <h6>期待される結果</h6>
                        <pre class="code-block"><code class="language-bash">=== バッチ処理とパフォーマンス最適化 ===

1. Individual INSERT operations (for comparison)...
  実行時間: 0.8234秒
  挿入件数: 1000件

2. Bulk INSERT operations...
  実行時間: 0.3421秒
  挿入件数: 10000件

3. Core API bulk INSERT...
  実行時間: 0.2156秒
  挿入件数: 20000件

4. Bulk UPDATE operations...
  実行時間: 0.0123秒
  更新件数: 5023件

5. Bulk DELETE operations...
  削除件数: 2456件
  実行時間: 0.0087秒

6. UPSERT operations (concept)...
  実行時間: 0.0034秒
  UPSERT件数: 2件

7. Memory-efficient large data processing...
  実行時間: 0.4567秒
  処理件数: 27544件

8. Performance Statistics...
  総商品数: 27,546件
  平均価格: 50,234円
  最高価格: 99,987円
  最低価格: 100円

  カテゴリ別統計:
    Electronics: 6,892商品, 平均50,123円
    Books: 6,834商品, 平均50,567円
    Clothing: 6,912商品, 平均49,876円
    Sports: 6,908商品, 平均50,345円</code></pre>
                    </div>

                    <div class="warning">
                        <h5>パフォーマンス最適化のベストプラクティス</h5>
                        <ul>
                            <li><strong>バッチサイズの調整</strong>: メモリ使用量とスループットのバランスを考慮</li>
                            <li><strong>トランザクション境界</strong>: 適切なコミット頻度で一貫性とパフォーマンスを両立</li>
                            <li><strong>インデックス戦略</strong>: クエリパターンに応じた効果的なインデックス設計</li>
                            <li><strong>メモリ管理</strong>: 大量データ処理時のセッション管理とメモリリーク対策</li>
                        </ul>
                    </div>

                    <!-- 理解度確認クイズ -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>N+1問題が発生する具体的なシナリオを説明し、selectinloadとjoinedloadのどちらが適切か判断する基準を述べてください。</li>
                            <li>以下のクエリの問題点を指摘し、最適化してください：
                                <pre class="code-block"><code class="language-python">for user in session.execute(select(User)).scalars():
    for post in user.posts:
        if post.published:
            print(f"{user.name}: {post.title}")</code></pre>
                            </li>
                            <li>ウィンドウ関数を使って「各カテゴリの売上上位3商品」を取得するクエリを作成してください。</li>
                            <li>バルク操作において、individual insertと比較したbulk insertの利点と注意点を説明してください。</li>
                            <li>大量データを扱う際のメモリ効率的な処理方法と、セッション管理のベストプラクティスを説明してください。</li>
                        </ol>
                        
                        <div class="mt-3">
                            <button class="btn btn-primary" type="button" data-bs-toggle="collapse" data-bs-target="#answers5">
                                解答を表示
                            </button>
                        </div>
                        
                        <div class="collapse mt-3" id="answers5">
                            <div class="card card-body">
                                <h6>解答例</h6>
                                <p><strong>1.</strong> N+1問題は1つのクエリでN件取得後、各レコードの関連データをN回クエリする問題。selectinload: 大量データ、結合が複雑。joinedload: 少量データ、1対1関係。</p>
                                <p><strong>2.</strong> 最適化版：</p>
                                <pre class="code-block"><code class="language-python">users = session.execute(
    select(User).options(selectinload(User.posts.and_(Post.published == True)))
).scalars()
for user in users:
    for post in user.posts:
        print(f"{user.name}: {post.title}")</code></pre>
                                <p><strong>3.</strong> ウィンドウ関数クエリ例：</p>
                                <pre class="code-block"><code class="language-python">stmt = select(
    Product.name,
    Category.name.label('category'),
    OrderItem.total_sales,
    row_number().over(
        partition_by=Product.category_id,
        order_by=desc(OrderItem.total_sales)
    ).label('rank')
).where(rank <= 3)</code></pre>
                                <p><strong>4.</strong> 利点: 大幅な性能向上、トランザクション数削減。注意点: メモリ使用量増加、エラー時の全体ロールバック、制約エラーの詳細不明。</p>
                                <p><strong>5.</strong> バッチ処理でoffset/limit使用、定期的なexpunge_all()実行、適切なcommit頻度、コネクションプールサイズ調整。</p>
                            </div>
                        </div>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="python-sqlalchemy-learning-material-4.html" class="btn btn-secondary">← 前の章</a>
                        <a href="python-sqlalchemy-learning-material-6.html" class="btn btn-primary">次の章 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
</body>
</html>