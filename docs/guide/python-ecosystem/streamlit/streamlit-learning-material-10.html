<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamlit学習教材 第10章 - 実践的なデータ分析アプリ開発</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #4caf50;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
            background-color: #f8f9fa;
        }

        /* タイトル */
        .chapter-title {
            color: #4caf50;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #4caf50;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #66bb6a;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e8f5e8;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #4caf50;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .info-box {
            background-color: #e1f5fe;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #2196F3;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #4caf50 !important;
            color: white !important;
        }

        .nav-link {
            color: #666;
        }

        .nav-link:hover {
            background-color: #e8f5e8;
            color: #4caf50;
        }

        pre {
            background-color: #f5f5f5;
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
        }

        code {
            background-color: #f5f5f5;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Streamlit学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="../README.md">学習ガイドに戻る</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        章の一覧
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-1.html">第1章: 入門と環境構築</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-2.html">第2章: 基本的なUIコンポーネント</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-3.html">第3章: データ表示と可視化</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-4.html">第4章: ユーザー入力とインタラクション</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-5.html">第5章: セッション状態管理</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-6.html">第6章: ファイル操作とデータ処理</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-7.html">第7章: マルチページアプリケーション</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-8.html">第8章: データベース連携とAPI統合</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="streamlit-learning-material-9.html">第9章: デプロイメントと本番環境</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="#chapter10">第10章: 実践的なデータ分析アプリ開発</a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <!-- 章ヘッダー -->
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第10章: 実践的なデータ分析アプリ開発</h1>
                </div>

                <div id="chapter10">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">総合的なデータ分析プラットフォームの構築</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>売上分析ダッシュボードの完全実装</li>
                            <li>機械学習モデルのデプロイと可視化</li>
                            <li>データ探索ツールの開発</li>
                            <li>自動レポート生成システムの構築</li>
                            <li>実務で使える高品質アプリケーションの設計</li>
                        </ul>
                    </div>

                    <!-- セクション1: 売上分析ダッシュボード -->
                    <h3 class="section-title">10.1 売上分析ダッシュボード</h3>
                    <p>実際のビジネスで使用できる包括的な売上分析ダッシュボードを構築します。KPI監視、トレンド分析、予測機能を含みます。</p>
                    
                    <div class="exercise-container">
                        <h5>実習 10-1: 売上分析ダッシュボード</h5>
                        <p>リアルタイムKPI監視、売上予測、地域別分析を含む総合的な売上分析システムを開発します。</p>
                        
                        <h6>sales_dashboard.py を作成</h6>
                        <pre><code>import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta, date
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_absolute_error
from sklearn.preprocessing import StandardScaler
import warnings
warnings.filterwarnings('ignore')

# ページ設定
st.set_page_config(
    page_title="売上分析ダッシュボード",
    page_icon="📊",
    layout="wide",
    initial_sidebar_state="expanded"
)

# カスタムCSS
st.markdown("""
<style>
    .main-header {
        background: linear-gradient(90deg, #1f77b4 0%, #17a2b8 100%);
        padding: 2rem;
        border-radius: 15px;
        color: white;
        text-align: center;
        margin-bottom: 2rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .kpi-card {
        background: white;
        padding: 1.5rem;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        text-align: center;
        margin: 1rem 0;
        border-left: 4px solid #1f77b4;
    }
    
    .insight-box {
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        padding: 1.5rem;
        border-radius: 10px;
        margin: 1rem 0;
        border-left: 4px solid #28a745;
    }
    
    .metric-positive { color: #28a745; }
    .metric-negative { color: #dc3545; }
    .metric-neutral { color: #6c757d; }
</style>
""", unsafe_allow_html=True)

class SalesAnalyzer:
    """売上分析クラス"""
    
    def __init__(self):
        self.data = None
        self.processed_data = None
    
    @st.cache_data
    def generate_sales_data(_self, days=730, seed=42):
        """リアルな売上データを生成"""
        np.random.seed(seed)
        
        # 基準日から過去N日分のデータを生成
        end_date = datetime.now().date()
        start_date = end_date - timedelta(days=days)
        dates = pd.date_range(start_date, end_date, freq='D')
        
        n_records = len(dates) * np.random.randint(50, 200)  # 日あたり50-200件の売上
        
        # 基本データ生成
        data = {
            'date': np.random.choice(dates, n_records),
            'product_category': np.random.choice(
                ['Electronics', 'Clothing', 'Home & Garden', 'Sports', 'Books', 'Beauty'], 
                n_records, 
                p=[0.25, 0.20, 0.15, 0.15, 0.15, 0.10]
            ),
            'region': np.random.choice(
                ['Tokyo', 'Osaka', 'Nagoya', 'Fukuoka', 'Sendai', 'Hiroshima'], 
                n_records,
                p=[0.30, 0.20, 0.15, 0.15, 0.10, 0.10]
            ),
            'customer_segment': np.random.choice(
                ['Premium', 'Standard', 'Budget'], 
                n_records,
                p=[0.20, 0.50, 0.30]
            ),
            'sales_channel': np.random.choice(
                ['Online', 'Store', 'Mobile App', 'Phone'], 
                n_records,
                p=[0.45, 0.30, 0.20, 0.05]
            )
        }
        
        df = pd.DataFrame(data)
        
        # 売上金額の生成（カテゴリとセグメントに基づく）
        base_price = {
            'Electronics': 50000, 'Clothing': 8000, 'Home & Garden': 15000,
            'Sports': 12000, 'Books': 2000, 'Beauty': 5000
        }
        
        segment_multiplier = {'Premium': 2.5, 'Standard': 1.0, 'Budget': 0.6}
        
        df['base_amount'] = df['product_category'].map(base_price)
        df['segment_multiplier'] = df['customer_segment'].map(segment_multiplier)
        df['amount'] = (df['base_amount'] * df['segment_multiplier'] * 
                       np.random.normal(1, 0.3, len(df))).clip(lower=100)
        
        # 季節性を追加
        df['month'] = pd.to_datetime(df['date']).dt.month
        seasonal_factor = 1 + 0.3 * np.sin(2 * np.pi * (df['month'] - 1) / 12)
        df['amount'] *= seasonal_factor
        
        # 曜日効果を追加
        df['weekday'] = pd.to_datetime(df['date']).dt.weekday
        weekend_factor = np.where(df['weekday'] >= 5, 1.2, 1.0)
        df['amount'] *= weekend_factor
        
        # 顧客ID生成
        df['customer_id'] = np.random.randint(1000, 9999, len(df))
        
        # 数量生成
        df['quantity'] = np.random.poisson(2, len(df)) + 1
        df['unit_price'] = (df['amount'] / df['quantity']).round(0)
        df['amount'] = df['amount'].round(0).astype(int)
        
        # 不要な列を削除
        df = df.drop(['base_amount', 'segment_multiplier'], axis=1)
        
        # 日付でソート
        df = df.sort_values('date').reset_index(drop=True)
        
        return df
    
    def load_data(self, days=730):
        """データを読み込み"""
        self.data = self.generate_sales_data(days)
        self.process_data()
        return self.data
    
    def process_data(self):
        """データを前処理"""
        df = self.data.copy()
        
        # 日付変換
        df['date'] = pd.to_datetime(df['date'])
        df['year'] = df['date'].dt.year
        df['month'] = df['date'].dt.month
        df['quarter'] = df['date'].dt.quarter
        df['weekday'] = df['date'].dt.weekday
        df['week'] = df['date'].dt.isocalendar().week
        
        # 月名追加
        month_names = {1: '1月', 2: '2月', 3: '3月', 4: '4月', 5: '5月', 6: '6月',
                      7: '7月', 8: '8月', 9: '9月', 10: '10月', 11: '11月', 12: '12月'}
        df['month_name'] = df['month'].map(month_names)
        
        # 曜日名追加
        weekday_names = {0: '月', 1: '火', 2: '水', 3: '木', 4: '金', 5: '土', 6: '日'}
        df['weekday_name'] = df['weekday'].map(weekday_names)
        
        self.processed_data = df
    
    def calculate_kpis(self, df):
        """KPI計算"""
        today = datetime.now().date()
        yesterday = today - timedelta(days=1)
        last_month = today - timedelta(days=30)
        
        # 全期間
        total_sales = df['amount'].sum()
        total_orders = len(df)
        avg_order_value = df['amount'].mean()
        unique_customers = df['customer_id'].nunique()
        
        # 昨日との比較
        yesterday_data = df[df['date'].dt.date == yesterday]
        prev_day_data = df[df['date'].dt.date == (yesterday - timedelta(days=1))]
        
        daily_sales = yesterday_data['amount'].sum()
        prev_daily_sales = prev_day_data['amount'].sum()
        daily_change = ((daily_sales - prev_daily_sales) / prev_daily_sales * 100) if prev_daily_sales > 0 else 0
        
        # 月次比較
        current_month_data = df[df['date'].dt.date >= last_month]
        prev_month_start = last_month - timedelta(days=30)
        prev_month_data = df[(df['date'].dt.date >= prev_month_start) & (df['date'].dt.date < last_month)]
        
        monthly_sales = current_month_data['amount'].sum()
        prev_monthly_sales = prev_month_data['amount'].sum()
        monthly_change = ((monthly_sales - prev_monthly_sales) / prev_monthly_sales * 100) if prev_monthly_sales > 0 else 0
        
        return {
            'total_sales': total_sales,
            'total_orders': total_orders,
            'avg_order_value': avg_order_value,
            'unique_customers': unique_customers,
            'daily_sales': daily_sales,
            'daily_change': daily_change,
            'monthly_sales': monthly_sales,
            'monthly_change': monthly_change
        }
    
    def sales_forecast(self, df, days_ahead=30):
        """簡単な売上予測"""
        # 日別売上を集計
        daily_sales = df.groupby('date')['amount'].sum().reset_index()
        daily_sales['days_since_start'] = (daily_sales['date'] - daily_sales['date'].min()).dt.days
        
        # 線形回帰で予測
        X = daily_sales[['days_since_start']]
        y = daily_sales['amount']
        
        model = LinearRegression()
        model.fit(X, y)
        
        # 予測
        last_day = daily_sales['days_since_start'].max()
        future_days = np.arange(last_day + 1, last_day + days_ahead + 1).reshape(-1, 1)
        future_dates = [daily_sales['date'].max() + timedelta(days=i) for i in range(1, days_ahead + 1)]
        
        predictions = model.predict(future_days)
        
        # 予測精度
        train_pred = model.predict(X)
        r2 = r2_score(y, train_pred)
        mae = mean_absolute_error(y, train_pred)
        
        forecast_df = pd.DataFrame({
            'date': future_dates,
            'predicted_sales': predictions.clip(lower=0)  # 負の値を防ぐ
        })
        
        return forecast_df, {'r2_score': r2, 'mae': mae}

def main():
    """メイン関数"""
    # ヘッダー
    st.markdown("""
    <div class="main-header">
        <h1>📊 売上分析ダッシュボード</h1>
        <p>リアルタイム売上監視・分析・予測システム</p>
    </div>
    """, unsafe_allow_html=True)
    
    # データ分析器の初期化
    analyzer = SalesAnalyzer()
    
    # サイドバー設定
    with st.sidebar:
        st.header("⚙️ 設定")
        
        # データ期間設定
        data_period = st.selectbox(
            "データ期間",
            [365, 730, 1095],
            index=1,
            format_func=lambda x: f"{x}日 ({x//365}年)"
        )
        
        # フィルタリング設定
        st.subheader("🔍 フィルタ")
        
        # データ読み込み
        with st.spinner("データを読み込み中..."):
            df = analyzer.load_data(data_period)
        
        # 日付範囲
        date_range = st.date_input(
            "日付範囲",
            value=(df['date'].min().date(), df['date'].max().date()),
            min_value=df['date'].min().date(),
            max_value=df['date'].max().date()
        )
        
        # カテゴリフィルタ
        categories = st.multiselect(
            "商品カテゴリ",
            options=df['product_category'].unique(),
            default=df['product_category'].unique()
        )
        
        # 地域フィルタ
        regions = st.multiselect(
            "地域",
            options=df['region'].unique(),
            default=df['region'].unique()
        )
        
        # セグメントフィルタ
        segments = st.multiselect(
            "顧客セグメント",
            options=df['customer_segment'].unique(),
            default=df['customer_segment'].unique()
        )
    
    # データフィルタリング
    if len(date_range) == 2:
        start_date, end_date = date_range
        filtered_df = analyzer.processed_data[
            (analyzer.processed_data['date'].dt.date >= start_date) &
            (analyzer.processed_data['date'].dt.date <= end_date) &
            (analyzer.processed_data['product_category'].isin(categories)) &
            (analyzer.processed_data['region'].isin(regions)) &
            (analyzer.processed_data['customer_segment'].isin(segments))
        ]
    else:
        filtered_df = analyzer.processed_data
    
    if filtered_df.empty:
        st.error("フィルタ条件に該当するデータがありません")
        return
    
    # KPI表示
    st.subheader("📈 重要指標 (KPI)")
    
    kpis = analyzer.calculate_kpis(filtered_df)
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        delta_color = "normal" if kpis['daily_change'] >= 0 else "inverse"
        st.metric(
            "総売上", 
            f"¥{kpis['total_sales']:,.0f}",
            delta=f"{kpis['daily_change']:+.1f}% (日次)"
        )
    
    with col2:
        st.metric(
            "総注文数", 
            f"{kpis['total_orders']:,}",
            delta=f"{kpis['monthly_change']:+.1f}% (月次)"
        )
    
    with col3:
        st.metric(
            "平均注文額", 
            f"¥{kpis['avg_order_value']:,.0f}"
        )
    
    with col4:
        st.metric(
            "ユニーク顧客数", 
            f"{kpis['unique_customers']:,}"
        )
    
    # メインダッシュボード
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["📊 概要", "📈 トレンド", "🗺️ 地域分析", "👥 顧客分析", "🔮 売上予測"])
    
    with tab1:
        show_overview_dashboard(filtered_df)
    
    with tab2:
        show_trend_analysis(filtered_df)
    
    with tab3:
        show_regional_analysis(filtered_df)
    
    with tab4:
        show_customer_analysis(filtered_df)
    
    with tab5:
        show_sales_forecast(analyzer, filtered_df)

def show_overview_dashboard(df):
    """概要ダッシュボード"""
    st.subheader("📊 売上概要")
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        # 日別売上推移
        daily_sales = df.groupby('date')['amount'].sum().reset_index()
        
        fig_daily = px.line(
            daily_sales, 
            x='date', 
            y='amount',
            title='日別売上推移',
            labels={'amount': '売上 (¥)', 'date': '日付'}
        )
        fig_daily.update_traces(line_color='#1f77b4', line_width=3)
        fig_daily.update_layout(height=400, showlegend=False)
        st.plotly_chart(fig_daily, use_container_width=True)
    
    with col2:
        # カテゴリ別売上円グラフ
        category_sales = df.groupby('product_category')['amount'].sum().reset_index()
        
        fig_category = px.pie(
            category_sales,
            values='amount',
            names='product_category',
            title='カテゴリ別売上構成'
        )
        fig_category.update_layout(height=400)
        st.plotly_chart(fig_category, use_container_width=True)
    
    # 詳細統計
    col1, col2 = st.columns(2)
    
    with col1:
        st.write("**月別売上トップ5**")
        monthly_sales = df.groupby('month_name')['amount'].sum().sort_values(ascending=False).head(5)
        for month, sales in monthly_sales.items():
            st.write(f"• {month}: ¥{sales:,.0f}")
    
    with col2:
        st.write("**地域別売上トップ5**")
        region_sales = df.groupby('region')['amount'].sum().sort_values(ascending=False).head(5)
        for region, sales in region_sales.items():
            st.write(f"• {region}: ¥{sales:,.0f}")

def show_trend_analysis(df):
    """トレンド分析"""
    st.subheader("📈 売上トレンド分析")
    
    # 時系列分解
    col1, col2 = st.columns(2)
    
    with col1:
        period_type = st.selectbox("集計期間", ["日別", "週別", "月別"])
    
    with col2:
        moving_avg_period = st.slider("移動平均期間", 7, 60, 30)
    
    # データ集計
    if period_type == "日別":
        time_series = df.groupby('date')['amount'].sum().reset_index()
        time_series['period'] = time_series['date']
    elif period_type == "週別":
        df['week_start'] = df['date'] - pd.to_timedelta(df['date'].dt.dayofweek, unit='d')
        time_series = df.groupby('week_start')['amount'].sum().reset_index()
        time_series['period'] = time_series['week_start']
    else:  # 月別
        df['month_start'] = df['date'].dt.to_period('M').dt.start_time
        time_series = df.groupby('month_start')['amount'].sum().reset_index()
        time_series['period'] = time_series['month_start']
    
    # 移動平均計算
    time_series['moving_avg'] = time_series['amount'].rolling(window=moving_avg_period).mean()
    
    # トレンドグラフ
    fig_trend = go.Figure()
    
    fig_trend.add_trace(go.Scatter(
        x=time_series['period'],
        y=time_series['amount'],
        mode='lines',
        name=f'{period_type}売上',
        line=dict(color='lightblue', width=1),
        opacity=0.7
    ))
    
    fig_trend.add_trace(go.Scatter(
        x=time_series['period'],
        y=time_series['moving_avg'],
        mode='lines',
        name=f'{moving_avg_period}期間移動平均',
        line=dict(color='#1f77b4', width=3)
    ))
    
    fig_trend.update_layout(
        title=f'{period_type}売上推移',
        xaxis_title='期間',
        yaxis_title='売上 (¥)',
        height=500
    )
    
    st.plotly_chart(fig_trend, use_container_width=True)
    
    # 季節性分析
    st.subheader("📅 季節性分析")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # 月別平均売上
        monthly_avg = df.groupby('month_name')['amount'].mean().reindex(
            ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月']
        )
        
        fig_monthly = px.bar(
            x=monthly_avg.index,
            y=monthly_avg.values,
            title='月別平均売上',
            labels={'x': '月', 'y': '平均売上 (¥)'}
        )
        st.plotly_chart(fig_monthly, use_container_width=True)
    
    with col2:
        # 曜日別平均売上
        weekday_avg = df.groupby('weekday_name')['amount'].mean().reindex(
            ['月', '火', '水', '木', '金', '土', '日']
        )
        
        fig_weekday = px.bar(
            x=weekday_avg.index,
            y=weekday_avg.values,
            title='曜日別平均売上',
            labels={'x': '曜日', 'y': '平均売上 (¥)'}
        )
        st.plotly_chart(fig_weekday, use_container_width=True)

def show_regional_analysis(df):
    """地域分析"""
    st.subheader("🗺️ 地域別売上分析")
    
    # 地域別概要
    region_summary = df.groupby('region').agg({
        'amount': ['sum', 'mean', 'count'],
        'customer_id': 'nunique',
        'quantity': 'sum'
    }).round(0)
    
    region_summary.columns = ['総売上', '平均売上', '注文数', 'ユニーク顧客数', '総数量']
    region_summary['売上シェア(%)'] = (region_summary['総売上'] / region_summary['総売上'].sum() * 100).round(1)
    
    st.dataframe(region_summary, use_container_width=True)
    
    col1, col2 = st.columns(2)
    
    with col1:
        # 地域別売上
        fig_region_bar = px.bar(
            x=region_summary.index,
            y=region_summary['総売上'],
            title='地域別総売上',
            labels={'x': '地域', 'y': '総売上 (¥)'},
            color=region_summary['総売上'],
            color_continuous_scale='Blues'
        )
        st.plotly_chart(fig_region_bar, use_container_width=True)
    
    with col2:
        # 地域×カテゴリヒートマップ
        heatmap_data = df.groupby(['region', 'product_category'])['amount'].sum().unstack(fill_value=0)
        
        fig_heatmap = px.imshow(
            heatmap_data,
            title='地域×カテゴリ売上ヒートマップ',
            color_continuous_scale='Blues',
            aspect='auto'
        )
        st.plotly_chart(fig_heatmap, use_container_width=True)

def show_customer_analysis(df):
    """顧客分析"""
    st.subheader("👥 顧客セグメント分析")
    
    # セグメント別分析
    segment_analysis = df.groupby('customer_segment').agg({
        'amount': ['sum', 'mean', 'count'],
        'customer_id': 'nunique',
        'unit_price': 'mean'
    }).round(0)
    
    segment_analysis.columns = ['総売上', '平均注文額', '注文数', 'ユニーク顧客数', '平均単価']
    segment_analysis['顧客あたり売上'] = (segment_analysis['総売上'] / segment_analysis['ユニーク顧客数']).round(0)
    
    st.dataframe(segment_analysis, use_container_width=True)
    
    col1, col2 = st.columns(2)
    
    with col1:
        # セグメント別売上分布
        fig_segment = px.box(
            df,
            x='customer_segment',
            y='amount',
            title='セグメント別売上分布',
            labels={'customer_segment': '顧客セグメント', 'amount': '売上 (¥)'}
        )
        st.plotly_chart(fig_segment, use_container_width=True)
    
    with col2:
        # チャネル別売上
        channel_sales = df.groupby('sales_channel')['amount'].sum().reset_index()
        
        fig_channel = px.pie(
            channel_sales,
            values='amount',
            names='sales_channel',
            title='販売チャネル別売上構成'
        )
        st.plotly_chart(fig_channel, use_container_width=True)
    
    # RFM分析（簡易版）
    st.subheader("🎯 顧客価値分析 (RFM)")
    
    # 顧客別統計
    customer_stats = df.groupby('customer_id').agg({
        'date': 'max',  # 最終購入日（Recency）
        'amount': ['sum', 'count']  # 総購入金額（Monetary）、購入頻度（Frequency）
    }).round(0)
    
    customer_stats.columns = ['last_purchase_date', 'total_amount', 'purchase_frequency']
    
    # Recency計算（最終購入からの日数）
    customer_stats['recency'] = (df['date'].max() - customer_stats['last_purchase_date']).dt.days
    
    # スコア化（5段階）
    customer_stats['r_score'] = pd.qcut(customer_stats['recency'], 5, labels=[5,4,3,2,1])
    customer_stats['f_score'] = pd.qcut(customer_stats['purchase_frequency'], 5, labels=[1,2,3,4,5])
    customer_stats['m_score'] = pd.qcut(customer_stats['total_amount'], 5, labels=[1,2,3,4,5])
    
    # RFMスコア
    customer_stats['rfm_score'] = (customer_stats['r_score'].astype(int) + 
                                  customer_stats['f_score'].astype(int) + 
                                  customer_stats['m_score'].astype(int))
    
    # セグメント分類
    def categorize_customer(row):
        if row['rfm_score'] >= 12:
            return 'Champions'
        elif row['rfm_score'] >= 9:
            return 'Loyal Customers'
        elif row['rfm_score'] >= 6:
            return 'Potential Loyalists'
        else:
            return 'At Risk'
    
    customer_stats['customer_category'] = customer_stats.apply(categorize_customer, axis=1)
    
    # カテゴリ別統計
    category_stats = customer_stats.groupby('customer_category').agg({
        'total_amount': ['count', 'mean'],
        'purchase_frequency': 'mean',
        'recency': 'mean'
    }).round(1)
    
    category_stats.columns = ['顧客数', '平均購入額', '平均購入頻度', '平均Recency']
    
    st.dataframe(category_stats, use_container_width=True)

def show_sales_forecast(analyzer, df):
    """売上予測"""
    st.subheader("🔮 売上予測")
    
    col1, col2 = st.columns([1, 2])
    
    with col1:
        forecast_days = st.slider("予測期間（日）", 7, 90, 30)
        
        if st.button("🚀 予測実行", type="primary"):
            with st.spinner("予測計算中..."):
                forecast_df, metrics = analyzer.sales_forecast(df, forecast_days)
                
                st.session_state.forecast_data = forecast_df
                st.session_state.forecast_metrics = metrics
    
    if 'forecast_data' in st.session_state:
        forecast_df = st.session_state.forecast_data
        metrics = st.session_state.forecast_metrics
        
        with col2:
            st.write("**予測精度**")
            col2_1, col2_2 = st.columns(2)
            with col2_1:
                st.metric("R² Score", f"{metrics['r2_score']:.3f}")
            with col2_2:
                st.metric("MAE", f"¥{metrics['mae']:,.0f}")
        
        # 予測グラフ
        # 過去30日の実績
        recent_data = df.groupby('date')['amount'].sum().reset_index().tail(30)
        
        fig_forecast = go.Figure()
        
        # 実績データ
        fig_forecast.add_trace(go.Scatter(
            x=recent_data['date'],
            y=recent_data['amount'],
            mode='lines+markers',
            name='実績',
            line=dict(color='#1f77b4', width=3)
        ))
        
        # 予測データ
        fig_forecast.add_trace(go.Scatter(
            x=forecast_df['date'],
            y=forecast_df['predicted_sales'],
            mode='lines+markers',
            name='予測',
            line=dict(color='#ff7f0e', width=3, dash='dash')
        ))
        
        fig_forecast.update_layout(
            title=f'売上予測 (今後{forecast_days}日間)',
            xaxis_title='日付',
            yaxis_title='売上 (¥)',
            height=500
        )
        
        st.plotly_chart(fig_forecast, use_container_width=True)
        
        # 予測サマリー
        total_predicted = forecast_df['predicted_sales'].sum()
        avg_daily_predicted = forecast_df['predicted_sales'].mean()
        
        col1, col2 = st.columns(2)
        with col1:
            st.metric("予測総売上", f"¥{total_predicted:,.0f}")
        with col2:
            st.metric("予測日平均売上", f"¥{avg_daily_predicted:,.0f}")

if __name__ == "__main__":
    main()</code></pre>
                        
                        <h6>実行と確認</h6>
                        <pre><code>pip install scikit-learn seaborn
streamlit run sales_dashboard.py</code></pre>
                        
                        <h6>期待される結果</h6>
                        <p>包括的なKPI監視、トレンド分析、地域分析、顧客セグメンテーション、売上予測を含む高度な売上分析ダッシュボードが表示されます。</p>
                    </div>

                    <!-- セクション2: 機械学習モデルのデプロイ -->
                    <h3 class="section-title">10.2 機械学習モデルのデプロイと可視化</h3>
                    <p>機械学習モデルを統合した予測アプリケーションを構築し、モデルの性能を可視化します。</p>

                    <div class="exercise-container">
                        <h5>実習 10-2: 機械学習予測アプリ</h5>
                        <p>複数の機械学習アルゴリズムを比較し、モデル性能を可視化する統合アプリケーションを開発します。</p>
                        
                        <h6>ml_prediction_app.py を作成</h6>
                        <pre><code>import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import plotly.figure_factory as ff
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.linear_model import LinearRegression, Ridge, Lasso
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.preprocessing import StandardScaler, LabelEncoder
import seaborn as sns
import matplotlib.pyplot as plt
import joblib
import io
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# ページ設定
st.set_page_config(
    page_title="ML予測アプリ",
    page_icon="🤖",
    layout="wide"
)

# カスタムCSS
st.markdown("""
<style>
    .ml-header {
        background: linear-gradient(90deg, #6a11cb 0%, #2575fc 100%);
        padding: 2rem;
        border-radius: 15px;
        color: white;
        text-align: center;
        margin-bottom: 2rem;
    }
    
    .model-card {
        background: white;
        padding: 1.5rem;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin: 1rem 0;
        border-left: 4px solid #6a11cb;
    }
    
    .metric-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1.5rem;
        border-radius: 10px;
        text-align: center;
        margin: 0.5rem 0;
    }
</style>
""", unsafe_allow_html=True)

class MLPredictor:
    """機械学習予測クラス"""
    
    def __init__(self):
        self.models = {
            'Linear Regression': LinearRegression(),
            'Random Forest': RandomForestRegressor(n_estimators=100, random_state=42),
            'Gradient Boosting': GradientBoostingRegressor(random_state=42),
            'Ridge Regression': Ridge(alpha=1.0),
            'Lasso Regression': Lasso(alpha=1.0),
            'SVR': SVR(kernel='rbf', C=1.0)
        }
        
        self.trained_models = {}
        self.scaler = StandardScaler()
        self.label_encoders = {}
    
    @st.cache_data
    def generate_housing_data(_self, n_samples=1000):
        """住宅価格データセットを生成"""
        np.random.seed(42)
        
        # 基本特徴量
        area = np.random.normal(100, 30, n_samples).clip(30, 300)  # 面積
        rooms = np.random.poisson(3, n_samples) + 1  # 部屋数
        age = np.random.exponential(15, n_samples).clip(0, 50)  # 築年数
        
        # カテゴリカル特徴量
        locations = ['都心', '郊外', '駅近', '住宅街']
        location = np.random.choice(locations, n_samples)
        
        building_types = ['マンション', '一戸建て', 'タウンハウス']
        building_type = np.random.choice(building_types, n_samples)
        
        # 価格計算（現実的な関係性を持たせる）
        base_price = 50000  # 基本価格（万円）
        
        # 面積効果
        area_effect = area * 500
        
        # 部屋数効果
        room_effect = rooms * 200
        
        # 築年数効果（古いほど安い）
        age_effect = -age * 30
        
        # 立地効果
        location_multiplier = {'都心': 1.5, '駅近': 1.3, '住宅街': 1.0, '郊外': 0.8}
        location_effect = [location_multiplier[loc] for loc in location]
        
        # 建物タイプ効果
        type_multiplier = {'マンション': 1.2, '一戸建て': 1.0, 'タウンハウス': 1.1}
        type_effect = [type_multiplier[t] for t in building_type]
        
        # 最終価格計算
        price = (base_price + area_effect + room_effect + age_effect) * np.array(location_effect) * np.array(type_effect)
        
        # ノイズ追加
        price += np.random.normal(0, price * 0.1)
        price = price.clip(1000, None)  # 最低価格1000万円
        
        # データフレーム作成
        df = pd.DataFrame({
            'area': area.round(1),
            'rooms': rooms,
            'age': age.round(1),
            'location': location,
            'building_type': building_type,
            'price': price.round(0).astype(int)
        })
        
        return df
    
    def preprocess_data(self, df, target_column='price'):
        """データ前処理"""
        # ターゲット変数を分離
        X = df.drop(columns=[target_column])
        y = df[target_column]
        
        # カテゴリカル変数をエンコード
        X_processed = X.copy()
        
        for column in X.select_dtypes(include=['object']).columns:
            if column not in self.label_encoders:
                self.label_encoders[column] = LabelEncoder()
                X_processed[column] = self.label_encoders[column].fit_transform(X[column])
            else:
                X_processed[column] = self.label_encoders[column].transform(X[column])
        
        return X_processed, y
    
    def train_models(self, X, y):
        """全モデルを訓練"""
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
        
        # 数値特徴量のスケーリング
        numeric_columns = X.select_dtypes(include=[np.number]).columns
        X_train_scaled = X_train.copy()
        X_test_scaled = X_test.copy()
        
        if len(numeric_columns) > 0:
            X_train_scaled[numeric_columns] = self.scaler.fit_transform(X_train[numeric_columns])
            X_test_scaled[numeric_columns] = self.scaler.transform(X_test[numeric_columns])
        
        results = {}
        
        for name, model in self.models.items():
            try:
                # SVRのみスケーリング済みデータを使用
                if name == 'SVR':
                    model.fit(X_train_scaled, y_train)
                    y_pred = model.predict(X_test_scaled)
                    self.trained_models[name] = (model, True)  # スケーリングフラグ
                else:
                    model.fit(X_train, y_train)
                    y_pred = model.predict(X_test)
                    self.trained_models[name] = (model, False)  # スケーリングフラグ
                
                # 評価指標計算
                mse = mean_squared_error(y_test, y_pred)
                mae = mean_absolute_error(y_test, y_pred)
                r2 = r2_score(y_test, y_pred)
                
                # クロスバリデーション
                if name == 'SVR':
                    cv_scores = cross_val_score(model, X_train_scaled, y_train, cv=5, scoring='r2')
                else:
                    cv_scores = cross_val_score(model, X_train, y_train, cv=5, scoring='r2')
                
                results[name] = {
                    'mse': mse,
                    'mae': mae,
                    'r2': r2,
                    'rmse': np.sqrt(mse),
                    'cv_mean': cv_scores.mean(),
                    'cv_std': cv_scores.std(),
                    'y_pred': y_pred,
                    'y_test': y_test
                }
                
            except Exception as e:
                st.error(f"モデル {name} の訓練中にエラー: {str(e)}")
                results[name] = None
        
        return results, X_test, y_test
    
    def get_feature_importance(self, model_name):
        """特徴量重要度を取得"""
        if model_name not in self.trained_models:
            return None
        
        model, _ = self.trained_models[model_name]
        
        if hasattr(model, 'feature_importances_'):
            return model.feature_importances_
        elif hasattr(model, 'coef_'):
            return np.abs(model.coef_)
        else:
            return None

def main():
    """メイン関数"""
    # ヘッダー
    st.markdown("""
    <div class="ml-header">
        <h1>🤖 機械学習予測アプリケーション</h1>
        <p>住宅価格予測による機械学習モデル比較システム</p>
    </div>
    """, unsafe_allow_html=True)
    
    # ML予測器の初期化
    predictor = MLPredictor()
    
    # サイドバー設定
    with st.sidebar:
        st.header("⚙️ 設定")
        
        # データ設定
        st.subheader("📊 データ設定")
        data_size = st.slider("データサイズ", 500, 5000, 1000)
        
        # モデル設定
        st.subheader("🤖 モデル設定")
        selected_models = st.multiselect(
            "訓練するモデル",
            options=list(predictor.models.keys()),
            default=list(predictor.models.keys())
        )
    
    # データ生成・読み込み
    with st.spinner("データを生成中..."):
        df = predictor.generate_housing_data(data_size)
    
    # データ概要表示
    st.subheader("📋 データセット概要")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("サンプル数", len(df))
    
    with col2:
        st.metric("特徴量数", len(df.columns) - 1)
    
    with col3:
        avg_price = df['price'].mean()
        st.metric("平均価格", f"{avg_price:,.0f}万円")
    
    with col4:
        price_std = df['price'].std()
        st.metric("価格標準偏差", f"{price_std:,.0f}万円")
    
    # データ表示
    tab1, tab2, tab3, tab4 = st.tabs(["📊 データ概要", "🤖 モデル訓練", "📈 結果比較", "🔮 予測実行"])
    
    with tab1:
        show_data_overview(df)
    
    with tab2:
        show_model_training(predictor, df, selected_models)
    
    with tab3:
        show_model_comparison(predictor)
    
    with tab4:
        show_prediction_interface(predictor, df)

def show_data_overview(df):
    """データ概要表示"""
    st.subheader("📊 データ分析")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # データプレビュー
        st.write("**データサンプル**")
        st.dataframe(df.head(10), use_container_width=True)
        
        # 基本統計
        st.write("**基本統計**")
        st.dataframe(df.describe(), use_container_width=True)
    
    with col2:
        # 価格分布
        fig_hist = px.histogram(
            df, 
            x='price',
            nbins=30,
            title='価格分布',
            labels={'price': '価格 (万円)', 'count': '頻度'}
        )
        st.plotly_chart(fig_hist, use_container_width=True)
    
    # 相関分析
    st.subheader("🔗 特徴量間の関係")
    
    # 数値特徴量の相関
    numeric_df = df.select_dtypes(include=[np.number])
    correlation_matrix = numeric_df.corr()
    
    fig_corr = px.imshow(
        correlation_matrix,
        title='特徴量相関マトリックス',
        color_continuous_scale='RdBu',
        zmin=-1,
        zmax=1
    )
    st.plotly_chart(fig_corr, use_container_width=True)
    
    # 散布図
    col1, col2 = st.columns(2)
    
    with col1:
        fig_scatter1 = px.scatter(
            df,
            x='area',
            y='price',
            color='location',
            title='面積 vs 価格',
            labels={'area': '面積 (㎡)', 'price': '価格 (万円)'}
        )
        st.plotly_chart(fig_scatter1, use_container_width=True)
    
    with col2:
        fig_scatter2 = px.scatter(
            df,
            x='age',
            y='price',
            color='building_type',
            title='築年数 vs 価格',
            labels={'age': '築年数', 'price': '価格 (万円)'}
        )
        st.plotly_chart(fig_scatter2, use_container_width=True)

def show_model_training(predictor, df, selected_models):
    """モデル訓練表示"""
    st.subheader("🤖 モデル訓練")
    
    if st.button("🚀 モデル訓練開始", type="primary"):
        # モデルを選択されたもののみに制限
        predictor.models = {k: v for k, v in predictor.models.items() if k in selected_models}
        
        with st.spinner("モデルを訓練中..."):
            # データ前処理
            X, y = predictor.preprocess_data(df)
            
            # モデル訓練
            results, X_test, y_test = predictor.train_models(X, y)
            
            # 結果をセッション状態に保存
            st.session_state.training_results = results
            st.session_state.X_test = X_test
            st.session_state.y_test = y_test
            st.session_state.feature_names = X.columns.tolist()
        
        st.success("✅ モデル訓練が完了しました！")
    
    # 訓練済みモデルの表示
    if 'training_results' in st.session_state:
        results = st.session_state.training_results
        
        st.write("**訓練結果**")
        
        results_df = []
        for model_name, result in results.items():
            if result is not None:
                results_df.append({
                    'モデル': model_name,
                    'R² Score': f"{result['r2']:.4f}",
                    'RMSE': f"{result['rmse']:.0f}",
                    'MAE': f"{result['mae']:.0f}",
                    'CV Score': f"{result['cv_mean']:.4f} (±{result['cv_std']:.4f})"
                })
        
        if results_df:
            results_table = pd.DataFrame(results_df)
            st.dataframe(results_table, use_container_width=True, hide_index=True)

def show_model_comparison(predictor):
    """モデル比較表示"""
    st.subheader("📈 モデル性能比較")
    
    if 'training_results' not in st.session_state:
        st.info("まず「モデル訓練」タブでモデルを訓練してください。")
        return
    
    results = st.session_state.training_results
    
    # 性能指標比較
    col1, col2 = st.columns(2)
    
    with col1:
        # R²スコア比較
        r2_scores = {name: result['r2'] for name, result in results.items() if result is not None}
        
        fig_r2 = px.bar(
            x=list(r2_scores.keys()),
            y=list(r2_scores.values()),
            title='R² Score 比較',
            labels={'x': 'モデル', 'y': 'R² Score'},
            color=list(r2_scores.values()),
            color_continuous_scale='viridis'
        )
        st.plotly_chart(fig_r2, use_container_width=True)
    
    with col2:
        # RMSE比較
        rmse_scores = {name: result['rmse'] for name, result in results.items() if result is not None}
        
        fig_rmse = px.bar(
            x=list(rmse_scores.keys()),
            y=list(rmse_scores.values()),
            title='RMSE 比較',
            labels={'x': 'モデル', 'y': 'RMSE'},
            color=list(rmse_scores.values()),
            color_continuous_scale='viridis_r'
        )
        st.plotly_chart(fig_rmse, use_container_width=True)
    
    # 予測値 vs 実際値の散布図
    st.subheader("🎯 予測精度の可視化")
    
    selected_model = st.selectbox(
        "表示するモデル",
        options=[name for name in results.keys() if results[name] is not None]
    )
    
    if selected_model and results[selected_model] is not None:
        result = results[selected_model]
        
        col1, col2 = st.columns(2)
        
        with col1:
            # 予測値 vs 実際値
            fig_pred = px.scatter(
                x=result['y_test'],
                y=result['y_pred'],
                title=f'{selected_model}: 予測値 vs 実際値',
                labels={'x': '実際値', 'y': '予測値'}
            )
            
            # 完全予測線
            min_val = min(result['y_test'].min(), result['y_pred'].min())
            max_val = max(result['y_test'].max(), result['y_pred'].max())
            fig_pred.add_shape(
                type="line",
                x0=min_val, y0=min_val,
                x1=max_val, y1=max_val,
                line=dict(color="red", dash="dash")
            )
            
            st.plotly_chart(fig_pred, use_container_width=True)
        
        with col2:
            # 残差プロット
            residuals = result['y_test'] - result['y_pred']
            
            fig_residuals = px.scatter(
                x=result['y_pred'],
                y=residuals,
                title=f'{selected_model}: 残差プロット',
                labels={'x': '予測値', 'y': '残差'}
            )
            
            # ゼロライン
            fig_residuals.add_hline(y=0, line_dash="dash", line_color="red")
            
            st.plotly_chart(fig_residuals, use_container_width=True)
    
    # 特徴量重要度
    st.subheader("🔍 特徴量重要度")
    
    importance = predictor.get_feature_importance(selected_model)
    
    if importance is not None:
        feature_names = st.session_state.feature_names
        importance_df = pd.DataFrame({
            'feature': feature_names,
            'importance': importance
        }).sort_values('importance', ascending=False)
        
        fig_importance = px.bar(
            importance_df,
            x='importance',
            y='feature',
            orientation='h',
            title=f'{selected_model}: 特徴量重要度',
            labels={'importance': '重要度', 'feature': '特徴量'}
        )
        
        st.plotly_chart(fig_importance, use_container_width=True)

def show_prediction_interface(predictor, df):
    """予測インターフェース"""
    st.subheader("🔮 住宅価格予測")
    
    if 'training_results' not in st.session_state:
        st.info("まず「モデル訓練」タブでモデルを訓練してください。")
        return
    
    results = st.session_state.training_results
    available_models = [name for name in results.keys() if results[name] is not None]
    
    if not available_models:
        st.error("利用可能な訓練済みモデルがありません。")
        return
    
    # 予測用入力
    st.write("**物件情報を入力してください**")
    
    col1, col2 = st.columns(2)
    
    with col1:
        area = st.number_input("面積 (㎡)", min_value=30.0, max_value=300.0, value=100.0)
        rooms = st.number_input("部屋数", min_value=1, max_value=10, value=3)
        age = st.number_input("築年数", min_value=0.0, max_value=50.0, value=10.0)
    
    with col2:
        location = st.selectbox("立地", df['location'].unique())
        building_type = st.selectbox("建物タイプ", df['building_type'].unique())
        selected_model = st.selectbox("使用するモデル", available_models)
    
    if st.button("💰 価格を予測", type="primary"):
        # 入力データの準備
        input_data = pd.DataFrame({
            'area': [area],
            'rooms': [rooms],
            'age': [age],
            'location': [location],
            'building_type': [building_type]
        })
        
        try:
            # データ前処理
            X_input, _ = predictor.preprocess_data(input_data, target_column='price')
            
            # モデルによる予測
            model, use_scaling = predictor.trained_models[selected_model]
            
            if use_scaling:
                # 数値列のみスケーリング
                numeric_columns = X_input.select_dtypes(include=[np.number]).columns
                X_input_scaled = X_input.copy()
                if len(numeric_columns) > 0:
                    X_input_scaled[numeric_columns] = predictor.scaler.transform(X_input[numeric_columns])
                prediction = model.predict(X_input_scaled)
            else:
                prediction = model.predict(X_input)
            
            # 結果表示
            predicted_price = prediction[0]
            
            st.markdown(f"""
            <div class="metric-card">
                <h3>予測価格</h3>
                <h1>{predicted_price:,.0f}万円</h1>
                <p>モデル: {selected_model}</p>
            </div>
            """, unsafe_allow_html=True)
            
            # 類似物件との比較
            st.subheader("📊 類似物件との価格比較")
            
            # 類似条件での価格範囲を算出
            similar_properties = df[
                (abs(df['area'] - area) <= 20) &
                (df['rooms'] == rooms) &
                (df['location'] == location)
            ]
            
            if len(similar_properties) > 0:
                price_stats = similar_properties['price'].describe()
                
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.metric("最低価格", f"{price_stats['min']:,.0f}万円")
                
                with col2:
                    st.metric("平均価格", f"{price_stats['mean']:,.0f}万円")
                
                with col3:
                    st.metric("最高価格", f"{price_stats['max']:,.0f}万円")
                
                # 価格分布と予測位置
                fig_comparison = px.histogram(
                    similar_properties,
                    x='price',
                    title='類似物件の価格分布',
                    labels={'price': '価格 (万円)', 'count': '件数'}
                )
                
                # 予測価格の位置を表示
                fig_comparison.add_vline(
                    x=predicted_price,
                    line_dash="dash",
                    line_color="red",
                    annotation_text=f"予測価格: {predicted_price:,.0f}万円"
                )
                
                st.plotly_chart(fig_comparison, use_container_width=True)
            
            else:
                st.info("類似条件の物件データが見つかりませんでした。")
        
        except Exception as e:
            st.error(f"予測中にエラーが発生しました: {str(e)}")

if __name__ == "__main__":
    main()</code></pre>
                        
                        <h6>実行と確認</h6>
                        <pre><code>streamlit run ml_prediction_app.py</code></pre>
                        
                        <h6>期待される結果</h6>
                        <p>複数の機械学習アルゴリズムを比較し、特徴量重要度分析、予測精度可視化、リアルタイム予測機能を含む包括的なML予測システムが表示されます。</p>
                    </div>

                    <!-- セクション3: データ探索ツール -->
                    <h3 class="section-title">10.3 データ探索ツールとレポート生成</h3>
                    <p>インタラクティブなデータ探索機能と自動レポート生成システムを構築します。</p>

                    <div class="info-box">
                        <h6>データ探索ツールの主要機能</h6>
                        <ul>
                            <li><strong>自動データプロファイリング</strong>: データ品質評価と統計サマリー</li>
                            <li><strong>インタラクティブ可視化</strong>: 動的なグラフ作成とフィルタリング</li>
                            <li><strong>異常値検出</strong>: 統計的手法による外れ値特定</li>
                            <li><strong>自動レポート生成</strong>: PDF/HTML形式での分析結果出力</li>
                        </ul>
                    </div>

                    <div class="exercise-container">
                        <h5>実習 10-3: 総合データ探索・レポート生成システム</h5>
                        <p>ファイルアップロード、自動分析、インタラクティブ探索、レポート生成を統合したシステムを開発します。</p>
                        
                        <h6>data_explorer.py を作成</h6>
                        <pre><code>import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import seaborn as sns
import matplotlib.pyplot as plt
from datetime import datetime
import io
import base64
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
import warnings
warnings.filterwarnings('ignore')

# ページ設定
st.set_page_config(
    page_title="データ探索ツール",
    page_icon="🔍",
    layout="wide"
)

# カスタムCSS
st.markdown("""
<style>
    .explorer-header {
        background: linear-gradient(90deg, #ff6b6b 0%, #4ecdc4 100%);
        padding: 2rem;
        border-radius: 15px;
        color: white;
        text-align: center;
        margin-bottom: 2rem;
    }
    
    .analysis-card {
        background: white;
        padding: 1.5rem;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin: 1rem 0;
        border-left: 4px solid #ff6b6b;
    }
    
    .insight-highlight {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1rem;
        border-radius: 8px;
        margin: 1rem 0;
    }
</style>
""", unsafe_allow_html=True)

class DataExplorer:
    """データ探索クラス"""
    
    def __init__(self):
        self.data = None
        self.analysis_results = {}
    
    def load_data(self, uploaded_file=None, sample_data_type=None):
        """データ読み込み"""
        if uploaded_file is not None:
            try:
                if uploaded_file.name.endswith('.csv'):
                    self.data = pd.read_csv(uploaded_file)
                elif uploaded_file.name.endswith(('.xlsx', '.xls')):
                    self.data = pd.read_excel(uploaded_file)
                else:
                    st.error("サポートされていないファイル形式です")
                    return False
                
                st.success(f"ファイルを正常に読み込みました: {uploaded_file.name}")
                return True
            
            except Exception as e:
                st.error(f"ファイル読み込みエラー: {str(e)}")
                return False
        
        elif sample_data_type:
            self.data = self.generate_sample_data(sample_data_type)
            return True
        
        return False
    
    @st.cache_data
    def generate_sample_data(_self, data_type="sales"):
        """サンプルデータ生成"""
        np.random.seed(42)
        
        if data_type == "sales":
            n = 1000
            dates = pd.date_range('2022-01-01', periods=n, freq='D')
            
            data = {
                'date': np.random.choice(dates, n),
                'product': np.random.choice(['Product_A', 'Product_B', 'Product_C', 'Product_D'], n),
                'category': np.random.choice(['Electronics', 'Clothing', 'Home'], n),
                'region': np.random.choice(['North', 'South', 'East', 'West'], n),
                'sales_amount': np.random.lognormal(mean=8, sigma=1, size=n),
                'quantity': np.random.poisson(lam=3, size=n) + 1,
                'customer_age': np.random.normal(35, 12, n).clip(18, 80),
                'discount': np.random.uniform(0, 0.3, n)
            }
            
        elif data_type == "marketing":
            n = 1500
            
            data = {
                'campaign_id': [f'CAM_{i:04d}' for i in range(n)],
                'channel': np.random.choice(['Email', 'Social Media', 'TV', 'Radio', 'Print'], n),
                'budget': np.random.lognormal(mean=9, sigma=0.8, size=n),
                'impressions': np.random.lognormal(mean=10, sigma=1, size=n),
                'clicks': np.random.poisson(lam=50, size=n),
                'conversions': np.random.poisson(lam=5, size=n),
                'revenue': np.random.lognormal(mean=8, sigma=1.2, size=n),
                'target_age_group': np.random.choice(['18-25', '26-35', '36-45', '46-55', '55+'], n),
                'season': np.random.choice(['Spring', 'Summer', 'Fall', 'Winter'], n)
            }
            
        else:  # customer
            n = 800
            
            data = {
                'customer_id': [f'CUST_{i:05d}' for i in range(n)],
                'age': np.random.normal(40, 15, n).clip(18, 80),
                'income': np.random.lognormal(mean=10.5, sigma=0.6, size=n),
                'purchase_frequency': np.random.poisson(lam=12, size=n),
                'avg_order_value': np.random.lognormal(mean=6, sigma=0.8, size=n),
                'loyalty_score': np.random.beta(2, 5, n) * 100,
                'satisfaction': np.random.normal(7.5, 1.5, n).clip(1, 10),
                'segment': np.random.choice(['Premium', 'Standard', 'Budget'], n, p=[0.2, 0.5, 0.3]),
                'registration_date': pd.date_range('2020-01-01', periods=n, freq='2D')
            }
        
        return pd.DataFrame(data)
    
    def basic_analysis(self):
        """基本分析実行"""
        if self.data is None:
            return None
        
        df = self.data
        
        analysis = {
            'shape': df.shape,
            'dtypes': df.dtypes.to_dict(),
            'missing_values': df.isnull().sum().to_dict(),
            'missing_percentage': (df.isnull().sum() / len(df) * 100).round(2).to_dict(),
            'duplicates': df.duplicated().sum(),
            'memory_usage': df.memory_usage(deep=True).sum() / 1024**2  # MB
        }
        
        # 数値列の統計
        numeric_cols = df.select_dtypes(include=[np.number]).columns
        if len(numeric_cols) > 0:
            analysis['numeric_stats'] = df[numeric_cols].describe().to_dict()
        
        # カテゴリ列の統計
        categorical_cols = df.select_dtypes(include=['object']).columns
        if len(categorical_cols) > 0:
            cat_stats = {}
            for col in categorical_cols:
                cat_stats[col] = {
                    'unique_count': df[col].nunique(),
                    'top_value': df[col].mode().iloc[0] if len(df[col].mode()) > 0 else None,
                    'top_frequency': df[col].value_counts().iloc[0] if len(df) > 0 else 0
                }
            analysis['categorical_stats'] = cat_stats
        
        self.analysis_results['basic'] = analysis
        return analysis
    
    def detect_outliers(self, method='isolation_forest'):
        """異常値検出"""
        if self.data is None:
            return None
        
        numeric_cols = self.data.select_dtypes(include=[np.number]).columns
        
        if len(numeric_cols) == 0:
            return None
        
        X = self.data[numeric_cols].dropna()
        
        if method == 'isolation_forest':
            iso_forest = IsolationForest(contamination=0.1, random_state=42)
            outliers = iso_forest.fit_predict(X)
            outlier_scores = iso_forest.decision_function(X)
            
        elif method == 'statistical':
            # Z-score method
            scaler = StandardScaler()
            X_scaled = scaler.fit_transform(X)
            z_scores = np.abs(X_scaled)
            threshold = 3
            outliers = (z_scores > threshold).any(axis=1)
            outlier_scores = z_scores.max(axis=1)
        
        outlier_data = X.copy()
        outlier_data['is_outlier'] = outliers == -1 if method == 'isolation_forest' else outliers
        outlier_data['outlier_score'] = outlier_scores
        
        self.analysis_results['outliers'] = outlier_data
        return outlier_data
    
    def correlation_analysis(self):
        """相関分析"""
        if self.data is None:
            return None
        
        numeric_cols = self.data.select_dtypes(include=[np.number]).columns
        
        if len(numeric_cols) < 2:
            return None
        
        correlation_matrix = self.data[numeric_cols].corr()
        
        # 強い相関を特定
        strong_correlations = []
        for i in range(len(correlation_matrix.columns)):
            for j in range(i+1, len(correlation_matrix.columns)):
                corr_value = correlation_matrix.iloc[i, j]
                if abs(corr_value) > 0.7:  # 強い相関の閾値
                    strong_correlations.append({
                        'var1': correlation_matrix.columns[i],
                        'var2': correlation_matrix.columns[j],
                        'correlation': corr_value
                    })
        
        self.analysis_results['correlation'] = {
            'matrix': correlation_matrix,
            'strong_correlations': strong_correlations
        }
        
        return correlation_matrix, strong_correlations
    
    def generate_insights(self):
        """洞察の生成"""
        insights = []
        
        if 'basic' in self.analysis_results:
            basic = self.analysis_results['basic']
            
            # データ品質に関する洞察
            missing_cols = [col for col, pct in basic['missing_percentage'].items() if pct > 10]
            if missing_cols:
                insights.append(f"⚠️ 以下の列で10%以上の欠損値が検出されました: {', '.join(missing_cols)}")
            
            if basic['duplicates'] > 0:
                insights.append(f"🔄 {basic['duplicates']}件の重複レコードが見つかりました")
            
            # メモリ使用量
            if basic['memory_usage'] > 100:  # 100MB以上
                insights.append(f"💾 大容量データです ({basic['memory_usage']:.1f}MB)")
        
        if 'correlation' in self.analysis_results:
            strong_corrs = self.analysis_results['correlation']['strong_correlations']
            if strong_corrs:
                insights.append(f"🔗 {len(strong_corrs)}組の強い相関関係が見つかりました")
        
        if 'outliers' in self.analysis_results:
            outlier_count = self.analysis_results['outliers']['is_outlier'].sum()
            total_count = len(self.analysis_results['outliers'])
            outlier_percentage = (outlier_count / total_count) * 100
            
            if outlier_percentage > 5:
                insights.append(f"🎯 異常値が多く検出されました ({outlier_percentage:.1f}%)")
        
        return insights

def main():
    """メイン関数"""
    # ヘッダー
    st.markdown("""
    <div class="explorer-header">
        <h1>🔍 データ探索・分析ツール</h1>
        <p>データの自動分析・可視化・レポート生成システム</p>
    </div>
    """, unsafe_allow_html=True)
    
    # データエクスプローラーの初期化
    explorer = DataExplorer()
    
    # サイドバー設定
    with st.sidebar:
        st.header("📂 データソース")
        
        data_source = st.radio(
            "データの選択",
            ["ファイルアップロード", "サンプルデータ"]
        )
        
        if data_source == "ファイルアップロード":
            uploaded_file = st.file_uploader(
                "ファイルを選択",
                type=['csv', 'xlsx', 'xls'],
                help="CSV, Excel形式をサポート"
            )
            
            if uploaded_file and st.button("📊 データを読み込み"):
                if explorer.load_data(uploaded_file=uploaded_file):
                    st.success("データを読み込みました！")
        
        else:
            sample_type = st.selectbox(
                "サンプルデータタイプ",
                ["sales", "marketing", "customer"]
            )
            
            if st.button("📊 サンプルデータを生成"):
                if explorer.load_data(sample_data_type=sample_type):
                    st.success("サンプルデータを生成しました！")
        
        # 分析設定
        if explorer.data is not None:
            st.header("⚙️ 分析設定")
            
            outlier_method = st.selectbox(
                "異常値検出手法",
                ["isolation_forest", "statistical"]
            )
    
    # データが読み込まれている場合の処理
    if explorer.data is not None:
        # タブで機能を分割
        tab1, tab2, tab3, tab4, tab5 = st.tabs([
            "📋 基本情報", "📊 可視化", "🔍 詳細分析", "⚠️ 異常値検出", "📄 レポート生成"
        ])
        
        with tab1:
            show_basic_info(explorer)
        
        with tab2:
            show_visualization(explorer)
        
        with tab3:
            show_detailed_analysis(explorer)
        
        with tab4:
            show_outlier_detection(explorer, outlier_method)
        
        with tab5:
            show_report_generation(explorer)
    
    else:
        st.info("👆 まず左のサイドバーからデータを読み込んでください")

def show_basic_info(explorer):
    """基本情報表示"""
    st.subheader("📋 データセット基本情報")
    
    # 基本分析実行
    analysis = explorer.basic_analysis()
    
    if analysis:
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("行数", f"{analysis['shape'][0]:,}")
        
        with col2:
            st.metric("列数", analysis['shape'][1])
        
        with col3:
            st.metric("重複行", analysis['duplicates'])
        
        with col4:
            st.metric("メモリ使用量", f"{analysis['memory_usage']:.1f} MB")
        
        # データ型情報
        st.subheader("📊 データ型と欠損値")
        
        dtype_df = pd.DataFrame({
            '列名': list(analysis['dtypes'].keys()),
            'データ型': list(analysis['dtypes'].values()),
            '欠損値数': list(analysis['missing_values'].values()),
            '欠損率(%)': list(analysis['missing_percentage'].values())
        })
        
        st.dataframe(dtype_df, use_container_width=True, hide_index=True)
        
        # データプレビュー
        st.subheader("👀 データプレビュー")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("**最初の5行**")
            st.dataframe(explorer.data.head(), use_container_width=True)
        
        with col2:
            st.write("**最後の5行**")
            st.dataframe(explorer.data.tail(), use_container_width=True)
        
        # 統計サマリー
        if 'numeric_stats' in analysis:
            st.subheader("📈 数値列統計サマリー")
            
            numeric_stats_df = pd.DataFrame(analysis['numeric_stats']).T
            st.dataframe(numeric_stats_df, use_container_width=True)
        
        if 'categorical_stats' in analysis:
            st.subheader("🏷️ カテゴリ列統計サマリー")
            
            cat_stats = []
            for col, stats in analysis['categorical_stats'].items():
                cat_stats.append({
                    '列名': col,
                    'ユニーク数': stats['unique_count'],
                    '最頻値': stats['top_value'],
                    '最頻値の頻度': stats['top_frequency']
                })
            
            cat_stats_df = pd.DataFrame(cat_stats)
            st.dataframe(cat_stats_df, use_container_width=True, hide_index=True)

def show_visualization(explorer):
    """可視化表示"""
    st.subheader("📊 インタラクティブ可視化")
    
    df = explorer.data
    
    # 列選択
    numeric_cols = df.select_dtypes(include=[np.number]).columns.tolist()
    categorical_cols = df.select_dtypes(include=['object']).columns.tolist()
    
    col1, col2 = st.columns(2)
    
    with col1:
        chart_type = st.selectbox(
            "グラフタイプ",
            ["ヒストグラム", "散布図", "箱ひげ図", "相関ヒートマップ", "棒グラフ"]
        )
    
    with col2:
        if chart_type in ["ヒストグラム", "箱ひげ図"]:
            selected_col = st.selectbox("列を選択", numeric_cols)
        elif chart_type == "散布図":
            selected_cols = st.multiselect("列を選択（2つ）", numeric_cols, max_selections=2)
        elif chart_type == "棒グラフ":
            selected_col = st.selectbox("列を選択", categorical_cols)
    
    # グラフ生成
    if chart_type == "ヒストグラム" and selected_col:
        fig = px.histogram(
            df, 
            x=selected_col,
            title=f'{selected_col}の分布',
            nbins=30
        )
        st.plotly_chart(fig, use_container_width=True)
    
    elif chart_type == "散布図" and len(selected_cols) == 2:
        # カラー列選択
        color_col = st.selectbox("色分け列（オプション）", [None] + categorical_cols)
        
        fig = px.scatter(
            df,
            x=selected_cols[0],
            y=selected_cols[1],
            color=color_col,
            title=f'{selected_cols[0]} vs {selected_cols[1]}'
        )
        st.plotly_chart(fig, use_container_width=True)
    
    elif chart_type == "箱ひげ図" and selected_col:
        # グループ化列選択
        group_col = st.selectbox("グループ化列（オプション）", [None] + categorical_cols)
        
        if group_col:
            fig = px.box(df, x=group_col, y=selected_col, title=f'{group_col}別{selected_col}の分布')
        else:
            fig = px.box(df, y=selected_col, title=f'{selected_col}の分布')
        
        st.plotly_chart(fig, use_container_width=True)
    
    elif chart_type == "相関ヒートマップ" and len(numeric_cols) > 1:
        corr_matrix = df[numeric_cols].corr()
        
        fig = px.imshow(
            corr_matrix,
            title='相関ヒートマップ',
            color_continuous_scale='RdBu',
            zmin=-1,
            zmax=1
        )
        st.plotly_chart(fig, use_container_width=True)
    
    elif chart_type == "棒グラフ" and selected_col:
        value_counts = df[selected_col].value_counts().head(20)
        
        fig = px.bar(
            x=value_counts.index,
            y=value_counts.values,
            title=f'{selected_col}の値の分布',
            labels={'x': selected_col, 'y': '頻度'}
        )
        st.plotly_chart(fig, use_container_width=True)

def show_detailed_analysis(explorer):
    """詳細分析表示"""
    st.subheader("🔍 詳細分析")
    
    # 相関分析
    if st.button("🔗 相関分析を実行"):
        with st.spinner("相関分析中..."):
            corr_result = explorer.correlation_analysis()
            
            if corr_result:
                correlation_matrix, strong_correlations = corr_result
                
                st.write("**相関マトリックス**")
                
                # 相関ヒートマップ
                fig = px.imshow(
                    correlation_matrix,
                    title='特徴量間相関',
                    color_continuous_scale='RdBu',
                    zmin=-1,
                    zmax=1
                )
                st.plotly_chart(fig, use_container_width=True)
                
                # 強い相関のリスト
                if strong_correlations:
                    st.write("**強い相関関係 (|r| > 0.7)**")
                    
                    strong_corr_df = pd.DataFrame(strong_correlations)
                    strong_corr_df['correlation'] = strong_corr_df['correlation'].round(3)
                    
                    st.dataframe(strong_corr_df, use_container_width=True, hide_index=True)
                else:
                    st.info("強い相関関係は見つかりませんでした")
    
    # 分布分析
    st.subheader("📊 分布分析")
    
    numeric_cols = explorer.data.select_dtypes(include=[np.number]).columns.tolist()
    
    if numeric_cols:
        selected_cols_dist = st.multiselect(
            "分析する数値列を選択",
            numeric_cols,
            default=numeric_cols[:3]
        )
        
        if selected_cols_dist:
            # 複数の分布を比較
            fig = make_subplots(
                rows=len(selected_cols_dist),
                cols=1,
                subplot_titles=selected_cols_dist
            )
            
            for i, col in enumerate(selected_cols_dist):
                fig.add_trace(
                    go.Histogram(x=explorer.data[col], name=col),
                    row=i+1, col=1
                )
            
            fig.update_layout(height=300*len(selected_cols_dist), title_text="分布比較")
            st.plotly_chart(fig, use_container_width=True)

def show_outlier_detection(explorer, method):
    """異常値検出表示"""
    st.subheader("⚠️ 異常値検出")
    
    if st.button("🎯 異常値検出を実行"):
        with st.spinner("異常値を検出中..."):
            outlier_data = explorer.detect_outliers(method)
            
            if outlier_data is not None:
                outlier_count = outlier_data['is_outlier'].sum()
                total_count = len(outlier_data)
                outlier_percentage = (outlier_count / total_count) * 100
                
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.metric("総データ数", total_count)
                
                with col2:
                    st.metric("異常値数", outlier_count)
                
                with col3:
                    st.metric("異常値率", f"{outlier_percentage:.1f}%")
                
                # 異常値の可視化
                if outlier_count > 0:
                    st.write("**異常値の分布**")
                    
                    numeric_cols = [col for col in outlier_data.columns 
                                  if col not in ['is_outlier', 'outlier_score']]
                    
                    if len(numeric_cols) >= 2:
                        col1, col2 = st.selectbox("X軸", numeric_cols), st.selectbox("Y軸", numeric_cols[1:])
                        
                        fig = px.scatter(
                            outlier_data,
                            x=col1,
                            y=col2,
                            color='is_outlier',
                            title='異常値分布',
                            color_discrete_map={True: 'red', False: 'blue'}
                        )
                        st.plotly_chart(fig, use_container_width=True)
                    
                    # 異常値リスト
                    outlier_records = outlier_data[outlier_data['is_outlier']]
                    if len(outlier_records) > 0:
                        st.write("**検出された異常値**")
                        st.dataframe(outlier_records.head(20), use_container_width=True)
                
                else:
                    st.success("異常値は検出されませんでした")
            
            else:
                st.warning("数値列が不足しているため、異常値検出を実行できません")

def show_report_generation(explorer):
    """レポート生成表示"""
    st.subheader("📄 分析レポート生成")
    
    # レポート設定
    col1, col2 = st.columns(2)
    
    with col1:
        report_title = st.text_input("レポートタイトル", value="データ分析レポート")
        include_insights = st.checkbox("洞察を含める", value=True)
        include_visualizations = st.checkbox("可視化を含める", value=True)
    
    with col2:
        report_format = st.selectbox("出力形式", ["HTML", "PDF"])
        include_raw_data = st.checkbox("生データを含める", value=False)
    
    if st.button("📊 レポートを生成", type="primary"):
        with st.spinner("レポートを生成中..."):
            # 分析実行
            basic_analysis = explorer.basic_analysis()
            correlation_result = explorer.correlation_analysis()
            outlier_data = explorer.detect_outliers()
            
            # 洞察生成
            insights = explorer.generate_insights()
            
            # レポート内容構築
            report_content = f"""
            # {report_title}
            
            **生成日時**: {datetime.now().strftime('%Y年%m月%d日 %H:%M:%S')}
            
            ## データセット概要
            
            - **データサイズ**: {basic_analysis['shape'][0]:,} 行 × {basic_analysis['shape'][1]} 列
            - **メモリ使用量**: {basic_analysis['memory_usage']:.1f} MB
            - **重複行数**: {basic_analysis['duplicates']:,}
            
            """
            
            if include_insights and insights:
                report_content += "\n## 🔍 主要な洞察\n\n"
                for insight in insights:
                    report_content += f"- {insight}\n"
            
            if basic_analysis['missing_values']:
                report_content += "\n## 📊 データ品質\n\n"
                missing_data = [(k, v) for k, v in basic_analysis['missing_values'].items() if v > 0]
                if missing_data:
                    report_content += "### 欠損値\n\n"
                    for col, count in missing_data:
                        percentage = basic_analysis['missing_percentage'][col]
                        report_content += f"- **{col}**: {count} ({percentage:.1f}%)\n"
            
            if correlation_result and correlation_result[1]:  # strong_correlations
                report_content += "\n## 🔗 相関分析\n\n"
                report_content += "### 強い相関関係 (|r| > 0.7)\n\n"
                for corr in correlation_result[1]:
                    report_content += f"- **{corr['var1']}** ↔ **{corr['var2']}**: {corr['correlation']:.3f}\n"
            
            if outlier_data is not None:
                outlier_count = outlier_data['is_outlier'].sum()
                outlier_percentage = (outlier_count / len(outlier_data)) * 100
                report_content += f"\n## ⚠️ 異常値検出\n\n"
                report_content += f"- **異常値数**: {outlier_count}\n"
                report_content += f"- **異常値率**: {outlier_percentage:.1f}%\n"
            
            if include_raw_data:
                report_content += "\n## 📋 データサンプル\n\n"
                report_content += explorer.data.head(10).to_markdown()
            
            report_content += f"\n\n---\n*このレポートは データ探索ツール により自動生成されました*"
            
            # レポート表示
            st.markdown("### 📄 生成されたレポート")
            st.markdown(report_content)
            
            # ダウンロードボタン
            if report_format == "HTML":
                html_content = f"""
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <title>{report_title}</title>
                    <style>
                        body {{ font-family: Arial, sans-serif; margin: 40px; }}
                        h1, h2, h3 {{ color: #333; }}
                        table {{ border-collapse: collapse; width: 100%; }}
                        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                        th {{ background-color: #f2f2f2; }}
                    </style>
                </head>
                <body>
                    {report_content.replace('# ', '<h1>').replace('## ', '<h2>').replace('### ', '<h3>').replace('**', '<strong>').replace('*', '</strong>')}
                </body>
                </html>
                """
                
                st.download_button(
                    label="📄 HTMLレポートをダウンロード",
                    data=html_content,
                    file_name=f"{report_title.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html",
                    mime="text/html"
                )
            
            else:  # PDF
                st.info("PDF生成機能は実装準備中です。HTMLレポートをご利用ください。")

if __name__ == "__main__":
    main()</code></pre>
                        
                        <h6>実行と確認</h6>
                        <pre><code>streamlit run data_explorer.py</code></pre>
                        
                        <h6>期待される結果</h6>
                        <p>ファイルアップロード、自動データ分析、インタラクティブ可視化、異常値検出、レポート生成機能を統合した包括的なデータ探索プラットフォームが表示されます。</p>
                    </div>

                    <!-- 理解度確認 -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <strong>データ分析ダッシュボードで重要なKPI指標を3つ挙げてください</strong>
                                <details style="margin-top: 0.5rem;">
                                    <summary>解答を見る</summary>
                                    <p><strong>答え例:</strong><br>
                                    1. <strong>総売上・収益</strong>: ビジネスの基本的な成果指標<br>
                                    2. <strong>顧客数・アクティブユーザー数</strong>: 事業規模の指標<br>
                                    3. <strong>平均注文額・顧客あたり売上</strong>: 収益性の指標<br>
                                    4. <strong>成長率・前期比</strong>: 事業トレンドの指標</p>
                                </details>
                            </li>
                            
                            <li>
                                <strong>機械学習モデルの性能評価で使用される主要な指標を3つ答えてください</strong>
                                <details style="margin-top: 0.5rem;">
                                    <summary>解答を見る</summary>
                                    <p><strong>答え:</strong><br>
                                    1. <strong>R² Score（決定係数）</strong>: 回帰モデルの説明力<br>
                                    2. <strong>RMSE（Root Mean Square Error）</strong>: 予測誤差の大きさ<br>
                                    3. <strong>MAE（Mean Absolute Error）</strong>: 絶対誤差の平均<br>
                                    4. <strong>Cross Validation Score</strong>: 汎化性能の評価</p>
                                </details>
                            </li>
                            
                            <li>
                                <strong>データ探索ツールに含めるべき主要機能を4つ挙げてください</strong>
                                <details style="margin-top: 0.5rem;">
                                    <summary>解答を見る</summary>
                                    <p><strong>答え例:</strong><br>
                                    1. <strong>データプロファイリング</strong>: 基本統計と品質評価<br>
                                    2. <strong>インタラクティブ可視化</strong>: 動的なグラフとフィルタリング<br>
                                    3. <strong>異常値検出</strong>: 統計的手法による外れ値特定<br>
                                    4. <strong>自動レポート生成</strong>: 分析結果の自動出力<br>
                                    5. <strong>相関分析</strong>: 変数間の関係性分析</p>
                                </details>
                            </li>
                        </ol>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="streamlit-learning-material-9.html" class="btn btn-secondary">← 前の章: デプロイメントと本番環境</a>
                        <div class="btn btn-success">🎉 学習完了！</div>
                    </div>

                    <!-- 完了メッセージ -->
                    <div class="highlight mt-4">
                        <h5>🎉 Streamlit学習教材完了おめでとうございます！</h5>
                        <p>この教材を通じて、以下のスキルを身につけることができました：</p>
                        <ul>
                            <li>Streamlitの基本的なコンポーネントと高度な機能の活用</li>
                            <li>データ可視化とインタラクティブなWebアプリケーション開発</li>
                            <li>マルチページアプリケーションとナビゲーション設計</li>
                            <li>データベース連携とAPI統合</li>
                            <li>本番環境対応のデプロイメント技術</li>
                            <li>実践的なデータ分析アプリケーションの構築</li>
                        </ul>
                        <p><strong>次のステップ:</strong> 学んだ知識を活用して、自分のプロジェクトやビジネス課題を解決するStreamlitアプリケーションを開発してみましょう！</p>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>