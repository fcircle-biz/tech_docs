<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Django学習教材 第10章 - 高度な機能と最適化</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <!-- カスタムCSS -->
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #2e7d32;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
            background-color: #f8f9fa;
        }

        /* タイトル */
        .chapter-title {
            color: #2e7d32;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #2e7d32;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #388e3c;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e8f5e9;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #2e7d32;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #2e7d32 !important;
            color: white !important;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand">
                <strong>Django学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="django-learning-material-1.html">
                                第1章: Django入門と環境構築
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="django-learning-material-2.html">
                                第2章: モデルとデータベース設計
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="django-learning-material-3.html">
                                第3章: ビューとURLルーティング
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="django-learning-material-4.html">
                                第4章: テンプレートとフロントエンド統合
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="django-learning-material-5.html">
                                第5章: フォームとユーザー入力処理
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="django-learning-material-6.html">
                                第6章: 認証とユーザー管理
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="django-learning-material-7.html">
                                第7章: Django REST Framework入門
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="django-learning-material-8.html">
                                第8章: テストとデバッグ
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="django-learning-material-9.html">
                                第9章: デプロイメントと本番環境設定
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="django-learning-material-10.html">
                                第10章: 高度な機能と最適化
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <!-- 章ヘッダー -->
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第10章: 高度な機能と最適化</h1>
                </div>

                <div id="chapter10">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">エンタープライズレベルのDjango開発</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>カスタム管理コマンドの作成と活用</li>
                            <li>シグナルによるイベント駆動アーキテクチャ</li>
                            <li>ミドルウェアによるリクエスト処理のカスタマイズ</li>
                            <li>キャッシュ戦略とパフォーマンス最適化</li>
                            <li>非同期処理とCeleryによるタスクキュー</li>
                            <li>国際化（i18n）と多言語対応</li>
                        </ul>
                    </div>

                    <!-- セクション1: カスタム管理コマンド -->
                    <h3 class="section-title">10.1 カスタム管理コマンドの作成</h3>
                    
                    <p>Django管理コマンドは、バッチ処理、データベースメンテナンス、定期実行タスクなどを実装するための強力な機能です。<code>manage.py</code>を通じて実行でき、Djangoの環境設定とORM機能を利用できます。</p>

                    <h4>管理コマンドの構造と作成方法</h4>
                    <div class="mermaid">
                        graph TD
                            A[カスタム管理コマンド] --> B[BaseCommand継承]
                            A --> C[add_arguments]
                            A --> D[handle]
                            
                            B --> B1[django.core.management.base.BaseCommand<br/>コマンドの基底クラス]
                            C --> C1[コマンドライン引数の定義<br/>オプションの設定]
                            D --> D1[実際の処理ロジック<br/>例外処理・ログ出力]
                    </div>

                    <pre class="code-block"><code class="language-python"># management/commands/cleanup_old_data.py
from django.core.management.base import BaseCommand, CommandError
from django.db import transaction
from django.utils import timezone
from datetime import timedelta
import logging
from blog.models import Article, Comment

logger = logging.getLogger('django.command')

class Command(BaseCommand):
    """古いデータを削除する管理コマンド"""
    help = '指定日数より古いデータを削除します'
    
    def add_arguments(self, parser):
        """コマンドライン引数の定義"""
        parser.add_argument(
            '--days',
            type=int,
            default=365,
            help='削除対象となる日数（デフォルト: 365日）'
        )
        
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='実際の削除は行わず、削除対象のみを表示'
        )
        
        parser.add_argument(
            '--model',
            choices=['article', 'comment', 'all'],
            default='all',
            help='削除対象のモデル'
        )
        
        parser.add_argument(
            '--batch-size',
            type=int,
            default=1000,
            help='一度に処理するレコード数'
        )
    
    def handle(self, *args, **options):
        """メイン処理"""
        days = options['days']
        dry_run = options['dry_run']
        model = options['model']
        batch_size = options['batch_size']
        
        # 削除対象日付の計算
        cutoff_date = timezone.now() - timedelta(days=days)
        
        self.stdout.write(
            self.style.SUCCESS(f'古いデータ削除処理を開始します')
        )
        self.stdout.write(f'対象日付: {cutoff_date.strftime("%Y-%m-%d")} より前')
        self.stdout.write(f'ドライラン: {dry_run}')
        
        try:
            with transaction.atomic():
                if model in ['article', 'all']:
                    self._cleanup_articles(cutoff_date, dry_run, batch_size)
                
                if model in ['comment', 'all']:
                    self._cleanup_comments(cutoff_date, dry_run, batch_size)
                
                if dry_run:
                    # ドライランの場合はロールバック
                    transaction.set_rollback(True)
                    
        except Exception as e:
            logger.error(f'データ削除処理でエラーが発生: {str(e)}')
            raise CommandError(f'処理に失敗しました: {str(e)}')
        
        self.stdout.write(
            self.style.SUCCESS('データ削除処理が完了しました')
        )
    
    def _cleanup_articles(self, cutoff_date, dry_run, batch_size):
        """古い記事の削除"""
        articles = Article.objects.filter(
            created_at__lt=cutoff_date,
            is_published=False  # 非公開記事のみ
        )
        
        total_count = articles.count()
        if total_count == 0:
            self.stdout.write('削除対象の記事はありません')
            return
        
        self.stdout.write(f'削除対象記事数: {total_count}')
        
        if not dry_run:
            deleted_count = 0
            while deleted_count < total_count:
                batch = articles[:batch_size]
                batch_ids = list(batch.values_list('id', flat=True))
                
                if not batch_ids:
                    break
                
                Article.objects.filter(id__in=batch_ids).delete()
                deleted_count += len(batch_ids)
                
                self.stdout.write(f'進捗: {deleted_count}/{total_count}')
            
            logger.info(f'記事を{deleted_count}件削除しました')
    
    def _cleanup_comments(self, cutoff_date, dry_run, batch_size):
        """古いコメントの削除"""
        comments = Comment.objects.filter(created_at__lt=cutoff_date)
        total_count = comments.count()
        
        if total_count == 0:
            self.stdout.write('削除対象のコメントはありません')
            return
        
        self.stdout.write(f'削除対象コメント数: {total_count}')
        
        if not dry_run:
            deleted_count = 0
            while deleted_count < total_count:
                batch = comments[:batch_size]
                batch_ids = list(batch.values_list('id', flat=True))
                
                if not batch_ids:
                    break
                
                Comment.objects.filter(id__in=batch_ids).delete()
                deleted_count += len(batch_ids)
                
                self.stdout.write(f'進捗: {deleted_count}/{total_count}')
            
            logger.info(f'コメントを{deleted_count}件削除しました')

# 使用例
# python manage.py cleanup_old_data --days=90 --dry-run
# python manage.py cleanup_old_data --model=article --batch-size=500</code></pre>

                    <!-- セクション2: Djangoシグナル -->
                    <h3 class="section-title">10.2 シグナルによるイベント駆動アーキテクチャ</h3>
                    
                    <p>Djangoシグナルは、特定のアクション（モデルの保存、削除、ユーザーログインなど）が発生した時に自動的に処理を実行するメカニズムです。疎結合なコードの設計とコードの再利用性向上に寄与します。</p>

                    <h4>主要なDjango組み込みシグナル</h4>
                    <div class="mermaid">
                        graph TD
                            A[Djangoシグナル] --> B[モデルシグナル]
                            A --> C[認証シグナル]
                            A --> D[リクエストシグナル]
                            
                            B --> B1[pre_save / post_save<br/>pre_delete / post_delete<br/>m2m_changed]
                            C --> C1[user_logged_in<br/>user_logged_out<br/>user_login_failed]
                            D --> D1[request_started<br/>request_finished<br/>got_request_exception]
                    </div>

                    <pre class="code-block"><code class="language-python"># signals.py
from django.db.models.signals import post_save, pre_delete, m2m_changed
from django.contrib.auth.signals import user_logged_in, user_logged_out
from django.dispatch import receiver
from django.contrib.auth.models import User
from django.core.mail import send_mail
from django.utils import timezone
import logging
from .models import Article, UserProfile, Tag

logger = logging.getLogger('blog.signals')

@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    """ユーザー作成時にプロフィールを自動作成"""
    if created:
        UserProfile.objects.create(user=instance)
        logger.info(f'ユーザープロフィールを作成しました: {instance.username}')

@receiver(post_save, sender=User)
def save_user_profile(sender, instance, **kwargs):
    """ユーザー保存時にプロフィールも保存"""
    try:
        instance.userprofile.save()
    except UserProfile.DoesNotExist:
        # プロフィールが存在しない場合は作成
        UserProfile.objects.create(user=instance)

@receiver(post_save, sender=Article)
def article_published_notification(sender, instance, created, **kwargs):
    """記事公開時の通知処理"""
    if not created and instance.is_published:
        # 前の状態を確認するため、データベースから再取得
        try:
            old_instance = Article.objects.get(pk=instance.pk)
            if hasattr(old_instance, '_state') and old_instance._state.adding:
                return  # 新規作成の場合はスキップ
        except Article.DoesNotExist:
            return
        
        # 管理者への通知メール
        subject = f'新しい記事が公開されました: {instance.title}'
        message = f'''
        記事「{instance.title}」が公開されました。
        
        著者: {instance.author.get_full_name() or instance.author.username}
        カテゴリ: {instance.category.name}
        公開日時: {instance.updated_at.strftime("%Y年%m月%d日 %H時%M分")}
        
        記事を確認する: http://yourdomain.com{instance.get_absolute_url()}
        '''
        
        try:
            send_mail(
                subject,
                message,
                'noreply@yourdomain.com',
                ['admin@yourdomain.com'],
                fail_silently=False,
            )
            logger.info(f'記事公開通知を送信しました: {instance.title}')
        except Exception as e:
            logger.error(f'記事公開通知の送信に失敗: {str(e)}')

@receiver(pre_delete, sender=Article)
def article_delete_log(sender, instance, **kwargs):
    """記事削除時のログ記録"""
    logger.warning(
        f'記事が削除されます: {instance.title} (ID: {instance.id}, 著者: {instance.author.username})'
    )

@receiver(m2m_changed, sender=Article.tags.through)
def article_tags_changed(sender, instance, action, pk_set, **kwargs):
    """記事のタグ変更時の処理"""
    if action == "post_add":
        added_tags = Tag.objects.filter(pk__in=pk_set)
        logger.info(
            f'記事「{instance.title}」にタグが追加されました: {[tag.name for tag in added_tags]}'
        )
    elif action == "post_remove":
        removed_tags = Tag.objects.filter(pk__in=pk_set)
        logger.info(
            f'記事「{instance.title}」からタグが削除されました: {[tag.name for tag in removed_tags]}'
        )

@receiver(user_logged_in)
def user_login_handler(sender, request, user, **kwargs):
    """ユーザーログイン時の処理"""
    # 最終ログイン時刻を更新（Djangoで自動的に行われるが、カスタム処理も可能）
    user.last_login = timezone.now()
    user.save()
    
    # ログイン記録
    logger.info(f'ユーザーがログインしました: {user.username} (IP: {request.META.get("REMOTE_ADDR")})')
    
    # 初回ログインの場合の処理
    if user.last_login is None:
        # ウェルカムメッセージの送信など
        pass

@receiver(user_logged_out)
def user_logout_handler(sender, request, user, **kwargs):
    """ユーザーログアウト時の処理"""
    if user:
        logger.info(f'ユーザーがログアウトしました: {user.username}')

# カスタムシグナルの定義
from django.dispatch import Signal

# 記事のビュー数増加シグナル
article_viewed = Signal()

@receiver(article_viewed)
def increment_article_views(sender, article, user, **kwargs):
    """記事閲覧時のビュー数増加"""
    # ビュー数をキャッシュで管理（Redis等を使用）
    from django.core.cache import cache
    
    cache_key = f'article_views:{article.id}'
    current_views = cache.get(cache_key, 0)
    cache.set(cache_key, current_views + 1, timeout=3600)  # 1時間キャッシュ
    
    logger.debug(f'記事「{article.title}」の閲覧数: {current_views + 1}')

# apps.py で シグナルを登録
class BlogConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'blog'
    
    def ready(self):
        import blog.signals  # シグナルをインポート</code></pre>

                    <!-- セクション3: カスタムミドルウェア -->
                    <h3 class="section-title">10.3 ミドルウェアによるリクエスト処理</h3>
                    
                    <p>ミドルウェアは、Djangoのリクエスト・レスポンス処理パイプラインに独自の処理を挟み込む強力な仕組みです。認証、ログ出力、パフォーマンス監視、セキュリティ対策などを実装できます。</p>

                    <pre class="code-block"><code class="language-python"># middleware.py
import time
import logging
from django.utils.deprecation import MiddlewareMixin
from django.http import HttpResponseForbidden
from django.core.cache import cache
from django.utils import timezone
from django.contrib.auth.models import AnonymousUser

logger = logging.getLogger('blog.middleware')

class RequestLoggingMiddleware:
    """リクエストログミドルウェア"""
    
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        # リクエスト前処理
        start_time = time.time()
        request.start_time = start_time
        
        # レスポンス処理
        response = self.get_response(request)
        
        # リクエスト後処理
        duration = time.time() - start_time
        
        # ログ出力
        logger.info(
            f'{request.method} {request.path} '
            f'Status: {response.status_code} '
            f'Duration: {duration:.3f}s '
            f'User: {request.user if not isinstance(request.user, AnonymousUser) else "Anonymous"} '
            f'IP: {request.META.get("REMOTE_ADDR", "Unknown")}'
        )
        
        return response

class RateLimitMiddleware:
    """レート制限ミドルウェア"""
    
    def __init__(self, get_response):
        self.get_response = get_response
        self.max_requests = 100  # 1時間あたりの最大リクエスト数
        self.window = 3600  # 1時間（秒）
    
    def __call__(self, request):
        # IPアドレス取得
        ip_address = self.get_client_ip(request)
        cache_key = f'rate_limit:{ip_address}'
        
        # 現在のリクエスト数を取得
        current_requests = cache.get(cache_key, 0)
        
        if current_requests >= self.max_requests:
            logger.warning(f'レート制限に達しました: IP {ip_address}')
            return HttpResponseForbidden('Rate limit exceeded. Try again later.')
        
        # リクエスト数を増加
        cache.set(cache_key, current_requests + 1, timeout=self.window)
        
        response = self.get_response(request)
        return response
    
    def get_client_ip(self, request):
        """クライアントIPアドレスを取得"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0].strip()
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip

class SecurityHeadersMiddleware:
    """セキュリティヘッダーミドルウェア"""
    
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        response = self.get_response(request)
        
        # セキュリティヘッダーの追加
        response['X-Content-Type-Options'] = 'nosniff'
        response['X-Frame-Options'] = 'DENY'
        response['X-XSS-Protection'] = '1; mode=block'
        response['Referrer-Policy'] = 'strict-origin-when-cross-origin'
        response['Content-Security-Policy'] = (
            "default-src 'self'; "
            "script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; "
            "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; "
            "font-src 'self' https://fonts.gstatic.com; "
            "img-src 'self' data: https:;"
        )
        
        return response

class MaintenanceModeMiddleware:
    """メンテナンスモードミドルウェア"""
    
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        # メンテナンスモードの確認
        maintenance_mode = cache.get('maintenance_mode', False)
        
        if maintenance_mode:
            # 管理者は除外
            if not (request.user.is_authenticated and request.user.is_staff):
                from django.template.response import TemplateResponse
                return TemplateResponse(
                    request, 
                    'maintenance.html', 
                    status=503
                )
        
        return self.get_response(request)

# settings.py での設定
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'blog.middleware.SecurityHeadersMiddleware',
    'blog.middleware.MaintenanceModeMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'blog.middleware.RateLimitMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'blog.middleware.RequestLoggingMiddleware',
]</code></pre>

                    <!-- 実習1 -->
                    <div class="exercise-container">
                        <h5>実習 10-1: イベント駆動システムの構築</h5>
                        <p>この実習では、シグナルとミドルウェアを活用したイベント駆動システムを構築します。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>データメンテナンス用のカスタム管理コマンドを作成する</li>
                            <li>モデル操作に連動したシグナル処理を実装する</li>
                            <li>リクエスト監視用のミドルウェアを実装する</li>
                            <li>レート制限とセキュリティ強化のミドルウェアを追加する</li>
                            <li>ログ出力とエラー通知システムを統合する</li>
                        </ol>

                        <h6>期待される結果</h6>
                        <p>イベントドリブンな処理が正常に動作し、適切なログ出力とセキュリティ対策が機能することを確認してください。</p>
                    </div>

                    <!-- セクション4: キャッシュ戦略 -->
                    <h3 class="section-title">10.4 キャッシュ戦略とパフォーマンス最適化</h3>
                    
                    <p>キャッシュは、Webアプリケーションのパフォーマンスを劇的に向上させる重要な最適化手法です。Djangoでは、複数のキャッシュレベルとバックエンドが提供されており、用途に応じた最適な戦略を選択できます。</p>

                    <h4>キャッシュ戦略の種類</h4>
                    <div class="mermaid">
                        graph TD
                            A[Djangoキャッシュ戦略] --> B[サイト全体キャッシュ]
                            A --> C[ビューレベルキャッシュ]
                            A --> D[テンプレートフラグメントキャッシュ]
                            A --> E[低レベルキャッシュAPI]
                            
                            B --> B1[全ページをキャッシュ<br/>高速だが柔軟性低]
                            C --> C1[個別ビューをキャッシュ<br/>デコレータで簡単実装]
                            D --> D1[テンプレートの一部をキャッシュ<br/>動的部分と静的部分を分離]
                            E --> E1[プログラム内で任意のデータをキャッシュ<br/>最大の柔軟性]
                    </div>

                    <pre class="code-block"><code class="language-python"># settings.py - Redis キャッシュ設定
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/1',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'CONNECTION_POOL_KWARGS': {
                'max_connections': 100,
                'retry_on_timeout': True,
            },
            'COMPRESSOR': 'django_redis.compressors.zlib.ZlibCompressor',
            'IGNORE_EXCEPTIONS': True,
        }
    },
    'session': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/2',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}

# セッションキャッシュの使用
SESSION_ENGINE = 'django.contrib.sessions.backends.cache'
SESSION_CACHE_ALIAS = 'session'

# views.py - 各種キャッシュの実装例
from django.views.decorators.cache import cache_page, cache_control
from django.views.decorators.vary import vary_on_headers
from django.core.cache import cache
from django.utils.cache import get_cache_key
import hashlib

# ビューレベルキャッシュ（15分）
@cache_page(60 * 15)
@vary_on_headers('User-Agent', 'Accept-Language')
def article_list(request):
    """記事一覧ページ（全体をキャッシュ）"""
    articles = Article.objects.select_related('author', 'category').filter(
        is_published=True
    ).order_by('-created_at')[:20]
    
    return render(request, 'blog/article_list.html', {
        'articles': articles
    })

# 条件付きキャッシュ
def article_detail(request, slug):
    """記事詳細ページ（認証状態に応じたキャッシュ）"""
    # キャッシュキーの生成
    cache_key = f'article_detail:{slug}:{request.user.is_authenticated}'
    cached_data = cache.get(cache_key)
    
    if cached_data:
        return cached_data
    
    try:
        article = Article.objects.select_related('author', 'category').get(
            slug=slug, is_published=True
        )
    except Article.DoesNotExist:
        raise Http404("記事が見つかりません")
    
    # 関連記事の取得（キャッシュ使用）
    related_articles = get_related_articles(article)
    
    context = {
        'article': article,
        'related_articles': related_articles,
    }
    
    response = render(request, 'blog/article_detail.html', context)
    
    # レスポンスをキャッシュ（5分間）
    cache.set(cache_key, response, timeout=300)
    
    return response

def get_related_articles(article):
    """関連記事取得（キャッシュ付き）"""
    cache_key = f'related_articles:{article.id}'
    related = cache.get(cache_key)
    
    if related is None:
        # 同じカテゴリの記事を取得
        related = list(Article.objects.filter(
            category=article.category,
            is_published=True
        ).exclude(
            id=article.id
        ).select_related('author')[:5])
        
        # 30分間キャッシュ
        cache.set(cache_key, related, timeout=1800)
    
    return related

# 低レベルキャッシュAPI使用例
class ArticleService:
    """記事関連のビジネスロジック"""
    
    @staticmethod
    def get_popular_articles(limit=10):
        """人気記事取得（キャッシュ付き）"""
        cache_key = f'popular_articles:{limit}'
        articles = cache.get(cache_key)
        
        if articles is None:
            # ビュー数でソート（実際の実装では別テーブルで管理）
            articles = list(Article.objects.filter(
                is_published=True
            ).select_related('author', 'category').order_by(
                '-created_at'  # 実際はビュー数でソート
            )[:limit])
            
            # 1時間キャッシュ
            cache.set(cache_key, articles, timeout=3600)
        
        return articles
    
    @staticmethod
    def invalidate_article_cache(article):
        """記事関連のキャッシュを無効化"""
        # 個別記事キャッシュを削除
        cache.delete_many([
            f'article_detail:{article.slug}:True',
            f'article_detail:{article.slug}:False',
            f'related_articles:{article.id}',
        ])
        
        # 一覧系キャッシュも削除
        cache.delete('popular_articles:10')
        
        # パターンマッチングで削除（django-redis使用時）
        from django_redis import get_redis_connection
        conn = get_redis_connection('default')
        keys = conn.keys(f'article_list:*')
        if keys:
            conn.delete(*keys)

# models.py - キャッシュ無効化をシグナルで自動化
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver

@receiver(post_save, sender=Article)
def invalidate_cache_on_save(sender, instance, **kwargs):
    ArticleService.invalidate_article_cache(instance)

@receiver(post_delete, sender=Article)
def invalidate_cache_on_delete(sender, instance, **kwargs):
    ArticleService.invalidate_article_cache(instance)</code></pre>

                    <!-- セクション5: 非同期処理とCelery -->
                    <h3 class="section-title">10.5 Celeryによる非同期タスク処理</h3>
                    
                    <p>Celeryは、時間のかかる処理やバックグラウンド処理を非同期で実行するためのタスクキューシステムです。メール送信、レポート生成、データ処理などをWebリクエストから切り離して実行できます。</p>

                    <pre class="code-block"><code class="language-python"># celery.py - Celery設定
import os
from celery import Celery
from django.conf import settings

# Django設定モジュールを指定
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')

app = Celery('myproject')

# Django設定からCelery設定を読み込み
app.config_from_object('django.conf:settings', namespace='CELERY')

# 登録されたアプリケーションからタスクを自動発見
app.autodiscover_tasks()

# settings.py - Celery設定
# Redis をメッセージブローカーとして使用
CELERY_BROKER_URL = 'redis://localhost:6379/0'
CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'

# タスクの設定
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TIMEZONE = 'Asia/Tokyo'
CELERY_ENABLE_UTC = True

# タスク実行設定
CELERY_TASK_ALWAYS_EAGER = False  # 本番環境ではFalse
CELERY_TASK_EAGER_PROPAGATES = True
CELERY_TASK_ROUTES = {
    'blog.tasks.send_email': {'queue': 'email'},
    'blog.tasks.generate_report': {'queue': 'reports'},
    'blog.tasks.process_image': {'queue': 'media'},
}

# 定期タスクの設定
from celery.schedules import crontab

CELERY_BEAT_SCHEDULE = {
    'daily-cleanup': {
        'task': 'blog.tasks.daily_cleanup',
        'schedule': crontab(hour=2, minute=0),  # 毎日午前2時
    },
    'weekly-report': {
        'task': 'blog.tasks.generate_weekly_report',
        'schedule': crontab(hour=9, minute=0, day_of_week=1),  # 毎週月曜日9時
    },
}

# tasks.py - タスクの定義
from celery import shared_task
from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.utils import timezone
from datetime import timedelta
import logging
from .models import Article, User

logger = logging.getLogger('celery.task')

@shared_task(bind=True, autoretry_for=(Exception,), retry_kwargs={'max_retries': 3})
def send_notification_email(self, user_id, article_id, notification_type):
    """通知メール送信タスク"""
    try:
        user = User.objects.get(id=user_id)
        article = Article.objects.get(id=article_id)
        
        subject = f'新しい記事が投稿されました: {article.title}'
        message = render_to_string('emails/article_notification.html', {
            'user': user,
            'article': article,
            'notification_type': notification_type,
        })
        
        send_mail(
            subject,
            message,
            'noreply@yourdomain.com',
            [user.email],
            fail_silently=False,
            html_message=message
        )
        
        logger.info(f'通知メール送信完了: {user.email} - {article.title}')
        return f'Email sent to {user.email}'
        
    except Exception as exc:
        logger.error(f'メール送信エラー: {str(exc)}')
        raise self.retry(exc=exc, countdown=60)

@shared_task
def process_image_upload(image_path, article_id):
    """画像処理タスク（リサイズ、最適化）"""
    try:
        from PIL import Image
        import os
        
        article = Article.objects.get(id=article_id)
        
        # 画像を開く
        with Image.open(image_path) as img:
            # サムネイル作成
            thumbnail_size = (300, 300)
            img.thumbnail(thumbnail_size, Image.Resampling.LANCZOS)
            
            # サムネイル保存
            thumbnail_path = image_path.replace('.jpg', '_thumb.jpg')
            img.save(thumbnail_path, 'JPEG', quality=85, optimize=True)
        
        logger.info(f'画像処理完了: {image_path}')
        return f'Image processed: {image_path}'
        
    except Exception as exc:
        logger.error(f'画像処理エラー: {str(exc)}')
        raise exc

@shared_task
def daily_cleanup():
    """日次クリーンアップタスク"""
    try:
        # 古い一時ファイルを削除
        import tempfile
        import os
        from pathlib import Path
        
        temp_dir = Path(tempfile.gettempdir())
        old_files = []
        
        for file_path in temp_dir.glob('django_*'):
            if file_path.is_file():
                # 24時間以上古いファイルを削除
                if file_path.stat().st_mtime < (timezone.now() - timedelta(hours=24)).timestamp():
                    file_path.unlink()
                    old_files.append(str(file_path))
        
        # キャッシュクリーンアップ
        from django.core.cache import cache
        cache.clear()
        
        logger.info(f'日次クリーンアップ完了: {len(old_files)}個のファイルを削除')
        return f'Cleaned up {len(old_files)} files'
        
    except Exception as exc:
        logger.error(f'日次クリーンアップエラー: {str(exc)}')
        raise exc

@shared_task
def generate_weekly_report():
    """週次レポート生成タスク"""
    try:
        # 過去1週間の統計を取得
        week_ago = timezone.now() - timedelta(days=7)
        
        stats = {
            'new_articles': Article.objects.filter(created_at__gte=week_ago).count(),
            'published_articles': Article.objects.filter(
                is_published=True,
                updated_at__gte=week_ago
            ).count(),
            'total_articles': Article.objects.count(),
        }
        
        # レポートメール送信
        subject = f'週次レポート - {timezone.now().strftime("%Y年%m月%d日")}'
        message = f'''
        過去1週間の統計:
        
        - 新規記事: {stats["new_articles"]}件
        - 公開記事: {stats["published_articles"]}件
        - 総記事数: {stats["total_articles"]}件
        
        生成日時: {timezone.now().strftime("%Y年%m月%d日 %H時%M分")}
        '''
        
        send_mail(
            subject,
            message,
            'reports@yourdomain.com',
            ['admin@yourdomain.com'],
            fail_silently=False,
        )
        
        logger.info('週次レポート生成・送信完了')
        return 'Weekly report generated and sent'
        
    except Exception as exc:
        logger.error(f'週次レポート生成エラー: {str(exc)}')
        raise exc

# views.py - タスクの実行例
from .tasks import send_notification_email, process_image_upload

def publish_article(request, article_id):
    """記事公開時の非同期処理"""
    article = get_object_or_404(Article, id=article_id)
    
    if request.method == 'POST':
        article.is_published = True
        article.save()
        
        # 非同期で通知メール送信
        subscribers = User.objects.filter(
            userprofile__email_notifications=True
        ).values_list('id', flat=True)
        
        for user_id in subscribers:
            send_notification_email.delay(user_id, article.id, 'new_article')
        
        messages.success(request, '記事を公開しました。通知メールを送信中です。')
        return redirect('article_detail', slug=article.slug)
    
    return render(request, 'blog/publish_article.html', {'article': article})</code></pre>

                    <!-- セクション6: 国際化対応 -->
                    <h3 class="section-title">10.6 国際化（i18n）と多言語対応</h3>
                    
                    <p>Django の国際化機能により、アプリケーションを複数の言語で提供できます。テキストの翻訳、日付・数値の地域化、タイムゾーン対応を統合的にサポートします。</p>

                    <pre class="code-block"><code class="language-python"># settings.py - 国際化設定
from django.utils.translation import gettext_lazy as _

# 言語設定
LANGUAGE_CODE = 'ja'
TIME_ZONE = 'Asia/Tokyo'
USE_I18N = True  # 国際化を有効化
USE_L10N = True  # 地域化を有効化
USE_TZ = True    # タイムゾーンを有効化

# 利用可能言語の設定
LANGUAGES = [
    ('ja', _('Japanese')),
    ('en', _('English')),
    ('zh', _('Chinese')),
]

# 翻訳ファイルの場所
LOCALE_PATHS = [
    BASE_DIR / 'locale',
]

# ミドルウェアに言語選択を追加
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.locale.LocaleMiddleware',  # 言語選択ミドルウェア
    'django.middleware.common.CommonMiddleware',
    # その他のミドルウェア...
]

# views.py - 翻訳対応のビュー
from django.utils.translation import gettext as _
from django.utils.translation import ngettext
from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.http import require_POST

def article_list(request):
    """多言語対応記事一覧"""
    articles = Article.objects.filter(is_published=True)
    
    # 記事数による複数形対応
    count = articles.count()
    message = ngettext(
        'There is %(count)d article.',
        'There are %(count)d articles.',
        count,
    ) % {'count': count}
    
    context = {
        'articles': articles,
        'page_title': _('Article List'),
        'message': message,
        'no_articles_message': _('No articles found.'),
    }
    
    return render(request, 'blog/article_list.html', context)

@require_POST
def set_language(request):
    """言語切り替えAPI"""
    from django.conf import settings
    from django.http import HttpResponseRedirect
    from django.utils.translation import activate
    from django.urls import translate_url
    
    language = request.POST.get('language')
    
    if language and language in [lang[0] for lang in settings.LANGUAGES]:
        # セッションに言語を保存
        request.session['django_language'] = language
        activate(language)
        
        # リダイレクト先URLも翻訳
        redirect_url = request.POST.get('next', '/')
        redirect_url = translate_url(redirect_url, language)
        
        return JsonResponse({
            'success': True,
            'language': language,
            'redirect_url': redirect_url
        })
    
    return JsonResponse({'success': False, 'error': _('Invalid language')})

# models.py - 多言語対応モデル
from django.utils.translation import gettext_lazy as _

class Category(models.Model):
    name = models.CharField(_('name'), max_length=100)
    description = models.TextField(_('description'), blank=True)
    created_at = models.DateTimeField(_('created at'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('category')
        verbose_name_plural = _('categories')
        ordering = ['name']
    
    def __str__(self):
        return self.name

# 多言語フィールドを持つモデル（django-modeltranslation使用）
# pip install django-modeltranslation

# translation.py
from modeltranslation.translator import register, TranslationOptions
from .models import Article

@register(Article)
class ArticleTranslationOptions(TranslationOptions):
    fields = ('title', 'content')

# 設定後、以下のフィールドが自動生成される
# title_ja, title_en, title_zh
# content_ja, content_en, content_zh</code></pre>

                    <!-- 実習2 -->
                    <div class="exercise-container">
                        <h5>実習 10-2: エンタープライズ機能の統合実装</h5>
                        <p>この実習では、Celeryを使用した非同期処理とキャッシュ最適化、国際化対応を統合実装します。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>Redis を使用したキャッシュシステムを構築する</li>
                            <li>Celery による非同期タスク処理を実装する</li>
                            <li>定期実行タスクでデータメンテナンスを自動化する</li>
                            <li>多言語対応システムを実装する</li>
                            <li>パフォーマンス監視とキャッシュ無効化戦略を構築する</li>
                        </ol>

                        <h6>期待される結果</h6>
                        <p>非同期処理が正常に動作し、適切なキャッシュ効果とパフォーマンス向上、多言語機能が確認できることを検証してください。</p>
                    </div>

                    <!-- 理解度確認 -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>Django管理コマンド、シグナル、ミドルウェアの使用場面をそれぞれ具体例で説明してください。</li>
                            <li>キャッシュの4つのレベル（サイト全体、ビュー、テンプレートフラグメント、低レベルAPI）の特徴と適用場面を説明してください。</li>
                            <li>Celeryを使用する利点と、同期処理と比較した場合のトレードオフを説明してください。</li>
                            <li>Django の国際化機能で対応できる地域化要素を5つ挙げてください。</li>
                            <li>本章で学んだ高度な機能を組み合わせて、スケーラブルなWebアプリケーションを設計する際の考慮点を説明してください。</li>
                        </ol>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="django-learning-material-9.html" class="btn btn-secondary">← 前の章</a>
                        <span class="btn btn-success">学習完了！</span>
                    </div>

                    <!-- 学習完了メッセージ -->
                    <div class="alert alert-success mt-4" role="alert">
                        <h4 class="alert-heading">🎉 Django学習教材完了おめでとうございます！</h4>
                        <p>この10章を通じて、Djangoフレームワークの基礎から高度な機能まで包括的に学習しました。</p>
                        <hr>
                        <p class="mb-0">
                            次のステップとして、実際のプロジェクトでこれらの知識を活用し、
                            <a href="../fastapi/README.html">FastAPI学習教材</a>や
                            <a href="../../../cheatsheet/web/web-app-design-cheatsheet.html">Webアプリケーション設計チートシート</a>
                            での学習を続けることをお勧めします。
                        </p>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">&copy; 2025 F-Circle All rights reserved.</p>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js 初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>