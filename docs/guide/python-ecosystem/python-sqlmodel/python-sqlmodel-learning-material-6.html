<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python SQLModel学習教材 第6章 - 高度なクエリとパフォーマンス</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        
        .navbar {
            background-color: #306998;
        }
        
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        
        .chapter-title {
            color: #306998;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #306998;
            padding-bottom: 0.5rem;
        }
        
        .section-title {
            color: #4b8bbe;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        
        .quiz-container {
            background-color: #e6f2ff;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #306998;
        }
        
        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }
        
        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }
        
        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }
        
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }
        
        .nav-link.active {
            background-color: #306998 !important;
            color: white !important;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Python SQLModel 学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../README.html">概要</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="https://sqlmodel.tiangolo.com/" target="_blank">公式ドキュメント</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- Sidebar -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
                <div class="position-sticky pt-3">
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-1.html">
                                第1章: SQLModel入門と環境構築
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-2.html">
                                第2章: モデル定義と型安全性
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-3.html">
                                第3章: 基本的なCRUD操作
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-4.html">
                                第4章: リレーションシップと結合
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-5.html">
                                第5章: FastAPIとの統合開発
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="python-sqlmodel-learning-material-6.html">
                                第6章: 高度なクエリとパフォーマンス
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-7.html">
                                第7章: データベースマイグレーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="python-sqlmodel-learning-material-8.html">
                                第8章: 実践的なWeb API開発
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- Main Content -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第6章: 高度なクエリとパフォーマンス</h1>
                </div>

                <div id="chapter6">
                    <h2 class="chapter-title">クエリ最適化とパフォーマンスチューニング</h2>
                    
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>複雑なクエリの構築とサブクエリの活用</li>
                            <li>集計関数とグループ化の効果的な使用</li>
                            <li>インデックスの活用とクエリ最適化</li>
                            <li>N+1問題の識別と解決方法</li>
                            <li>Eager LoadingとLazy Loadingの使い分け</li>
                            <li>大量データ処理のベストプラクティス</li>
                        </ul>
                    </div>

                    <h3 class="section-title">6.1 複雑なクエリとサブクエリ</h3>
                    <p>SQLModelでより高度なクエリを構築する方法を学習します。サブクエリ、ウィンドウ関数、CTEなどの高度な機能を活用しましょう。</p>
                    
                    <div class="exercise-container">
                        <h5>実習 6-1: 複雑なクエリの実装</h5>
                        <p>サブクエリとJOINを組み合わせた複雑なクエリを実装します。</p>
                        
                        <h6>実行例 (advanced_queries.py)</h6>
                        <pre class="code-block"><code class="language-python">from datetime import datetime, timedelta
from typing import List, Tuple
from sqlmodel import Session, select, func, text, and_, or_
from sqlalchemy import desc, case

# 複雑なクエリの例
def get_active_users_with_post_stats(session: Session):
    """アクティブユーザーと投稿統計を取得"""
    # サブクエリで各ユーザーの投稿統計を計算
    post_stats_subquery = (
        select(
            Post.author_id,
            func.count(Post.id).label('post_count'),
            func.count(case((Post.is_published == True, 1))).label('published_count'),
            func.max(Post.created_at).label('last_post_date')
        )
        .group_by(Post.author_id)
        .subquery()
    )
    
    # メインクエリ
    statement = (
        select(
            User.id,
            User.username,
            User.email,
            User.created_at,
            func.coalesce(post_stats_subquery.c.post_count, 0).label('total_posts'),
            func.coalesce(post_stats_subquery.c.published_count, 0).label('published_posts'),
            post_stats_subquery.c.last_post_date
        )
        .outerjoin(post_stats_subquery, User.id == post_stats_subquery.c.author_id)
        .where(User.status == 'active')
        .order_by(desc('total_posts'))
    )
    
    results = session.exec(statement).all()
    return results

def get_popular_posts_by_period(
    session: Session, 
    days: int = 30
) -> List[Tuple]:
    """指定期間内の人気投稿を取得"""
    start_date = datetime.utcnow() - timedelta(days=days)
    
    statement = (
        select(
            Post.id,
            Post.title,
            User.username.label('author_name'),
            Post.created_at,
            # コメント数のサブクエリ（仮想的な例）
            select(func.count()).select_from(text('comments')).where(
                text('comments.post_id = posts.id')
            ).scalar_subquery().label('comment_count')
        )
        .join(User, Post.author_id == User.id)
        .where(
            and_(
                Post.is_published == True,
                Post.created_at >= start_date
            )
        )
        .order_by(desc('comment_count'), desc(Post.created_at))
        .limit(20)
    )
    
    results = session.exec(statement).all()
    return results

def get_user_engagement_metrics(session: Session):
    """ユーザーエンゲージメント指標を計算"""
    # CTE（Common Table Expression）を使用した複雑なクエリ
    user_activity_cte = (
        select(
            User.id.label('user_id'),
            User.username,
            User.created_at.label('join_date'),
            func.count(Post.id).label('post_count'),
            func.avg(
                func.extract('epoch', func.current_timestamp() - Post.created_at) / 86400
            ).label('avg_days_since_post')
        )
        .outerjoin(Post, User.id == Post.author_id)
        .group_by(User.id, User.username, User.created_at)
        .cte('user_activity')
    )
    
    statement = (
        select(
            user_activity_cte.c.user_id,
            user_activity_cte.c.username,
            user_activity_cte.c.post_count,
            case(
                (user_activity_cte.c.post_count >= 10, 'High'),
                (user_activity_cte.c.post_count >= 5, 'Medium'),
                else_='Low'
            ).label('engagement_level'),
            func.round(user_activity_cte.c.avg_days_since_post, 2).label('avg_days_since_post')
        )
        .select_from(user_activity_cte)
        .order_by(desc(user_activity_cte.c.post_count))
    )
    
    results = session.exec(statement).all()
    return results

def search_posts_with_full_text(
    session: Session, 
    search_term: str
) -> List[Post]:
    """全文検索（SQLiteの場合はLIKE検索）"""
    statement = (
        select(Post)
        .join(User, Post.author_id == User.id)
        .where(
            or_(
                Post.title.contains(search_term),
                Post.content.contains(search_term),
                User.username.contains(search_term)
            )
        )
        .where(Post.is_published == True)
        .order_by(desc(Post.created_at))
    )
    
    results = session.exec(statement).all()
    return results</code></pre>
                    </div>

                    <h3 class="section-title">6.2 N+1問題の解決</h3>
                    <p>N+1問題は、関連データを取得する際に大量のクエリが実行されるパフォーマンス問題です。この問題を識別し、効果的に解決する方法を学習します。</p>

                    <div class="exercise-container">
                        <h5>実習 6-2: N+1問題の解決</h5>
                        <p>N+1問題を発生させる悪い例と、それを解決する良い例を実装します。</p>
                        
                        <h6>実行例 (n_plus_1_solutions.py)</h6>
                        <pre class="code-block"><code class="language-python">import time
from typing import List
from sqlmodel import Session, select
from sqlalchemy.orm import selectinload, joinedload

class QueryPerformanceAnalyzer:
    """クエリパフォーマンス分析ツール"""
    
    def __init__(self, session: Session):
        self.session = session
        self.query_count = 0
        self.start_time = None
    
    def start_monitoring(self):
        """監視開始"""
        self.query_count = 0
        self.start_time = time.time()
        # SQLログをカウントするための簡易実装
        original_execute = self.session.execute
        
        def counting_execute(*args, **kwargs):
            self.query_count += 1
            return original_execute(*args, **kwargs)
        
        self.session.execute = counting_execute
    
    def get_stats(self):
        """統計情報を取得"""
        end_time = time.time()
        duration = end_time - self.start_time if self.start_time else 0
        return {
            'query_count': self.query_count,
            'duration': round(duration, 3),
            'queries_per_second': round(self.query_count / duration, 2) if duration > 0 else 0
        }

def bad_example_n_plus_1(session: Session) -> List[dict]:
    """悪い例：N+1問題が発生するコード"""
    analyzer = QueryPerformanceAnalyzer(session)
    analyzer.start_monitoring()
    
    # 1つ目のクエリ：全ユーザーを取得
    users = session.exec(select(User)).all()
    
    result = []
    for user in users:  # Nユーザーに対して
        # 各ユーザーごとに追加のクエリが実行される（+N個のクエリ）
        posts = session.exec(
            select(Post).where(Post.author_id == user.id)
        ).all()
        
        result.append({
            'user': user.username,
            'post_count': len(posts),
            'posts': [post.title for post in posts]
        })
    
    stats = analyzer.get_stats()
    print(f"❌ N+1問題発生: {stats['query_count']}個のクエリ実行（{stats['duration']}秒）")
    return result

def good_example_join_solution(session: Session) -> List[dict]:
    """良い例：JOINを使用した解決"""
    analyzer = QueryPerformanceAnalyzer(session)
    analyzer.start_monitoring()
    
    # 1つのクエリで全データを取得
    statement = (
        select(User, Post)
        .outerjoin(Post, User.id == Post.author_id)
        .order_by(User.id, Post.created_at.desc())
    )
    
    results = session.exec(statement).all()
    
    # 結果を整理
    user_posts = {}
    for user, post in results:
        if user.id not in user_posts:
            user_posts[user.id] = {
                'user': user.username,
                'posts': []
            }
        if post:
            user_posts[user.id]['posts'].append(post.title)
    
    result = []
    for user_data in user_posts.values():
        result.append({
            'user': user_data['user'],
            'post_count': len(user_data['posts']),
            'posts': user_data['posts']
        })
    
    stats = analyzer.get_stats()
    print(f"✅ JOIN解決: {stats['query_count']}個のクエリ実行（{stats['duration']}秒）")
    return result

def good_example_selectinload(session: Session) -> List[dict]:
    """良い例：selectinloadを使用した解決"""
    analyzer = QueryPerformanceAnalyzer(session)
    analyzer.start_monitoring()
    
    # selectinloadで関連データを事前読み込み
    statement = select(User).options(selectinload(User.posts))
    users = session.exec(statement).all()
    
    result = []
    for user in users:
        # 関連データは既にメモリに読み込まれているため、追加クエリなし
        result.append({
            'user': user.username,
            'post_count': len(user.posts),
            'posts': [post.title for post in user.posts]
        })
    
    stats = analyzer.get_stats()
    print(f"✅ selectinload解決: {stats['query_count']}個のクエリ実行（{stats['duration']}秒）")
    return result

def demonstrate_loading_strategies(session: Session):
    """読み込み戦略の比較"""
    print("=== N+1問題解決方法の比較 ===\n")
    
    # テストデータが少ない場合のための警告
    user_count = session.exec(select(func.count(User.id))).one()
    if user_count < 5:
        print("⚠️  テストデータが少ないため、差が分かりにくい可能性があります")
        print("   実際の本番環境では大きな差が生まれます\n")
    
    print("1. 悪い例（N+1問題）:")
    bad_result = bad_example_n_plus_1(session)
    
    print("\n2. 良い例（JOIN使用）:")
    join_result = good_example_join_solution(session)
    
    print("\n3. 良い例（selectinload使用）:")
    selectin_result = good_example_selectinload(session)
    
    print(f"\n取得したユーザー数: {len(bad_result)}")

# バッチ処理での効率的なデータ処理
def process_large_dataset_efficiently(session: Session, batch_size: int = 1000):
    """大量データの効率的なバッチ処理"""
    print(f"=== バッチサイズ {batch_size} での効率的処理 ===")
    
    total_processed = 0
    offset = 0
    
    while True:
        # バッチごとにデータを取得
        statement = (
            select(User)
            .where(User.status == 'active')
            .offset(offset)
            .limit(batch_size)
        )
        
        batch_users = session.exec(statement).all()
        
        if not batch_users:
            break
        
        # バッチ処理
        for user in batch_users:
            # 何らかの処理（例：メール送信、データ更新など）
            pass
        
        total_processed += len(batch_users)
        offset += batch_size
        
        print(f"処理済み: {total_processed}件")
        
        # メモリクリア（大量データ処理時に重要）
        session.expunge_all()
    
    return total_processed</code></pre>
                    </div>

                    <h3 class="section-title">6.3 インデックス戦略とクエリ最適化</h3>
                    <p>効果的なインデックス戦略を学び、クエリパフォーマンスを向上させる方法を理解します。</p>

                    <div class="exercise-container">
                        <h5>実習 6-3: インデックス最適化の実装</h5>
                        <p>インデックスを活用したクエリ最適化を実装します。</p>
                        
                        <h6>実行例 (index_optimization.py)</h6>
                        <pre class="code-block"><code class="language-python">from sqlmodel import SQLModel, Field, create_engine, text
from sqlalchemy import Index

# インデックス最適化されたモデル
class OptimizedUser(SQLModel, table=True):
    __tablename__ = "optimized_users"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    username: str = Field(max_length=50, unique=True, index=True)  # 単一インデックス
    email: str = Field(max_length=255, unique=True, index=True)
    status: str = Field(index=True)  # ステータス検索用
    created_at: datetime = Field(default_factory=datetime.utcnow, index=True)
    last_login: Optional[datetime] = Field(default=None, index=True)
    
    # 複合インデックスの定義
    __table_args__ = (
        Index('idx_status_created', 'status', 'created_at'),  # 複合インデックス
        Index('idx_email_status', 'email', 'status'),
    )

class OptimizedPost(SQLModel, table=True):
    __tablename__ = "optimized_posts"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    title: str = Field(max_length=200, index=True)  # タイトル検索用
    content: str
    is_published: bool = Field(default=False, index=True)
    created_at: datetime = Field(default_factory=datetime.utcnow, index=True)
    author_id: int = Field(foreign_key="optimized_users.id", index=True)
    
    # 複合インデックス
    __table_args__ = (
        Index('idx_author_published', 'author_id', 'is_published'),
        Index('idx_published_created', 'is_published', 'created_at'),
    )

def analyze_query_performance(session: Session):
    """クエリパフォーマンスの分析"""
    print("=== クエリパフォーマンス分析 ===\n")
    
    # EXPLAIN QUERY PLANの実行（SQLiteの場合）
    queries = [
        # インデックスを活用するクエリ
        "SELECT * FROM optimized_users WHERE status = 'active'",
        "SELECT * FROM optimized_users WHERE email = 'test@example.com'",
        "SELECT * FROM optimized_posts WHERE author_id = 1 AND is_published = true",
        
        # 複合インデックスを活用するクエリ
        "SELECT * FROM optimized_users WHERE status = 'active' ORDER BY created_at DESC",
        "SELECT * FROM optimized_posts WHERE is_published = true ORDER BY created_at DESC",
    ]
    
    for i, query in enumerate(queries, 1):
        print(f"{i}. クエリ分析:")
        print(f"   SQL: {query}")
        
        # EXPLAIN QUERY PLAN実行
        explain_result = session.exec(text(f"EXPLAIN QUERY PLAN {query}")).all()
        
        print("   実行計画:")
        for row in explain_result:
            print(f"   {row}")
        print()

def demonstrate_index_usage(session: Session):
    """インデックス使用例の実演"""
    # テストデータの作成
    test_users = []
    for i in range(1000):
        user = OptimizedUser(
            username=f"user_{i:04d}",
            email=f"user_{i:04d}@example.com",
            status='active' if i % 3 == 0 else 'inactive',
            created_at=datetime.utcnow() - timedelta(days=i % 365)
        )
        test_users.append(user)
    
    session.add_all(test_users)
    session.commit()
    
    print("=== インデックス効果の実演 ===\n")
    
    # 1. 単一インデックスの効果
    start_time = time.time()
    statement = select(OptimizedUser).where(OptimizedUser.status == 'active')
    active_users = session.exec(statement).all()
    end_time = time.time()
    
    print(f"1. ステータス検索（インデックス使用）:")
    print(f"   結果: {len(active_users)}件")
    print(f"   実行時間: {end_time - start_time:.4f}秒\n")
    
    # 2. 複合インデックスの効果
    start_time = time.time()
    statement = (
        select(OptimizedUser)
        .where(OptimizedUser.status == 'active')
        .order_by(OptimizedUser.created_at.desc())
        .limit(10)
    )
    recent_active_users = session.exec(statement).all()
    end_time = time.time()
    
    print(f"2. ステータス+作成日順検索（複合インデックス使用）:")
    print(f"   結果: {len(recent_active_users)}件")
    print(f"   実行時間: {end_time - start_time:.4f}秒\n")
    
    # 3. 範囲検索
    week_ago = datetime.utcnow() - timedelta(days=7)
    start_time = time.time()
    statement = (
        select(OptimizedUser)
        .where(OptimizedUser.created_at >= week_ago)
        .order_by(OptimizedUser.created_at.desc())
    )
    recent_users = session.exec(statement).all()
    end_time = time.time()
    
    print(f"3. 日付範囲検索（インデックス使用）:")
    print(f"   結果: {len(recent_users)}件")
    print(f"   実行時間: {end_time - start_time:.4f}秒")

# インデックス最適化のベストプラクティス
def index_best_practices():
    """インデックス最適化のベストプラクティス"""
    print("=== インデックス最適化のベストプラクティス ===\n")
    
    practices = [
        "1. WHERE句で頻繁に使用されるカラムにインデックスを作成",
        "2. ORDER BY句で使用されるカラムにインデックスを作成",
        "3. 複数カラムでの検索には複合インデックスを検討",
        "4. カーディナリティ（重複度）の高いカラムを優先",
        "5. インデックスの数は適度に抑制（INSERT/UPDATE性能への影響）",
        "6. 定期的なインデックス使用状況の監視",
        "7. 不要になったインデックスの削除"
    ]
    
    for practice in practices:
        print(f"✅ {practice}")
    
    print(f"\n⚠️  注意点:")
    print(f"   - インデックスはストレージ容量を消費します")
    print(f"   - INSERT/UPDATE/DELETE操作が若干遅くなります")
    print(f"   - インデックスのメンテナンスコストを考慮してください")</code></pre>
                    </div>

                    <h3 class="section-title">6.4 キャッシング戦略</h3>
                    <p>アプリケーションレベルでのキャッシング戦略を学び、データベースアクセスを最小限に抑える方法を理解します。</p>

                    <div class="exercise-container">
                        <h5>実習 6-4: キャッシング戦略の実装</h5>
                        <p>Redisを使用したキャッシング戦略を実装します。</p>
                        
                        <h6>実行例 (caching_strategies.py)</h6>
                        <pre class="code-block"><code class="language-python">import json
import hashlib
from typing import Any, Optional
from functools import wraps
from datetime import timedelta

# Redis キャッシュ実装（疑似実装）
class CacheManager:
    """キャッシュ管理クラス"""
    
    def __init__(self):
        # 実際の実装ではRedisクライアントを使用
        self._cache = {}  # 簡易実装用の辞書
    
    def get_cache_key(self, prefix: str, *args, **kwargs) -> str:
        """キャッシュキーを生成"""
        key_data = f"{prefix}:{args}:{sorted(kwargs.items())}"
        return hashlib.md5(key_data.encode()).hexdigest()
    
    def get(self, key: str) -> Optional[Any]:
        """キャッシュから値を取得"""
        return self._cache.get(key)
    
    def set(self, key: str, value: Any, ttl: int = 3600):
        """キャッシュに値を設定"""
        self._cache[key] = value
        # 実際の実装ではTTL（Time To Live）を設定
    
    def delete(self, key: str):
        """キャッシュから値を削除"""
        self._cache.pop(key, None)
    
    def clear_pattern(self, pattern: str):
        """パターンにマッチするキーを削除"""
        keys_to_delete = [k for k in self._cache.keys() if pattern in k]
        for key in keys_to_delete:
            del self._cache[key]

# キャッシュデコレータ
def cached(cache_key_prefix: str, ttl: int = 3600):
    """キャッシュデコレータ"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            cache_manager = CacheManager()
            cache_key = cache_manager.get_cache_key(cache_key_prefix, *args, **kwargs)
            
            # キャッシュから取得を試行
            cached_result = cache_manager.get(cache_key)
            if cached_result is not None:
                print(f"🎯 キャッシュヒット: {cache_key}")
                return cached_result
            
            # キャッシュミスの場合、関数を実行
            print(f"💾 キャッシュミス: {cache_key}")
            result = func(*args, **kwargs)
            
            # 結果をキャッシュに保存
            cache_manager.set(cache_key, result, ttl)
            return result
        
        return wrapper
    return decorator

# キャッシュ付きのデータアクセスレイヤー
class CachedUserService:
    """キャッシュ付きユーザーサービス"""
    
    def __init__(self, session: Session):
        self.session = session
        self.cache = CacheManager()
    
    @cached("user_by_id", ttl=1800)  # 30分キャッシュ
    def get_user_by_id(self, user_id: int) -> Optional[dict]:
        """ユーザーをIDで取得（キャッシュ付き）"""
        user = self.session.get(User, user_id)
        if not user:
            return None
        
        return {
            'id': user.id,
            'username': user.username,
            'email': user.email,
            'status': user.status,
            'created_at': user.created_at.isoformat()
        }
    
    @cached("user_posts", ttl=900)  # 15分キャッシュ
    def get_user_posts(self, user_id: int, published_only: bool = True) -> List[dict]:
        """ユーザーの投稿を取得（キャッシュ付き）"""
        statement = select(Post).where(Post.author_id == user_id)
        
        if published_only:
            statement = statement.where(Post.is_published == True)
        
        posts = self.session.exec(statement).all()
        
        return [
            {
                'id': post.id,
                'title': post.title,
                'created_at': post.created_at.isoformat(),
                'is_published': post.is_published
            }
            for post in posts
        ]
    
    @cached("popular_posts", ttl=600)  # 10分キャッシュ
    def get_popular_posts(self, limit: int = 10) -> List[dict]:
        """人気投稿を取得（キャッシュ付き）"""
        statement = (
            select(Post, User.username)
            .join(User, Post.author_id == User.id)
            .where(Post.is_published == True)
            .order_by(Post.created_at.desc())
            .limit(limit)
        )
        
        results = self.session.exec(statement).all()
        
        return [
            {
                'id': post.id,
                'title': post.title,
                'author': username,
                'created_at': post.created_at.isoformat()
            }
            for post, username in results
        ]
    
    def invalidate_user_cache(self, user_id: int):
        """ユーザー関連のキャッシュを無効化"""
        self.cache.clear_pattern(f"user_by_id:{user_id}")
        self.cache.clear_pattern(f"user_posts:{user_id}")
        self.cache.clear_pattern("popular_posts")  # 人気投稿も更新される可能性

# キャッシュ戦略のデモンストレーション
def demonstrate_caching_strategy(session: Session):
    """キャッシング戦略のデモ"""
    print("=== キャッシング戦略のデモンストレーション ===\n")
    
    service = CachedUserService(session)
    
    # 1回目のアクセス（キャッシュミス）
    print("1. 初回アクセス:")
    start_time = time.time()
    user = service.get_user_by_id(1)
    end_time = time.time()
    print(f"   実行時間: {end_time - start_time:.4f}秒")
    print(f"   結果: {user['username'] if user else 'なし'}\n")
    
    # 2回目のアクセス（キャッシュヒット）
    print("2. 2回目のアクセス:")
    start_time = time.time()
    user = service.get_user_by_id(1)
    end_time = time.time()
    print(f"   実行時間: {end_time - start_time:.4f}秒")
    print(f"   結果: {user['username'] if user else 'なし'}\n")
    
    # 投稿取得
    print("3. 投稿取得:")
    posts = service.get_user_posts(1)
    print(f"   投稿数: {len(posts)}\n")
    
    # キャッシュ無効化のテスト
    print("4. キャッシュ無効化:")
    service.invalidate_user_cache(1)
    start_time = time.time()
    user = service.get_user_by_id(1)  # 再度キャッシュミス
    end_time = time.time()
    print(f"   実行時間: {end_time - start_time:.4f}秒")</code></pre>
                    </div>

                    <div class="warning">
                        <h6>パフォーマンス最適化の注意点</h6>
                        <ul>
                            <li><strong>過度な最適化を避ける</strong>: 実際のボトルネックを特定してから最適化</li>
                            <li><strong>キャッシュの一貫性</strong>: データ更新時のキャッシュ無効化戦略</li>
                            <li><strong>メモリ使用量</strong>: 大量データ処理時のメモリリーク対策</li>
                            <li><strong>インデックスコスト</strong>: 書き込み性能への影響を考慮</li>
                            <li><strong>測定とモニタリング</strong>: 継続的なパフォーマンス監視</li>
                        </ul>
                    </div>

                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>N+1問題が発生する典型的なパターンは何ですか？</li>
                            <li>selectinloadとjoinedloadの違いは何ですか？</li>
                            <li>複合インデックスを作成する際の考慮点は？</li>
                            <li>キャッシュのTTL（Time To Live）を設定する理由は？</li>
                            <li>大量データ処理でバッチ処理を使用する利点は？</li>
                        </ol>
                        
                        <details class="mt-3">
                            <summary>解答例</summary>
                            <ol>
                                <li>親データを取得後、各親に対して個別に子データを取得するループ処理</li>
                                <li>selectinload：別クエリで関連データ取得、joinedload：JOINで一度に取得</li>
                                <li>カラムの順序、カーディナリティ、クエリパターンとの整合性</li>
                                <li>データの鮮度保持、メモリ使用量制御、一貫性確保</li>
                                <li>メモリ効率、トランザクション分割、エラー時の部分復旧可能性</li>
                            </ol>
                        </details>
                    </div>

                    <div class="d-flex justify-content-between mt-4">
                        <a href="python-sqlmodel-learning-material-5.html" class="btn btn-secondary">← 前の章：FastAPIとの統合開発</a>
                        <a href="python-sqlmodel-learning-material-7.html" class="btn btn-primary">次の章：データベースマイグレーション →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
</body>
</html>