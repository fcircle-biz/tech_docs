<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring学習教材 第10章 - さらに一歩進んだSpring開発へ①</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <!-- カスタムCSS -->
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #4caf50;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }

        /* タイトル */
        .chapter-title {
            color: #4caf50;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #4caf50;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #66bb6a;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e8f5e8;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #4caf50;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #4caf50 !important;
            color: white !important;
        }

        /* その他 */
        .card {
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand">
                <strong>Spring学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-1.html">
                                第1章: JavaとWebの基礎理解
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-2.html">
                                第2章: Spring Bootの導入と開発環境構築
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-3.html">
                                第3章: Spring Bootの基本構成とDI（依存性注入）
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-4.html">
                                第4章: Webアプリケーション開発の基礎（MVC）
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-5.html">
                                第5章: データベース連携（Spring Data JDBC）
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-6.html">
                                第6章: 入力バリデーションとエラーハンドリング
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-7.html">
                                第7章: Spring Securityによる認証・認可
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-8.html">
                                第8章: Spring MVCのテスト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-9.html">
                                第9章: Todoアプリケーション開発
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="spring-learning-material-10.html">
                                第10章: さらに一歩進んだSpring開発へ①
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-11.html">
                                第11章: さらに一歩進んだSpring開発へ②
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-ex-1.html">
                                補足①: Spring Data JPA入門
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <!-- 章ヘッダー -->
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第10章: さらに一歩進んだSpring開発へ①</h1>
                </div>

                <div id="chapter10">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">REST API開発とWebClient連携</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>RESTful APIの設計原則と基本概念</li>
                            <li>@RestControllerによるAPIエンドポイント実装</li>
                            <li>HTTPメソッド（GET、POST、PUT、DELETE）の適切な使い分け</li>
                            <li>JSONデータの変換とレスポンスフォーマット</li>
                            <li>Spring WebClientによる外部API連携</li>
                            <li>エラーハンドリングとHTTPステータスコード管理</li>
                        </ul>
                    </div>

                    <!-- セクション10.1 -->
                    <h3 class="section-title">10.1 RESTful API設計の基本原則</h3>
                    <p>
                        REST（Representational State Transfer）は、Webサービスのアーキテクチャスタイルの一つです。リソース指向の設計により、シンプルで拡張性の高いAPIを構築できます。
                    </p>

                    <div class="highlight">
                        <h6>RESTの基本原則</h6>
                        <ul>
                            <li><strong>統一インターフェース</strong>: HTTPメソッドとURLの標準的な組み合わせ</li>
                            <li><strong>ステートレス</strong>: サーバーがクライアントの状態を保持しない</li>
                            <li><strong>キャッシュ可能</strong>: レスポンスはキャッシュできるように設計</li>
                            <li><strong>階層システム</strong>: プロキシやゲートウェイを透過的に利用可能</li>
                            <li><strong>リソース識別</strong>: URLによるリソースの一意識別</li>
                        </ul>
                    </div>

                    <div class="mermaid">
                        graph LR
                            A["クライアント"] -->|"HTTP Request"| B["REST API"]
                            B -->|"HTTP Response"| A
                            
                            subgraph "HTTP Methods"
                                C["GET<br/>(読み取り)"]
                                D["POST<br/>(作成)"]
                                E["PUT<br/>(更新)"]
                                F["DELETE<br/>(削除)"]
                            end
                            
                            subgraph "Status Codes"
                                G["200 OK"]
                                H["201 Created"]
                                I["400 Bad Request"]
                                J["404 Not Found"]
                                K["500 Internal Server Error"]
                            end
                            
                            B --> C
                            B --> D
                            B --> E
                            B --> F
                            
                            B --> G
                            B --> H
                            B --> I
                            B --> J
                            B --> K
                    </div>

                    <h4>RESTful URLパターンの例</h4>
                    <pre class="code-block"><code class="language-bash"># リソース操作のURLパターン例

# ユーザー一覧取得
GET /api/users

# 特定ユーザー取得
GET /api/users/123

# ユーザー作成
POST /api/users

# ユーザー更新（全体）
PUT /api/users/123

# ユーザー部分更新
PATCH /api/users/123

# ユーザー削除
DELETE /api/users/123

# ユーザーのタスク一覧
GET /api/users/123/tasks

# 特定ユーザーの特定タスク
GET /api/users/123/tasks/456</code></pre>

                    <!-- セクション10.2 -->
                    <h3 class="section-title">10.2 @RestControllerによるAPI実装</h3>
                    <p>
                        Spring MVCの<code>@RestController</code>を使用して、RESTful APIエンドポイントを実装します。従来の<code>@Controller</code>と異なり、レスポンスは自動的にJSONやXMLに変換されます。
                    </p>

                    <div class="mermaid">
                        sequenceDiagram
                            participant Client as クライアント
                            participant Controller as @RestController
                            participant Service as Service層
                            participant Repository as Repository層
                            participant DB as データベース

                            Client->>Controller: HTTP Request
                            Controller->>Service: ビジネスロジック呼び出し
                            Service->>Repository: データアクセス
                            Repository->>DB: SQL実行
                            DB-->>Repository: 結果セット
                            Repository-->>Service: エンティティ
                            Service-->>Controller: 処理結果
                            Controller-->>Client: JSON Response
                    </div>

                    <!-- 実習10-1 -->
                    <div class="exercise-container">
                        <h5>実習 10-1: TaskのREST API実装</h5>
                        <p>TaskエンティティのCRUD操作を提供するREST APIを実装してみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>TaskApiControllerクラスの作成</li>
                            <li>各HTTPメソッドのエンドポイント実装</li>
                            <li>適切なHTTPステータスコードの設定</li>
                            <li>Postmanやcurlでのテスト実行</li>
                        </ol>

                        <h6>TaskApiController.java</h6>
                        <pre class="code-block"><code class="language-java">package com.example.todoapp.api;

import com.example.todoapp.entity.Task;
import com.example.todoapp.service.TaskService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/tasks")
@CrossOrigin(origins = "*") // 開発時のCORS設定
public class TaskApiController {
    
    private final TaskService taskService;
    
    @Autowired
    public TaskApiController(TaskService taskService) {
        this.taskService = taskService;
    }
    
    /**
     * タスク一覧取得 - GET /api/tasks
     */
    @GetMapping
    public ResponseEntity&lt;List&lt;Task&gt;&gt; getAllTasks(
            Authentication auth,
            @RequestParam(required = false) String filter,
            @RequestParam(required = false) Long categoryId,
            @RequestParam(required = false) String priority,
            @RequestParam(required = false) String search) {
        
        try {
            Long userId = getUserId(auth);
            List&lt;Task&gt; tasks;
            
            // フィルタリング処理
            if ("completed".equals(filter)) {
                tasks = taskService.findTasksByCompletionStatus(userId, true);
            } else if ("pending".equals(filter)) {
                tasks = taskService.findTasksByCompletionStatus(userId, false);
            } else if ("overdue".equals(filter)) {
                tasks = taskService.findOverdueTasks(userId);
            } else if ("today".equals(filter)) {
                tasks = taskService.findTodayTasks(userId);
            } else if (categoryId != null) {
                tasks = taskService.findTasksByCategory(userId, categoryId);
            } else if (priority != null && !priority.isEmpty()) {
                tasks = taskService.findTasksByPriority(userId, priority);
            } else if (search != null && !search.trim().isEmpty()) {
                tasks = taskService.searchTasksByTitle(userId, search.trim());
            } else {
                tasks = taskService.findTasksByUserId(userId);
            }
            
            return ResponseEntity.ok(tasks);
            
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * 特定タスク取得 - GET /api/tasks/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity&lt;Task&gt; getTaskById(@PathVariable Long id, Authentication auth) {
        try {
            Long userId = getUserId(auth);
            Optional&lt;Task&gt; task = taskService.findTaskByIdAndUserId(id, userId);
            
            if (task.isPresent()) {
                return ResponseEntity.ok(task.get());
            } else {
                return ResponseEntity.notFound().build();
            }
            
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * タスク作成 - POST /api/tasks
     */
    @PostMapping
    public ResponseEntity&lt;Task&gt; createTask(@Valid @RequestBody Task task, Authentication auth) {
        try {
            task.setUserId(getUserId(auth));
            Task createdTask = taskService.createTask(task);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(createdTask);
            
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().build();
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * タスク更新 - PUT /api/tasks/{id}
     */
    @PutMapping("/{id}")
    public ResponseEntity&lt;Task&gt; updateTask(
            @PathVariable Long id, 
            @Valid @RequestBody Task task, 
            Authentication auth) {
        
        try {
            Long userId = getUserId(auth);
            Task updatedTask = taskService.updateTask(id, task, userId);
            
            return ResponseEntity.ok(updatedTask);
            
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().build();
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * タスク完了状態切り替え - PATCH /api/tasks/{id}/toggle
     */
    @PatchMapping("/{id}/toggle")
    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; toggleTaskCompletion(@PathVariable Long id, Authentication auth) {
        try {
            Long userId = getUserId(auth);
            boolean success = taskService.toggleTaskCompletion(id, userId);
            
            if (success) {
                return ResponseEntity.ok(Map.of(
                    "success", true, 
                    "message", "タスクの状態を更新しました",
                    "timestamp", LocalDateTime.now()
                ));
            } else {
                return ResponseEntity.badRequest().body(Map.of(
                    "success", false, 
                    "message", "更新に失敗しました"
                ));
            }
            
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().body(Map.of(
                "success", false, 
                "message", "タスクが見つかりません"
            ));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of(
                "success", false, 
                "message", "内部エラーが発生しました"
            ));
        }
    }
    
    /**
     * タスク削除 - DELETE /api/tasks/{id}
     */
    @DeleteMapping("/{id}")
    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; deleteTask(@PathVariable Long id, Authentication auth) {
        try {
            Long userId = getUserId(auth);
            boolean success = taskService.deleteTask(id, userId);
            
            if (success) {
                return ResponseEntity.ok(Map.of(
                    "success", true, 
                    "message", "タスクが正常に削除されました"
                ));
            } else {
                return ResponseEntity.badRequest().body(Map.of(
                    "success", false, 
                    "message", "削除に失敗しました"
                ));
            }
            
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().body(Map.of(
                "success", false, 
                "message", "タスクが見つかりません"
            ));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of(
                "success", false, 
                "message", "内部エラーが発生しました"
            ));
        }
    }
    
    /**
     * タスク統計取得 - GET /api/tasks/statistics
     */
    @GetMapping("/statistics")
    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getTaskStatistics(Authentication auth) {
        try {
            Long userId = getUserId(auth);
            Map&lt;String, Object&gt; statistics = taskService.getTaskStatistics(userId);
            
            return ResponseEntity.ok(statistics);
            
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * ヘルスチェック - GET /api/tasks/health
     */
    @GetMapping("/health")
    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; healthCheck() {
        return ResponseEntity.ok(Map.of(
            "status", "healthy",
            "timestamp", LocalDateTime.now(),
            "service", "Task API"
        ));
    }
    
    // 認証情報からユーザーIDを取得（実際の実装では適切にユーザーIDを取得）
    private Long getUserId(Authentication auth) {
        return 2L; // サンプルデータのuser1のID
    }
}</code></pre>

                        <h6>curlでのAPI テスト例</h6>
                        <pre class="code-block"><code class="language-bash"># タスク一覧取得
curl -X GET "http://localhost:8080/api/tasks" \
     -H "Content-Type: application/json"

# 特定タスク取得
curl -X GET "http://localhost:8080/api/tasks/1" \
     -H "Content-Type: application/json"

# タスク作成
curl -X POST "http://localhost:8080/api/tasks" \
     -H "Content-Type: application/json" \
     -d '{
       "title": "REST APIテスト",
       "description": "APIから作成されたタスク",
       "priority": "HIGH",
       "dueDate": "2024-02-01"
     }'

# タスク更新
curl -X PUT "http://localhost:8080/api/tasks/1" \
     -H "Content-Type: application/json" \
     -d '{
       "title": "更新されたタスク",
       "description": "PUT APIで更新",
       "priority": "MEDIUM",
       "completed": true
     }'

# タスク完了状態切り替え
curl -X PATCH "http://localhost:8080/api/tasks/1/toggle" \
     -H "Content-Type: application/json"

# タスク削除
curl -X DELETE "http://localhost:8080/api/tasks/1" \
     -H "Content-Type: application/json"

# 統計取得
curl -X GET "http://localhost:8080/api/tasks/statistics" \
     -H "Content-Type: application/json"</code></pre>

                        <h6>期待される結果</h6>
                        <p>REST APIエンドポイントが正常に動作し、適切なHTTPステータスコードとJSONレスポンスが返されることを確認できます。</p>
                    </div>

                    <!-- セクション10.3 -->
                    <h3 class="section-title">10.3 エラーハンドリングとAPIレスポンス標準化</h3>
                    <p>
                        APIの一貫性と使いやすさを向上させるために、エラーレスポンスの標準化とグローバルエラーハンドリングを実装します。
                    </p>

                    <!-- 実習10-2 -->
                    <div class="exercise-container">
                        <h5>実習 10-2: API用グローバルエラーハンドラーの実装</h5>
                        <p>@RestControllerAdviceを使用して、API全体で統一されたエラーレスポンスを実装しましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>APIレスポンスの標準形式を定義</li>
                            <li>@RestControllerAdviceでグローバルエラーハンドラーを作成</li>
                            <li>各種例外に対するエラーレスポンスの実装</li>
                            <li>バリデーションエラーのハンドリング</li>
                        </ol>

                        <h6>ApiResponse.java（統一レスポンス形式）</h6>
                        <pre class="code-block"><code class="language-java">package com.example.todoapp.api.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.time.LocalDateTime;
import java.util.List;

/**
 * API統一レスポンス形式
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiResponse&lt;T&gt; {
    
    private boolean success;
    private T data;
    private String message;
    private List&lt;String&gt; errors;
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime timestamp;
    
    // 成功レスポンス用コンストラクタ
    public ApiResponse(T data) {
        this.success = true;
        this.data = data;
        this.timestamp = LocalDateTime.now();
    }
    
    public ApiResponse(T data, String message) {
        this.success = true;
        this.data = data;
        this.message = message;
        this.timestamp = LocalDateTime.now();
    }
    
    // エラーレスポンス用コンストラクタ
    public ApiResponse(String message) {
        this.success = false;
        this.message = message;
        this.timestamp = LocalDateTime.now();
    }
    
    public ApiResponse(List&lt;String&gt; errors) {
        this.success = false;
        this.errors = errors;
        this.timestamp = LocalDateTime.now();
    }
    
    // 静的メソッド
    public static &lt;T&gt; ApiResponse&lt;T&gt; success(T data) {
        return new ApiResponse&lt;&gt;(data);
    }
    
    public static &lt;T&gt; ApiResponse&lt;T&gt; success(T data, String message) {
        return new ApiResponse&lt;&gt;(data, message);
    }
    
    public static ApiResponse&lt;Void&gt; error(String message) {
        return new ApiResponse&lt;&gt;(message);
    }
    
    public static ApiResponse&lt;Void&gt; error(List&lt;String&gt; errors) {
        return new ApiResponse&lt;&gt;(errors);
    }
    
    // Getters and Setters
    public boolean isSuccess() { return success; }
    public void setSuccess(boolean success) { this.success = success; }
    
    public T getData() { return data; }
    public void setData(T data) { this.data = data; }
    
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    
    public List&lt;String&gt; getErrors() { return errors; }
    public void setErrors(List&lt;String&gt; errors) { this.errors = errors; }
    
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
}</code></pre>

                        <h6>ApiExceptionHandler.java</h6>
                        <pre class="code-block"><code class="language-java">package com.example.todoapp.api.exception;

import com.example.todoapp.api.dto.ApiResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.validation.BindException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.util.ArrayList;
import java.util.List;

@RestControllerAdvice(basePackages = "com.example.todoapp.api")
public class ApiExceptionHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(ApiExceptionHandler.class);
    
    /**
     * バリデーションエラー (@RequestBody)
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; handleValidationException(MethodArgumentNotValidException e) {
        logger.warn("Validation error: {}", e.getMessage());
        
        List&lt;String&gt; errors = new ArrayList&lt;&gt;();
        for (FieldError error : e.getBindingResult().getFieldErrors()) {
            errors.add(error.getField() + ": " + error.getDefaultMessage());
        }
        
        return ResponseEntity.badRequest().body(ApiResponse.error(errors));
    }
    
    /**
     * バリデーションエラー (フォーム)
     */
    @ExceptionHandler(BindException.class)
    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; handleBindException(BindException e) {
        logger.warn("Bind error: {}", e.getMessage());
        
        List&lt;String&gt; errors = new ArrayList&lt;&gt;();
        for (FieldError error : e.getBindingResult().getFieldErrors()) {
            errors.add(error.getField() + ": " + error.getDefaultMessage());
        }
        
        return ResponseEntity.badRequest().body(ApiResponse.error(errors));
    }
    
    /**
     * 引数の型変換エラー
     */
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; handleTypeMismatchException(MethodArgumentTypeMismatchException e) {
        logger.warn("Type mismatch error: {}", e.getMessage());
        
        String message = String.format("パラメータ '%s' の値 '%s' は無効です", 
                                     e.getName(), e.getValue());
        
        return ResponseEntity.badRequest().body(ApiResponse.error(message));
    }
    
    /**
     * 権限なしエラー
     */
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; handleAccessDeniedException(AccessDeniedException e) {
        logger.warn("Access denied: {}", e.getMessage());
        
        return ResponseEntity.status(HttpStatus.FORBIDDEN)
                .body(ApiResponse.error("アクセス権限がありません"));
    }
    
    /**
     * 不正な引数エラー
     */
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; handleIllegalArgumentException(IllegalArgumentException e) {
        logger.warn("Illegal argument: {}", e.getMessage());
        
        return ResponseEntity.badRequest().body(ApiResponse.error(e.getMessage()));
    }
    
    /**
     * リソース未発見エラー
     */
    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; handleNotFoundException(RuntimeException e) {
        if (e.getMessage() != null && e.getMessage().contains("見つかりません")) {
            logger.warn("Resource not found: {}", e.getMessage());
            return ResponseEntity.notFound().build();
        }
        
        // その他のRuntimeExceptionは内部エラーとして処理
        logger.error("Runtime exception: ", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("処理中にエラーが発生しました"));
    }
    
    /**
     * 予期しないエラー
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; handleGeneralException(Exception e) {
        logger.error("Unexpected error: ", e);
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("予期しないエラーが発生しました"));
    }
}</code></pre>

                        <h6>更新されたTaskApiController.java（レスポンス統一版）</h6>
                        <pre class="code-block"><code class="language-java">// TaskApiControllerの一部メソッドを統一レスポンス形式に更新

@GetMapping
public ResponseEntity&lt;ApiResponse&lt;List&lt;Task&gt;&gt;&gt; getAllTasks(/* パラメータ */) {
    Long userId = getUserId(auth);
    List&lt;Task&gt; tasks = taskService.findTasksByUserId(userId);
    
    return ResponseEntity.ok(ApiResponse.success(tasks, "タスク一覧を取得しました"));
}

@PostMapping
public ResponseEntity&lt;ApiResponse&lt;Task&gt;&gt; createTask(@Valid @RequestBody Task task, Authentication auth) {
    task.setUserId(getUserId(auth));
    Task createdTask = taskService.createTask(task);
    
    return ResponseEntity.status(HttpStatus.CREATED)
            .body(ApiResponse.success(createdTask, "タスクを作成しました"));
}

@DeleteMapping("/{id}")
public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; deleteTask(@PathVariable Long id, Authentication auth) {
    Long userId = getUserId(auth);
    taskService.deleteTask(id, userId);
    
    return ResponseEntity.ok(ApiResponse.success(null, "タスクを削除しました"));
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>全てのAPIエンドポイントで一貫したレスポンス形式が使用され、エラーハンドリングが適切に動作することを確認できます。</p>
                    </div>

                    <!-- セクション10.4 -->
                    <h3 class="section-title">10.4 Spring WebClientによる外部API連携</h3>
                    <p>
                        Spring WebClientは、リアクティブHTTPクライアントで、外部サービスとの連携に使用します。従来のRestTemplateより柔軟で高機能です。
                    </p>

                    <div class="mermaid">
                        sequenceDiagram
                            participant App as 自分のアプリ
                            participant WebClient as Spring WebClient
                            participant External as 外部API
                            participant DB as データベース

                            App->>WebClient: 外部API呼び出し設定
                            WebClient->>External: HTTP Request
                            External-->>WebClient: HTTP Response
                            WebClient-->>App: レスポンスデータ
                            App->>DB: 取得データを保存/更新
                    </div>

                    <!-- 実習10-3 -->
                    <div class="exercise-container">
                        <h5>実習 10-3: WebClientで外部API連携サービス実装</h5>
                        <p>WebClientを使用して外部の天気APIと連携し、タスクに天気情報を付与する機能を実装してみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>WebClient設定クラスの作成</li>
                            <li>外部API連携サービスの実装</li>
                            <li>天気情報を取得してタスクに関連付け</li>
                            <li>エラーハンドリングとタイムアウト設定</li>
                        </ol>

                        <h6>WebClientConfig.java</h6>
                        <pre class="code-block"><code class="language-java">package com.example.todoapp.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.netty.http.client.HttpClient;

import java.time.Duration;

@Configuration
public class WebClientConfig {
    
    /**
     * 汎用WebClient設定
     */
    @Bean
    public WebClient webClient() {
        HttpClient httpClient = HttpClient.create()
                .responseTimeout(Duration.ofSeconds(30))  // レスポンスタイムアウト
                .followRedirect(true);                    // リダイレクト追従
        
        return WebClient.builder()
                .clientConnector(new ReactorClientHttpConnector(httpClient))
                .defaultHeader("User-Agent", "TodoApp/1.0")
                .build();
    }
    
    /**
     * 天気API専用WebClient
     */
    @Bean(name = "weatherWebClient")
    public WebClient weatherWebClient() {
        return WebClient.builder()
                .baseUrl("https://api.openweathermap.org/data/2.5")
                .defaultHeader("User-Agent", "TodoApp Weather Client")
                .build();
    }
}</code></pre>

                        <h6>WeatherService.java</h6>
                        <pre class="code-block"><code class="language-java">package com.example.todoapp.service;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.List;

@Service
public class WeatherService {
    
    private static final Logger logger = LoggerFactory.getLogger(WeatherService.class);
    
    private final WebClient weatherWebClient;
    
    @Value("${weather.api.key:demo_key}") // application.ymlで設定
    private String apiKey;
    
    public WeatherService(@Qualifier("weatherWebClient") WebClient weatherWebClient) {
        this.weatherWebClient = weatherWebClient;
    }
    
    /**
     * 天気情報を取得
     */
    public Mono&lt;WeatherInfo&gt; getCurrentWeather(String city) {
        return weatherWebClient
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path("/weather")
                        .queryParam("q", city)
                        .queryParam("appid", apiKey)
                        .queryParam("units", "metric")  // 摂氏温度
                        .queryParam("lang", "ja")       // 日本語
                        .build())
                .retrieve()
                .bodyToMono(WeatherApiResponse.class)
                .map(this::convertToWeatherInfo)
                .timeout(Duration.ofSeconds(10))
                .doOnError(WebClientResponseException.class, ex -> {
                    logger.error("Weather API error: Status={}, Body={}", 
                               ex.getStatusCode(), ex.getResponseBodyAsString());
                })
                .doOnError(Exception.class, ex -> {
                    logger.error("Unexpected error in weather service: ", ex);
                })
                .onErrorReturn(getDefaultWeatherInfo());
    }
    
    /**
     * 複数都市の天気情報を並列取得
     */
    public Mono&lt;List&lt;WeatherInfo&gt;&gt; getMultipleCityWeather(List&lt;String&gt; cities) {
        List&lt;Mono&lt;WeatherInfo&gt;&gt; weatherMonos = cities.stream()
                .map(this::getCurrentWeather)
                .toList();
        
        return Mono.zip(weatherMonos, results -> {
            return List.of(results).stream()
                    .map(result -> (WeatherInfo) result)
                    .toList();
        });
    }
    
    /**
     * レスポンスを内部形式に変換
     */
    private WeatherInfo convertToWeatherInfo(WeatherApiResponse response) {
        WeatherInfo info = new WeatherInfo();
        info.setCityName(response.getName());
        info.setTemperature(response.getMain().getTemp());
        info.setHumidity(response.getMain().getHumidity());
        
        if (!response.getWeather().isEmpty()) {
            WeatherApiResponse.Weather weather = response.getWeather().get(0);
            info.setDescription(weather.getDescription());
            info.setIcon(weather.getIcon());
        }
        
        return info;
    }
    
    /**
     * デフォルト天気情報（API取得失敗時）
     */
    private WeatherInfo getDefaultWeatherInfo() {
        WeatherInfo info = new WeatherInfo();
        info.setCityName("不明");
        info.setDescription("天気情報を取得できません");
        info.setTemperature(0.0);
        info.setHumidity(0);
        return info;
    }
    
    // 内部使用のDTOクラス
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class WeatherApiResponse {
        private String name;
        private Main main;
        private List&lt;Weather&gt; weather;
        
        // Getters and Setters
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        
        public Main getMain() { return main; }
        public void setMain(Main main) { this.main = main; }
        
        public List&lt;Weather&gt; getWeather() { return weather; }
        public void setWeather(List&lt;Weather&gt; weather) { this.weather = weather; }
        
        @JsonIgnoreProperties(ignoreUnknown = true)
        public static class Main {
            private Double temp;
            private Integer humidity;
            
            public Double getTemp() { return temp; }
            public void setTemp(Double temp) { this.temp = temp; }
            
            public Integer getHumidity() { return humidity; }
            public void setHumidity(Integer humidity) { this.humidity = humidity; }
        }
        
        @JsonIgnoreProperties(ignoreUnknown = true)
        public static class Weather {
            private String description;
            private String icon;
            
            public String getDescription() { return description; }
            public void setDescription(String description) { this.description = description; }
            
            public String getIcon() { return icon; }
            public void setIcon(String icon) { this.icon = icon; }
        }
    }
    
    // 外部公開用の天気情報クラス
    public static class WeatherInfo {
        private String cityName;
        private String description;
        private Double temperature;
        private Integer humidity;
        private String icon;
        
        // Getters and Setters
        public String getCityName() { return cityName; }
        public void setCityName(String cityName) { this.cityName = cityName; }
        
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
        
        public Double getTemperature() { return temperature; }
        public void setTemperature(Double temperature) { this.temperature = temperature; }
        
        public Integer getHumidity() { return humidity; }
        public void setHumidity(Integer humidity) { this.humidity = humidity; }
        
        public String getIcon() { return icon; }
        public void setIcon(String icon) { this.icon = icon; }
    }
}</code></pre>

                        <h6>WeatherApiController.java（天気API用コントローラー）</h6>
                        <pre class="code-block"><code class="language-java">package com.example.todoapp.api;

import com.example.todoapp.api.dto.ApiResponse;
import com.example.todoapp.service.WeatherService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.List;

@RestController
@RequestMapping("/api/weather")
public class WeatherApiController {
    
    private final WeatherService weatherService;
    
    @Autowired
    public WeatherApiController(WeatherService weatherService) {
        this.weatherService = weatherService;
    }
    
    /**
     * 天気情報取得 - GET /api/weather/{city}
     */
    @GetMapping("/{city}")
    public Mono&lt;ResponseEntity&lt;ApiResponse&lt;WeatherService.WeatherInfo&gt;&gt;&gt; getWeather(@PathVariable String city) {
        return weatherService.getCurrentWeather(city)
                .map(weather -> ResponseEntity.ok(
                    ApiResponse.success(weather, city + "の天気情報を取得しました")
                ));
    }
    
    /**
     * 複数都市天気情報取得 - POST /api/weather/multiple
     */
    @PostMapping("/multiple")
    public Mono&lt;ResponseEntity&lt;ApiResponse&lt;List&lt;WeatherService.WeatherInfo&gt;&gt;&gt;&gt; getMultipleWeather(
            @RequestBody List&lt;String&gt; cities) {
        
        return weatherService.getMultipleCityWeather(cities)
                .map(weatherList -> ResponseEntity.ok(
                    ApiResponse.success(weatherList, "複数都市の天気情報を取得しました")
                ));
    }
}</code></pre>

                        <h6>application.yml（天気API設定追加）</h6>
                        <pre class="code-block"><code class="language-yaml"># 既存設定に追加
weather:
  api:
    key: "your_openweather_api_key_here"  # 実際のAPIキーに置き換え
    
# WebClient設定
webclient:
  timeout:
    connection: 5000  # 接続タイムアウト（ミリ秒）
    read: 30000      # 読み取りタイムアウト（ミリ秒）</code></pre>

                        <h6>期待される結果</h6>
                        <p>WebClientを使用して外部天気APIと正常に連携し、非同期でデータを取得してJSONで返すことを確認できます。</p>
                    </div>

                    <!-- セクション10.5 -->
                    <h3 class="section-title">10.5 APIドキュメント生成とSwagger統合</h3>
                    <p>
                        API開発では、適切なドキュメントが不可欠です。SpringDocとOpenAPIを使用して、自動的にAPIドキュメントを生成し、インタラクティブなテスト環境を提供します。
                    </p>

                    <!-- 実習10-4 -->
                    <div class="exercise-container">
                        <h5>実習 10-4: SpringDocによるAPIドキュメント生成</h5>
                        <p>SpringDoc OpenAPIを使用して、自動的にAPI仕様書とSwagger UIを生成してみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>SpringDoc依存関係の追加</li>
                            <li>OpenAPI設定クラスの作成</li>
                            <li>コントローラーへのアノテーション追加</li>
                            <li>Swagger UIでのAPI テスト</li>
                        </ol>

                        <h6>build.gradle（依存関係追加）</h6>
                        <pre class="code-block"><code class="language-bash"># 既存のdependenciesブロックに追加
dependencies {
    // 既存の依存関係...
    
    // SpringDoc OpenAPI (Swagger UI)
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.3.0'
}</code></pre>

                        <h6>OpenApiConfig.java</h6>
                        <pre class="code-block"><code class="language-java">package com.example.todoapp.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.servers.Server;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

@Configuration
public class OpenApiConfig {
    
    @Bean
    public OpenAPI todoAppOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Todo Application API")
                        .description("Spring Boot で開発されたTodoアプリケーションのREST API仕様書")
                        .version("1.0.0")
                        .contact(new Contact()
                                .name("開発チーム")
                                .email("dev-team@example.com")
                                .url("https://example.com"))
                        .license(new License()
                                .name("MIT License")
                                .url("https://opensource.org/licenses/MIT")))
                .servers(List.of(
                        new Server()
                                .url("http://localhost:8080")
                                .description("開発環境"),
                        new Server()
                                .url("https://api.todoapp.com")
                                .description("本番環境")))
                .addSecurityItem(new SecurityRequirement().addList("bearerAuth"))
                .components(new io.swagger.v3.oas.models.Components()
                        .addSecuritySchemes("bearerAuth",
                                new SecurityScheme()
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("bearer")
                                        .bearerFormat("JWT")));
    }
}</code></pre>

                        <h6>TaskApiController.java（OpenAPIアノテーション付き）</h6>
                        <pre class="code-block"><code class="language-java">// 必要なimport文を追加
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

@RestController
@RequestMapping("/api/tasks")
@Tag(name = "Task Management", description = "タスク管理API")
public class TaskApiController {
    
    // 既存のフィールドとコンストラクタ...
    
    @Operation(
        summary = "タスク一覧取得", 
        description = "ユーザーに紐づくタスク一覧を取得します。フィルタリング機能も提供しています。"
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200", 
            description = "正常にタスク一覧を取得",
            content = @Content(mediaType = "application/json", 
                             schema = @Schema(implementation = ApiResponse.class))
        ),
        @ApiResponse(
            responseCode = "500", 
            description = "内部エラー"
        )
    })
    @GetMapping
    public ResponseEntity&lt;List&lt;Task&gt;&gt; getAllTasks(
            Authentication auth,
            @Parameter(description = "フィルタ条件", example = "completed") 
            @RequestParam(required = false) String filter,
            @Parameter(description = "カテゴリID", example = "1")
            @RequestParam(required = false) Long categoryId,
            @Parameter(description = "優先度", example = "HIGH")
            @RequestParam(required = false) String priority,
            @Parameter(description = "検索キーワード", example = "会議")
            @RequestParam(required = false) String search) {
        // 既存の実装...
    }
    
    @Operation(
        summary = "タスク作成",
        description = "新しいタスクを作成します。バリデーション機能も含まれています。"
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "201", 
            description = "タスクが正常に作成されました"
        ),
        @ApiResponse(
            responseCode = "400", 
            description = "入力データが無効です"
        )
    })
    @PostMapping
    public ResponseEntity&lt;Task&gt; createTask(
            @Parameter(description = "作成するタスクの情報", required = true)
            @Valid @RequestBody Task task, 
            Authentication auth) {
        // 既存の実装...
    }
    
    @Operation(
        summary = "タスク更新",
        description = "既存のタスク情報を更新します。権限チェック機能付きです。"
    )
    @PutMapping("/{id}")
    public ResponseEntity&lt;Task&gt; updateTask(
            @Parameter(description = "更新対象タスクID", required = true, example = "1")
            @PathVariable Long id,
            @Parameter(description = "更新するタスク情報", required = true)
            @Valid @RequestBody Task task,
            Authentication auth) {
        // 既存の実装...
    }
}</code></pre>

                        <h6>application.yml（SpringDoc設定追加）</h6>
                        <pre class="code-block"><code class="language-yaml"># SpringDoc OpenAPI設定
springdoc:
  api-docs:
    path: /api-docs
  swagger-ui:
    path: /swagger-ui.html
    display-request-duration: true
    groups-order: DESC
    operationsSorter: method
    disable-swagger-default-url: true
    use-root-path: true
  show-actuator: true</code></pre>

                        <h6>期待される結果</h6>
                        <p>アプリケーション起動後、http://localhost:8080/swagger-ui.html にアクセスして、インタラクティブなAPI仕様書が表示され、直接APIテストが実行できることを確認できます。</p>
                    </div>

                    <!-- 理解度確認テスト -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <strong>RESTful APIでリソース作成に適切なHTTPメソッドとステータスコードの組み合わせは？</strong>
                                <ul>
                                    <li>a) GET + 200 OK</li>
                                    <li>b) POST + 201 Created</li>
                                    <li>c) PUT + 200 OK</li>
                                    <li>d) DELETE + 204 No Content</li>
                                </ul>
                            </li>
                            <li>
                                <strong>@RestControllerと@Controllerの主な違いは？</strong>
                                <ul>
                                    <li>a) @RestControllerはJSONを自動変換する</li>
                                    <li>b) @Controllerの方が高機能</li>
                                    <li>c) 違いはない</li>
                                    <li>d) @RestControllerはセキュリティ機能が強化されている</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Spring WebClientの主な利点は？</strong>
                                <ul>
                                    <li>a) 同期処理専用</li>
                                    <li>b) リアクティブ・非同期処理対応</li>
                                    <li>c) RestTemplateより機能が少ない</li>
                                    <li>d) 設定が複雑</li>
                                </ul>
                            </li>
                            <li>
                                <strong>API統一レスポンス形式を実装する主な目的は？</strong>
                                <ul>
                                    <li>a) パフォーマンスの向上</li>
                                    <li>b) セキュリティの強化</li>
                                    <li>c) レスポンスの一貫性とクライアント側の処理簡素化</li>
                                    <li>d) データベースアクセスの最適化</li>
                                </ul>
                            </li>
                            <li>
                                <strong>SpringDoc OpenAPIを使う主な利点は？</strong>
                                <ul>
                                    <li>a) API実行速度の向上</li>
                                    <li>b) 自動的なAPI仕様書生成とテスト環境提供</li>
                                    <li>c) データベース接続の最適化</li>
                                    <li>d) セキュリティの自動設定</li>
                                </ul>
                            </li>
                        </ol>
                        <details>
                            <summary>解答と解説</summary>
                            <ol>
                                <li><strong>b) POST + 201 Created</strong><br>
                                RESTful APIでは、リソース作成にはPOSTメソッドを使用し、成功時は201 Createdステータスを返すのが標準的です。</li>
                                <li><strong>a) @RestControllerはJSONを自動変換する</strong><br>
                                @RestControllerは@Controller + @ResponseBodyの組み合わせで、戻り値を自動的にJSONやXMLに変換します。</li>
                                <li><strong>b) リアクティブ・非同期処理対応</strong><br>
                                WebClientは非同期・リアクティブ処理に対応し、従来のRestTemplateより柔軟で高機能です。</li>
                                <li><strong>c) レスポンスの一貫性とクライアント側の処理簡素化</strong><br>
                                統一されたレスポンス形式により、クライアント側での処理が標準化され、エラーハンドリングも簡素化されます。</li>
                                <li><strong>b) 自動的なAPI仕様書生成とテスト環境提供</strong><br>
                                SpringDoc OpenAPIはコードから自動的にAPI仕様書を生成し、Swagger UIによるインタラクティブなテスト環境も提供します。</li>
                            </ol>
                        </details>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="spring-learning-material-9.html" class="btn btn-secondary">← 前の章</a>
                        <a href="spring-learning-material-11.html" class="btn btn-primary">次の章 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">&copy; 2025 F-Circle All rights reserved.</p>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js 初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>