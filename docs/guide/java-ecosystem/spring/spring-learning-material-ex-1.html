<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring学習教材 補足① - Spring Data JPA入門</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <!-- カスタムCSS -->
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #4caf50;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }

        /* タイトル */
        .chapter-title {
            color: #4caf50;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #4caf50;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #66bb6a;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e8f5e8;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #4caf50;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #4caf50 !important;
            color: white !important;
        }

        /* その他 */
        .card {
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand">
                <strong>Spring学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-1.html">
                                第1章: JavaとWebの基礎理解
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-2.html">
                                第2章: Spring Bootの導入と開発環境構築
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-3.html">
                                第3章: Spring Bootの基本構成とDI（依存性注入）
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-4.html">
                                第4章: Webアプリケーション開発の基礎（MVC）
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-5.html">
                                第5章: データベース連携（Spring Data JDBC）
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-6.html">
                                第6章: 入力バリデーションとエラーハンドリング
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-7.html">
                                第7章: Spring Securityによる認証・認可
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-8.html">
                                第8章: Spring MVCのテスト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-9.html">
                                第9章: Todoアプリケーション開発
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-10.html">
                                第10章: さらに一歩進んだSpring開発へ①
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-11.html">
                                第11章: さらに一歩進んだSpring開発へ②
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="spring-learning-material-ex-1.html">
                                補足①: Spring Data JPA入門
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <!-- 章ヘッダー -->
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">補足①: Spring Data JPA入門</h1>
                </div>

                <div id="supplement1">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">JPA/Hibernateによる高度なデータアクセス</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>JPAとHibernateの基本概念と仕組み</li>
                            <li>Spring Data JPAの設定と基本的な使用方法</li>
                            <li>エンティティ間のリレーションシップマッピング</li>
                            <li>遅延読み込み（Lazy Loading）とN+1問題の対処法</li>
                            <li>JPQLとCriteriaAPIによる高度なクエリ実装</li>
                            <li>Spring Data JDBCとJPAの使い分け基準</li>
                        </ul>
                    </div>

                    <!-- セクション補1.1 -->
                    <h3 class="section-title">補1.1 JPAとHibernateの基本概念</h3>
                    <p>
                        JPA（Java Persistence API）は、Javaでオブジェクトリレーショナルマッピング（ORM）を行うための標準仕様です。Hibernateは、JPAの代表的な実装であり、Spring Boot ではデフォルトで使用されます。
                    </p>

                    <div class="highlight">
                        <h6>JPA/Hibernateの主要概念</h6>
                        <ul>
                            <li><strong>エンティティ</strong>: データベーステーブルにマッピングされるJavaオブジェクト</li>
                            <li><strong>永続化コンテキスト</strong>: エンティティのライフサイクルを管理する環境</li>
                            <li><strong>遅延読み込み</strong>: 必要になるまでデータの読み込みを遅延させる仕組み</li>
                            <li><strong>自動DDL生成</strong>: エンティティ定義からデータベーススキーマを自動生成</li>
                            <li><strong>キャッシュ機能</strong>: 1次キャッシュと2次キャッシュによる性能向上</li>
                        </ul>
                    </div>

                    <div class="mermaid">
                        graph TB
                            subgraph "アプリケーション層"
                                A[Service Layer]
                            end
                            
                            subgraph "データアクセス層"
                                B[Repository Interface]
                                C[Spring Data JPA]
                            end
                            
                            subgraph "JPA/Hibernate層"
                                D[EntityManager]
                                E[Persistence Context]
                                F[1st Level Cache]
                            end
                            
                            subgraph "データベース"
                                G[(Database)]
                            end
                            
                            A --> B
                            B --> C
                            C --> D
                            D --> E
                            E --> F
                            F --> G
                            
                            H[Entity Classes] --> E
                            I[JPA Annotations] --> H
                    </div>

                    <h4>Spring Data JDBCとSpring Data JPAの比較</h4>
                    <pre class="code-block"><code class="language-java">// Spring Data JDBC（シンプル・軽量）
@Table("users")
public class User {
    @Id
    private Long id;
    private String name;
    private String email;
    // getter/setter
}

// Spring Data JPA（高機能・複雑）
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 100)
    private String name;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List&lt;Order&gt; orders = new ArrayList&lt;&gt;();
    
    // getter/setter, equals/hashCode
}</code></pre>

                    <!-- セクション補1.2 -->
                    <h3 class="section-title">補1.2 Spring Data JPAのセットアップと基本設定</h3>
                    <p>
                        Spring Data JPAを使用するための設定と、基本的なエンティティとリポジトリの実装方法を学習します。
                    </p>

                    <!-- 実習補1-1 -->
                    <div class="exercise-container">
                        <h5>実習 補1-1: Spring Data JPAプロジェクトのセットアップ</h5>
                        <p>Spring Data JPAの依存関係追加から基本的なエンティティ実装まで行ってみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>build.gradleにSpring Data JPA依存関係を追加</li>
                            <li>application.ymlでJPA設定を行う</li>
                            <li>基本的なJPAエンティティを作成</li>
                            <li>JpaRepositoryインターフェースを実装</li>
                        </ol>

                        <h6>build.gradle（依存関係追加）</h6>
                        <pre class="code-block"><code class="language-bash">dependencies {
    // Spring Boot Starters
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'  // JPA追加
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    
    // Database
    runtimeOnly 'org.postgresql:postgresql'
    runtimeOnly 'com.h2database:h2'
    
    // Optional: Hibernate additional features
    implementation 'org.hibernate:hibernate-envers'  // 監査機能
    implementation 'org.hibernate:hibernate-validator' // バリデーション強化
    
    // Testing
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.testcontainers:postgresql' // 統合テスト用
}</code></pre>

                        <h6>application.yml（JPA設定）</h6>
                        <pre class="code-block"><code class="language-yaml">spring:
  application:
    name: jpa-demo-app
  
  # Database configuration
  datasource:
    url: jdbc:postgresql://localhost:5432/jpadb
    username: jpauser
    password: jpapass
    driver-class-name: org.postgresql.Driver
  
  # JPA/Hibernate configuration
  jpa:
    hibernate:
      ddl-auto: validate  # none, create, create-drop, update, validate
    show-sql: true
    format-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
        use_sql_comments: true
        jdbc:
          batch_size: 20      # バッチサイズ
        order_inserts: true   # INSERT順序最適化
        order_updates: true   # UPDATE順序最適化
        cache:
          use_second_level_cache: true
          region:
            factory_class: org.hibernate.cache.jcache.JCacheRegionFactory
    
  # SQL initialization (for development)
  sql:
    init:
      mode: never  # JPAのddl-autoを使用する場合はnever

# Logging
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.orm.jdbc.bind: TRACE  # パラメータログ
    org.springframework.transaction: DEBUG
    com.example.jpademq: DEBUG

---
# Test profile
spring:
  config:
    activate:
      on-profile: test
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password: ""
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: false  # テスト時はログ抑制</code></pre>

                        <h6>基本的なJPAエンティティ</h6>
                        <pre class="code-block"><code class="language-java">package com.example.jpademq.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.Objects;

@Entity
@Table(name = "customers",
       indexes = {
           @Index(name = "idx_customer_email", columnList = "email"),
           @Index(name = "idx_customer_company", columnList = "company_name")
       })
public class Customer {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "first_name", nullable = false, length = 50)
    @NotBlank(message = "名前は必須です")
    @Size(max = 50, message = "名前は50文字以内で入力してください")
    private String firstName;
    
    @Column(name = "last_name", nullable = false, length = 50)
    @NotBlank(message = "姓は必須です")
    @Size(max = 50, message = "姓は50文字以内で入力してください")
    private String lastName;
    
    @Column(name = "email", unique = true, nullable = false, length = 100)
    @NotBlank(message = "メールアドレスは必須です")
    @Email(message = "正しいメールアドレス形式で入力してください")
    private String email;
    
    @Column(name = "phone_number", length = 20)
    @Pattern(regexp = "^[0-9\\-\\+\\(\\)\\s]*$", message = "正しい電話番号形式で入力してください")
    private String phoneNumber;
    
    @Column(name = "company_name", length = 100)
    @Size(max = 100, message = "会社名は100文字以内で入力してください")
    private String companyName;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private CustomerStatus status = CustomerStatus.ACTIVE;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at", nullable = false)
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    // デフォルトコンストラクタ（JPA要件）
    protected Customer() {}
    
    // ビジネス用コンストラクタ
    public Customer(String firstName, String lastName, String email) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.email = email;
        this.status = CustomerStatus.ACTIVE;
    }
    
    // ビジネスメソッド
    public String getFullName() {
        return firstName + " " + lastName;
    }
    
    public void activate() {
        this.status = CustomerStatus.ACTIVE;
    }
    
    public void deactivate() {
        this.status = CustomerStatus.INACTIVE;
    }
    
    public boolean isActive() {
        return CustomerStatus.ACTIVE.equals(this.status);
    }
    
    // equals and hashCode (重要: JPAエンティティでは慎重に実装)
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Customer customer)) return false;
        return Objects.equals(email, customer.email);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(email);
    }
    
    @Override
    public String toString() {
        return "Customer{" +
                "id=" + id +
                ", firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                ", email='" + email + '\'' +
                ", status=" + status +
                '}';
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }
    
    public String getCompanyName() { return companyName; }
    public void setCompanyName(String companyName) { this.companyName = companyName; }
    
    public CustomerStatus getStatus() { return status; }
    public void setStatus(CustomerStatus status) { this.status = status; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
}

/**
 * 顧客ステータス列挙型
 */
enum CustomerStatus {
    ACTIVE("有効"),
    INACTIVE("無効"),
    SUSPENDED("停止中");
    
    private final String displayName;
    
    CustomerStatus(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}</code></pre>

                        <h6>JpaRepositoryインターフェース</h6>
                        <pre class="code-block"><code class="language-java">package com.example.jpademq.repository;

import com.example.jpademq.entity.Customer;
import com.example.jpademq.entity.CustomerStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface CustomerRepository extends JpaRepository&lt;Customer, Long&gt; {
    
    // メソッド名からクエリを自動生成
    Optional&lt;Customer&gt; findByEmail(String email);
    
    List&lt;Customer&gt; findByStatus(CustomerStatus status);
    
    List&lt;Customer&gt; findByFirstNameAndLastName(String firstName, String lastName);
    
    List&lt;Customer&gt; findByCompanyNameContainingIgnoreCase(String companyName);
    
    boolean existsByEmail(String email);
    
    long countByStatus(CustomerStatus status);
    
    // ページング対応
    Page&lt;Customer&gt; findByStatusOrderByCreatedAtDesc(CustomerStatus status, Pageable pageable);
    
    // カスタムJPQLクエリ
    @Query("SELECT c FROM Customer c WHERE c.firstName LIKE :name OR c.lastName LIKE :name")
    List&lt;Customer&gt; findByNameLike(@Param("name") String name);
    
    @Query("SELECT c FROM Customer c WHERE c.createdAt BETWEEN :startDate AND :endDate ORDER BY c.createdAt DESC")
    List&lt;Customer&gt; findByCreatedAtBetween(@Param("startDate") LocalDateTime startDate, 
                                         @Param("endDate") LocalDateTime endDate);
    
    // ネイティブSQLクエリ
    @Query(value = "SELECT * FROM customers WHERE company_name IS NOT NULL AND status = :status ORDER BY company_name", 
           nativeQuery = true)
    List&lt;Customer&gt; findCorporateCustomersByStatus(@Param("status") String status);
    
    // 更新クエリ
    @Modifying
    @Query("UPDATE Customer c SET c.status = :newStatus WHERE c.status = :oldStatus")
    int bulkUpdateStatus(@Param("oldStatus") CustomerStatus oldStatus, @Param("newStatus") CustomerStatus newStatus);
    
    // 集計クエリ
    @Query("SELECT c.status, COUNT(c) FROM Customer c GROUP BY c.status")
    List&lt;Object[]&gt; getCustomerCountByStatus();
    
    // 複雑な条件での検索
    @Query("SELECT c FROM Customer c WHERE " +
           "(:firstName IS NULL OR c.firstName LIKE %:firstName%) AND " +
           "(:lastName IS NULL OR c.lastName LIKE %:lastName%) AND " +
           "(:email IS NULL OR c.email LIKE %:email%) AND " +
           "(:companyName IS NULL OR c.companyName LIKE %:companyName%) AND " +
           "(:status IS NULL OR c.status = :status)")
    Page&lt;Customer&gt; findByMultipleConditions(@Param("firstName") String firstName,
                                          @Param("lastName") String lastName,
                                          @Param("email") String email,
                                          @Param("companyName") String companyName,
                                          @Param("status") CustomerStatus status,
                                          Pageable pageable);
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>Spring Data JPAが正常に設定され、エンティティの基本的なCRUD操作とカスタムクエリが動作することを確認できます。</p>
                    </div>

                    <!-- セクション補1.3 -->
                    <h3 class="section-title">補1.3 エンティティ間のリレーションシップマッピング</h3>
                    <p>
                        JPAの最も強力な機能の一つは、エンティティ間の複雑な関係をオブジェクト指向的に表現できることです。1対多、多対1、多対多の関係を適切にマッピングする方法を学習します。
                    </p>

                    <div class="mermaid">
                        erDiagram
                            CUSTOMER ||--o{ ORDER : places
                            ORDER ||--o{ ORDER_ITEM : contains
                            PRODUCT ||--o{ ORDER_ITEM : "ordered as"
                            CATEGORY ||--o{ PRODUCT : categorizes
                            ORDER }o--|| PAYMENT : "paid by"
                            
                            CUSTOMER {
                                bigint id PK
                                varchar first_name
                                varchar last_name
                                varchar email UK
                                varchar phone_number
                                varchar company_name
                                varchar status
                                timestamp created_at
                                timestamp updated_at
                            }
                            
                            ORDER {
                                bigint id PK
                                bigint customer_id FK
                                varchar order_number UK
                                varchar status
                                decimal total_amount
                                timestamp order_date
                                timestamp created_at
                                timestamp updated_at
                            }
                            
                            ORDER_ITEM {
                                bigint id PK
                                bigint order_id FK
                                bigint product_id FK
                                integer quantity
                                decimal unit_price
                                decimal subtotal
                            }
                            
                            PRODUCT {
                                bigint id PK
                                bigint category_id FK
                                varchar name
                                text description
                                decimal price
                                integer stock_quantity
                                varchar status
                                timestamp created_at
                            }
                            
                            CATEGORY {
                                bigint id PK
                                varchar name UK
                                varchar description
                                varchar status
                                timestamp created_at
                            }
                            
                            PAYMENT {
                                bigint id PK
                                bigint order_id FK
                                varchar payment_method
                                decimal amount
                                varchar status
                                timestamp payment_date
                            }
                    </div>

                    <!-- 実習補1-2 -->
                    <div class="exercise-container">
                        <h5>実習 補1-2: 複雑なエンティティ関係のマッピング実装</h5>
                        <p>Customer、Order、OrderItem、Productの関係を含むECサイトのデータモデルを実装してみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>関連エンティティクラスの作成</li>
                            <li>@OneToMany、@ManyToOne、@ManyToManyの適用</li>
                            <li>FetchType（遅延読み込み）の設定</li>
                            <li>CascadeTypeの設定とライフサイクル管理</li>
                        </ol>

                        <h6>Order.java（1対多の親エンティティ）</h6>
                        <pre class="code-block"><code class="language-java">package com.example.jpademq.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@Entity
@Table(name = "orders",
       indexes = {
           @Index(name = "idx_order_customer_id", columnList = "customer_id"),
           @Index(name = "idx_order_number", columnList = "order_number"),
           @Index(name = "idx_order_date", columnList = "order_date")
       })
public class Order {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // 多対1: 複数の注文が一人の顧客に属する
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "customer_id", nullable = false)
    private Customer customer;
    
    @Column(name = "order_number", unique = true, nullable = false, length = 50)
    @NotBlank(message = "注文番号は必須です")
    private String orderNumber;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private OrderStatus status = OrderStatus.PENDING;
    
    @Column(name = "total_amount", nullable = false, precision = 10, scale = 2)
    @NotNull(message = "合計金額は必須です")
    @DecimalMin(value = "0.0", inclusive = false, message = "合計金額は0より大きい値を設定してください")
    private BigDecimal totalAmount = BigDecimal.ZERO;
    
    @Column(name = "order_date", nullable = false)
    @NotNull(message = "注文日時は必須です")
    private LocalDateTime orderDate;
    
    // 1対多: 一つの注文に複数の注文項目が含まれる
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;();
    
    // 1対1: 一つの注文に一つの支払い情報
    @OneToOne(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Payment payment;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at", nullable = false)
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    // デフォルトコンストラクタ
    protected Order() {}
    
    // ビジネス用コンストラクタ
    public Order(Customer customer, String orderNumber, LocalDateTime orderDate) {
        this.customer = customer;
        this.orderNumber = orderNumber;
        this.orderDate = orderDate;
        this.status = OrderStatus.PENDING;
        this.totalAmount = BigDecimal.ZERO;
    }
    
    // ビジネスメソッド
    public void addOrderItem(OrderItem orderItem) {
        orderItems.add(orderItem);
        orderItem.setOrder(this);
        calculateTotalAmount();
    }
    
    public void removeOrderItem(OrderItem orderItem) {
        orderItems.remove(orderItem);
        orderItem.setOrder(null);
        calculateTotalAmount();
    }
    
    private void calculateTotalAmount() {
        this.totalAmount = orderItems.stream()
                .map(OrderItem::getSubtotal)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
    
    public void confirm() {
        if (OrderStatus.PENDING.equals(this.status)) {
            this.status = OrderStatus.CONFIRMED;
        } else {
            throw new IllegalStateException("確定できる状態ではありません: " + this.status);
        }
    }
    
    public void ship() {
        if (OrderStatus.CONFIRMED.equals(this.status)) {
            this.status = OrderStatus.SHIPPED;
        } else {
            throw new IllegalStateException("発送できる状態ではありません: " + this.status);
        }
    }
    
    public void complete() {
        if (OrderStatus.SHIPPED.equals(this.status)) {
            this.status = OrderStatus.COMPLETED;
        } else {
            throw new IllegalStateException("完了にできる状態ではありません: " + this.status);
        }
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Order order)) return false;
        return Objects.equals(orderNumber, order.orderNumber);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(orderNumber);
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public Customer getCustomer() { return customer; }
    public void setCustomer(Customer customer) { this.customer = customer; }
    
    public String getOrderNumber() { return orderNumber; }
    public void setOrderNumber(String orderNumber) { this.orderNumber = orderNumber; }
    
    public OrderStatus getStatus() { return status; }
    public void setStatus(OrderStatus status) { this.status = status; }
    
    public BigDecimal getTotalAmount() { return totalAmount; }
    public void setTotalAmount(BigDecimal totalAmount) { this.totalAmount = totalAmount; }
    
    public LocalDateTime getOrderDate() { return orderDate; }
    public void setOrderDate(LocalDateTime orderDate) { this.orderDate = orderDate; }
    
    public List&lt;OrderItem&gt; getOrderItems() { return orderItems; }
    public void setOrderItems(List&lt;OrderItem&gt; orderItems) { this.orderItems = orderItems; }
    
    public Payment getPayment() { return payment; }
    public void setPayment(Payment payment) { this.payment = payment; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
}

enum OrderStatus {
    PENDING("注文待ち"),
    CONFIRMED("確定"),
    SHIPPED("発送済み"),
    COMPLETED("完了"),
    CANCELLED("キャンセル");
    
    private final String displayName;
    
    OrderStatus(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}</code></pre>

                        <h6>OrderItem.java（中間エンティティ）</h6>
                        <pre class="code-block"><code class="language-java">package com.example.jpademq.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;

import java.math.BigDecimal;
import java.util.Objects;

@Entity
@Table(name = "order_items",
       indexes = {
           @Index(name = "idx_order_item_order_id", columnList = "order_id"),
           @Index(name = "idx_order_item_product_id", columnList = "product_id")
       })
public class OrderItem {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // 多対1: 複数の注文項目が一つの注文に属する
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;
    
    // 多対1: 複数の注文項目が一つの商品を参照する
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;
    
    @Column(name = "quantity", nullable = false)
    @Min(value = 1, message = "数量は1以上で入力してください")
    private Integer quantity;
    
    @Column(name = "unit_price", nullable = false, precision = 10, scale = 2)
    @NotNull(message = "単価は必須です")
    @DecimalMin(value = "0.0", inclusive = false, message = "単価は0より大きい値を設定してください")
    private BigDecimal unitPrice;
    
    @Column(name = "subtotal", nullable = false, precision = 10, scale = 2)
    @NotNull(message = "小計は必須です")
    private BigDecimal subtotal;
    
    // デフォルトコンストラクタ
    protected OrderItem() {}
    
    // ビジネス用コンストラクタ
    public OrderItem(Order order, Product product, Integer quantity, BigDecimal unitPrice) {
        this.order = order;
        this.product = product;
        this.quantity = quantity;
        this.unitPrice = unitPrice;
        this.subtotal = calculateSubtotal();
    }
    
    // ビジネスメソッド
    public BigDecimal calculateSubtotal() {
        if (quantity != null && unitPrice != null) {
            return unitPrice.multiply(BigDecimal.valueOf(quantity));
        }
        return BigDecimal.ZERO;
    }
    
    public void updateQuantity(Integer newQuantity) {
        this.quantity = newQuantity;
        this.subtotal = calculateSubtotal();
    }
    
    public void updateUnitPrice(BigDecimal newUnitPrice) {
        this.unitPrice = newUnitPrice;
        this.subtotal = calculateSubtotal();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof OrderItem orderItem)) return false;
        return Objects.equals(order, orderItem.order) && 
               Objects.equals(product, orderItem.product);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(order, product);
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public Order getOrder() { return order; }
    public void setOrder(Order order) { this.order = order; }
    
    public Product getProduct() { return product; }
    public void setProduct(Product product) { this.product = product; }
    
    public Integer getQuantity() { return quantity; }
    public void setQuantity(Integer quantity) { 
        this.quantity = quantity;
        this.subtotal = calculateSubtotal();
    }
    
    public BigDecimal getUnitPrice() { return unitPrice; }
    public void setUnitPrice(BigDecimal unitPrice) { 
        this.unitPrice = unitPrice;
        this.subtotal = calculateSubtotal();
    }
    
    public BigDecimal getSubtotal() { return subtotal; }
    public void setSubtotal(BigDecimal subtotal) { this.subtotal = subtotal; }
}</code></pre>

                        <h6>Product.java（多対多関係を含む）</h6>
                        <pre class="code-block"><code class="language-java">package com.example.jpademq.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import org.hibernate.annotations.CreationTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "products",
       indexes = {
           @Index(name = "idx_product_category_id", columnList = "category_id"),
           @Index(name = "idx_product_name", columnList = "name"),
           @Index(name = "idx_product_status", columnList = "status")
       })
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // 多対1: 複数の商品が一つのカテゴリに属する
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "category_id", nullable = false)
    private Category category;
    
    @Column(name = "name", nullable = false, length = 200)
    @NotBlank(message = "商品名は必須です")
    @Size(max = 200, message = "商品名は200文字以内で入力してください")
    private String name;
    
    @Column(name = "description", columnDefinition = "TEXT")
    private String description;
    
    @Column(name = "price", nullable = false, precision = 10, scale = 2)
    @NotNull(message = "価格は必須です")
    @DecimalMin(value = "0.0", inclusive = false, message = "価格は0より大きい値を設定してください")
    private BigDecimal price;
    
    @Column(name = "stock_quantity", nullable = false)
    @Min(value = 0, message = "在庫数量は0以上で入力してください")
    private Integer stockQuantity;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private ProductStatus status = ProductStatus.ACTIVE;
    
    // 多対多: 商品は複数のタグを持ち、タグは複数の商品に関連付けられる
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(name = "product_tags",
               joinColumns = @JoinColumn(name = "product_id"),
               inverseJoinColumns = @JoinColumn(name = "tag_id"))
    private Set&lt;Tag&gt; tags = new HashSet&lt;&gt;();
    
    @Column(name = "created_at", nullable = false, updatable = false)
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    // デフォルトコンストラクタ
    protected Product() {}
    
    // ビジネス用コンストラクタ
    public Product(Category category, String name, String description, BigDecimal price, Integer stockQuantity) {
        this.category = category;
        this.name = name;
        this.description = description;
        this.price = price;
        this.stockQuantity = stockQuantity;
        this.status = ProductStatus.ACTIVE;
    }
    
    // ビジネスメソッド
    public void addTag(Tag tag) {
        tags.add(tag);
        tag.getProducts().add(this);
    }
    
    public void removeTag(Tag tag) {
        tags.remove(tag);
        tag.getProducts().remove(this);
    }
    
    public boolean isInStock() {
        return stockQuantity != null && stockQuantity > 0;
    }
    
    public boolean canOrder(int quantity) {
        return isInStock() && stockQuantity >= quantity && ProductStatus.ACTIVE.equals(status);
    }
    
    public void reduceStock(int quantity) {
        if (!canOrder(quantity)) {
            throw new IllegalStateException("在庫が不足しています");
        }
        this.stockQuantity -= quantity;
    }
    
    public void increaseStock(int quantity) {
        this.stockQuantity += quantity;
    }
    
    public void activate() {
        this.status = ProductStatus.ACTIVE;
    }
    
    public void deactivate() {
        this.status = ProductStatus.INACTIVE;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Product product)) return false;
        return Objects.equals(name, product.name) && Objects.equals(category, product.category);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, category);
    }
    
    // Getters and Setters (省略...)
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public Category getCategory() { return category; }
    public void setCategory(Category category) { this.category = category; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public BigDecimal getPrice() { return price; }
    public void setPrice(BigDecimal price) { this.price = price; }
    
    public Integer getStockQuantity() { return stockQuantity; }
    public void setStockQuantity(Integer stockQuantity) { this.stockQuantity = stockQuantity; }
    
    public ProductStatus getStatus() { return status; }
    public void setStatus(ProductStatus status) { this.status = status; }
    
    public Set&lt;Tag&gt; getTags() { return tags; }
    public void setTags(Set&lt;Tag&gt; tags) { this.tags = tags; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
}

enum ProductStatus {
    ACTIVE("販売中"),
    INACTIVE("販売停止"),
    DISCONTINUED("販売終了");
    
    private final String displayName;
    
    ProductStatus(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>複雑なエンティティ間の関係が適切にマッピングされ、ビジネスロジックを含むメソッドが正常に動作することを確認できます。</p>
                    </div>

                    <!-- セクション補1.4 -->
                    <h3 class="section-title">補1.4 遅延読み込み（Lazy Loading）とN+1問題</h3>
                    <p>
                        JPAの遅延読み込みは性能最適化の重要な機能ですが、不適切に使用するとN+1問題などの性能問題を引き起こします。これらの問題を理解し、適切な対処法を学習します。
                    </p>

                    <div class="warning">
                        <h6>N+1問題とは</h6>
                        <p>
                            1つのクエリで親エンティティを取得した後、各親エンティティの子エンティティを取得するために N回のクエリが実行される問題。
                            例：10件の注文を取得し、それぞれの注文項目を取得する場合、1 + 10 = 11回のクエリが実行される。
                        </p>
                    </div>

                    <div class="mermaid">
                        sequenceDiagram
                            participant App as Application
                            participant JPA as JPA/Hibernate
                            participant DB as Database

                            Note over App,DB: N+1問題の発生例
                            App->>JPA: findAll() - 注文一覧取得
                            JPA->>DB: SELECT * FROM orders (1回目)
                            DB-->>JPA: 10件の注文データ
                            
                            App->>JPA: order1.getOrderItems()
                            JPA->>DB: SELECT * FROM order_items WHERE order_id=1 (2回目)
                            DB-->>JPA: order1の注文項目
                            
                            App->>JPA: order2.getOrderItems()
                            JPA->>DB: SELECT * FROM order_items WHERE order_id=2 (3回目)
                            DB-->>JPA: order2の注文項目
                            
                            Note over App,DB: ... 以下、各注文に対して繰り返し
                            
                            App->>JPA: order10.getOrderItems()
                            JPA->>DB: SELECT * FROM order_items WHERE order_id=10 (11回目)
                            DB-->>JPA: order10の注文項目
                    </div>

                    <!-- 実習補1-3 -->
                    <div class="exercise-container">
                        <h5>実習 補1-3: N+1問題の解決手法実装</h5>
                        <p>N+1問題を発生させ、その後Fetch Join、EntityGraph、Batch Fetchingなどの手法で解決してみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>N+1問題を発生させるコードの実装</li>
                            <li>JPQLのFetch Joinによる解決</li>
                            <li>@EntityGraphによる解決</li>
                            <li>Batch Fetchingによる解決</li>
                        </ol>

                        <h6>N+1問題の解決：リポジトリレベル</h6>
                        <pre class="code-block"><code class="language-java">package com.example.jpademq.repository;

import com.example.jpademq.entity.Order;
import com.example.jpademq.entity.OrderStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {
    
    // N+1問題が発生するクエリ（問題のあるパターン）
    List&lt;Order&gt; findByStatusOrderByOrderDateDesc(OrderStatus status);
    
    // 解決策1: JPQL Fetch Join
    @Query("SELECT DISTINCT o FROM Order o " +
           "LEFT JOIN FETCH o.orderItems oi " +
           "LEFT JOIN FETCH oi.product " +
           "WHERE o.status = :status " +
           "ORDER BY o.orderDate DESC")
    List&lt;Order&gt; findByStatusWithItemsAndProducts(@Param("status") OrderStatus status);
    
    // 解決策2: @EntityGraph（アノテーションベース）
    @EntityGraph(attributePaths = {"orderItems", "orderItems.product", "customer"})
    @Query("SELECT o FROM Order o WHERE o.status = :status ORDER BY o.orderDate DESC")
    List&lt;Order&gt; findByStatusWithEntityGraph(@Param("status") OrderStatus status);
    
    // 解決策3: 名前付きEntityGraph
    @EntityGraph("Order.withItemsAndProducts")
    List&lt;Order&gt; findByCustomerIdOrderByOrderDateDesc(Long customerId);
    
    // 複雑なFetch Join（複数の関連を一度に取得）
    @Query("SELECT DISTINCT o FROM Order o " +
           "LEFT JOIN FETCH o.orderItems oi " +
           "LEFT JOIN FETCH oi.product p " +
           "LEFT JOIN FETCH p.category " +
           "LEFT JOIN FETCH o.customer " +
           "LEFT JOIN FETCH o.payment " +
           "WHERE o.orderDate BETWEEN :startDate AND :endDate " +
           "ORDER BY o.orderDate DESC")
    List&lt;Order&gt; findOrdersWithAllRelationsByDateRange(@Param("startDate") LocalDateTime startDate,
                                                     @Param("endDate") LocalDateTime endDate);
    
    // ページング対応のFetch Join（重複排除が重要）
    @Query(value = "SELECT DISTINCT o FROM Order o " +
                   "LEFT JOIN FETCH o.orderItems oi " +
                   "LEFT JOIN FETCH oi.product",
           countQuery = "SELECT COUNT(DISTINCT o) FROM Order o WHERE o.status = :status")
    Page&lt;Order&gt; findByStatusWithItemsPageable(@Param("status") OrderStatus status, Pageable pageable);
    
    // サブクエリを使った効率的な関連データ取得
    @Query("SELECT o FROM Order o WHERE o.id IN (" +
           "SELECT DISTINCT oi.order.id FROM OrderItem oi " +
           "WHERE oi.product.name LIKE %:productName%" +
           ")")
    List&lt;Order&gt; findOrdersByProductNameContaining(@Param("productName") String productName);
}</code></pre>

                        <h6>Orderエンティティに@NamedEntityGraph追加</h6>
                        <pre class="code-block"><code class="language-java">// Order.java の先頭に追加
@Entity
@Table(name = "orders")
@NamedEntityGraph(
    name = "Order.withItemsAndProducts",
    attributeNodes = {
        @NamedAttributeNode("customer"),
        @NamedAttributeNode(value = "orderItems", subgraph = "items-subgraph"),
        @NamedAttributeNode("payment")
    },
    subgraphs = {
        @NamedSubgraph(
            name = "items-subgraph",
            attributeNodes = {
                @NamedAttributeNode("product"),
                @NamedAttributeNode(value = "product", subgraph = "product-subgraph")
            }
        ),
        @NamedSubgraph(
            name = "product-subgraph",
            attributeNodes = {
                @NamedAttributeNode("category")
            }
        )
    }
)
public class Order {
    // 既存のコード...
}</code></pre>

                        <h6>Batch Fetching設定（application.yml）</h6>
                        <pre class="code-block"><code class="language-yaml">spring:
  jpa:
    properties:
      hibernate:
        # Batch Fetching設定
        jdbc:
          batch_size: 10
        default_batch_fetch_size: 16
        
        # 遅延読み込みの最適化
        enable_lazy_load_no_trans: false
        
        # クエリ統計の有効化（開発時のみ）
        generate_statistics: true
        
        # 2次キャッシュ設定
        cache:
          use_second_level_cache: true
          use_query_cache: true</code></pre>

                        <h6>サービスレイヤーでの最適化</h6>
                        <pre class="code-block"><code class="language-java">package com.example.jpademq.service;

import com.example.jpademq.entity.Order;
import com.example.jpademq.entity.OrderStatus;
import com.example.jpademq.repository.OrderRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@Transactional(readOnly = true)
public class OrderOptimizationService {
    
    private final OrderRepository orderRepository;
    
    @Autowired
    public OrderOptimizationService(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }
    
    /**
     * N+1問題が発生するバッドパターン
     */
    public List&lt;Order&gt; getBadPatternOrders(OrderStatus status) {
        List&lt;Order&gt; orders = orderRepository.findByStatusOrderByOrderDateDesc(status);
        
        // この処理でN+1問題が発生
        for (Order order : orders) {
            System.out.println("Order: " + order.getOrderNumber());
            
            // 各注文の明細を取得（N回のクエリが実行される）
            order.getOrderItems().forEach(item -> {
                System.out.println("  - " + item.getProduct().getName() + ": " + item.getQuantity());
            });
            
            // 顧客情報を取得（N回のクエリが実行される）
            System.out.println("Customer: " + order.getCustomer().getFullName());
        }
        
        return orders;
    }
    
    /**
     * Fetch Joinによる最適化パターン
     */
    public List&lt;Order&gt; getOptimizedOrdersWithFetchJoin(OrderStatus status) {
        List&lt;Order&gt; orders = orderRepository.findByStatusWithItemsAndProducts(status);
        
        // すべての関連データが既に読み込まれているため、追加クエリなし
        for (Order order : orders) {
            System.out.println("Order: " + order.getOrderNumber());
            
            order.getOrderItems().forEach(item -> {
                System.out.println("  - " + item.getProduct().getName() + ": " + item.getQuantity());
            });
            
            System.out.println("Customer: " + order.getCustomer().getFullName());
        }
        
        return orders;
    }
    
    /**
     * EntityGraphによる最適化パターン
     */
    public List&lt;Order&gt; getOptimizedOrdersWithEntityGraph(OrderStatus status) {
        List&lt;Order&gt; orders = orderRepository.findByStatusWithEntityGraph(status);
        
        // EntityGraphで指定した関連データが読み込まれている
        for (Order order : orders) {
            System.out.println("Order: " + order.getOrderNumber());
            System.out.println("Items count: " + order.getOrderItems().size());
            System.out.println("Customer: " + order.getCustomer().getFullName());
        }
        
        return orders;
    }
    
    /**
     * プロジェクション使用による最適化
     */
    @Transactional(readOnly = true)
    public List&lt;OrderSummaryDto&gt; getOrderSummaries(OrderStatus status) {
        // 必要なデータのみを取得するカスタムクエリ
        return orderRepository.findOrderSummariesByStatus(status);
    }
    
    /**
     * 段階的データ取得による最適化
     */
    public List&lt;Order&gt; getOrdersWithStepwiseLoading(OrderStatus status) {
        // 1. 基本的な注文データのみ取得
        List&lt;Order&gt; orders = orderRepository.findByStatusOrderByOrderDateDesc(status);
        
        if (!orders.isEmpty()) {
            // 2. 必要に応じて関連データを一括取得
            List&lt;Long&gt; orderIds = orders.stream().map(Order::getId).toList();
            // カスタムクエリで関連データを一括取得（実装は省略）
        }
        
        return orders;
    }
}

// プロジェクション用DTO
record OrderSummaryDto(
    Long id,
    String orderNumber,
    String customerName,
    BigDecimal totalAmount,
    LocalDateTime orderDate,
    String status,
    int itemCount
) {}</code></pre>

                        <h6>期待される結果</h6>
                        <p>N+1問題が解決され、SQLクエリの実行回数が大幅に削減されることをログで確認できます。また、各手法の特徴と適用場面を理解できます。</p>
                    </div>

                    <!-- セクション補1.5 -->
                    <h3 class="section-title">補1.5 Spring Data JDBCとJPAの使い分け</h3>
                    <p>
                        Spring Data JDBCとJPAはそれぞれ異なる特徴と適用場面を持っています。プロジェクトの要件に応じて適切に選択することが重要です。
                    </p>

                    <div class="mermaid">
                        graph TB
                            subgraph "プロジェクト要件"
                                A["シンプルなCRUD"] --> B["Spring Data JDBC"]
                                C["複雑な関連"] --> D["Spring Data JPA"]
                                E["高性能要求"] --> F["要件により選択"]
                                G["チーム経験"] --> H["適切な選択"]
                            end
                            
                            subgraph "Spring Data JDBC特徴"
                                B --> I["・シンプル軽量<br/>・直接的SQL実行<br/>・明示的制御<br/>・学習コスト低"]
                            end
                            
                            subgraph "Spring Data JPA特徴" 
                                D --> J["・ORM機能<br/>・自動関連管理<br/>・遅延読み込み<br/>・高度なクエリ機能"]
                            end
                            
                            subgraph "ハイブリッド選択"
                                F --> K["・部分的にJDBCを使用<br/>・パフォーマンス重要部分<br/>・バッチ処理"]
                            end
                    </div>

                    <!-- 比較テーブル -->
                    <h4>Spring Data JDBCとJPAの詳細比較</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered">
                            <thead class="table-dark">
                                <tr>
                                    <th>項目</th>
                                    <th>Spring Data JDBC</th>
                                    <th>Spring Data JPA</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>複雑さ</strong></td>
                                    <td class="table-success">シンプル</td>
                                    <td class="table-warning">複雑</td>
                                </tr>
                                <tr>
                                    <td><strong>学習コスト</strong></td>
                                    <td class="table-success">低い</td>
                                    <td class="table-warning">高い</td>
                                </tr>
                                <tr>
                                    <td><strong>パフォーマンス</strong></td>
                                    <td class="table-success">予測しやすい</td>
                                    <td class="table-warning">要注意</td>
                                </tr>
                                <tr>
                                    <td><strong>関連管理</strong></td>
                                    <td class="table-warning">手動</td>
                                    <td class="table-success">自動</td>
                                </tr>
                                <tr>
                                    <td><strong>キャッシュ</strong></td>
                                    <td class="table-danger">なし</td>
                                    <td class="table-success">1次・2次キャッシュ</td>
                                </tr>
                                <tr>
                                    <td><strong>クエリ機能</strong></td>
                                    <td class="table-warning">基本的</td>
                                    <td class="table-success">高度（JPQL、Criteria）</td>
                                </tr>
                                <tr>
                                    <td><strong>デバッグ</strong></td>
                                    <td class="table-success">簡単</td>
                                    <td class="table-warning">複雑</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- 実習補1-4 -->
                    <div class="exercise-container">
                        <h5>実習 補1-4: 使い分け実践とマイグレーション戦略</h5>
                        <p>同じ機能をJDBCとJPAの両方で実装し、特徴の違いを体験してみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>同一機能のJDBCとJPA実装</li>
                            <li>パフォーマンス測定</li>
                            <li>コード複雑性の比較</li>
                            <li>プロジェクトでの選択基準の策定</li>
                        </ol>

                        <h6>選択基準のガイドライン</h6>
                        <pre class="code-block"><code class="language-java">/**
 * プロジェクトでのデータアクセス技術選択ガイド
 */
public class DataAccessTechnologySelector {
    
    /**
     * Spring Data JDBCを選ぶべき場合
     */
    public enum JdbcSuitableScenarios {
        SIMPLE_CRUD("シンプルなCRUD操作が中心"),
        PERFORMANCE_CRITICAL("パフォーマンスが重要"),
        SQL_CONTROL("SQL制御が必要"),
        SMALL_TEAM("小規模チーム・短期開発"),
        LEGACY_INTEGRATION("既存システム統合"),
        BATCH_PROCESSING("大量データ処理");
        
        private final String description;
        
        JdbcSuitableScenarios(String description) {
            this.description = description;
        }
        
        public String getDescription() { return description; }
    }
    
    /**
     * Spring Data JPAを選ぶべき場合
     */
    public enum JpaSuitableScenarios {
        COMPLEX_RELATIONS("複雑なエンティティ関係"),
        RICH_DOMAIN_MODEL("リッチなドメインモデル"),
        CROSS_DB_COMPATIBILITY("データベース非依存性"),
        LARGE_TEAM("大規模チーム開発"),
        LONG_TERM_PROJECT("長期メンテナンスプロジェクト"),
        ORM_EXPERTISE("ORMの専門知識がある");
        
        private final String description;
        
        JpaSuitableScenarios(String description) {
            this.description = description;
        }
        
        public String getDescription() { return description; }
    }
    
    /**
     * プロジェクト要件に基づく技術選択
     */
    public static String selectTechnology(ProjectRequirements requirements) {
        int jdbcScore = calculateJdbcScore(requirements);
        int jpaScore = calculateJpaScore(requirements);
        
        if (jdbcScore > jpaScore) {
            return "Spring Data JDBC推奨 (スコア: JDBC=" + jdbcScore + ", JPA=" + jpaScore + ")";
        } else if (jpaScore > jdbcScore) {
            return "Spring Data JPA推奨 (スコア: JPA=" + jpaScore + ", JDBC=" + jdbcScore + ")";
        } else {
            return "ハイブリッド構成検討 (同スコア: " + jdbcScore + ")";
        }
    }
    
    private static int calculateJdbcScore(ProjectRequirements req) {
        int score = 0;
        if (req.isSimpleCrud()) score += 3;
        if (req.isPerformanceCritical()) score += 3;
        if (req.isSmallTeam()) score += 2;
        if (req.isShortTerm()) score += 2;
        if (req.needsSqlControl()) score += 3;
        return score;
    }
    
    private static int calculateJpaScore(ProjectRequirements req) {
        int score = 0;
        if (req.hasComplexRelations()) score += 3;
        if (req.needsRichDomainModel()) score += 3;
        if (req.isLargeTeam()) score += 2;
        if (req.isLongTerm()) score += 2;
        if (req.needsCrossDatabaseSupport()) score += 2;
        return score;
    }
    
    // プロジェクト要件クラス
    public static class ProjectRequirements {
        private boolean simpleCrud;
        private boolean performanceCritical;
        private boolean smallTeam;
        private boolean shortTerm;
        private boolean needsSqlControl;
        private boolean hasComplexRelations;
        private boolean needsRichDomainModel;
        private boolean largeTeam;
        private boolean longTerm;
        private boolean needsCrossDatabaseSupport;
        
        // Builder pattern for easy construction
        public static ProjectRequirements builder() {
            return new ProjectRequirements();
        }
        
        public ProjectRequirements simpleCrud(boolean value) {
            this.simpleCrud = value;
            return this;
        }
        
        public ProjectRequirements performanceCritical(boolean value) {
            this.performanceCritical = value;
            return this;
        }
        
        // その他のsetterメソッド...
        
        // Getters
        public boolean isSimpleCrud() { return simpleCrud; }
        public boolean isPerformanceCritical() { return performanceCritical; }
        public boolean isSmallTeam() { return smallTeam; }
        public boolean isShortTerm() { return shortTerm; }
        public boolean needsSqlControl() { return needsSqlControl; }
        public boolean hasComplexRelations() { return hasComplexRelations; }
        public boolean needsRichDomainModel() { return needsRichDomainModel; }
        public boolean isLargeTeam() { return largeTeam; }
        public boolean isLongTerm() { return longTerm; }
        public boolean needsCrossDatabaseSupport() { return needsCrossDatabaseSupport; }
    }
    
    /**
     * 使用例とテスト
     */
    public static void main(String[] args) {
        // 例1: シンプルなWebアプリケーション
        ProjectRequirements webApp = ProjectRequirements.builder()
                .simpleCrud(true)
                .smallTeam(true)
                .shortTerm(true)
                .performanceCritical(false)
                .hasComplexRelations(false);
        
        System.out.println("Webアプリ: " + selectTechnology(webApp));
        
        // 例2: 大規模エンタープライズシステム
        ProjectRequirements enterprise = ProjectRequirements.builder()
                .simpleCrud(false)
                .largeTeam(true)
                .longTerm(true)
                .hasComplexRelations(true)
                .needsRichDomainModel(true)
                .needsCrossDatabaseSupport(true);
        
        System.out.println("エンタープライズ: " + selectTechnology(enterprise));
    }
}</code></pre>

                        <h6>マイグレーション戦略</h6>
                        <pre class="code-block"><code class="language-java">/**
 * JDBCからJPA、またはその逆のマイグレーション戦略
 */
@Service
public class DataAccessMigrationStrategy {
    
    /**
     * 段階的マイグレーション: JDBC → JPA
     */
    public void migrateJdbcToJpa() {
        // フェーズ1: 新機能はJPAで実装
        // - 新しいエンティティはJPAで作成
        // - 既存機能は当面JDBC維持
        
        // フェーズ2: 複雑な関連部分を優先移行
        // - 1対多、多対多関係が多い部分
        // - ビジネスロジックが複雑な部分
        
        // フェーズ3: 残りの機能を段階移行
        // - 単純なCRUD操作
        // - バッチ処理は最後（または維持）
    }
    
    /**
     * ハイブリッド構成での最適化
     */
    @Service
    public class HybridDataAccessService {
        
        private final CustomerJpaRepository jpaRepository;
        private final CustomerJdbcRepository jdbcRepository;
        
        public HybridDataAccessService(
                CustomerJpaRepository jpaRepository,
                CustomerJdbcRepository jdbcRepository) {
            this.jpaRepository = jpaRepository;
            this.jdbcRepository = jdbcRepository;
        }
        
        // 複雑な検索はJPAを使用
        public List&lt;Customer&gt; searchCustomersWithComplexCriteria(CustomerSearchCriteria criteria) {
            return jpaRepository.findByComplexCriteria(criteria);
        }
        
        // パフォーマンス重要な処理はJDBCを使用
        public int bulkUpdateCustomerStatus(CustomerStatus oldStatus, CustomerStatus newStatus) {
            return jdbcRepository.bulkUpdateStatus(oldStatus, newStatus);
        }
        
        // 単純な操作はJPAで十分
        public Customer findById(Long id) {
            return jpaRepository.findById(id).orElse(null);
        }
        
        // 大量データ処理はJDBCが効率的
        public List&lt;CustomerReport&gt; generateMonthlyReport(LocalDate month) {
            return jdbcRepository.generateMonthlyReport(month);
        }
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>プロジェクトの特性に応じたデータアクセス技術の選択基準が明確になり、適切な技術選択ができるようになります。</p>
                    </div>

                    <!-- 理解度確認テスト -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <strong>N+1問題の説明として正しいものは？</strong>
                                <ul>
                                    <li>a) 1つのクエリで全てのデータを取得する効率的な手法</li>
                                    <li>b) 親エンティティを1回で取得後、各子エンティティをN回のクエリで取得する問題</li>
                                    <li>c) データベースの接続数が制限される問題</li>
                                    <li>d) メモリ使用量が1+N倍になる問題</li>
                                </ul>
                            </li>
                            <li>
                                <strong>JPQLのFetch Joinの主な目的は？</strong>
                                <ul>
                                    <li>a) データベースのパフォーマンス向上</li>
                                    <li>b) 関連エンティティを一度のクエリで取得してN+1問題を回避</li>
                                    <li>c) SQLの構文を簡潔にする</li>
                                    <li>d) エンティティ間の関係を定義する</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Spring Data JPAとJDBCの使い分け基準として適切でないものは？</strong>
                                <ul>
                                    <li>a) 複雑な関連がある場合はJPAが適している</li>
                                    <li>b) シンプルなCRUD操作中心の場合はJDBCが適している</li>
                                    <li>c) JPA は常にJDBCより高性能である</li>
                                    <li>d) 大規模チームの長期プロジェクトではJPAが有利</li>
                                </ul>
                            </li>
                            <li>
                                <strong>@EntityGraphアノテーションの役割は？</strong>
                                <ul>
                                    <li>a) エンティティ間の関係を定義する</li>
                                    <li>b) 取得する関連エンティティの範囲を指定する</li>
                                    <li>c) データベーステーブルをマッピングする</li>
                                    <li>d) バリデーションルールを設定する</li>
                                </ul>
                            </li>
                            <li>
                                <strong>HibernateのFetchType.LAZYの特徴は？</strong>
                                <ul>
                                    <li>a) 関連データを即座に読み込む</li>
                                    <li>b) 関連データへのアクセス時に読み込む</li>
                                    <li>c) 関連データを全く読み込まない</li>
                                    <li>d) バックグラウンドで非同期読み込みする</li>
                                </ul>
                            </li>
                        </ol>
                        <details>
                            <summary>解答と解説</summary>
                            <ol>
                                <li><strong>b) 親エンティティを1回で取得後、各子エンティティをN回のクエリで取得する問題</strong><br>
                                N+1問題は、遅延読み込み時に発生する典型的なパフォーマンス問題で、1回の親取得クエリとN回の子取得クエリが実行される問題です。</li>
                                <li><strong>b) 関連エンティティを一度のクエリで取得してN+1問題を回避</strong><br>
                                Fetch Joinは、関連するエンティティを一度のJOINクエリで取得し、N+1問題を解決する代表的な手法です。</li>
                                <li><strong>c) JPA は常にJDBCより高性能である</strong><br>
                                この記述は間違いです。JPAは機能が豊富ですが、シンプルな操作ではJDBCの方が高性能な場合があります。用途に応じた使い分けが重要です。</li>
                                <li><strong>b) 取得する関連エンティティの範囲を指定する</strong><br>
                                @EntityGraphは、クエリ実行時に取得する関連エンティティの範囲を宣言的に指定し、N+1問題を回避するためのアノテーションです。</li>
                                <li><strong>b) 関連データへのアクセス時に読み込む</strong><br>
                                LAZY（遅延読み込み）は、関連データに実際にアクセスする時点で初めてデータベースからデータを取得する読み込み戦略です。</li>
                            </ol>
                        </details>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="spring-learning-material-11.html" class="btn btn-secondary">← 前の章</a>
                        <a href="../../../" class="btn btn-success">学習完了 🎉</a>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js 初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>