<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring学習教材 第8章 - Spring MVCのテスト</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <!-- カスタムCSS -->
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #4caf50;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }

        /* タイトル */
        .chapter-title {
            color: #4caf50;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #4caf50;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #66bb6a;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e8f5e8;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #4caf50;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #4caf50 !important;
            color: white !important;
        }

        /* その他 */
        .card {
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand">
                <strong>Spring学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-1.html">
                                第1章: JavaとWebの基礎理解
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-2.html">
                                第2章: Spring Bootの導入と開発環境構築
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-3.html">
                                第3章: Spring Bootの基本構成とDI（依存性注入）
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-4.html">
                                第4章: Webアプリケーション開発の基礎（MVC）
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-5.html">
                                第5章: データベース連携（Spring Data JDBC）
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-6.html">
                                第6章: 入力バリデーションとエラーハンドリング
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-7.html">
                                第7章: Spring Securityによる認証・認可
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="spring-learning-material-8.html">
                                第8章: Spring MVCのテスト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-9.html">
                                第9章: Todoアプリケーション開発
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-10.html">
                                第10章: さらに一歩進んだSpring開発へ①
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-11.html">
                                第11章: さらに一歩進んだSpring開発へ②
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="spring-learning-material-ex-1.html">
                                補足①: Spring Data JPA入門
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <!-- 章ヘッダー -->
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第8章: Spring MVCのテスト</h1>
                </div>

                <div id="chapter8">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">テスト駆動による品質保証</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>テストの重要性と種類（ユニットテスト、インテグレーションテスト）</li>
                            <li>JUnit 5とSpring Boot Testフレームワークの活用</li>
                            <li>MockMvcを使ったコントローラーテストの実装</li>
                            <li>Mockitoによるサービス層のテスト</li>
                            <li>テスト用データベースの設定と管理</li>
                            <li>テストプロファイルによる環境分離</li>
                        </ul>
                    </div>

                    <!-- セクション8.1 -->
                    <h3 class="section-title">8.1 テストの重要性と基本概念</h3>
                    <p>
                        ソフトウェアテストは、アプリケーションの品質を保証し、バグを早期に発見するために不可欠です。Spring Bootでは、テストフレームワークが充実しており、効率的にテストを実装できます。
                    </p>

                    <div class="highlight">
                        <h6>テストの種類とメリット</h6>
                        <ul>
                            <li><strong>ユニットテスト</strong>: 個別の機能（メソッド）を単体でテスト</li>
                            <li><strong>インテグレーションテスト</strong>: 複数のコンポーネント間の連携をテスト</li>
                            <li><strong>システムテスト</strong>: アプリケーション全体を通したテスト</li>
                            <li><strong>リグレッションテスト</strong>: 既存機能の退行検証</li>
                        </ul>
                    </div>

                    <div class="mermaid">
                        graph TB
                            A["テストピラミッド"] --> B["システムテスト<br/>（少数・遅い・高コスト）"]
                            A --> C["インテグレーションテスト<br/>（中程度の数・中程度の速度）"]
                            A --> D["ユニットテスト<br/>（多数・高速・低コスト）"]
                            
                            B --> E["E2Eテスト<br/>UIテスト"]
                            C --> F["APIテスト<br/>データベーステスト"]
                            D --> G["単体関数テスト<br/>モックテスト"]
                    </div>

                    <!-- セクション8.2 -->
                    <h3 class="section-title">8.2 Spring Boot TestとJUnit 5の基本</h3>
                    <p>
                        Spring Bootには<code>spring-boot-starter-test</code>が含まれており、JUnit 5、Mockito、AssertJ、Hamcrest、Spring Test、TestContainersなど、テストに必要なライブラリが一括で提供されます。
                    </p>

                    <h4>build.gradleでのテスト依存関係</h4>
                    <pre class="code-block"><code class="language-bash">dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
    
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'com.h2database:h2'  // テスト用インメモリDB
}

test {
    useJUnitPlatform()  // JUnit 5を使用
}</code></pre>

                    <div class="highlight">
                        <h6>Spring Boot Testの主要アノテーション</h6>
                        <ul>
                            <li><code>@SpringBootTest</code>: Spring Bootアプリケーションコンテキストをロード</li>
                            <li><code>@WebMvcTest</code>: Webレイヤーのみをテスト（コントローラーテスト用）</li>
                            <li><code>@DataJdbcTest</code>: データアクセス層のみをテスト</li>
                            <li><code>@TestPropertySource</code>: テスト用プロパティファイルを指定</li>
                            <li><code>@ActiveProfiles</code>: テスト用プロファイルをアクティブ化</li>
                        </ul>
                    </div>

                    <!-- 実習8-1 -->
                    <div class="exercise-container">
                        <h5>実習 8-1: 基本的なユニットテストの作成</h5>
                        <p>シンプルなサービスクラスのユニットテストを作成してみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>計算処理を行うCalculationServiceクラスを作成</li>
                            <li>JUnit 5を使ったテストクラスを作成</li>
                            <li>様々なテストケースを実装</li>
                            <li>テストを実行して結果を確認</li>
                        </ol>

                        <h6>CalculationService.java</h6>
                        <pre class="code-block"><code class="language-java">package com.example.demo.service;

import org.springframework.stereotype.Service;

@Service
public class CalculationService {
    
    public int add(int a, int b) {
        return a + b;
    }
    
    public int divide(int a, int b) {
        if (b == 0) {
            throw new IllegalArgumentException("Division by zero is not allowed");
        }
        return a / b;
    }
    
    public boolean isEven(int number) {
        return number % 2 == 0;
    }
}</code></pre>

                        <h6>CalculationServiceTest.java</h6>
                        <pre class="code-block"><code class="language-java">package com.example.demo.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import static org.junit.jupiter.api.Assertions.*;

class CalculationServiceTest {
    
    private CalculationService calculationService;
    
    @BeforeEach
    void setUp() {
        calculationService = new CalculationService();
    }
    
    @Test
    @DisplayName("正常な加算のテスト")
    void testAdd() {
        // Given - テストデータの準備
        int a = 5;
        int b = 3;
        
        // When - テスト対象メソッドの実行
        int result = calculationService.add(a, b);
        
        // Then - 結果の検証
        assertEquals(8, result);
    }
    
    @Test
    @DisplayName("ゼロ除算の例外テスト")
    void testDivideByZero() {
        // Given
        int a = 10;
        int b = 0;
        
        // When & Then - 例外の発生を検証
        IllegalArgumentException exception = assertThrows(
            IllegalArgumentException.class, 
            () -> calculationService.divide(a, b)
        );
        
        assertEquals("Division by zero is not allowed", exception.getMessage());
    }
    
    @ParameterizedTest
    @ValueSource(ints = {2, 4, 6, 8, 10})
    @DisplayName("偶数判定のテスト（パラメータ化テスト）")
    void testIsEven(int number) {
        assertTrue(calculationService.isEven(number));
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>すべてのテストケースが成功し、JUnit 5の機能（DisplayName、ParameterizedTest等）が正しく動作することを確認できます。</p>
                    </div>

                    <!-- セクション8.3 -->
                    <h3 class="section-title">8.3 MockMvcによるコントローラーテスト</h3>
                    <p>
                        <code>MockMvc</code>は、実際のHTTPサーバーを起動せずに、Spring MVCの動作をシミュレートしてコントローラーをテストできる強力なツールです。レスポンス内容、ステータスコード、ヘッダー等を詳細に検証できます。
                    </p>

                    <div class="highlight">
                        <h6>MockMvcの利点</h6>
                        <ul>
                            <li>高速実行：実際のサーバー起動が不要</li>
                            <li>細かい制御：リクエスト・レスポンスの詳細検証</li>
                            <li>依存関係のモック：外部サービスをモック化可能</li>
                            <li>統合テスト：Spring MVCフレームワークとの統合テスト</li>
                        </ul>
                    </div>

                    <!-- 実習8-2 -->
                    <div class="exercise-container">
                        <h5>実習 8-2: MockMvcを使ったコントローラーテスト</h5>
                        <p>RESTコントローラーのテストをMockMvcで実装してみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>UserControllerクラスを作成</li>
                            <li>@WebMvcTestを使ったテストクラスを作成</li>
                            <li>MockMvcでHTTPリクエストをシミュレート</li>
                            <li>レスポンスの検証を実装</li>
                        </ol>

                        <h6>UserController.java</h6>
                        <pre class="code-block"><code class="language-java">package com.example.demo.controller;

import org.springframework.web.bind.annotation.*;

import java.util.*;

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private static final Map&lt;Long, User&gt; users = new HashMap&lt;&gt;();
    static {
        users.put(1L, new User(1L, "Alice", "alice@example.com"));
        users.put(2L, new User(2L, "Bob", "bob@example.com"));
    }
    
    @GetMapping
    public List&lt;User&gt; getAllUsers() {
        return new ArrayList&lt;&gt;(users.values());
    }
    
    @GetMapping("/{id}")
    public User getUserById(@PathVariable Long id) {
        User user = users.get(id);
        if (user == null) {
            throw new RuntimeException("User not found");
        }
        return user;
    }
    
    @PostMapping
    public User createUser(@RequestBody User user) {
        user.setId(System.currentTimeMillis());
        users.put(user.getId(), user);
        return user;
    }
    
    public static class User {
        private Long id;
        private String name;
        private String email;
        
        // コンストラクタ、getter、setter
        public User() {}
        
        public User(Long id, String name, String email) {
            this.id = id;
            this.name = name;
            this.email = email;
        }
        
        // getter/setter省略...
        public Long getId() { return id; }
        public void setId(Long id) { this.id = id; }
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public String getEmail() { return email; }
        public void setEmail(String email) { this.email = email; }
    }
}</code></pre>

                        <h6>UserControllerTest.java</h6>
                        <pre class="code-block"><code class="language-java">package com.example.demo.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
import static org.hamcrest.Matchers.*;

@WebMvcTest(UserController.class)
class UserControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    void getAllUsers_ShouldReturnUsersList() throws Exception {
        mockMvc.perform(get("/api/users"))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$", hasSize(2)))
                .andExpect(jsonPath("$[0].name", is("Alice")))
                .andExpect(jsonPath("$[1].name", is("Bob")));
    }
    
    @Test
    void getUserById_ExistingUser_ShouldReturnUser() throws Exception {
        mockMvc.perform(get("/api/users/1"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id", is(1)))
                .andExpect(jsonPath("$.name", is("Alice")))
                .andExpect(jsonPath("$.email", is("alice@example.com")));
    }
    
    @Test
    void getUserById_NonExistingUser_ShouldReturn500() throws Exception {
        mockMvc.perform(get("/api/users/999"))
                .andExpect(status().isInternalServerError());
    }
    
    @Test
    void createUser_ValidUser_ShouldCreateUser() throws Exception {
        UserController.User newUser = new UserController.User(null, "Charlie", "charlie@example.com");
        String userJson = objectMapper.writeValueAsString(newUser);
        
        mockMvc.perform(post("/api/users")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(userJson))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name", is("Charlie")))
                .andExpect(jsonPath("$.email", is("charlie@example.com")))
                .andExpect(jsonPath("$.id", notNullValue()));
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>MockMvcがHTTPリクエストを正しくシミュレートし、JSONレスポンスの構造とデータを適切に検証できることを確認できます。</p>
                    </div>

                    <!-- セクション8.4 -->
                    <h3 class="section-title">8.4 Mockitoによるサービス層テスト</h3>
                    <p>
                        実際のサービス層では外部依存関係（データベース、外部API等）がある場合が多く、これらをモック化することで、テストを高速化し、外部要因に影響されない単体テストが実現できます。
                    </p>

                    <div class="mermaid">
                        graph LR
                            A["テスト対象<br/>UserService"] --> B["モック<br/>UserRepository"]
                            A --> C["モック<br/>EmailService"]
                            
                            D["実際のテスト"] --> A
                            D --> E["検証<br/>・戻り値<br/>・例外処理<br/>・メソッド呼び出し"]
                    </div>

                    <!-- 実習8-3 -->
                    <div class="exercise-container">
                        <h5>実習 8-3: Mockitoを使ったサービス層テスト</h5>
                        <p>依存関係をモック化したサービス層のテストを実装してみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>UserServiceクラスと依存関係を作成</li>
                            <li>Mockitoでモックオブジェクトを作成</li>
                            <li>モックの振る舞いを定義</li>
                            <li>テスト実行とモック呼び出しの検証</li>
                        </ol>

                        <h6>UserService.java</h6>
                        <pre class="code-block"><code class="language-java">package com.example.demo.service;

import org.springframework.stereotype.Service;
import java.util.Optional;

@Service
public class UserService {
    
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
    
    public User createUser(String name, String email) {
        // メールアドレスの重複チェック
        if (userRepository.existsByEmail(email)) {
            throw new IllegalArgumentException("Email already exists: " + email);
        }
        
        User user = new User(null, name, email);
        User savedUser = userRepository.save(user);
        
        // ウェルカムメール送信
        emailService.sendWelcomeEmail(savedUser.getEmail(), savedUser.getName());
        
        return savedUser;
    }
    
    public Optional&lt;User&gt; getUserById(Long id) {
        return userRepository.findById(id);
    }
}

// Repository interface
interface UserRepository {
    User save(User user);
    Optional&lt;User&gt; findById(Long id);
    boolean existsByEmail(String email);
}

// Email service interface
interface EmailService {
    void sendWelcomeEmail(String email, String name);
}

// User entity
class User {
    private Long id;
    private String name;
    private String email;
    
    public User(Long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
    
    // getter/setter
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}</code></pre>

                        <h6>UserServiceTest.java</h6>
                        <pre class="code-block"><code class="language-java">package com.example.demo.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private EmailService emailService;
    
    private UserService userService;
    
    @BeforeEach
    void setUp() {
        userService = new UserService(userRepository, emailService);
    }
    
    @Test
    void createUser_NewEmail_ShouldCreateUserAndSendEmail() {
        // Given
        String name = "John Doe";
        String email = "john@example.com";
        User savedUser = new User(1L, name, email);
        
        // モックの振る舞いを定義
        when(userRepository.existsByEmail(email)).thenReturn(false);
        when(userRepository.save(any(User.class))).thenReturn(savedUser);
        
        // When
        User result = userService.createUser(name, email);
        
        // Then
        assertEquals(1L, result.getId());
        assertEquals(name, result.getName());
        assertEquals(email, result.getEmail());
        
        // メソッド呼び出しの検証
        verify(userRepository).existsByEmail(email);
        verify(userRepository).save(any(User.class));
        verify(emailService).sendWelcomeEmail(email, name);
    }
    
    @Test
    void createUser_DuplicateEmail_ShouldThrowException() {
        // Given
        String name = "Jane Doe";
        String email = "existing@example.com";
        
        when(userRepository.existsByEmail(email)).thenReturn(true);
        
        // When & Then
        IllegalArgumentException exception = assertThrows(
            IllegalArgumentException.class,
            () -> userService.createUser(name, email)
        );
        
        assertEquals("Email already exists: " + email, exception.getMessage());
        
        // リポジトリの保存メソッドが呼び出されていないことを確認
        verify(userRepository, never()).save(any(User.class));
        verify(emailService, never()).sendWelcomeEmail(anyString(), anyString());
    }
    
    @Test
    void getUserById_ExistingUser_ShouldReturnUser() {
        // Given
        Long userId = 1L;
        User user = new User(userId, "Alice", "alice@example.com");
        
        when(userRepository.findById(userId)).thenReturn(Optional.of(user));
        
        // When
        Optional&lt;User&gt; result = userService.getUserById(userId);
        
        // Then
        assertTrue(result.isPresent());
        assertEquals(userId, result.get().getId());
        assertEquals("Alice", result.get().getName());
        
        verify(userRepository).findById(userId);
    }
    
    @Test
    void getUserById_NonExistingUser_ShouldReturnEmpty() {
        // Given
        Long userId = 999L;
        
        when(userRepository.findById(userId)).thenReturn(Optional.empty());
        
        // When
        Optional&lt;User&gt; result = userService.getUserById(userId);
        
        // Then
        assertFalse(result.isPresent());
        
        verify(userRepository).findById(userId);
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>Mockitoが依存関係を適切にモック化し、サービス層のビジネスロジックを外部依存なしでテストできることを確認できます。</p>
                    </div>

                    <!-- セクション8.5 -->
                    <h3 class="section-title">8.5 テスト用データベースとプロファイル設定</h3>
                    <p>
                        実際のアプリケーションでは、本番環境とは別のテスト用データベースを使用し、テストデータの初期化と削除を自動化することが重要です。Spring Bootではプロファイル機能により、環境ごとの設定を分離できます。
                    </p>

                    <div class="highlight">
                        <h6>テストプロファイルの利点</h6>
                        <ul>
                            <li>本番データへの影響防止</li>
                            <li>高速なインメモリデータベース（H2）の活用</li>
                            <li>テストデータの自動初期化とクリーンアップ</li>
                            <li>並列テスト実行時の分離保証</li>
                        </ul>
                    </div>

                    <!-- 実習8-4 -->
                    <div class="exercise-container">
                        <h5>実習 8-4: テストプロファイルとデータベーステスト</h5>
                        <p>テスト専用の設定とインメモリデータベースを使ったデータアクセス層のテストを実装してみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>テスト用プロパティファイルを作成</li>
                            <li>@DataJdbcTestを使ったリポジトリテストを実装</li>
                            <li>テストデータの初期化とクリーンアップを設定</li>
                            <li>統合テストを実行して動作確認</li>
                        </ol>

                        <h6>src/test/resources/application-test.yml</h6>
                        <pre class="code-block"><code class="language-yaml">spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password: ""
  h2:
    console:
      enabled: true
  sql:
    init:
      mode: always
      schema-locations: classpath:schema-test.sql
      data-locations: classpath:data-test.sql

logging:
  level:
    org.springframework.jdbc: DEBUG</code></pre>

                        <h6>src/test/resources/schema-test.sql</h6>
                        <pre class="code-block"><code class="language-sql">DROP TABLE IF EXISTS users;

CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);</code></pre>

                        <h6>src/test/resources/data-test.sql</h6>
                        <pre class="code-block"><code class="language-sql">INSERT INTO users (name, email) VALUES 
('Alice Johnson', 'alice@example.com'),
('Bob Smith', 'bob@example.com'),
('Charlie Brown', 'charlie@example.com');</code></pre>

                        <h6>UserRepositoryTest.java</h6>
                        <pre class="code-block"><code class="language-java">package com.example.demo.repository;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.jdbc.DataJdbcTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.jdbc.Sql;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;

@DataJdbcTest
@ActiveProfiles("test")
class UserRepositoryTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void findAll_ShouldReturnAllUsers() {
        // When
        List&lt;User&gt; users = userRepository.findAll();
        
        // Then
        assertEquals(3, users.size());
        
        // 名前でソートされているかチェック
        assertEquals("Alice Johnson", users.get(0).getName());
        assertEquals("Bob Smith", users.get(1).getName());
        assertEquals("Charlie Brown", users.get(2).getName());
    }
    
    @Test
    void findById_ExistingUser_ShouldReturnUser() {
        // When
        Optional&lt;User&gt; user = userRepository.findById(1L);
        
        // Then
        assertTrue(user.isPresent());
        assertEquals("Alice Johnson", user.get().getName());
        assertEquals("alice@example.com", user.get().getEmail());
    }
    
    @Test
    void save_NewUser_ShouldSaveAndReturnWithId() {
        // Given
        User newUser = new User(null, "David Wilson", "david@example.com");
        
        // When
        User savedUser = userRepository.save(newUser);
        
        // Then
        assertNotNull(savedUser.getId());
        assertEquals("David Wilson", savedUser.getName());
        assertEquals("david@example.com", savedUser.getEmail());
        
        // データベースに実際に保存されたかチェック
        Optional&lt;User&gt; foundUser = userRepository.findById(savedUser.getId());
        assertTrue(foundUser.isPresent());
    }
    
    @Test
    void deleteById_ExistingUser_ShouldRemoveUser() {
        // Given
        Long userId = 1L;
        assertTrue(userRepository.findById(userId).isPresent());
        
        // When
        userRepository.deleteById(userId);
        
        // Then
        assertFalse(userRepository.findById(userId).isPresent());
        
        // 他のユーザーは削除されていないことを確認
        assertEquals(2, userRepository.findAll().size());
    }
    
    @Test
    @Sql("/test-data/additional-users.sql")
    void findByEmailContaining_ShouldReturnMatchingUsers() {
        // When
        List&lt;User&gt; gmailUsers = userRepository.findByEmailContaining("@gmail.com");
        
        // Then
        assertFalse(gmailUsers.isEmpty());
        gmailUsers.forEach(user -> 
            assertTrue(user.getEmail().contains("@gmail.com"))
        );
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>インメモリH2データベースでテストが高速に実行され、各テスト間でデータが適切に分離されることを確認できます。</p>
                    </div>

                    <!-- セクション8.6 -->
                    <h3 class="section-title">8.6 統合テストとテストスライス</h3>
                    <p>
                        Spring Bootでは、アプリケーション全体をテストする統合テストと、特定の層のみをテストするテストスライスが提供されています。適切に使い分けることで、効率的なテスト戦略を構築できます。
                    </p>

                    <div class="mermaid">
                        graph TB
                            A["@SpringBootTest<br/>統合テスト"] --> B["アプリケーション全体<br/>すべてのBeanをロード"]
                            
                            C["テストスライス"] --> D["@WebMvcTest<br/>Webレイヤーのみ"]
                            C --> E["@DataJdbcTest<br/>データアクセス層のみ"]
                            C --> F["@JsonTest<br/>JSON変換のみ"]
                            
                            B --> G["遅い・高コスト<br/>E2Eテスト向け"]
                            D --> H["高速・軽量<br/>コントローラーテスト"]
                            E --> I["高速・軽量<br/>リポジトリテスト"]
                            F --> J["高速・軽量<br/>シリアル化テスト"]
                    </div>

                    <!-- 実習8-5 -->
                    <div class="exercise-container">
                        <h5>実習 8-5: 統合テストの実装</h5>
                        <p>@SpringBootTestを使った統合テストを実装し、アプリケーション全体の動作を確認してみましょう。</p>
                        
                        <h6>手順</h6>
                        <ol>
                            <li>統合テスト用のテストクラスを作成</li>
                            <li>TestRestTemplateを使ったHTTPクライアントテスト</li>
                            <li>エンドツーエンドシナリオのテスト実装</li>
                            <li>テストコンテナ（オプション）の設定</li>
                        </ol>

                        <h6>UserIntegrationTest.java</h6>
                        <pre class="code-block"><code class="language-java">package com.example.demo.integration;

import com.example.demo.controller.UserController;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.ActiveProfiles;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
class UserIntegrationTest {
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    void createUser_EndToEndTest() {
        // Given
        String baseUrl = "http://localhost:" + port + "/api/users";
        UserController.User newUser = new UserController.User(null, "Integration Test User", "integration@example.com");
        
        // When - ユーザー作成
        ResponseEntity&lt;UserController.User&gt; createResponse = restTemplate.postForEntity(
                baseUrl, 
                newUser, 
                UserController.User.class
        );
        
        // Then - 作成成功確認
        assertEquals(HttpStatus.OK, createResponse.getStatusCode());
        assertNotNull(createResponse.getBody());
        assertNotNull(createResponse.getBody().getId());
        assertEquals("Integration Test User", createResponse.getBody().getName());
        
        // When - 作成されたユーザーを取得
        Long createdUserId = createResponse.getBody().getId();
        ResponseEntity&lt;UserController.User&gt; getResponse = restTemplate.getForEntity(
                baseUrl + "/" + createdUserId, 
                UserController.User.class
        );
        
        // Then - 取得成功確認
        assertEquals(HttpStatus.OK, getResponse.getStatusCode());
        assertEquals(createdUserId, getResponse.getBody().getId());
        assertEquals("Integration Test User", getResponse.getBody().getName());
        
        // When - 全ユーザー取得
        ResponseEntity&lt;UserController.User[]&gt; allUsersResponse = restTemplate.getForEntity(
                baseUrl, 
                UserController.User[].class
        );
        
        // Then - リストに新しいユーザーが含まれることを確認
        assertEquals(HttpStatus.OK, allUsersResponse.getStatusCode());
        UserController.User[] users = allUsersResponse.getBody();
        assertTrue(users.length &gt;= 3);  // 初期データ2件 + 新規作成1件
        
        boolean userFound = false;
        for (UserController.User user : users) {
            if ("Integration Test User".equals(user.getName())) {
                userFound = true;
                break;
            }
        }
        assertTrue(userFound, "作成したユーザーが一覧に含まれていません");
    }
    
    @Test
    void getNonExistentUser_ShouldReturn500() {
        // Given
        String baseUrl = "http://localhost:" + port + "/api/users";
        
        // When
        ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(
                baseUrl + "/99999", 
                String.class
        );
        
        // Then
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>実際のHTTPサーバーが起動し、REST APIを通したエンドツーエンドのテストが成功することを確認できます。</p>
                    </div>

                    <!-- 理解度確認テスト -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <strong>テストピラミッドにおいて、最も多く実装すべきテストの種類は？</strong>
                                <ul>
                                    <li>a) システムテスト</li>
                                    <li>b) インテグレーションテスト</li>
                                    <li>c) ユニットテスト</li>
                                    <li>d) E2Eテスト</li>
                                </ul>
                            </li>
                            <li>
                                <strong>@WebMvcTestアノテーションの主な用途は？</strong>
                                <ul>
                                    <li>a) データベーステスト</li>
                                    <li>b) コントローラー層のテスト</li>
                                    <li>c) サービス層のテスト</li>
                                    <li>d) 統合テスト</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Mockitoで依存オブジェクトをモック化する利点として正しくないものは？</strong>
                                <ul>
                                    <li>a) テストの高速化</li>
                                    <li>b) 外部依存の排除</li>
                                    <li>c) 本番環境での動作保証</li>
                                    <li>d) テストの独立性確保</li>
                                </ul>
                            </li>
                            <li>
                                <strong>JUnit 5の@ParameterizedTestの用途は？</strong>
                                <ul>
                                    <li>a) 複数のテストデータで同じテストロジックを実行</li>
                                    <li>b) テストの実行順序を制御</li>
                                    <li>c) テスト用プロファイルの設定</li>
                                    <li>d) モックオブジェクトの作成</li>
                                </ul>
                            </li>
                            <li>
                                <strong>テスト用にH2データベースを使う主な理由は？</strong>
                                <ul>
                                    <li>a) 本番環境との完全な一致</li>
                                    <li>b) 高速実行とテスト分離</li>
                                    <li>c) より多くの機能を提供</li>
                                    <li>d) 設定が不要</li>
                                </ul>
                            </li>
                        </ol>
                        <details>
                            <summary>解答と解説</summary>
                            <ol>
                                <li><strong>c) ユニットテスト</strong><br>
                                テストピラミッドでは、高速で低コストなユニットテストを最も多く実装し、上位層のテストは必要最小限に抑えるのが基本です。</li>
                                <li><strong>b) コントローラー層のテスト</strong><br>
                                @WebMvcTestはSpring MVCのWebレイヤーのみを起動し、コントローラーのテストに特化したアノテーションです。</li>
                                <li><strong>c) 本番環境での動作保証</strong><br>
                                モックテストは単体の機能確認には有効ですが、実際の依存関係での動作は統合テストで確認する必要があります。</li>
                                <li><strong>a) 複数のテストデータで同じテストロジックを実行</strong><br>
                                @ParameterizedTestは異なる入力値で同じテストメソッドを実行するために使用されます。</li>
                                <li><strong>b) 高速実行とテスト分離</strong><br>
                                インメモリH2データベースは高速で、テスト間の分離が確実に行われ、本番データへの影響もありません。</li>
                            </ol>
                        </details>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="spring-learning-material-7.html" class="btn btn-secondary">← 前の章</a>
                        <a href="spring-learning-material-9.html" class="btn btn-primary">次の章 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">&copy; 2025 F-Circle All rights reserved.</p>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js 初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>