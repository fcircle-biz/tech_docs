<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Framework初心者向け学習教材 - 第11章：さらに一歩進んだSpring開発へ②</title>
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        .navbar {
            background-color: #28a745;
        }
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        .chapter-title {
            color: #28a745;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #28a745;
            padding-bottom: 0.5rem;
        }
        .section-title {
            color: #218838;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        code {
            display: block;
            background-color: #f5f5f5;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            white-space: pre;
            overflow-x: auto;
        }
        .quiz-container {
            background-color: #e8f4e8;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }
        .quiz-question {
            font-weight: 500;
            margin-bottom: 1rem;
        }
        .diagram {
            max-width: 100%;
            height: auto;
            margin: 1.5rem 0;
            text-align: center;
        }
        .exercise {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        .note {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        #table-of-contents .list-group-item {
            border: none;
            padding: 0.5rem 1rem;
        }
        #table-of-contents .list-group-item-action {
            color: #28a745;
        }
        #table-of-contents .list-group-item-action.active,
        .list-group-item.active {
            color: white !important;
            background-color: #28a745;
            border-color: #28a745;
        }
        .section-nav {
            padding-left: 1rem;
        }
        .inline-code {
            background-color: #f5f5f5;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            display: inline;
        }
        footer {
            background-color: #28a745;
            color: white;
            padding: 1rem 0;
            margin-top: 3rem;
        }
        .table-example {
            width: 100%;
            margin-bottom: 1rem;
            border-collapse: collapse;
        }
        .table-example th {
            background-color: #e8f4e8;
            border: 1px solid #c3e6cb;
            padding: 0.5rem;
            text-align: center;
        }
        .table-example td {
            border: 1px solid #c3e6cb;
            padding: 0.5rem;
            text-align: center;
        }
        .example-result {
            background-color: #f1f8e9;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
        }
        .warning {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 1rem;
            margin: 1.5rem 0;
        }
    </style>
</head>
<body data-bs-spy="scroll" data-bs-target="#tableOfContents">
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="#">Spring Framework初心者向け学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="#introduction">はじめに</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#chapter11">第11章: さらに一歩進んだSpring開発へ②</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container my-4">
        <div class="row">
            <!-- Sidebar - Table of Contents -->
            <div class="col-lg-3">
                <div class="sidebar">
                    <div class="card">
                        <div class="card-header bg-success text-white">
                            <h5 class="mb-0">目次</h5>
                        </div>
                        <div id="table-of-contents" class="list-group list-group-flush">
                            <a href="#introduction" class="list-group-item list-group-item-action">はじめに</a>
                            <a href="#chapter11" class="list-group-item list-group-item-action">第11章: さらに一歩進んだSpring開発へ②</a>
                            <div class="section-nav">
                                <a href="#java-records" class="list-group-item list-group-item-action">11.1 Java RecordsとSpring Data JDBC</a>
                                <a href="#aggregate-root" class="list-group-item list-group-item-action">11.2 集約ルート（Aggregate Root）</a>
                                <a href="#one-to-many" class="list-group-item list-group-item-action">11.3 1対多の関連モデル</a>
                                <a href="#practical-example" class="list-group-item list-group-item-action">11.4 実践的な例</a>
                                <a href="#quiz" class="list-group-item list-group-item-action">11.5 理解度確認テスト</a>
                            </div>
                            <a href="#next-steps" class="list-group-item list-group-item-action">次のステップ</a>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Main Content -->
            <div class="col-lg-9">
                <section id="introduction">
                    <h1 class="display-5 mb-4">Spring Framework初心者向け学習教材</h1>
                    <p class="lead">この教材では、Java開発の効率化と保守性の向上を実現するSpring Frameworkについて学習します。第11章では、Java RecordsとSpring Data JDBCを組み合わせた高度な開発手法と、集約ルート（Aggregate Root）を使った1対多の関連モデルの設計について学びます。</p>

                    <div class="note">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>Java Recordsの基本概念と利点</li>
                            <li>Spring Data JDBCとJava Recordsの連携方法</li>
                            <li>集約ルート（Aggregate Root）の概念と実装</li>
                            <li>1対多の関連を持つデータモデルの設計と実装</li>
                            <li>効率的なデータアクセスパターン</li>
                        </ul>
                    </div>

                    <div class="note">
                        <h5>前提知識</h5>
                        <ul>
                            <li>Java基本文法の理解</li>
                            <li>Spring Frameworkの基本概念</li>
                            <li>リレーショナルデータベースの基礎知識</li>
                            <li>Spring Data JDBCの基本</li>
                        </ul>
                    </div>
                </section>

                <section id="chapter11">
                    <h2 class="chapter-title">第11章：さらに一歩進んだSpring開発へ②</h2>
                    <p>前章までにSpring Data JDBCの基本的な使い方を学んできました。この章では、Java 14から導入されたRecords機能とSpring Data JDBCを組み合わせることで、より簡潔で保守性の高いコードを実現する方法と、ドメイン駆動設計（DDD）の考え方を取り入れた集約ルート（Aggregate Root）パターンを用いた1対多の関連モデルの実装方法について学びます。</p>

                    <section id="java-records">
                        <h3 class="section-title">11.1 Java RecordsとSpring Data JDBC</h3>
                        
                        <h4>Java Recordsとは</h4>
                        <p>Java Recordsは、Java 14でプレビュー機能として導入され、Java 16で正式な機能となった、データを保持するための新しいクラス型です。Recordsは、主にデータ転送や不変データの表現に適しており、ボイラープレートコードを大幅に削減できます。</p>

                        <p>従来のJavaクラスでは、データを保持するために以下のようなコードが必要でした：</p>

                        <code>// 従来のJavaクラス
public class Customer {
    private final Long id;
    private final String name;
    private final String email;
    private final LocalDate registeredDate;

    public Customer(Long id, String name, String email, LocalDate registeredDate) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.registeredDate = registeredDate;
    }

    // Getters
    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public LocalDate getRegisteredDate() {
        return registeredDate;
    }

    // equals, hashCode, toString
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Customer customer = (Customer) o;
        return Objects.equals(id, customer.id) &&
               Objects.equals(name, customer.name) &&
               Objects.equals(email, customer.email) &&
               Objects.equals(registeredDate, customer.registeredDate);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name, email, registeredDate);
    }

    @Override
    public String toString() {
        return "Customer{" +
               "id=" + id +
               ", name='" + name + '\'' +
               ", email='" + email + '\'' +
               ", registeredDate=" + registeredDate +
               '}';
    }
}</code>

                        <p>Java Recordsを使うと、同様の機能を持つクラスが以下のように簡潔に定義できます：</p>

                        <code>// Java Recordの定義
public record Customer(Long id, String name, String email, LocalDate registeredDate) {
    // コンストラクタ、equals, hashCode, toStringは自動で生成される
}</code>

                        <p>Java Recordsの主な特徴は以下の通りです：</p>
                        <ul>
                            <li><strong>不変性（Immutable）</strong>：すべてのフィールドは暗黙的にfinalになります</li>
                            <li><strong>自動生成メソッド</strong>：コンストラクタ、アクセサメソッド、equals()、hashCode()、toString()が自動的に生成されます</li>
                            <li><strong>パブリックコンポーネントアクセス</strong>：getterの代わりにフィールド名と同じ名前のメソッドでアクセスできます</li>
                            <li><strong>コンパクトなコード</strong>：シンプルな宣言でデータクラスを定義できます</li>
                        </ul>

                        <h4>Spring Data JDBCとRecordsの連携</h4>
                        <p>Spring Data JDBCは、Spring Framework 2.1以降、Java Recordsをエンティティとして使用することをサポートしています。これにより、データベースとのマッピングがさらに簡潔になります。</p>

                        <code>// Spring Data JDBCでRecordを使用したエンティティ
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

@Table("customers")
public record Customer(
    @Id Long id, 
    String name, 
    String email, 
    @Column("registered_date") LocalDate registeredDate
) {}</code>

                        <p>従来のクラスと同様に、Spring Data JDBCのアノテーションを使用してテーブルやカラムとのマッピングを定義できます。</p>

                        <div class="note">
                            <h5>Recordsを使用する利点</h5>
                            <ul>
                                <li><strong>コードの簡潔さ</strong>：ボイラープレートコードが削減され、コードの可読性が向上します</li>
                                <li><strong>不変性の保証</strong>：データの不変性が言語レベルで保証されるため、副作用を防ぎやすくなります</li>
                                <li><strong>パターンマッチング</strong>：Java 16以降、パターンマッチングと組み合わせて使用することで、さらに表現力の高いコードを書くことができます</li>
                                <li><strong>DTOとの統一性</strong>：データ転送オブジェクト（DTO）とエンティティの両方にRecordsを使用することで、コードの一貫性が向上します</li>
                            </ul>
                        </div>

                        <h4>Recordsの制約と注意点</h4>
                        <p>Recordsは多くのケースで便利ですが、いくつかの制約や注意点もあります：</p>

                        <div class="warning">
                            <h5>Java Recordsを使用する際の注意点</h5>
                            <ul>
                                <li><strong>不変性</strong>：Recordsは不変であるため、エンティティの一部のフィールドのみを更新する場合は、新しいインスタンスを作成する必要があります</li>
                                <li><strong>継承の制限</strong>：Recordsは他のクラスを継承できず、また他のRecordやクラスに継承することもできません</li>
                                <li><strong>ライフサイクルコールバック</strong>：Spring Data JDBCのライフサイクルイベントを使用する場合は、追加の設定が必要になる場合があります</li>
                                <li><strong>Java 14以上が必要</strong>：Recordsを使用するには、Java 14以上が必要です（本格的な使用にはJava 16以上を推奨）</li>
                            </ul>
                        </div>

                        <h4>カスタマイズされたRecordコンストラクタ</h4>
                        <p>Recordsは、コンパクトコンストラクタと呼ばれる特殊なコンストラクタを定義することで、初期化ロジックをカスタマイズできます：</p>

                        <code>// カスタマイズされたコンパクトコンストラクタ
@Table("customers")
public record Customer(
    @Id Long id, 
    String name, 
    String email, 
    @Column("registered_date") LocalDate registeredDate
) {
    // コンパクトコンストラクタ - フィールドの宣言が不要
    public Customer {
        // バリデーションロジック
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("Name cannot be empty");
        }
        if (email == null || !email.contains("@")) {
            throw new IllegalArgumentException("Invalid email format");
        }
        // registeredDateが指定されていない場合は現在の日付を設定
        if (registeredDate == null) {
            registeredDate = LocalDate.now(); // 注意: これは自動的にフィールドに割り当てられる
        }
    }
    
    // 静的ファクトリメソッド
    public static Customer createNew(String name, String email) {
        return new Customer(null, name, email, LocalDate.now());
    }
}</code>

                        <div class="exercise">
                            <h5>練習問題 11.1</h5>
                            <p>次の要件に基づいて、Spring Data JDBCで使用するProductレコードを定義してください：</p>
                            <ul>
                                <li>テーブル名は「products」</li>
                                <li>フィールド：id（主キー）、name、description、price、stockQuantity、createdAt</li>
                                <li>priceは0より大きい値でなければならない</li>
                                <li>stockQuantityは0以上の値でなければならない</li>
                                <li>新商品を作成するための静的ファクトリメソッドを提供</li>
                            </ul>
                        </div>

                        <div class="example-result">
                            <h5>解答例：</h5>
                            <code>import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Table("products")
public record Product(
    @Id Long id,
    String name,
    String description,
    BigDecimal price,
    @Column("stock_quantity") int stockQuantity,
    @Column("created_at") LocalDateTime createdAt
) {
    // コンパクトコンストラクタ
    public Product {
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("Name cannot be empty");
        }
        if (price != null && price.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Price must be greater than 0");
        }
        if (stockQuantity < 0) {
            throw new IllegalArgumentException("Stock quantity cannot be negative");
        }
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
    }
    
    // 静的ファクトリメソッド
    public static Product createNew(String name, String description, BigDecimal price, int stockQuantity) {
        return new Product(null, name, description, price, stockQuantity, LocalDateTime.now());
    }
}</code>
                        </div>
                    </section>

                    <section id="aggregate-root">
                        <h3 class="section-title">11.2 集約ルート（Aggregate Root）</h3>
                        
                        <h4>集約ルートとは</h4>
                        <p>集約ルート（Aggregate Root）は、ドメイン駆動設計（DDD）の概念の一つで、関連するエンティティとバリューオブジェクトのグループ（集約）へのアクセスを制御するエンティティです。Spring Data JDBCはこの概念を中心に設計されており、エンティティ間の関連を効果的にモデル化するのに役立ちます。</p>

                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 300" width="600" height="300">
                                <!-- 集約ルート -->
                                <rect x="250" y="50" width="120" height="60" fill="#e8f5e9" stroke="#4caf50" stroke-width="2" rx="5" />
                                <text x="310" y="85" text-anchor="middle" font-size="14">Order</text>
                                <text x="310" y="105" text-anchor="middle" font-size="12" font-style="italic">集約ルート</text>
                                
                                <!-- 子エンティティ -->
                                <rect x="150" y="180" width="120" height="60" fill="#e3f2fd" stroke="#2196f3" stroke-width="2" rx="5" />
                                <text x="210" y="215" text-anchor="middle" font-size="14">OrderLine</text>
                                
                                <rect x="350" y="180" width="120" height="60" fill="#e3f2fd" stroke="#2196f3" stroke-width="2" rx="5" />
                                <text x="410" y="215" text-anchor="middle" font-size="14">ShippingAddress</text>
                                
                                <!-- 境界 -->
                                <ellipse cx="310" cy="160" rx="220" ry="130" fill="none" stroke="#9e9e9e" stroke-width="1.5" stroke-dasharray="5,5" />
                                <text x="310" y="40" text-anchor="middle" font-size="14" font-weight="bold">Order集約</text>
                                
                                <!-- 矢印 -->
                                <line x1="280" y1="110" x2="210" y2="180" stroke="#000" stroke-width="1.5" marker-end="url(#arrow)" />
                                <line x1="340" y1="110" x2="410" y2="180" stroke="#000" stroke-width="1.5" marker-end="url(#arrow)" />
                                
                                <defs>
                                    <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                        <path d="M0,0 L0,6 L9,3 z" fill="#000" />
                                    </marker>
                                </defs>
                                
                                <!-- 外部からのアクセス -->
                                <path d="M50,160 C100,160 100,80 250,80" fill="none" stroke="#f44336" stroke-width="2" marker-end="url(#arrow)" />
                                <text x="120" y="150" text-anchor="middle" font-size="12" fill="#f44336">外部からのアクセス</text>
                                
                                <!-- 内部アクセス -->
                                <path d="M410,190 C450,170 450,130 350,130 C300,130 270,170 210,170" fill="none" stroke="#4caf50" stroke-width="1.5" stroke-dasharray="4,4" />
                                <text x="370" y="140" text-anchor="middle" font-size="12" fill="#4caf50">内部関連</text>
                            </svg>
                            <p class="text-center">図11.1: 集約ルートと集約境界の概念</p>
                        </div>

                        <p>集約ルートの主な特徴と利点：</p>
                        <ul>
                            <li><strong>一貫性の境界</strong>：集約は一貫性を保つべきドメインオブジェクトのグループを定義します</li>
                            <li><strong>カプセル化</strong>：集約ルートは集約内のすべてのエンティティへのアクセスポイントとなります</li>
                            <li><strong>トランザクション境界</strong>：集約全体が一つのトランザクションで更新されるべきです</li>
                            <li><strong>参照の制限</strong>：外部から集約内のエンティティを直接参照するのではなく、常に集約ルートを経由します</li>
                        </ul>

                        <h4>Spring Data JDBCにおける集約</h4>
                        <p>Spring Data JDBCは、集約指向の設計を前提としています。リレーショナルデータベースとオブジェクト指向プログラミングのミスマッチを減らすために、エンティティ間の関係をシンプルにモデル化することを推奨しています。</p>

                        <div class="note">
                            <h5>Spring Data JDBCの集約の特徴</h5>
                            <ul>
                                <li>集約ルートのみがリポジトリを持ちます</li>
                                <li>集約内のエンティティは集約ルートを通じてのみアクセスされます</li>
                                <li>集約間の参照はIDによって行われます（外部キー）</li>
                                <li>集約全体がアトミックに保存、更新、削除されます</li>
                            </ul>
                        </div>

                        <h4>集約ルートの実装例</h4>
                        <p>以下は、注文（Order）を集約ルートとし、注文明細（OrderLine）を子エンティティとする集約の例です：</p>

                        <code>// 集約ルート：Order
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.MappedCollection;
import org.springframework.data.relational.core.mapping.Table;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Table("orders")
public class Order {
    @Id
    private Long id;
    
    @Column("customer_id")
    private Long customerId;
    
    @Column("order_date")
    private LocalDateTime orderDate;
    
    private String status;
    
    // 子エンティティへの参照（集約内）
    @MappedCollection(idColumn = "order_id")
    private Set<OrderLine> orderLines = new HashSet<>();
    
    // コンストラクタ、ゲッター、セッター
    
    // 子エンティティを管理するメソッド
    public void addOrderLine(OrderLine orderLine) {
        this.orderLines.add(orderLine);
    }
    
    public void removeOrderLine(OrderLine orderLine) {
        this.orderLines.remove(orderLine);
    }
    
    // ビジネスロジック
    public double calculateTotal() {
        return orderLines.stream()
                .mapToDouble(line -> line.getPrice() * line.getQuantity())
                .sum();
    }
    
    // 注文の状態を変更するメソッド
    public void placeOrder() {
        if (orderLines.isEmpty()) {
            throw new IllegalStateException("Cannot place an order with no order lines");
        }
        this.status = "PLACED";
        this.orderDate = LocalDateTime.now();
    }
}

// 子エンティティ：OrderLine
@Table("order_lines")
public class OrderLine {
    @Id
    private Long id;
    
    @Column("product_id")
    private Long productId;
    
    private int quantity;
    
    private double price;
    
    // コンストラクタ、ゲッター、セッター
}</code>

                        <p>集約ルートを使用するリポジトリの例：</p>

                        <code>// 集約ルート用のリポジトリ
public interface OrderRepository extends CrudRepository<Order, Long> {
    // 標準的なCRUD操作は自動的に提供される
    // 必要に応じてカスタムクエリを追加
}

// 子エンティティ用のリポジトリは作成しない</code>

                        <p>集約ルートを使用したサービスの例：</p>

                        <code>@Service
public class OrderService {
    private final OrderRepository orderRepository;
    
    public OrderService(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }
    
    @Transactional
    public Order createOrder(Long customerId, List<OrderLineDto> orderLineDtos) {
        Order order = new Order();
        order.setCustomerId(customerId);
        order.setStatus("DRAFT");
        
        // 子エンティティの追加
        for (OrderLineDto dto : orderLineDtos) {
            OrderLine orderLine = new OrderLine();
            orderLine.setProductId(dto.getProductId());
            orderLine.setQuantity(dto.getQuantity());
            orderLine.setPrice(dto.getPrice());
            order.addOrderLine(orderLine);
        }
        
        // 注文の保存（集約全体が保存される）
        return orderRepository.save(order);
    }
    
    @Transactional
    public Order placeOrder(Long orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new IllegalArgumentException("Order not found"));
        order.placeOrder();
        return orderRepository.save(order);
    }
}</code>

                        <div class="exercise">
                            <h5>練習問題 11.2</h5>
                            <p>ブログシステムの集約を設計してください。ブログ記事（BlogPost）を集約ルートとし、コメント（Comment）を子エンティティとする集約を実装してください。以下の要件を満たすようにしてください：</p>
                            <ul>
                                <li>BlogPostはタイトル、内容、作成日時、公開フラグを持つ</li>
                                <li>Commentは内容、作成者名、作成日時を持つ</li>
                                <li>BlogPostはコメントを追加・削除できるメソッドを持つ</li>
                                <li>BlogPostは公開状態を切り替えるメソッドを持つ</li>
                            </ul>
                        </div>
                    </section>

                    <section id="one-to-many">
                        <h3 class="section-title">11.3 1対多の関連モデル</h3>
                        
                        <h4>Spring Data JDBCにおける1対多の関連</h4>
                        <p>Spring Data JDBCでは、集約の概念に基づいて1対多の関連をモデル化します。集約ルートから子エンティティへの1対多の関連は、<span class="inline-code">@MappedCollection</span>アノテーションを使用して実装されます。</p>

                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 400" width="600" height="400">
                                <!-- データベースのテーブル -->
                                <rect x="50" y="50" width="200" height="120" fill="#f5f5f5" stroke="#9e9e9e" stroke-width="2" rx="5" />
                                <text x="150" y="80" text-anchor="middle" font-size="14" font-weight="bold">departments</text>
                                <line x1="50" y1="90" x2="250" y2="90" stroke="#9e9e9e" stroke-width="1" />
                                <text x="70" y="110" font-size="12">id: BIGINT (PK)</text>
                                <text x="70" y="130" font-size="12">name: VARCHAR</text>
                                <text x="70" y="150" font-size="12">location: VARCHAR</text>
                                
                                <rect x="50" y="220" width="200" height="140" fill="#f5f5f5" stroke="#9e9e9e" stroke-width="2" rx="5" />
                                <text x="150" y="250" text-anchor="middle" font-size="14" font-weight="bold">employees</text>
                                <line x1="50" y1="260" x2="250" y2="260" stroke="#9e9e9e" stroke-width="1" />
                                <text x="70" y="280" font-size="12">id: BIGINT (PK)</text>
                                <text x="70" y="300" font-size="12">department_id: BIGINT (FK)</text>
                                <text x="70" y="320" font-size="12">name: VARCHAR</text>
                                <text x="70" y="340" font-size="12">email: VARCHAR</text>
                                
                                <!-- 関連線 -->
                                <line x1="70" y1="300" x2="70" y2="110" stroke="#f44336" stroke-width="1.5" marker-end="url(#arrow)" stroke-dasharray="4,4" />
                                <text x="45" y="200" text-anchor="middle" font-size="12" fill="#f44336">FK</text>
                                
                                <!-- Javaオブジェクト -->
                                <rect x="350" y="50" width="200" height="120" fill="#e8f5e9" stroke="#4caf50" stroke-width="2" rx="5" />
                                <text x="450" y="80" text-anchor="middle" font-size="14" font-weight="bold">Department</text>
                                <line x1="350" y1="90" x2="550" y2="90" stroke="#4caf50" stroke-width="1" />
                                <text x="370" y="110" font-size="12">Long id</text>
                                <text x="370" y="130" font-size="12">String name</text>
                                <text x="370" y="150" font-size="12">String location</text>
                                
                                <rect x="350" y="220" width="200" height="140" fill="#e3f2fd" stroke="#2196f3" stroke-width="2" rx="5" />
                                <text x="450" y="250" text-anchor="middle" font-size="14" font-weight="bold">Employee</text>
                                <line x1="350" y1="260" x2="550" y2="260" stroke="#2196f3" stroke-width="1" />
                                <text x="370" y="280" font-size="12">Long id</text>
                                <text x="370" y="300" font-size="12">(FK not needed)</text>
                                <text x="370" y="320" font-size="12">String name</text>
                                <text x="370" y="340" font-size="12">String email</text>
                                
                                <!-- Javaオブジェクト間の関連 -->
                                <line x1="450" y1="170" x2="450" y2="220" stroke="#4caf50" stroke-width="1.5" marker-end="url(#arrow)" />
                                <text x="510" y="200" text-anchor="middle" font-size="12" fill="#4caf50">@MappedCollection</text>
                                <text x="510" y="220" text-anchor="middle" font-size="12" fill="#4caf50">Set&lt;Employee&gt;</text>
                                
                                <defs>
                                    <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                        <path d="M0,0 L0,6 L9,3 z" fill="#000" />
                                    </marker>
                                </defs>
                                
                                <text x="150" y="30" text-anchor="middle" font-size="16" font-weight="bold">データベース</text>
                                <text x="450" y="30" text-anchor="middle" font-size="16" font-weight="bold">Javaオブジェクト</text>
                            </svg>
                            <p class="text-center">図11.2: Spring Data JDBCにおける1対多の関連</p>
                        </div>

                        <h4>@MappedCollectionアノテーション</h4>
                        <p><span class="inline-code">@MappedCollection</span>アノテーションは、集約ルートから子エンティティへの参照を定義します。子エンティティのテーブルには、親エンティティを参照する外部キーカラムが必要です。</p>

                        <p>主な属性：</p>
                        <ul>
                            <li><strong>idColumn</strong>：子エンティティテーブルの外部キーカラム名</li>
                            <li><strong>keyColumn</strong>：Mapでキーとなるカラムがある場合に使用</li>
                        </ul>

                        <code>// 1対多の関連モデルの実装例
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.MappedCollection;
import org.springframework.data.relational.core.mapping.Table;
import java.util.HashSet;
import java.util.Set;

// 集約ルート
@Table("departments")
public class Department {
    @Id
    private Long id;
    
    private String name;
    
    private String location;
    
    // 1対多の関連
    @MappedCollection(idColumn = "department_id")
    private Set<Employee> employees = new HashSet<>();
    
    // コンストラクタ、ゲッター、セッター
    
    // 子エンティティ管理メソッド
    public void addEmployee(Employee employee) {
        employees.add(employee);
    }
    
    public void removeEmployee(Employee employee) {
        employees.remove(employee);
    }
}

// 子エンティティ
@Table("employees")
public class Employee {
    @Id
    private Long id;
    
    private String name;
    
    private String email;
    
    // コンストラクタ、ゲッター、セッター
    // 注意: department_idのフィールドは不要
}</code>

                        <p>テーブル作成のためのSQLの例：</p>

                        <code>-- テーブル作成
CREATE TABLE departments (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    location VARCHAR(100)
);

CREATE TABLE employees (
    id BIGSERIAL PRIMARY KEY,
    department_id BIGINT NOT NULL,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100),
    CONSTRAINT fk_department FOREIGN KEY (department_id) REFERENCES departments(id)
);</code>

                        <h4>RecordsとMappedCollectionの利用</h4>
                        <p>Java RecordsとMappedCollectionを組み合わせて使用することもできます。ただし、子エンティティのコレクションを変更するためには、新しいインスタンスを作成する必要があります：</p>

                        <code>// Recordを使用した1対多の関連モデル
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.MappedCollection;
import org.springframework.data.relational.core.mapping.Table;
import java.util.HashSet;
import java.util.Set;

@Table("departments")
public record Department(
    @Id Long id,
    String name,
    String location,
    @MappedCollection(idColumn = "department_id") Set<Employee> employees
) {
    // コンパクトコンストラクタでデフォルト初期化
    public Department {
        if (employees == null) {
            employees = new HashSet<>();
        }
    }
    
    // 不変オブジェクトなので、新しいインスタンスを返すメソッドを提供
    public Department addEmployee(Employee employee) {
        Set<Employee> newEmployees = new HashSet<>(this.employees);
        newEmployees.add(employee);
        return new Department(this.id, this.name, this.location, newEmployees);
    }
    
    public Department removeEmployee(Employee employee) {
        Set<Employee> newEmployees = new HashSet<>(this.employees);
        newEmployees.remove(employee);
        return new Department(this.id, this.name, this.location, newEmployees);
    }
}

@Table("employees")
public record Employee(
    @Id Long id,
    String name,
    String email
) {}</code>

                        <h4>1対多関連の操作</h4>
                        <p>集約ルートと子エンティティの1対多関連を操作するサービスの例：</p>

                        <code>@Service
public class DepartmentService {
    private final DepartmentRepository departmentRepository;
    
    public DepartmentService(DepartmentRepository departmentRepository) {
        this.departmentRepository = departmentRepository;
    }
    
    @Transactional
    public Department createDepartment(String name, String location) {
        Department department = new Department();
        department.setName(name);
        department.setLocation(location);
        return departmentRepository.save(department);
    }
    
    @Transactional
    public Department addEmployeeToDepartment(Long departmentId, Employee employee) {
        Department department = departmentRepository.findById(departmentId)
                .orElseThrow(() -> new IllegalArgumentException("Department not found"));
        
        department.addEmployee(employee);
        return departmentRepository.save(department);
    }
    
    @Transactional
    public Department removeEmployeeFromDepartment(Long departmentId, Long employeeId) {
        Department department = departmentRepository.findById(departmentId)
                .orElseThrow(() -> new IllegalArgumentException("Department not found"));
        
        department.getEmployees().removeIf(emp -> emp.getId().equals(employeeId));
        return departmentRepository.save(department);
    }
}</code>

                        <div class="note">
                            <h5>注意点</h5>
                            <ul>
                                <li>Spring Data JDBCでは、集約ルートを保存すると、すべての子エンティティも自動的に保存されます</li>
                                <li>子エンティティを削除するには、集約ルートから削除してから保存する必要があります</li>
                                <li>子エンティティの追加や削除は、必ず集約ルートを通じて行う必要があります</li>
                                <li>多対多や多対一の関連は、Spring Data JDBCでは集約外の関連として扱われるため、IDでの参照となります</li>
                            </ul>
                        </div>

                        <div class="exercise">
                            <h5>練習問題 11.3</h5>
                            <p>ショッピングカート機能を実装するため、以下の要件に基づいて1対多の関連モデルを設計してください：</p>
                            <ul>
                                <li>Cartを集約ルートとし、CartItemを子エンティティとする</li>
                                <li>Cartはユーザー参照（userId）と作成日時を持つ</li>
                                <li>CartItemは商品参照（productId）、数量、価格を持つ</li>
                                <li>Java Recordsを使用して両方のエンティティを定義する</li>
                                <li>カートに商品を追加・削除するメソッドを実装する</li>
                                <li>カートの合計金額を計算するメソッドを実装する</li>
                            </ul>
                        </div>
                    </section>

                    <section id="practical-example">
                        <h3 class="section-title">11.4 実践的な例</h3>
                        
                        <h4>プロジェクト管理システムの実装</h4>
                        <p>ここまで学んだ概念を使用して、プロジェクト管理システムの一部を実装します。プロジェクト（Project）を集約ルートとし、タスク（Task）を子エンティティとする1対多の関連モデルを作成します。</p>

                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 300" width="600" height="300">
                                <!-- データモデル -->
                                <rect x="50" y="50" width="500" height="200" fill="none" stroke="#9e9e9e" stroke-width="1" stroke-dasharray="5,5" rx="5" />
                                <text x="300" y="30" text-anchor="middle" font-size="16" font-weight="bold">プロジェクト管理システム - データモデル</text>
                                
                                <!-- Project -->
                                <rect x="100" y="80" width="150" height="140" fill="#e8f5e9" stroke="#4caf50" stroke-width="2" rx="5" />
                                <text x="175" y="105" text-anchor="middle" font-size="14" font-weight="bold">Project</text>
                                <line x1="100" y1="115" x2="250" y2="115" stroke="#4caf50" stroke-width="1" />
                                <text x="120" y="135" font-size="12">id: Long</text>
                                <text x="120" y="155" font-size="12">name: String</text>
                                <text x="120" y="175" font-size="12">description: String</text>
                                <text x="120" y="195" font-size="12">deadline: LocalDate</text>
                                
                                <!-- Task -->
                                <rect x="350" y="80" width="150" height="140" fill="#e3f2fd" stroke="#2196f3" stroke-width="2" rx="5" />
                                <text x="425" y="105" text-anchor="middle" font-size="14" font-weight="bold">Task</text>
                                <line x1="350" y1="115" x2="500" y2="115" stroke="#2196f3" stroke-width="1" />
                                <text x="370" y="135" font-size="12">id: Long</text>
                                <text x="370" y="155" font-size="12">title: String</text>
                                <text x="370" y="175" font-size="12">description: String</text>
                                <text x="370" y="195" font-size="12">status: TaskStatus</text>
                                
                                <!-- 関連 -->
                                <line x1="250" y1="150" x2="350" y2="150" stroke="#000" stroke-width="1.5" marker-end="url(#arrow)" />
                                <text x="300" y="140" text-anchor="middle" font-size="12">1対多</text>
                                
                                <defs>
                                    <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                        <path d="M0,0 L0,6 L9,3 z" fill="#000" />
                                    </marker>
                                </defs>
                            </svg>
                            <p class="text-center">図11.3: プロジェクト管理システムのデータモデル</p>
                        </div>

                        <p>まずは、Java Recordsを使用してエンティティを定義します：</p>

                        <code>// TaskStatus列挙型
public enum TaskStatus {
    TODO, IN_PROGRESS, DONE
}

// タスクエンティティ（子エンティティ）
@Table("tasks")
public record Task(
    @Id Long id,
    String title,
    String description,
    @Column("status") TaskStatus status,
    @Column("due_date") LocalDate dueDate
) {
    // バリデーション用のコンパクトコンストラクタ
    public Task {
        if (title == null || title.isBlank()) {
            throw new IllegalArgumentException("Task title cannot be empty");
        }
    }
    
    // タスクを完了としてマークする
    public Task markAsDone() {
        return new Task(id, title, description, TaskStatus.DONE, dueDate);
    }
    
    // タスクの状態を更新する
    public Task updateStatus(TaskStatus newStatus) {
        return new Task(id, title, description, newStatus, dueDate);
    }
}

// プロジェクトエンティティ（集約ルート）
@Table("projects")
public record Project(
    @Id Long id,
    String name,
    String description,
    @Column("deadline") LocalDate deadline,
    @Column("created_at") LocalDateTime createdAt,
    @MappedCollection(idColumn = "project_id") Set<Task> tasks
) {
    // コンパクトコンストラクタ
    public Project {
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("Project name cannot be empty");
        }
        if (tasks == null) {
            tasks = new HashSet<>();
        }
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
    }
    
    // タスクを追加する
    public Project addTask(Task task) {
        Set<Task> newTasks = new HashSet<>(this.tasks);
        newTasks.add(task);
        return new Project(this.id, this.name, this.description, this.deadline, this.createdAt, newTasks);
    }
    
    // タスクを削除する
    public Project removeTask(Long taskId) {
        Set<Task> newTasks = new HashSet<>(this.tasks);
        newTasks.removeIf(task -> task.id() != null && task.id().equals(taskId));
        return new Project(this.id, this.name, this.description, this.deadline, this.createdAt, newTasks);
    }
    
    // タスクを更新する
    public Project updateTask(Task updatedTask) {
        if (updatedTask.id() == null) {
            throw new IllegalArgumentException("Task ID cannot be null for update");
        }
        
        Set<Task> newTasks = new HashSet<>();
        boolean found = false;
        
        for (Task existingTask : this.tasks) {
            if (existingTask.id() != null && existingTask.id().equals(updatedTask.id())) {
                newTasks.add(updatedTask);
                found = true;
            } else {
                newTasks.add(existingTask);
            }
        }
        
        if (!found) {
            throw new IllegalArgumentException("Task not found in this project");
        }
        
        return new Project(this.id, this.name, this.description, this.deadline, this.createdAt, newTasks);
    }
    
    // プロジェクトの完了率を計算する
    public double calculateCompletionRate() {
        if (tasks.isEmpty()) {
            return 0.0;
        }
        
        long completedTasksCount = tasks.stream()
                .filter(task -> TaskStatus.DONE.equals(task.status()))
                .count();
                
        return (double) completedTasksCount / tasks.size() * 100.0;
    }
    
    // 締切までの残り日数を計算する
    public long calculateDaysUntilDeadline() {
        if (deadline == null) {
            return 0;
        }
        return ChronoUnit.DAYS.between(LocalDate.now(), deadline);
    }
    
    // 静的ファクトリメソッド
    public static Project createNew(String name, String description, LocalDate deadline) {
        return new Project(null, name, description, deadline, LocalDateTime.now(), new HashSet<>());
    }
}</code>

                        <p>次に、プロジェクトリポジトリを定義します：</p>

                        <code>// プロジェクトリポジトリ
public interface ProjectRepository extends CrudRepository<Project, Long> {
    List<Project> findByNameContaining(String name);
    List<Project> findByDeadlineBefore(LocalDate date);
}</code>

                        <p>そして、プロジェクト管理のためのサービスを実装します：</p>

                        <code>// プロジェクト管理サービス
@Service
public class ProjectService {
    private final ProjectRepository projectRepository;
    
    public ProjectService(ProjectRepository projectRepository) {
        this.projectRepository = projectRepository;
    }
    
    @Transactional
    public Project createProject(String name, String description, LocalDate deadline) {
        Project project = Project.createNew(name, description, deadline);
        return projectRepository.save(project);
    }
    
    @Transactional
    public Project getProject(Long projectId) {
        return projectRepository.findById(projectId)
                .orElseThrow(() -> new IllegalArgumentException("Project not found with id: " + projectId));
    }
    
    @Transactional
    public Project addTaskToProject(Long projectId, String title, String description, LocalDate dueDate) {
        Project project = getProject(projectId);
        Task newTask = new Task(null, title, description, TaskStatus.TODO, dueDate);
        Project updatedProject = project.addTask(newTask);
        return projectRepository.save(updatedProject);
    }
    
    @Transactional
    public Project updateTaskStatus(Long projectId, Long taskId, TaskStatus newStatus) {
        Project project = getProject(projectId);
        
        // タスクを検索
        Task taskToUpdate = project.tasks().stream()
                .filter(task -> task.id() != null && task.id().equals(taskId))
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("Task not found with id: " + taskId));
        
        // タスクの状態を更新
        Task updatedTask = taskToUpdate.updateStatus(newStatus);
        Project updatedProject = project.updateTask(updatedTask);
        
        return projectRepository.save(updatedProject);
    }
    
    @Transactional
    public void deleteProject(Long projectId) {
        projectRepository.deleteById(projectId);
    }
    
    public List<Project> findProjectsByName(String name) {
        return projectRepository.findByNameContaining(name);
    }
    
    public List<Project> findProjectsWithUpcomingDeadlines(int days) {
        LocalDate thresholdDate = LocalDate.now().plusDays(days);
        return projectRepository.findByDeadlineBefore(thresholdDate);
    }
}</code>

                        <p>最後に、データベースのテーブル定義：</p>

                        <code>-- PostgreSQL用テーブル定義
CREATE TABLE projects (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    deadline DATE,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE tasks (
    id BIGSERIAL PRIMARY KEY,
    project_id BIGINT NOT NULL,
    title VARCHAR(100) NOT NULL,
    description TEXT,
    status VARCHAR(20) NOT NULL DEFAULT 'TODO',
    due_date DATE,
    CONSTRAINT fk_project FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
);</code>

                        <div class="exercise">
                            <h5>練習問題 11.4</h5>
                            <p>プロジェクト管理システムを拡張して、以下の機能を追加してください：</p>
                            <ul>
                                <li>タスクにコメント（Comment）を追加できるようにする（Task → Comments の1対多関連）</li>
                                <li>プロジェクトにメンバー（Member）を追加できるようにする（プロジェクトとメンバーは多対多関連）</li>
                                <li>優先度（Priority：HIGH、MEDIUM、LOW）をタスクに追加する</li>
                                <li>タスクの完了までの予想時間（estimatedHours）を追加する</li>
                            </ul>
                        </div>
                    </section>

                    <section id="quiz">
                        <h3 class="section-title">11.5 理解度確認テスト</h3>
                        <div class="quiz-container">
                            <h4>第11章の理解度チェック</h4>
                            <p>以下の問題に答えて、第11章の内容の理解度を確認しましょう。</p>
                            
                            <div class="quiz-question">
                                <p><strong>問題1:</strong> Java Recordsの特徴として正しくないものを選んでください。</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1a" value="a">
                                    <label class="form-check-label" for="q1a">
                                        不変（Immutable）である
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1b" value="b">
                                    <label class="form-check-label" for="q1b">
                                        equals()、hashCode()、toString()メソッドが自動生成される
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1c" value="c">
                                        <label class="form-check-label" for="q1c">
                                        他のクラスを継承できる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q1" id="q1d" value="d">
                                        <label class="form-check-label" for="q1d">
                                        コンパクトコンストラクタを定義できる
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題2:</strong> Spring Data JDBCで集約ルートから子エンティティへの1対多の関連を定義するために使用するアノテーションは何ですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2a" value="a">
                                    <label class="form-check-label" for="q2a">
                                        @OneToMany
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2b" value="b">
                                    <label class="form-check-label" for="q2b">
                                        @MappedCollection
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2c" value="c">
                                        <label class="form-check-label" for="q2c">
                                        @Embedded
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2d" value="d">
                                        <label class="form-check-label" for="q2d">
                                        @Relationship
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題3:</strong> 集約ルート（Aggregate Root）の特徴として正しいものはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3a" value="a">
                                    <label class="form-check-label" for="q3a">
                                        集約ルート以外のエンティティも独自のリポジトリを持つべきである
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3b" value="b">
                                    <label class="form-check-label" for="q3b">
                                        集約内のエンティティは、集約ルートを通さずに直接アクセスするべきである
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3c" value="c">
                                        <label class="form-check-label" for="q3c">
                                        集約は一貫性を保つべきドメインオブジェクトのグループを定義する
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q3" id="q3d" value="d">
                                        <label class="form-check-label" for="q3d">
                                        集約間の参照は常に直接的なオブジェクト参照で行うべきである
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題4:</strong> Java Recordsを使用して1対多の関連を持つエンティティを実装する場合、子エンティティを追加する際に何が必要ですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4a" value="a">
                                    <label class="form-check-label" for="q4a">
                                        子エンティティを変更するだけでよい
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4b" value="b">
                                    <label class="form-check-label" for="q4b">
                                        新しいインスタンスを作成し、変更されたコレクションを持たせる
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4c" value="c">
                                        <label class="form-check-label" for="q4c">
                                        Recordのフィールドを直接変更する
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4d" value="d">
                                        <label class="form-check-label" for="q4d">
                                        @MutableCollectionアノテーションを使用する
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題5:</strong> Spring Data JDBCで集約ルートを保存した場合、子エンティティはどうなりますか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5a" value="a">
                                    <label class="form-check-label" for="q5a">
                                        子エンティティは別途保存する必要がある
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5b" value="b">
                                    <label class="form-check-label" for="q5b">
                                        子エンティティのリポジトリを使って保存する必要がある
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5c" value="c">
                                        <label class="form-check-label" for="q5c">
                                        子エンティティは自動的に保存される
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5d" value="d">
                                        <label class="form-check-label" for="q5d">
                                        @Cascadeアノテーションを設定した場合のみ保存される
                                    </label>
                                </div>
                            </div>
                            
                            <button class="btn btn-success mt-3" id="checkAnswers">回答を確認</button>
                            <div id="quizResults" class="mt-3 d-none">
                                <div class="alert alert-success">
                                    <h5>正解:</h5>
                                    <ol>
                                        <li>c（他のクラスを継承できる）- Recordsは他のクラスを継承できません</li>
                                        <li>b（@MappedCollection）- Spring Data JDBCで1対多の関連を定義するためのアノテーションです</li>
                                        <li>c（集約は一貫性を保つべきドメインオブジェクトのグループを定義する）- 集約ルートの基本的な概念です</li>
                                        <li>b（新しいインスタンスを作成し、変更されたコレクションを持たせる）- Recordsは不変なので、変更には新しいインスタンスが必要です</li>
                                        <li>c（子エンティティは自動的に保存される）- Spring Data JDBCでは集約ルートを保存すると子エンティティも自動的に保存されます</li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="next-steps">
                        <h3 class="section-title">次のステップ</h3>
                        <p>この章では、Java RecordsとSpring Data JDBCを組み合わせた効率的なデータモデリング、集約ルート（Aggregate Root）の概念、1対多の関連モデルの実装方法について学びました。</p>
                        <p>次の章では、これらの知識をさらに発展させ、実際のアプリケーション開発においてこれらの概念をどのように適用するかを学んでいきます。特に、RESTful APIの設計、セキュリティの実装、テスト手法などに焦点を当てます。</p>
                        <div class="note">
                            <h5>推奨される追加学習</h5>
                            <ul>
                                <li><strong>Java Records</strong>：<a href="https://docs.oracle.com/en/java/javase/16/language/records.html" target="_blank">Java Language Documentation</a></li>
                                <li><strong>Spring Data JDBC</strong>：<a href="https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/" target="_blank">Spring Data JDBC Reference Documentation</a></li>
                                <li><strong>ドメイン駆動設計</strong>：<a href="https://www.domainlanguage.com/ddd/" target="_blank">Domain-Driven Design</a></li>
                                <li><strong>関連プロジェクト</strong>：<a href="https://github.com/spring-projects/spring-data-examples/tree/main/jdbc" target="_blank">Spring Data JDBC Examples</a></li>
                            </ul>
                        </div>
                    </section>
                </section>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="text-center py-4">
        <div class="container">
            <p class="mb-0">Copyright © 2025 F-Circle All rights reserved.</p>
        </div>
    </footer>

    <!-- Bootstrap JS and Popper.js -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 理解度テストの回答確認ボタンの処理
        document.getElementById('checkAnswers').addEventListener('click', function() {
            document.getElementById('quizResults').classList.remove('d-none');
        });
    </script>
</body>
</html>