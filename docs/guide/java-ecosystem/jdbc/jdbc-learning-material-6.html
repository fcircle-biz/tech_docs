<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JDBC学習教材 第6章 - JDBCとオブジェクト指向設計</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #f57c00;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }

        /* タイトル */
        .chapter-title {
            color: #f57c00;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #f57c00;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #ff9800;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #fff3e0;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #f57c00;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #f57c00 !important;
            color: white !important;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand">
                <strong>JDBC学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
                <div class="position-sticky pt-3">
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-1.html">第1章: JDBCの基礎</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-2.html">第2章: データベース接続</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-3.html">第3章: 基本的なCRUD操作</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-4.html">第4章: 例外処理とリソース管理</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-5.html">第5章: 高度なJDBC機能</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="jdbc-learning-material-6.html">第6章: JDBCとオブジェクト指向設計</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-7.html">第7章: パフォーマンスとセキュリティ</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-8.html">第8章: 総合プロジェクト - 図書館管理システム</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-9.html">第9章: JDBCリファレンス</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="jdbc-learning-material-10.html">第10章: データベース固有の設定</a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <!-- 章ヘッダー -->
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第6章: JDBCとオブジェクト指向設計</h1>
                </div>

                <div id="chapter6">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">保守性と拡張性の高いデータアクセス層</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>Data Access Object（DAO）パターンの理論と実装</li>
                            <li>オブジェクトリレーショナルマッピング（ORM）の基本原理</li>
                            <li>JDBCを使ったデータベース操作とJavaコレクションの連携手法</li>
                            <li>レイヤー化アーキテクチャにおけるデータアクセス層の役割</li>
                            <li>実際のECサイトバックエンドでのDAOパターン適用方法</li>
                        </ul>
                    </div>

                    <!-- セクション1: DAOパターンの概念 -->
                    <h3 class="section-title">6.1 Data Access Object（DAO）パターンの理論</h3>
                    <p>DAOパターンは、データアクセスロジックをビジネスロジックから分離するための設計パターンです。これにより、データベースの変更やビジネスロジックの変更が互いに影響することを防ぎ、保守性の高いアプリケーションを構築できます。</p>

                    <div class="mermaid">
                        flowchart TB
                            subgraph "従来のアプローチ"
                                A1[ビジネスロジック] --> B1[直接SQL実行]
                                B1 --> C1[データベース]
                            end
                            
                            subgraph "DAOパターン"
                                A2[ビジネスロジック] --> B2[DAOインターフェース]
                                B2 --> C2[DAO実装クラス]
                                C2 --> D2[データベース]
                                B2 --> E2[別のDAO実装<br/>（テスト用など）]
                                E2 --> F2[別のデータソース]
                            end
                    </div>

                    <h4>DAOパターンの構成要素</h4>
                    <ul>
                        <li><strong>DAOインターフェース</strong>：データアクセス操作の契約を定義</li>
                        <li><strong>DAO実装クラス</strong>：具体的なデータアクセス処理を実装</li>
                        <li><strong>データモデル（Entity）</strong>：データベースのテーブルに対応するJavaオブジェクト</li>
                        <li><strong>ファクトリクラス</strong>：適切なDAO実装を提供する（オプション）</li>
                    </ul>

                    <h4>DAOパターンの利点</h4>
                    <ul>
                        <li><strong>関心の分離</strong>：データアクセスロジックとビジネスロジックを分離</li>
                        <li><strong>テスタビリティ</strong>：モックオブジェクトによる単体テストが容易</li>
                        <li><strong>保守性</strong>：データベース変更の影響をDAO層に限定</li>
                        <li><strong>再利用性</strong>：異なるアプリケーションでDAOを再利用可能</li>
                    </ul>

                    <!-- セクション2: Entityクラスの設計 -->
                    <h3 class="section-title">6.2 データモデル（Entity）クラスの設計</h3>
                    <p>Entityクラスは、データベースのテーブル構造をJavaオブジェクトで表現したものです。適切に設計されたEntityクラスは、データの整合性を保ち、コードの可読性を向上させます。</p>

                    <!-- 実習1: Entity設計 -->
                    <div class="exercise-container">
                        <h5>実習 6-1: ECサイトのEntityクラス設計</h5>
                        <p>ECサイトの商品管理システムを例に、適切なEntityクラスの設計方法を学習します。</p>

                        <h6>データベーステーブル設計</h6>
                        <pre class="code-block"><code class="language-sql">-- 商品テーブル
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    price DECIMAL(10,2) NOT NULL,
    stock INTEGER NOT NULL DEFAULT 0,
    category_id INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- カテゴリテーブル
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT
);</code></pre>

                        <h6>Productエンティティクラス</h6>
                        <pre class="code-block"><code class="language-java">import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Objects;

/**
 * 商品エンティティクラス
 */
public class Product {
    private Integer id;
    private String name;
    private String description;
    private BigDecimal price;
    private Integer stock;
    private Integer categoryId;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // デフォルトコンストラクタ
    public Product() {}
    
    // 全フィールドコンストラクタ
    public Product(Integer id, String name, String description, 
                   BigDecimal price, Integer stock, Integer categoryId,
                   LocalDateTime createdAt, LocalDateTime updatedAt) {
        this.id = id;
        this.name = name;
        this.description = description;
        this.price = price;
        this.stock = stock;
        this.categoryId = categoryId;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }
    
    // 新規作成用コンストラクタ（IDと日時は自動生成）
    public Product(String name, String description, BigDecimal price, 
                   Integer stock, Integer categoryId) {
        this.name = name;
        this.description = description;
        this.price = price;
        this.stock = stock;
        this.categoryId = categoryId;
    }
    
    // Getter/Setterメソッド
    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public BigDecimal getPrice() { return price; }
    public void setPrice(BigDecimal price) { this.price = price; }
    
    public Integer getStock() { return stock; }
    public void setStock(Integer stock) { this.stock = stock; }
    
    public Integer getCategoryId() { return categoryId; }
    public void setCategoryId(Integer categoryId) { this.categoryId = categoryId; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    
    // ビジネスメソッド
    public boolean isInStock() {
        return stock != null && stock > 0;
    }
    
    public boolean canPurchase(int quantity) {
        return isInStock() && stock >= quantity;
    }
    
    // equals/hashCode（IDベース）
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Product product = (Product) obj;
        return Objects.equals(id, product.id);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
    
    // toString
    @Override
    public String toString() {
        return String.format("Product{id=%d, name='%s', price=%s, stock=%d}", 
                           id, name, price, stock);
    }
}</code></pre>

                        <h6>Categoryエンティティクラス</h6>
                        <pre class="code-block"><code class="language-java">import java.util.Objects;

/**
 * カテゴリエンティティクラス
 */
public class Category {
    private Integer id;
    private String name;
    private String description;
    
    // コンストラクタ
    public Category() {}
    
    public Category(Integer id, String name, String description) {
        this.id = id;
        this.name = name;
        this.description = description;
    }
    
    public Category(String name, String description) {
        this.name = name;
        this.description = description;
    }
    
    // Getter/Setter
    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Category category = (Category) obj;
        return Objects.equals(id, category.id);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
    
    @Override
    public String toString() {
        return String.format("Category{id=%d, name='%s'}", id, name);
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>これらのEntityクラスは、データベースのテーブル構造を正確に反映し、ビジネスロジックに必要なメソッドを提供します。equals/hashCodeの実装により、コレクション操作も安全に行えます。</p>
                    </div>

                    <!-- セクション3: DAOインターフェースの設計 -->
                    <h3 class="section-title">6.3 DAOインターフェースの設計</h3>
                    <p>DAOインターフェースは、データアクセス操作の契約を定義します。一般的なCRUD操作に加えて、ビジネス要件に応じた検索メソッドも含めます。</p>

                    <!-- 実習2: DAOインターフェース -->
                    <div class="exercise-container">
                        <h5>実習 6-2: ProductDAOインターフェースの設計と実装</h5>
                        <p>商品エンティティに対するデータアクセス操作を定義し、具体的な実装を行います。</p>

                        <h6>ProductDAOインターフェース</h6>
                        <pre class="code-block"><code class="language-java">import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

/**
 * 商品データアクセスオブジェクトのインターフェース
 */
public interface ProductDAO {
    
    /**
     * 商品を新規作成
     * @param product 作成する商品
     * @return 作成された商品（IDが設定される）
     */
    Product create(Product product);
    
    /**
     * IDによる商品検索
     * @param id 商品ID
     * @return 商品（見つからない場合はEmpty）
     */
    Optional&lt;Product&gt; findById(Integer id);
    
    /**
     * すべての商品を取得
     * @return 商品リスト
     */
    List&lt;Product&gt; findAll();
    
    /**
     * カテゴリIDによる商品検索
     * @param categoryId カテゴリID
     * @return 該当商品リスト
     */
    List&lt;Product&gt; findByCategoryId(Integer categoryId);
    
    /**
     * 商品名による部分一致検索
     * @param namePattern 商品名パターン
     * @return 該当商品リスト
     */
    List&lt;Product&gt; findByNameContaining(String namePattern);
    
    /**
     * 価格帯による商品検索
     * @param minPrice 最低価格
     * @param maxPrice 最高価格
     * @return 該当商品リスト
     */
    List&lt;Product&gt; findByPriceRange(BigDecimal minPrice, BigDecimal maxPrice);
    
    /**
     * 在庫ありの商品のみを取得
     * @return 在庫ありの商品リスト
     */
    List&lt;Product&gt; findInStockProducts();
    
    /**
     * 商品情報を更新
     * @param product 更新する商品
     * @return 更新が成功した場合true
     */
    boolean update(Product product);
    
    /**
     * 商品を削除
     * @param id 削除する商品のID
     * @return 削除が成功した場合true
     */
    boolean delete(Integer id);
    
    /**
     * 在庫を更新
     * @param id 商品ID
     * @param newStock 新しい在庫数
     * @return 更新が成功した場合true
     */
    boolean updateStock(Integer id, Integer newStock);
}</code></pre>

                        <h6>ProductDAO実装クラス（一部）</h6>
                        <pre class="code-block"><code class="language-java">import java.math.BigDecimal;
import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * ProductDAOの実装クラス
 */
public class ProductDAOImpl implements ProductDAO {
    private static final String DB_URL = "jdbc:postgresql://localhost:5432/testdb";
    private static final String DB_USER = "user";
    private static final String DB_PASSWORD = "password";
    
    @Override
    public Product create(Product product) {
        String sql = "INSERT INTO products (name, description, price, stock, category_id, created_at, updated_at) " +
                    "VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP) RETURNING id, created_at, updated_at";
        
        try (Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
             PreparedStatement statement = connection.prepareStatement(sql)) {
            
            statement.setString(1, product.getName());
            statement.setString(2, product.getDescription());
            statement.setBigDecimal(3, product.getPrice());
            statement.setInt(4, product.getStock());
            statement.setInt(5, product.getCategoryId());
            
            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    product.setId(resultSet.getInt("id"));
                    product.setCreatedAt(resultSet.getTimestamp("created_at").toLocalDateTime());
                    product.setUpdatedAt(resultSet.getTimestamp("updated_at").toLocalDateTime());
                    return product;
                }
            }
            
        } catch (SQLException e) {
            System.err.println("商品作成エラー: " + e.getMessage());
        }
        
        return null;
    }
    
    @Override
    public Optional&lt;Product&gt; findById(Integer id) {
        String sql = "SELECT * FROM products WHERE id = ?";
        
        try (Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
             PreparedStatement statement = connection.prepareStatement(sql)) {
            
            statement.setInt(1, id);
            
            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    return Optional.of(mapRowToProduct(resultSet));
                }
            }
            
        } catch (SQLException e) {
            System.err.println("商品検索エラー: " + e.getMessage());
        }
        
        return Optional.empty();
    }
    
    @Override
    public List&lt;Product&gt; findByCategoryId(Integer categoryId) {
        String sql = "SELECT * FROM products WHERE category_id = ? ORDER BY name";
        List&lt;Product&gt; products = new ArrayList&lt;&gt;();
        
        try (Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
             PreparedStatement statement = connection.prepareStatement(sql)) {
            
            statement.setInt(1, categoryId);
            
            try (ResultSet resultSet = statement.executeQuery()) {
                while (resultSet.next()) {
                    products.add(mapRowToProduct(resultSet));
                }
            }
            
        } catch (SQLException e) {
            System.err.println("カテゴリ別商品検索エラー: " + e.getMessage());
        }
        
        return products;
    }
    
    @Override
    public List&lt;Product&gt; findInStockProducts() {
        String sql = "SELECT * FROM products WHERE stock > 0 ORDER BY name";
        List&lt;Product&gt; products = new ArrayList&lt;&gt;();
        
        try (Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
             PreparedStatement statement = connection.prepareStatement(sql);
             ResultSet resultSet = statement.executeQuery()) {
            
            while (resultSet.next()) {
                products.add(mapRowToProduct(resultSet));
            }
            
        } catch (SQLException e) {
            System.err.println("在庫ありの商品検索エラー: " + e.getMessage());
        }
        
        return products;
    }
    
    /**
     * ResultSetからProductオブジェクトにマッピング
     */
    private Product mapRowToProduct(ResultSet resultSet) throws SQLException {
        Product product = new Product();
        product.setId(resultSet.getInt("id"));
        product.setName(resultSet.getString("name"));
        product.setDescription(resultSet.getString("description"));
        product.setPrice(resultSet.getBigDecimal("price"));
        product.setStock(resultSet.getInt("stock"));
        product.setCategoryId(resultSet.getInt("category_id"));
        
        Timestamp createdAt = resultSet.getTimestamp("created_at");
        if (createdAt != null) {
            product.setCreatedAt(createdAt.toLocalDateTime());
        }
        
        Timestamp updatedAt = resultSet.getTimestamp("updated_at");
        if (updatedAt != null) {
            product.setUpdatedAt(updatedAt.toLocalDateTime());
        }
        
        return product;
    }
    
    // 他のメソッドも同様に実装...
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>このDAO実装により、データアクセス処理がビジネスロジックから分離され、テストやメンテナンスが容易になります。また、インターフェースによる抽象化により、将来的に異なるデータストアに変更することも可能です。</p>
                    </div>

                    <!-- セクション4: サービス層との連携 -->
                    <h3 class="section-title">6.4 サービス層とDAOの連携</h3>
                    <p>サービス層は、ビジネスロジックを集約する層で、複数のDAOを組み合わせて複雑な処理を実現します。この層により、プレゼンテーション層からデータアクセス層を隠蔽できます。</p>

                    <div class="mermaid">
                        flowchart TB
                            A[コントローラー層] --> B[サービス層]
                            B --> C[ProductDAO]
                            B --> D[CategoryDAO]
                            B --> E[OrderDAO]
                            C --> F[データベース]
                            D --> F
                            E --> F
                            
                            subgraph "ビジネスロジック"
                                B
                            end
                            
                            subgraph "データアクセス層"
                                C
                                D
                                E
                            end
                    </div>

                    <!-- 実習3: サービス層 -->
                    <div class="exercise-container">
                        <h5>実習 6-3: ProductServiceの実装</h5>
                        <p>商品に関するビジネスロジックを集約したサービス層を実装し、DAOとの適切な連携方法を学習します。</p>

                        <h6>ProductServiceインターフェース</h6>
                        <pre class="code-block"><code class="language-java">import java.math.BigDecimal;
import java.util.List;

/**
 * 商品関連のビジネスロジックを提供するサービス
 */
public interface ProductService {
    
    /**
     * 新商品を登録
     * @param product 商品情報
     * @return 登録された商品
     */
    Product registerNewProduct(Product product);
    
    /**
     * 商品検索（複数条件）
     * @param categoryId カテゴリID（nullの場合は全カテゴリ）
     * @param namePattern 商品名パターン（nullの場合は条件なし）
     * @param minPrice 最低価格（nullの場合は条件なし）
     * @param maxPrice 最高価格（nullの場合は条件なし）
     * @param inStockOnly 在庫ありのみ
     * @return 検索結果
     */
    List&lt;Product&gt; searchProducts(Integer categoryId, String namePattern,
                                BigDecimal minPrice, BigDecimal maxPrice, 
                                boolean inStockOnly);
    
    /**
     * 商品購入処理（在庫チェック＋減少）
     * @param productId 商品ID
     * @param quantity 購入数量
     * @return 購入成功時true
     */
    boolean purchaseProduct(Integer productId, Integer quantity);
    
    /**
     * 人気商品の取得（購入回数によるランキング）
     * @param limit 取得件数
     * @return 人気商品リスト
     */
    List&lt;Product&gt; getPopularProducts(int limit);
    
    /**
     * 商品価格の一括更新（カテゴリ別）
     * @param categoryId カテゴリID
     * @param priceMultiplier 価格倍率
     * @return 更新件数
     */
    int updatePricesByCategory(Integer categoryId, BigDecimal priceMultiplier);
}</code></pre>

                        <h6>ProductService実装クラス</h6>
                        <pre class="code-block"><code class="language-java">import java.math.BigDecimal;
import java.util.List;
import java.util.stream.Collectors;

/**
 * ProductServiceの実装クラス
 */
public class ProductServiceImpl implements ProductService {
    private final ProductDAO productDAO;
    private final CategoryDAO categoryDAO;
    
    public ProductServiceImpl(ProductDAO productDAO, CategoryDAO categoryDAO) {
        this.productDAO = productDAO;
        this.categoryDAO = categoryDAO;
    }
    
    @Override
    public Product registerNewProduct(Product product) {
        // ビジネスルール検証
        if (product.getName() == null || product.getName().trim().isEmpty()) {
            throw new IllegalArgumentException("商品名は必須です");
        }
        
        if (product.getPrice() == null || product.getPrice().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("価格は正の値である必要があります");
        }
        
        if (product.getCategoryId() == null) {
            throw new IllegalArgumentException("カテゴリIDは必須です");
        }
        
        // カテゴリの存在確認
        if (!categoryDAO.findById(product.getCategoryId()).isPresent()) {
            throw new IllegalArgumentException("指定されたカテゴリが存在しません");
        }
        
        // 在庫の初期値設定
        if (product.getStock() == null) {
            product.setStock(0);
        }
        
        return productDAO.create(product);
    }
    
    @Override
    public List&lt;Product&gt; searchProducts(Integer categoryId, String namePattern,
                                      BigDecimal minPrice, BigDecimal maxPrice,
                                      boolean inStockOnly) {
        
        // 基本リストの取得
        List&lt;Product&gt; products;
        
        if (categoryId != null) {
            products = productDAO.findByCategoryId(categoryId);
        } else {
            products = productDAO.findAll();
        }
        
        // Java Streamを使用したフィルタリング
        return products.stream()
                .filter(p -&gt; namePattern == null || 
                           p.getName().toLowerCase().contains(namePattern.toLowerCase()))
                .filter(p -&gt; minPrice == null || p.getPrice().compareTo(minPrice) >= 0)
                .filter(p -&gt; maxPrice == null || p.getPrice().compareTo(maxPrice) <= 0)
                .filter(p -&gt; !inStockOnly || p.isInStock())
                .collect(Collectors.toList());
    }
    
    @Override
    public boolean purchaseProduct(Integer productId, Integer quantity) {
        // 商品存在確認
        Product product = productDAO.findById(productId)
                .orElseThrow(() -&gt; new IllegalArgumentException("商品が見つかりません"));
        
        // 在庫チェック
        if (!product.canPurchase(quantity)) {
            System.err.println("在庫不足または商品が利用できません");
            return false;
        }
        
        // 在庫減少
        int newStock = product.getStock() - quantity;
        boolean success = productDAO.updateStock(productId, newStock);
        
        if (success) {
            System.out.println("商品購入完了: " + product.getName() + " x " + quantity);
        }
        
        return success;
    }
    
    // 簡易実装例
    @Override
    public List&lt;Product&gt; getPopularProducts(int limit) {
        // 実際の実装では注文履歴から集計
        return productDAO.findInStockProducts().stream()
                .limit(limit)
                .collect(Collectors.toList());
    }
    
    @Override
    public int updatePricesByCategory(Integer categoryId, BigDecimal priceMultiplier) {
        List&lt;Product&gt; products = productDAO.findByCategoryId(categoryId);
        int updateCount = 0;
        
        for (Product product : products) {
            BigDecimal newPrice = product.getPrice().multiply(priceMultiplier);
            product.setPrice(newPrice);
            
            if (productDAO.update(product)) {
                updateCount++;
            }
        }
        
        return updateCount;
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>サービス層により、複雑なビジネスロジックが適切に処理され、データアクセス処理が抽象化されます。また、Java Streamを活用した効率的なデータ操作も実現できます。</p>
                    </div>

                    <!-- セクション5: オブジェクトリレーショナルマッピング -->
                    <h3 class="section-title">6.5 オブジェクトリレーショナルマッピング（ORM）の概念</h3>
                    <p>ORMは、リレーショナルデータベースのテーブルとオブジェクト指向プログラミングのクラスを対応付ける技術です。JDBCを基盤としながら、より高レベルな抽象化を提供します。</p>

                    <div class="highlight">
                        <h5>ORMの主要な概念</h5>
                        <ul>
                            <li><strong>テーブル ⇔ クラス</strong>：データベーステーブルがJavaクラスに対応</li>
                            <li><strong>行 ⇔ インスタンス</strong>：テーブルの行がオブジェクトのインスタンスに対応</li>
                            <li><strong>列 ⇔ フィールド</strong>：テーブルの列がクラスのフィールドに対応</li>
                            <li><strong>外部キー ⇔ 関連</strong>：外部キー制約がオブジェクト間の関連に対応</li>
                        </ul>
                    </div>

                    <div class="mermaid">
                        flowchart TB
                            subgraph "データベース層"
                                A[products テーブル]
                                B[categories テーブル]
                                A --> C[外部キー関係]
                                C --> B
                            end
                            
                            subgraph "ORM層"
                                D[マッピング処理]
                            end
                            
                            subgraph "オブジェクト層"
                                E[Product クラス]
                                F[Category クラス]
                                E --> G[オブジェクト関連]
                                G --> F
                            end
                            
                            A -.-> D
                            B -.-> D
                            D -.-> E
                            D -.-> F
                    </div>

                    <!-- 理解度確認クイズ -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <p><strong>DAOパターンの主要な構成要素を4つ挙げ、それぞれの役割を説明してください。</strong></p>
                            </li>
                            
                            <li>
                                <p><strong>以下のコードでDAOパターンを使用する利点を3つ説明してください：</strong></p>
                                <pre class="code-block"><code class="language-java">// ビジネスロジック
ProductService service = new ProductServiceImpl(productDAO, categoryDAO);
List&lt;Product&gt; products = service.searchProducts(null, "PC", null, null, true);</code></pre>
                            </li>
                            
                            <li>
                                <p><strong>Entityクラスでequals()とhashCode()を適切に実装することが重要な理由を説明してください。</strong></p>
                            </li>
                            
                            <li>
                                <p><strong>サービス層の役割とDAOとの違いを説明し、以下の処理がどちらに属するか分類してください：</strong></p>
                                <ul>
                                    <li>商品の在庫チェック</li>
                                    <li>データベースへのSQL実行</li>
                                    <li>複数商品の一括価格更新</li>
                                    <li>ResultSetからEntityオブジェクトへの変換</li>
                                </ul>
                            </li>
                            
                            <li>
                                <p><strong>ORMの利点と欠点をそれぞれ3つずつ挙げ、JDBCとの使い分けについて考察してください。</strong></p>
                            </li>
                        </ol>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="jdbc-learning-material-5.html" class="btn btn-secondary">← 前の章</a>
                        <a href="jdbc-learning-material-7.html" class="btn btn-primary">次の章 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js 初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>