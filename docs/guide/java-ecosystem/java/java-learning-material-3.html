<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java初心者向け学習教材 - オブジェクト指向プログラミング入門</title>
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        .navbar {
            background-color: #1565c0;
        }
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        .chapter-title {
            color: #1565c0;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #1565c0;
            padding-bottom: 0.5rem;
        }
        .section-title {
            color: #1976d2;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        code {
            display: block;
            background-color: #f5f5f5;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            white-space: pre;
            overflow-x: auto;
        }
        .quiz-container {
            background-color: #e3f2fd;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }
        .quiz-question {
            font-weight: 500;
            margin-bottom: 1rem;
        }
        .diagram {
            max-width: 100%;
            height: auto;
            margin: 1.5rem 0;
            text-align: center;
        }
        .exercise {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        .note {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        #table-of-contents .list-group-item {
            border: none;
            padding: 0.5rem 1rem;
        }
        #table-of-contents .list-group-item-action {
            color: #1976d2;
        }
        /* 選択された目次項目のスタイル */
        #table-of-contents .list-group-item-action.active,
        .list-group-item.active {
            color: white !important; /* テキストを白色にして青い背景に対してコントラストをつける */
            background-color: #1976d2;
            border-color: #1976d2;
        }
        .section-nav {
            padding-left: 1rem;
        }
        .inline-code {
            background-color: #f5f5f5;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            display: inline;
        }
    </style>
</head>
<body data-bs-spy="scroll" data-bs-target="#tableOfContents">
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="#">Java初心者向け学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="#introduction">はじめに</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#chapter3">第3章: オブジェクト指向プログラミング</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container my-4">
        <div class="row">
            <!-- Sidebar - Table of Contents -->
            <div class="col-lg-3">
                <div class="sidebar">
                    <div class="card">
                        <div class="card-header bg-primary text-white">
                            <h5 class="mb-0">目次</h5>
                        </div>
                        <div id="table-of-contents" class="list-group list-group-flush">
                            <a href="#introduction" class="list-group-item list-group-item-action">はじめに</a>
                            <a href="#chapter3" class="list-group-item list-group-item-action">第3章: オブジェクト指向プログラミング</a>
                            <div class="section-nav">
                                <a href="#oop-overview" class="list-group-item list-group-item-action">3.1 オブジェクト指向プログラミングの概要</a>
                                <a href="#classes-objects" class="list-group-item list-group-item-action">3.2 クラスとオブジェクト</a>
                                <a href="#fields-methods" class="list-group-item list-group-item-action">3.3 フィールドとメソッド</a>
                                <a href="#constructors" class="list-group-item list-group-item-action">3.4 コンストラクタ</a>
                                <a href="#access-modifiers" class="list-group-item list-group-item-action">3.5 アクセス修飾子</a>
                                <a href="#encapsulation" class="list-group-item list-group-item-action">3.6 カプセル化の概念</a>
                                <a href="#getters-setters" class="list-group-item list-group-item-action">3.7 getterとsetterメソッド</a>
                                <a href="#chapter3-quiz" class="list-group-item list-group-item-action">3.8 理解度確認テスト</a>
                            </div>
                            <a href="#next-steps" class="list-group-item list-group-item-action">次のステップ</a>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Main Content -->
            <div class="col-lg-9">
                <section id="introduction">
                    <h1 class="display-5 mb-4">Java初心者向け学習教材</h1>
                    <p class="lead">この第3章では、Javaのオブジェクト指向プログラミングの基礎を学習します。クラスとオブジェクトの概念から始め、フィールド、メソッド、コンストラクタ、アクセス修飾子、カプセル化など、オブジェクト指向の重要な概念をわかりやすく解説します。</p>
                    <img src="img/java_03.png" class="img-fluid mt-3 mb-4" style="max-width: 50%; height: auto;">
                    <div class="note">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>オブジェクト指向プログラミングの基本概念と利点</li>
                            <li>クラスとオブジェクトの関係と使い方</li>
                            <li>フィールドとメソッドの定義方法</li>
                            <li>コンストラクタの役割と実装方法</li>
                            <li>アクセス修飾子を使ったコードの保護</li>
                            <li>カプセル化を活用したコード設計</li>
                            <li>getterとsetterメソッドによるデータアクセス制御</li>
                        </ul>
                    </div>
                </section>

                <section id="chapter3">
                    <h2 class="chapter-title">第3章：オブジェクト指向プログラミング入門</h2>
                    <p>オブジェクト指向プログラミング（OOP）は、ソフトウェア開発の主要なパラダイムの一つで、Javaは完全なオブジェクト指向言語として設計されています。この章では、オブジェクト指向の基本概念と、Javaでの実装方法を学びます。</p>

                    <section id="oop-overview">
                        <h3 class="section-title">3.1 オブジェクト指向プログラミングの概要</h3>
                        <p>オブジェクト指向プログラミングは、データ（属性）とそのデータを操作する機能（メソッド）をひとまとめにした「オブジェクト」を基本単位とするプログラミングアプローチです。このアプローチにより、コードの再利用性、保守性、拡張性が向上します。</p>

                        <h4>オブジェクト指向の主な特徴</h4>
                        <div class="row mt-3">
                            <div class="col-md-6">
                                <div class="card mb-3">
                                    <div class="card-header bg-primary text-white">カプセル化 (Encapsulation)</div>
                                    <div class="card-body">
                                        <p class="card-text">データと操作をひとつのユニットにまとめ、内部の詳細を隠蔽することで、安全で管理しやすいコードを実現します。</p>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card mb-3">
                                    <div class="card-header bg-primary text-white">継承 (Inheritance)</div>
                                    <div class="card-body">
                                        <p class="card-text">既存のクラスの特性を新しいクラスが引き継ぐことができ、コードの再利用性を高めます。</p>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card mb-3">
                                    <div class="card-header bg-primary text-white">ポリモーフィズム (Polymorphism)</div>
                                    <div class="card-body">
                                        <p class="card-text">同じインターフェースを持つオブジェクトが異なる実装を持つことができ、柔軟なコード設計が可能になります。</p>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card mb-3">
                                    <div class="card-header bg-primary text-white">抽象化 (Abstraction)</div>
                                    <div class="card-body">
                                        <p class="card-text">複雑なシステムの本質的な特性だけを表現し、不要な詳細を隠すことで、複雑さを管理します。</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="note">
                            <h5>なぜオブジェクト指向プログラミングなのか？</h5>
                            <p>オブジェクト指向プログラミングの利点：</p>
                            <ul>
                                <li><strong>モジュール性</strong>: コードを論理的なユニットに分割でき、大規模なアプリケーション開発に適しています。</li>
                                <li><strong>再利用性</strong>: 一度作成したクラスは他のプログラムでも再利用できます。</li>
                                <li><strong>保守性</strong>: 変更が必要な場合、影響範囲を特定のクラスに限定できます。</li>
                                <li><strong>拡張性</strong>: 既存のコードに影響を与えずに新機能を追加できます。</li>
                                <li><strong>セキュリティ</strong>: データ隠蔽により、不正なアクセスからデータを保護できます。</li>
                            </ul>
                        </div>
                    </section>

                    <section id="classes-objects">
                        <h3 class="section-title">3.2 クラスとオブジェクト</h3>
                        <p>クラスとオブジェクトは、オブジェクト指向プログラミングの中心的な概念です。クラスはオブジェクトの設計図やテンプレートであり、オブジェクトはそのクラスのインスタンス（実体）です。</p>

                        <h4>クラスとは</h4>
                        <p>クラスは関連するデータ（フィールド）と操作（メソッド）をまとめた定義です。Javaでは、クラスは以下のように定義します：</p>
                        <code>public class Car {
    // フィールド（データ）
    String model;
    String color;
    int year;
    
    // メソッド（操作）
    void start() {
        System.out.println("エンジンを始動します。");
    }
    
    void stop() {
        System.out.println("エンジンを停止します。");
    }
}</code>

                        <h4>オブジェクトとは</h4>
                        <p>オブジェクトは、クラスから作成される実体（インスタンス）です。クラスが「車」という概念の設計図なら、オブジェクトは「青いトヨタのカローラ」など具体的な車のことです。Javaでオブジェクトを作成する方法：</p>
                        <code>// Carクラスからオブジェクトを作成
Car myCar = new Car();  // newキーワードを使ってインスタンス化

// オブジェクトのフィールドに値を設定
myCar.model = "カローラ";
myCar.color = "青";
myCar.year = 2023;

// オブジェクトのメソッドを呼び出す
myCar.start();  // 出力: エンジンを始動します。</code>

                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 300">
                                <!-- Class and Object Relationship -->
                                <rect x="80" y="50" width="170" height="200" fill="#bbdefb" stroke="#1976d2" stroke-width="2" rx="10" />
                                <text x="165" y="80" text-anchor="middle" font-size="16" font-weight="bold">Car クラス</text>
                                <line x1="80" y1="90" x2="250" y2="90" stroke="#1976d2" stroke-width="2" />
                                <text x="100" y="120" font-size="12">フィールド:</text>
                                <text x="110" y="145" font-size="12">- model: String</text>
                                <text x="110" y="165" font-size="12">- color: String</text>
                                <text x="110" y="185" font-size="12">- year: int</text>
                                <line x1="80" y1="195" x2="250" y2="195" stroke="#1976d2" stroke-width="2" />
                                <text x="100" y="215" font-size="12">メソッド:</text>
                                <text x="110" y="235" font-size="12">- start(): void</text>
                                <text x="110" y="255" font-size="12">- stop(): void</text>
                                
                                <rect x="350" y="50" width="150" height="110" fill="#c8e6c9" stroke="#388e3c" stroke-width="2" rx="10" />
                                <text x="425" y="80" text-anchor="middle" font-size="14" font-weight="bold">myCar オブジェクト</text>
                                <line x1="350" y1="90" x2="500" y2="90" stroke="#388e3c" stroke-width="2" />
                                <text x="370" y="115" font-size="12">model: "カローラ"</text>
                                <text x="370" y="135" font-size="12">color: "青"</text>
                                <text x="370" y="155" font-size="12">year: 2023</text>
                                
                                <rect x="350" y="170" width="150" height="110" fill="#c8e6c9" stroke="#388e3c" stroke-width="2" rx="10" />
                                <text x="425" y="200" text-anchor="middle" font-size="14" font-weight="bold">yourCar オブジェクト</text>
                                <line x1="350" y1="210" x2="500" y2="210" stroke="#388e3c" stroke-width="2" />
                                <text x="370" y="235" font-size="12">model: "プリウス"</text>
                                <text x="370" y="255" font-size="12">color: "赤"</text>
                                <text x="370" y="275" font-size="12">year: 2022</text>
                                
                                <!-- Arrows -->
                                <line x1="250" y1="100" x2="350" y2="100" stroke="#333" stroke-width="2" />
                                <polygon points="350,100 335,95 335,105" fill="#333" />
                                
                                <line x1="250" y1="200" x2="350" y2="220" stroke="#333" stroke-width="2" />
                                <polygon points="350,220 335,215 335,225" fill="#333" />
                            </svg>
                            <p class="text-center">図3.1: クラスとオブジェクトの関係</p>
                        </div>
                        
                        <div class="exercise">
                            <h5>Exercise 3.1: クラスとオブジェクトの作成</h5>
                            <p>以下の要件を満たすクラスとオブジェクトを作成してみましょう：</p>
                            <ol>
                                <li><strong>Studentクラス</strong>を作成し、フィールドとして name（名前）、id（学籍番号）、grade（学年）を持たせる</li>
                                <li>introduce() メソッドを追加し、学生の情報を出力する</li>
                                <li>Studentクラスから2つの異なるオブジェクトを作成し、フィールドに値を設定する</li>
                                <li>各オブジェクトの introduce() メソッドを呼び出し、結果を確認する</li>
                            </ol>
                            <p><strong>ヒント</strong>: プログラムのメインメソッド内で複数のオブジェクトを作成し、それぞれに異なる値を設定します。</p>
                        </div>
                    </section>

                    <section id="fields-methods">
                        <h3 class="section-title">3.3 フィールドとメソッド</h3>
                        <p>クラスの主要な構成要素であるフィールドとメソッドについて、より詳しく見ていきましょう。</p>

                        <h4>フィールド（Fields）</h4>
                        <p>フィールドはクラスの状態（データ）を表すクラス内の変数です。フィールドは以下のように宣言します：</p>
                        <code>public class Person {
    // フィールド宣言
    String name;           // 名前
    int age;               // 年齢
    double height;         // 身長
    boolean isStudent;     // 学生かどうか
    static int personCount; // すべてのPersonオブジェクトで共有する静的フィールド
}</code>

                        <h5>フィールドの特徴</h5>
                        <ul>
                            <li><strong>インスタンスフィールド</strong>: オブジェクトごとに異なる値を持ちます（例: name, age）</li>
                            <li><strong>静的（static）フィールド</strong>: クラスのすべてのオブジェクトで共有される値を持ちます（例: personCount）</li>
                            <li>フィールドには初期値を設定できます（例: <code>int age = 20;</code>）</li>
                            <li>フィールドはアクセス修飾子（public, private など）で保護できます</li>
                        </ul>

                        <h4>メソッド（Methods）</h4>
                        <p>メソッドはクラスの振る舞い（操作）を定義する関数です。メソッドは以下のように宣言します：</p>
                        <code>public class Person {
    String name;
    int age;
    
    // メソッド宣言
    void introduce() {
        System.out.println("こんにちは、私の名前は" + name + "です。" + age + "歳です。");
    }
    
    int getBirthYear() {
        return 2023 - age; // 現在の年から年齢を引いて生年を計算
    }
    
    void celebrateBirthday() {
        age++; // 年齢を1増やす
        System.out.println("お誕生日おめでとう！" + age + "歳になりました。");
    }
    
    static void showPersonCount() {
        System.out.println("現在の人数: " + personCount);
    }
}</code>

                        <h5>メソッドの特徴</h5>
                        <ul>
                            <li><strong>戻り値</strong>: メソッドは結果を返すことができます（例: getBirthYear() → int型の値を返す）</li>
                            <li><strong>パラメータ</strong>: メソッドは入力値を受け取ることができます（例: <code>void setAge(int newAge) { age = newAge; }</code>）</li>
                            <li><strong>インスタンスメソッド</strong>: オブジェクトを通じて呼び出されるメソッド（例: <code>person.introduce()</code>）</li>
                            <li><strong>静的（static）メソッド</strong>: クラス名を通じて呼び出されるメソッド（例: <code>Person.showPersonCount()</code>）</li>
                            <li>メソッドはアクセス修飾子で保護できます</li>
                        </ul>

                        <div class="note">
                            <h5>フィールドとメソッドの命名規則</h5>
                            <p>Javaでは以下の命名規則に従うことがベストプラクティスとされています：</p>
                            <ul>
                                <li><strong>フィールド・変数名</strong>: キャメルケース（最初は小文字、単語の区切りは大文字）e.g., studentName</li>
                                <li><strong>メソッド名</strong>: 動詞または動詞句で、キャメルケース e.g., calculateTotal()</li>
                                <li><strong>クラス名</strong>: パスカルケース（単語の最初の文字を大文字）e.g., StudentRecord</li>
                                <li><strong>定数</strong>: すべて大文字、単語の区切りはアンダースコア e.g., MAX_STUDENTS</li>
                            </ul>
                        </div>

                        <div class="exercise">
                            <h5>Exercise 3.2: フィールドとメソッドの活用</h5>
                            <p>以下の要件を満たす BankAccount クラスを作成してみましょう：</p>
                            <ol>
                                <li>フィールドとして accountNumber（口座番号）、ownerName（口座名義）、balance（残高）を持つ</li>
                                <li>以下のメソッドを実装する：
                                    <ul>
                                        <li>deposit(double amount): 指定した金額を預け入れる</li>
                                        <li>withdraw(double amount): 指定した金額を引き出す（残高不足の場合はエラーメッセージを表示）</li>
                                        <li>showBalance(): 現在の残高を表示する</li>
                                    </ul>
                                </li>
                                <li>クラス内に静的フィールド totalAccounts を追加し、作成された口座の数を追跡する</li>
                                <li>静的メソッド getTotalAccounts() を追加して、作成された口座の総数を返す</li>
                            </ol>
                        </div>
                    </section>

                    <section id="constructors">
                        <h3 class="section-title">3.4 コンストラクタ</h3>
                        <p>コンストラクタは、オブジェクトの生成時に呼び出される特別なメソッドです。コンストラクタを使用して、オブジェクトの初期状態を設定できます。</p>

                        <h4>コンストラクタの特徴</h4>
                        <ul>
                            <li>コンストラクタ名はクラス名と同じである必要があります</li>
                            <li>戻り値を宣言しません（voidも書きません）</li>
                            <li>new演算子でオブジェクトを作成するときに自動的に呼び出されます</li>
                            <li>複数のコンストラクタをオーバーロード（異なるパラメータリスト）できます</li>
                        </ul>

                        <h4>コンストラクタの例</h4>
                        <code>public class Student {
    String name;
    int id;
    int grade;
    
    // デフォルトコンストラクタ
    public Student() {
        name = "名前なし";
        id = 0;
        grade = 1;
        System.out.println("デフォルトコンストラクタが呼び出されました");
    }
    
    // パラメータ付きコンストラクタ
    public Student(String studentName, int studentId, int studentGrade) {
        name = studentName;
        id = studentId;
        grade = studentGrade;
        System.out.println("パラメータ付きコンストラクタが呼び出されました");
    }
    
    // 一部のパラメータだけを指定するコンストラクタ
    public Student(String studentName) {
        name = studentName;
        id = 0;
        grade = 1;
        System.out.println("名前だけのコンストラクタが呼び出されました");
    }
    
    void introduce() {
        System.out.println("私の名前は" + name + "、学籍番号は" + id + "、" + grade + "年生です。");
    }
}</code>

                        <h4>コンストラクタの使用例</h4>
                        <code>// デフォルトコンストラクタを使用
Student student1 = new Student();
student1.introduce();  // 出力: 私の名前は名前なし、学籍番号は0、1年生です。

// パラメータ付きコンストラクタを使用
Student student2 = new Student("山田太郎", 12345, 2);
student2.introduce();  // 出力: 私の名前は山田太郎、学籍番号は12345、2年生です。

// 名前だけのコンストラクタを使用
Student student3 = new Student("佐藤花子");
student3.introduce();  // 出力: 私の名前は佐藤花子、学籍番号は0、1年生です。</code>

                        <div class="note">
                            <h5>デフォルトコンストラクタ</h5>
                            <p>クラスにコンストラクタが明示的に定義されていない場合、Javaは自動的にパラメータを持たないデフォルトコンストラクタを提供します。しかし、一つでもコンストラクタを明示的に定義すると、自動生成されるデフォルトコンストラクタは提供されなくなります。</p>
                        </div>

                        <h4>コンストラクタのオーバーロード</h4>
                        <p>同じクラス内に複数のコンストラクタを定義することを「コンストラクタのオーバーロード」と呼びます。パラメータリスト（数、型、順序）が異なる必要があります。</p>

                        <div class="exercise">
                            <h5>Exercise 3.3: コンストラクタの実装</h5>
                            <p>Exercise 3.2で作成した<code>BankAccount</code>クラスに以下のコンストラクタを追加してみましょう：</p>
                            <ol>
                                <li>デフォルトコンストラクタ: 口座番号を"000000"、名義を"名義なし"、残高を0に設定</li>
                                <li>パラメータ付きコンストラクタ: 口座番号、名義、初期残高を引数として受け取る</li>
                                <li>口座番号と名義だけのコンストラクタ: 残高は0に設定</li>
                            </ol>
                            <p>メインメソッドで各コンストラクタを使用してオブジェクトを作成し、<code>showBalance()</code>メソッドで結果を確認してください。</p>
                        </div>
                    </section>

                    <section id="access-modifiers">
                        <h3 class="section-title">3.5 アクセス修飾子</h3>
                        <p>アクセス修飾子は、クラス、フィールド、メソッド、コンストラクタなどのアクセス範囲（可視性）を制御する修飾子です。Javaには4種類のアクセス修飾子があります。</p>

                        <div class="row mt-3">
                            <div class="col-md-6">
                                <div class="card mb-3">
                                    <div class="card-header bg-primary text-white">public</div>
                                    <div class="card-body">
                                        <p class="card-text">どこからでもアクセス可能。最も制限の少ないアクセス修飾子。</p>
                                        <p class="card-text"><strong>可視範囲</strong>: 同じクラス、同じパッケージ、異なるパッケージのサブクラス、異なるパッケージの非サブクラス（すべて）</p>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card mb-3">
                                    <div class="card-header bg-primary text-white">protected</div>
                                    <div class="card-body">
                                        <p class="card-text">同じパッケージ内と、異なるパッケージの子クラスからアクセス可能。</p>
                                        <p class="card-text"><strong>可視範囲</strong>: 同じクラス、同じパッケージ、異なるパッケージのサブクラス</p>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card mb-3">
                                    <div class="card-header bg-primary text-white">デフォルト (package-private)</div>
                                    <div class="card-body">
                                        <p class="card-text">アクセス修飾子を指定しない場合のデフォルト。同じパッケージ内のみからアクセス可能。</p>
                                        <p class="card-text"><strong>可視範囲</strong>: 同じクラス、同じパッケージ</p>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card mb-3">
                                    <div class="card-header bg-primary text-white">private</div>
                                    <div class="card-body">
                                        <p class="card-text">同じクラス内からのみアクセス可能。最も制限の厳しいアクセス修飾子。</p>
                                        <p class="card-text"><strong>可視範囲</strong>: 同じクラスのみ</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="diagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 350">
                                <!-- Access Modifiers Visualization -->
                                <circle cx="300" cy="150" r="150" fill="#ede7f6" stroke="#673ab7" stroke-width="2" />
                                <circle cx="300" cy="150" r="110" fill="#d1c4e9" stroke="#673ab7" stroke-width="2" />
                                <circle cx="300" cy="150" r="70" fill="#b39ddb" stroke="#673ab7" stroke-width="2" />
                                <circle cx="300" cy="150" r="35" fill="#9575cd" stroke="#673ab7" stroke-width="2" />
                                
                                <text x="300" y="150" text-anchor="middle" font-size="14" fill="white">private</text>
                                <text x="300" y="110" text-anchor="middle" font-size="14">default</text>
                                <text x="300" y="80" text-anchor="middle" font-size="14">protected</text>
                                <text x="300" y="40" text-anchor="middle" font-size="14">public</text>
                                
                                <text x="300" y="185" text-anchor="middle" font-size="12">同じクラス</text>
                                <text x="300" y="220" text-anchor="middle" font-size="12">同じパッケージ</text>
                                <text x="300" y="255" text-anchor="middle" font-size="12">サブクラス</text>
                                <text x="300" y="290" text-anchor="middle" font-size="12">他のクラス</text>
                            </svg>
                            <p class="text-center">図3.2: アクセス修飾子の可視範囲</p>
                        </div>

                        <h4>アクセス修飾子の使用例</h4>
                        <code>public class Person {
    // 異なるアクセス修飾子を持つフィールド
    public String name;       // どこからでもアクセス可能
    protected int age;        // 同じパッケージと子クラスからアクセス可能
    double height;            // デフォルト (package-private): 同じパッケージからのみアクセス可能
    private double weight;    // 同じクラス内からのみアクセス可能
    
    // 異なるアクセス修飾子を持つメソッド
    public void introduce() {
        System.out.println("私の名前は" + name + "です。");
    }
    
    protected void showAge() {
        System.out.println("私は" + age + "歳です。");
    }
    
    void showHeight() {
        System.out.println("身長は" + height + "cmです。");
    }
    
    private void showWeight() {
        System.out.println("体重は" + weight + "kgです。");
    }
    
    // privateフィールドにアクセスするためのpublicメソッド
    public void showDetails() {
        introduce();
        showAge();
        showHeight();
        showWeight();  // privateメソッドは同じクラス内から呼び出し可能
    }
}</code>

                        <div class="note">
                            <h5>アクセス修飾子の選択ガイドライン</h5>
                            <ul>
                                <li><strong>クラス</strong>: 通常は<code>public</code>（他のクラスから使用するため）</li>
                                <li><strong>フィールド</strong>: 通常は<code>private</code>（カプセル化のため）</li>
                                <li><strong>メソッド</strong>: 外部から呼び出す必要があるものは<code>public</code>、内部実装のみで使用するものは<code>private</code></li>
                                <li><strong>コンストラクタ</strong>: 通常は<code>public</code>（オブジェクトの生成を可能にするため）</li>
                            </ul>
                            <p>「最小特権の原則」に従い、必要最小限のアクセス権限を与えることがベストプラクティスです。</p>
                        </div>

                        <div class="exercise">
                            <h5>Exercise 3.4: アクセス修飾子の適用</h5>
                            <p>これまでに作成した<code>BankAccount</code>クラスを修正し、適切なアクセス修飾子を適用してみましょう：</p>
                            <ol>
                                <li>フィールド（<code>accountNumber</code>、<code>ownerName</code>、<code>balance</code>）を<code>private</code>に変更</li>
                                <li>メソッド（<code>deposit</code>、<code>withdraw</code>、<code>showBalance</code>）を<code>public</code>に変更</li>
                                <li>静的フィールド<code>totalAccounts</code>を<code>private</code>に変更</li>
                                <li>静的メソッド<code>getTotalAccounts</code>を<code>public</code>に変更</li>
                            </ol>
                            <p>修正後のクラスをコンパイルしようとすると、エラーが発生するかもしれません。なぜエラーが発生するのか、次のセクションで学ぶカプセル化と関連しています。</p>
                        </div>
                    </section>

                    <section id="encapsulation">
                        <h3 class="section-title">3.6 カプセル化の概念</h3>
                        <p>カプセル化は、データ（フィールド）と操作（メソッド）を単一のユニット（クラス）にまとめ、内部実装の詳細を隠蔽する概念です。カプセル化により、クラスの内部実装を変更しても、そのクラスを使用するコードに影響を与えずに済みます。</p>

                        <h4>カプセル化の実現方法</h4>
                        <ol>
                            <li>クラスのフィールドを<code>private</code>に設定し、直接アクセスを防ぐ</li>
                            <li>フィールドの値にアクセスするための<code>public</code>メソッド（getterとsetter）を提供する</li>
                            <li>setterメソッドではデータの検証を行い、無効な値の設定を防ぐ</li>
                        </ol>

                        <h4>カプセル化の例</h4>
                        <code>public class Employee {
    // privateフィールド
    private int id;
    private String name;
    private double salary;
    
    // コンストラクタ
    public Employee(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.setSalary(salary);  // setter経由で値を設定（検証のため）
    }
    
    // getterメソッド
    public int getId() {
        return id;
    }
    
    public String getName() {
        return name;
    }
    
    public double getSalary() {
        return salary;
    }
    
    // setterメソッド（データ検証あり）
    public void setId(int id) {
        if (id > 0) {
            this.id = id;
        } else {
            System.out.println("エラー: 社員IDは正の値である必要があります。");
        }
    }
    
    public void setName(String name) {
        if (name != null && !name.isEmpty()) {
            this.name = name;
        } else {
            System.out.println("エラー: 名前は空にできません。");
        }
    }
    
    public void setSalary(double salary) {
        if (salary >= 0) {
            this.salary = salary;
        } else {
            System.out.println("エラー: 給与は負の値にはできません。");
        }
    }
    
    // その他のメソッド
    public void raiseSalary(double percentage) {
        if (percentage > 0) {
            this.salary += this.salary * percentage / 100;
            System.out.println(name + "の給与が" + percentage + "%上昇しました。");
        } else {
            System.out.println("エラー: 昇給率は正の値である必要があります。");
        }
    }
}</code>

                        <h4>カプセル化の利点</h4>
                        <ul>
                            <li><strong>データ隠蔽</strong>: クラスの内部実装を隠すことで、外部からの不正なアクセスを防ぎます。</li>
                            <li><strong>データ検証</strong>: setterメソッドでデータの有効性を検証できます。</li>
                            <li><strong>柔軟性</strong>: クラスの内部実装を変更しても、外部インターフェースを変更する必要がありません。</li>
                            <li><strong>保守性</strong>: コードの保守や拡張が容易になります。</li>
                        </ul>

                        <div class="note">
                            <h5>カプセル化と情報隠蔽</h5>
                            <p>カプセル化と情報隠蔽（information hiding）は密接に関連した概念ですが、微妙な違いがあります：</p>
                            <ul>
                                <li><strong>カプセル化</strong>: データと操作をクラスという単一のユニットにまとめること</li>
                                <li><strong>情報隠蔽</strong>: 実装の詳細を外部から隠し、必要なインターフェースのみを公開すること</li>
                            </ul>
                            <p>Javaでは、privateフィールドとpublicメソッドを使用することで、両方の概念を実現しています。</p>
                        </div>

                        <div class="exercise">
                            <h5>Exercise 3.5: カプセル化の実装</h5>
                            <p>Exercise 3.4で修正した<code>BankAccount</code>クラスに、以下の改良を加えてカプセル化を完全に実装してみましょう：</p>
                            <ol>
                                <li>各フィールド（<code>accountNumber</code>、<code>ownerName</code>、<code>balance</code>）のgetterメソッドを追加</li>
                                <li>各フィールドのsetterメソッドを追加し、適切なデータ検証を行う：
                                    <ul>
                                        <li><code>accountNumber</code>: 6桁の文字列である必要がある</li>
                                        <li><code>ownerName</code>: nullや空文字列は不可</li>
                                        <li><code>balance</code>: 負の値は不可</li>
                                    </ul>
                                </li>
                                <li>コンストラクタ内でもsetterメソッドを使用してデータを設定するように修正</li>
                            </ol>
                        </div>
                    </section>

                    <section id="getters-setters">
                        <h3 class="section-title">3.7 getterとsetterメソッド</h3>
                        <p>getterとsetterメソッドは、カプセル化を実現するための重要な手段です。これらのメソッドを通じて、privateフィールドの値を安全に取得・設定できます。</p>

                        <h4>getterメソッド</h4>
                        <ul>
                            <li>privateフィールドの値を返すメソッド</li>
                            <li>通常、「get」で始まり、続いてフィールド名（先頭大文字）が付きます</li>
                            <li>例: <code>getName()</code>、<code>getAge()</code></li>
                            <li>boolean型のフィールドの場合、「is」で始めることもあります（例: <code>isActive()</code>）</li>
                        </ul>

                        <h4>setterメソッド</h4>
                        <ul>
                            <li>privateフィールドの値を設定するメソッド</li>
                            <li>通常、「set」で始まり、続いてフィールド名（先頭大文字）が付きます</li>
                            <li>例: <code>setName(String name)</code>、<code>setAge(int age)</code></li>
                            <li>パラメータとして新しい値を受け取り、その値の検証を行ってからフィールドに設定します</li>
                        </ul>

                        <h4>getterとsetterの標準的な実装</h4>
                        <code>public class Person {
    private String name;
    private int age;
    private boolean active;
    
    // getterメソッド
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    public boolean isActive() {  // boolean型のgetter
        return active;
    }
    
    // setterメソッド（データ検証あり）
    public void setName(String name) {
        if (name != null && !name.isEmpty()) {
            this.name = name;
        } else {
            System.out.println("エラー: 名前は空にできません。");
        }
    }
    
    public void setAge(int age) {
        if (age >= 0) {
            this.age = age;
        } else {
            System.out.println("エラー: 年齢は負の値にはできません。");
        }
    }
    
    public void setActive(boolean active) {
        this.active = active;
    }
}</code>

                        <h4>getterとsetterを使用したコード例</h4>
                        <code>// Personクラスのオブジェクトを作成
Person person = new Person();

// setterを使ってフィールドに値を設定
person.setName("山田太郎");
person.setAge(25);
person.setActive(true);

// getterを使ってフィールドの値を取得
System.out.println("名前: " + person.getName());
System.out.println("年齢: " + person.getAge());
System.out.println("アクティブ: " + person.isActive());</code>

                        <div class="note">
                            <h5>getterとsetterの利点</h5>
                            <ul>
                                <li><strong>カプセル化</strong>: 内部実装を隠しながら、フィールドへのアクセスを提供します。</li>
                                <li><strong>データ検証</strong>: setterでデータの検証を行うことで、無効な値が設定されるのを防ぎます。</li>
                                <li><strong>柔軟性</strong>: フィールドの内部表現を変更しても、getterとsetterのインターフェースは変更する必要がありません。</li>
                                <li><strong>デバッグ</strong>: データアクセスの集中化により、デバッグが容易になります。</li>
                                <li><strong>計算プロパティ</strong>: getter内で計算した値を返すこともできます（例: <code>getFullName()</code>で名前と姓を結合）。</li>
                            </ul>
                        </div>

                        <h4>読み取り専用と書き込み専用のプロパティ</h4>
                        <ul>
                            <li><strong>読み取り専用プロパティ</strong>: getterのみを提供し、setterは提供しない（例: 生成されたIDなど）</li>
                            <li><strong>書き込み専用プロパティ</strong>: setterのみを提供し、getterは提供しない（例: パスワードなど）</li>
                        </ul>

                        <div class="exercise">
                            <h5>Exercise 3.6: getterとsetterの実装</h5>
                            <p>以下の要件を満たす<code>Product</code>クラスを作成してみましょう：</p>
                            <ol>
                                <li>privateフィールドとして<code>id</code>、<code>name</code>、<code>price</code>、<code>quantity</code>を持つ</li>
                                <li>すべてのフィールドに対するgetterとsetterを実装する</li>
                                <li>setterには適切なデータ検証を追加する（例: priceとquantityは負の値にはできない）</li>
                                <li>読み取り専用の計算プロパティ<code>getTotalValue()</code>を追加する（price × quantityを返す）</li>
                                <li>適切なコンストラクタを追加する</li>
                            </ol>
                            <p>メインメソッドでProductオブジェクトを作成し、getterとsetterを使ってフィールドの値を操作してみましょう。</p>
                        </div>
                    </section>

                    <section id="chapter3-quiz">
                        <h3 class="section-title">3.8 理解度確認テスト</h3>
                        <div class="quiz-container">
                            <h4>第3章の理解度チェック</h4>
                            <p>以下の問題に答えて、第3章の内容の理解度を確認しましょう。</p>
                            
                            <div class="quiz-question">
                                <p><strong>問題1:</strong> 次のうち、オブジェクト指向プログラミングの主な特徴はどれですか？（複数選択可）</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" name="q1" id="q1a" value="a">
                                    <label class="form-check-label" for="q1a">
                                        カプセル化 (Encapsulation)
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" name="q1" id="q1b" value="b">
                                    <label class="form-check-label" for="q1b">
                                        継承 (Inheritance)
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" name="q1" id="q1c" value="c">
                                    <label class="form-check-label" for="q1c">
                                        ポリモーフィズム (Polymorphism)
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" name="q1" id="q1d" value="d">
                                    <label class="form-check-label" for="q1d">
                                        順次実行 (Sequential Execution)
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題2:</strong> クラスとオブジェクトの関係について、最も正しい説明はどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2a" value="a">
                                    <label class="form-check-label" for="q2a">
                                        クラスはオブジェクトから生成される。
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2b" value="b">
                                    <label class="form-check-label" for="q2b">
                                        クラスとオブジェクトは同じものである。
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2c" value="c">
                                    <label class="form-check-label" for="q2c">
                                        クラスはオブジェクトの設計図やテンプレートであり、オブジェクトはクラスから生成されるインスタンスである。
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q2" id="q2d" value="d">
                                    <label class="form-check-label" for="q2d">
                                        オブジェクトは複数のクラスから生成される。
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題3:</strong> 次のうち、Javaのコンストラクタについて正しい説明はどれですか？（複数選択可）</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" name="q3" id="q3a" value="a">
                                    <label class="form-check-label" for="q3a">
                                        コンストラクタ名はクラス名と同じでなければならない。
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" name="q3" id="q3b" value="b">
                                    <label class="form-check-label" for="q3b">
                                        コンストラクタは戻り値の型（voidを含む）を宣言してはいけない。
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" name="q3" id="q3c" value="c">
                                        <label class="form-check-label" for="q3c">
                                        同じクラス内で複数のコンストラクタを定義できる（オーバーロード）。
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" name="q3" id="q3d" value="d">
                                    <label class="form-check-label" for="q3d">
                                        コンストラクタはオブジェクトが破棄されるときに呼び出される。
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題4:</strong> 次のうち、アクセス修飾子<code>private</code>が付いたフィールドまたはメソッドにアクセスできるのはどれですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4a" value="a">
                                    <label class="form-check-label" for="q4a">
                                        同じパッケージ内のすべてのクラス
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4b" value="b">
                                    <label class="form-check-label" for="q4b">
                                        同じクラス内のコードのみ
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4c" value="c">
                                        <label class="form-check-label" for="q4c">
                                        サブクラス（継承したクラス）のコード
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q4" id="q4d" value="d">
                                    <label class="form-check-label" for="q4d">
                                        すべてのクラスからアクセス可能
                                    </label>
                                </div>
                            </div>
                            
                            <div class="quiz-question">
                                <p><strong>問題5:</strong> 次のJavaコードにおいて、カプセル化が正しく実装されているのはどのクラスですか？</p>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5a" value="a">
                                    <label class="form-check-label" for="q5a">
<pre class="bg-light p-2 rounded">
public class User {
    public String username;
    public String password;
    
    public void login() {
        System.out.println(username + " logged in");
    }
}</pre>
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5b" value="b">
                                    <label class="form-check-label" for="q5b">
<pre class="bg-light p-2 rounded">
public class User {
    private String username;
    private String password;
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public void setPassword(String password) {
        this.password = password;
    }
    
    public void login() {
        System.out.println(username + " logged in");
    }
}</pre>
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="q5" id="q5c" value="c">
                                    <label class="form-check-label" for="q5c">
<pre class="bg-light p-2 rounded">
public class User {
    String username;
    String password;
    
    public void login() {
        System.out.println(username + " logged in");
    }
    
    public void setLoginInfo(String username, String password) {
        this.username = username;
        this.password = password;
    }
}</pre>
                                    </label>
                                </div>
                            </div>
                            
                            <button class="btn btn-primary mt-3" id="checkAnswers">回答を確認</button>
                            <div id="quizResults" class="mt-3 d-none">
                                <div class="alert alert-success">
                                    <h5>正解:</h5>
                                    <ol>
                                        <li>a, b, c（カプセル化、継承、ポリモーフィズムがオブジェクト指向の主な特徴）</li>
                                        <li>c（クラスはオブジェクトの設計図やテンプレートであり、オブジェクトはクラスから生成されるインスタンスである）</li>
                                        <li>a, b, c（コンストラクタ名はクラス名と同じ、戻り値の型を宣言しない、オーバーロード可能）</li>
                                        <li>b（privateは同じクラス内のコードからのみアクセス可能）</li>
                                        <li>b（privateフィールドとpublicなgetterとsetterを使用している）</li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="next-steps">
                        <h3 class="section-title">次のステップ</h3>
                        <p>この章では、オブジェクト指向プログラミングの基本概念について学びました。次の章では、これらの概念をさらに発展させ、継承やポリモーフィズムなど、オブジェクト指向プログラミングのより高度なトピックについて学んでいきます。</p>
                        <p>練習問題に取り組み、自分でクラスを作成してみることで、この章で学んだ概念をしっかりと身につけましょう。</p>
                        <div class="note">
                            <h5>推奨される練習プロジェクト</h5>
                            <p>以下のミニプロジェクトに取り組んで、オブジェクト指向プログラミングの概念を実践してみましょう：</p>
                            <ol>
                                <li><strong>図書館管理システム</strong>: 本（Book）、利用者（User）、貸出記録（Lending）などのクラスを作成</li>
                                <li><strong>学生成績管理システム</strong>: 学生（Student）、科目（Subject）、成績（Grade）などのクラスを設計</li>
                                <li><strong>シンプルなバンキングアプリケーション</strong>: 口座（Account）、トランザクション（Transaction）などのクラスを実装</li>
                            </ol>
                        </div>
                    </section>
                </section>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS and Popper.js -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 理解度テストの回答確認ボタンの処理
        document.getElementById('checkAnswers').addEventListener('click', function() {
            document.getElementById('quizResults').classList.remove('d-none');
        });
    </script>
</body>
</html>
