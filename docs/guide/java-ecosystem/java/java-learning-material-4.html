<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java学習教材 第4章 - オブジェクト指向プログラミング応用</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        .navbar {
            background-color: #f57c00;
        }

        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }

        .chapter-title {
            color: #f57c00;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #f57c00;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #ff9800;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        .quiz-container {
            background-color: #fff3e0;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #f57c00;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .nav-link.active {
            background-color: #f57c00 !important;
            color: white !important;
        }

        .concept-card {
            background-color: #f8f9fa;
            border-left: 4px solid #6c757d;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="../../../index.html">Java学習ガイド</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="../README.html">Java生態系ガイド</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
                <div class="position-sticky pt-3">
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="java-learning-material-1.html">第1章: Java基礎</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="java-learning-material-2.html">第2章: Java言語の基本</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="java-learning-material-3.html">第3章: オブジェクト指向入門</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="java-learning-material-4.html">第4章: オブジェクト指向応用</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="java-learning-material-5.html">第5章: Java API基礎</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="java-learning-material-6.html">第6章: 例外処理</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="java-learning-material-7.html">第7章: 入出力操作</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="java-learning-material-8.html">第8章: コレクション応用</a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第4章: オブジェクト指向プログラミング応用</h1>
                </div>

                <div id="chapter4">
                    <h2 class="chapter-title">高度なオブジェクト指向機能を理解する</h2>

                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>継承（inheritance）の概念と実装方法を理解する</li>
                            <li>メソッドオーバーライドとsuperキーワードの使用法を学ぶ</li>
                            <li>ポリモーフィズム（多態性）の仕組みを把握する</li>
                            <li>抽象クラス（abstract class）の設計と活用を習得する</li>
                            <li>インターフェース（interface）の定義と実装方法をマスターする</li>
                            <li>パッケージによる名前空間の管理を理解する</li>
                        </ul>
                    </div>

                    <!-- 4.1 継承 -->
                    <h3 class="section-title">4.1 継承（Inheritance）</h3>
                    <p><strong>継承</strong>は、既存のクラス（親クラス・スーパークラス）の特徴を受け継いで、新しいクラス（子クラス・サブクラス）を作成する仕組みです。コードの再利用性を高め、階層的な設計を可能にします。</p>

                    <div class="concept-card">
                        <h6>現実世界での継承の例</h6>
                        <p><strong>動物</strong>という大きなカテゴリがあり、そこから<strong>哺乳類</strong>、<strong>鳥類</strong>、<strong>魚類</strong>などが派生します。さらに哺乳類からは<strong>犬</strong>、<strong>猫</strong>、<strong>象</strong>などが派生します。</p>
                        <p>動物の共通特徴（生きている、呼吸する、栄養を摂取する）は、すべての動物が持っています。一方で、犬特有の特徴（吠える、尻尾を振る）は犬だけが持っています。</p>
                    </div>

                    <div class="mermaid">
                        classDiagram
                            class Animal {
                                -String name
                                -int age
                                +eat() void
                                +sleep() void
                                +makeSound() void
                            }
                            
                            class Dog {
                                -String breed
                                +bark() void
                                +wagTail() void
                                +makeSound() void
                            }
                            
                            class Cat {
                                -boolean isIndoor
                                +meow() void
                                +purr() void
                                +makeSound() void
                            }
                            
                            Animal <|-- Dog
                            Animal <|-- Cat
                    </div>

                    <h4>Javaにおける継承の構文</h4>
                    <p>Javaでは<code>extends</code>キーワードを使用して継承を実現します：</p>

                    <pre class="code-block"><code class="language-java">// 親クラス（スーパークラス）
public class 親クラス名 {
    // フィールドとメソッドの定義
}

// 子クラス（サブクラス）
public class 子クラス名 extends 親クラス名 {
    // 追加のフィールドとメソッド
    // 親クラスのメソッドをオーバーライド可能
}</code></pre>

                    <!-- 実習 -->
                    <div class="exercise-container">
                        <h5>実習 4-1: 動物クラスの継承階層</h5>
                        <p>動物の継承階層を作成し、継承の基本概念を理解しましょう。</p>

                        <h6>Animal.java（親クラス）</h6>
                        <pre class="code-block"><code class="language-java">public class Animal {
    // 共通の属性
    protected String name;  // protectedで子クラスからアクセス可能
    protected int age;
    protected double weight;
    
    // コンストラクタ
    public Animal(String name, int age, double weight) {
        this.name = name;
        this.age = age;
        this.weight = weight;
        System.out.println("動物「" + name + "」が生まれました");
    }
    
    // 共通のメソッド
    public void eat(String food) {
        System.out.println(name + "は" + food + "を食べています");
        weight += 0.1;  // 体重が少し増える
    }
    
    public void sleep() {
        System.out.println(name + "は眠っています... ZZZ");
    }
    
    public void displayInfo() {
        System.out.println("名前: " + name);
        System.out.println("年齢: " + age + "歳");
        System.out.println("体重: " + weight + "kg");
    }
    
    // 子クラスでオーバーライドされることを想定
    public void makeSound() {
        System.out.println(name + "は何かの音を出しています");
    }
    
    // ゲッター
    public String getName() { return name; }
    public int getAge() { return age; }
    public double getWeight() { return weight; }
}</code></pre>

                        <h6>Dog.java（子クラス）</h6>
                        <pre class="code-block"><code class="language-java">public class Dog extends Animal {
    // Dog特有の属性
    private String breed;  // 犬種
    private boolean isTrained;  // しつけされているかどうか
    
    // コンストラクタ
    public Dog(String name, int age, double weight, String breed) {
        super(name, age, weight);  // 親クラスのコンストラクタ呼び出し
        this.breed = breed;
        this.isTrained = false;
        System.out.println(breed + "の" + name + "です");
    }
    
    // Dog特有のメソッド
    public void bark() {
        System.out.println(name + "は吠えています: ワンワン！");
    }
    
    public void wagTail() {
        System.out.println(name + "は尻尾を振って喜んでいます");
    }
    
    public void fetch(String item) {
        if (isTrained) {
            System.out.println(name + "は" + item + "を取ってきました");
        } else {
            System.out.println(name + "はまだ" + item + "を取ってくることができません");
        }
    }
    
    public void train() {
        isTrained = true;
        System.out.println(name + "のしつけが完了しました");
    }
    
    // 親クラスのメソッドをオーバーライド
    @Override
    public void makeSound() {
        bark();  // Dog特有の鳴き方
    }
    
    // 親クラスのdisplayInfoを拡張
    @Override
    public void displayInfo() {
        super.displayInfo();  // 親クラスのメソッドを呼び出し
        System.out.println("犬種: " + breed);
        System.out.println("しつけ状況: " + (isTrained ? "完了" : "未完了"));
    }
}</code></pre>

                        <h6>Cat.java（子クラス）</h6>
                        <pre class="code-block"><code class="language-java">public class Cat extends Animal {
    // Cat特有の属性
    private boolean isIndoor;   // 室内飼いかどうか
    private int livesLeft;      // 残りの命（猫は9つの命を持つという言い伝えから）
    
    // コンストラクタ
    public Cat(String name, int age, double weight, boolean isIndoor) {
        super(name, age, weight);
        this.isIndoor = isIndoor;
        this.livesLeft = 9;  // 猫は9つの命を持つ
        System.out.println((isIndoor ? "室内飼い" : "外飼い") + "の" + name + "です");
    }
    
    // Cat特有のメソッド
    public void meow() {
        System.out.println(name + "は鳴いています: ニャーニャー");
    }
    
    public void purr() {
        System.out.println(name + "は喉をゴロゴロ鳴らしています");
    }
    
    public void climb() {
        if (isIndoor) {
            System.out.println(name + "はキャットタワーに登っています");
        } else {
            System.out.println(name + "は木に登っています");
        }
    }
    
    public void hunt() {
        if (!isIndoor) {
            System.out.println(name + "は狩りをしています");
        } else {
            System.out.println(name + "はおもちゃで狩りの練習をしています");
        }
    }
    
    // 親クラスのメソッドをオーバーライド
    @Override
    public void makeSound() {
        meow();  // Cat特有の鳴き方
    }
    
    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("飼育環境: " + (isIndoor ? "室内" : "屋外"));
        System.out.println("残りの命: " + livesLeft);
    }
}</code></pre>

                        <h6>テストクラス（AnimalTest.java）</h6>
                        <pre class="code-block"><code class="language-java">public class AnimalTest {
    public static void main(String[] args) {
        System.out.println("=== 動物の生成 ===");
        
        // 各種動物のインスタンス作成
        Dog dog = new Dog("ポチ", 3, 15.5, "柴犬");
        Cat cat = new Cat("タマ", 2, 4.2, true);
        
        System.out.println();
        
        // 基本的な動物の行動
        System.out.println("=== 基本的な行動 ===");
        dog.eat("ドッグフード");
        cat.eat("キャットフード");
        
        dog.sleep();
        cat.sleep();
        
        System.out.println();
        
        // 動物特有の行動
        System.out.println("=== 動物特有の行動 ===");
        dog.bark();
        dog.wagTail();
        
        cat.meow();
        cat.purr();
        cat.climb();
        
        System.out.println();
        
        // オーバーライドされたメソッドの動作確認
        System.out.println("=== 鳴き声の確認 ===");
        dog.makeSound();
        cat.makeSound();
        
        System.out.println();
        
        // しつけと特殊行動
        System.out.println("=== 特殊な行動 ===");
        dog.fetch("ボール");
        dog.train();
        dog.fetch("ボール");
        
        cat.hunt();
        
        System.out.println();
        
        // 情報表示
        System.out.println("=== 動物の詳細情報 ===");
        dog.displayInfo();
        System.out.println();
        cat.displayInfo();
    }
}</code></pre>

                        <h6>期待される実行結果</h6>
                        <pre class="code-block"><code class="language-bash">=== 動物の生成 ===
動物「ポチ」が生まれました
柴犬のポチです
動物「タマ」が生まれました
室内飼いのタマです

=== 基本的な行動 ===
ポチはドッグフードを食べています
タマはキャットフードを食べています
ポチは眠っています... ZZZ
タマは眠っています... ZZZ

=== 動物特有の行動 ===
ポチは吠えています: ワンワン！
ポチは尻尾を振って喜んでいます
タマは鳴いています: ニャーニャー
タマは喉をゴロゴロ鳴らしています
タマはキャットタワーに登っています

=== 鳴き声の確認 ===
ポチは吠えています: ワンワン！
タマは鳴いています: ニャーニャー

=== 特殊な行動 ===
ポチはまだボールを取ってくることができません
ポチのしつけが完了しました
ポチはボールを取ってきました
タマはおもちゃで狩りの練習をしています

=== 動物の詳細情報 ===
名前: ポチ
年齢: 3歳
体重: 15.6kg
犬種: 柴犬
しつけ状況: 完了

名前: タマ
年齢: 2歳
体重: 4.3kg
飼育環境: 室内
残りの命: 9</code></pre>
                    </div>

                    <!-- 4.2 メソッドオーバーライド -->
                    <h3 class="section-title">4.2 メソッドオーバーライド</h3>
                    <p><strong>メソッドオーバーライド</strong>は、子クラスで親クラスのメソッドを再定義する仕組みです。同じメソッド名でありながら、各クラス特有の動作を実現できます。</p>

                    <div class="highlight">
                        <h6>@Overrideアノテーション</h6>
                        <p>Java 5以降、<code>@Override</code>アノテーションを使用することが推奨されています。これにより以下の利点があります：</p>
                        <ul>
                            <li>コンパイラがオーバーライドの正確性をチェック</li>
                            <li>コードの意図を明確化</li>
                            <li>タイプミスによるエラーを防止</li>
                        </ul>
                    </div>

                    <h4>superキーワード</h4>
                    <p><code>super</code>キーワードは、親クラスのメソッドやコンストラクタにアクセスするために使用します：</p>

                    <pre class="code-block"><code class="language-java">public class Child extends Parent {
    @Override
    public void someMethod() {
        super.someMethod();  // 親クラスのメソッドを呼び出し
        // 子クラス独自の処理を追加
    }
}</code></pre>

                    <!-- 4.3 ポリモーフィズム -->
                    <h3 class="section-title">4.3 ポリモーフィズム（多態性）</h3>
                    <p><strong>ポリモーフィズム</strong>は、同じインターフェースで異なる実装を持つオブジェクトを統一的に扱える仕組みです。親クラス型の変数で子クラスのオブジェクトを参照し、実行時に適切なメソッドが呼び出されます。</p>

                    <div class="concept-card">
                        <h6>ポリモーフィズムの利点</h6>
                        <ul>
                            <li><strong>コードの柔軟性</strong>：新しいクラスを追加してもメインコードの変更が不要</li>
                            <li><strong>保守性の向上</strong>：共通のインターフェースで統一的な処理が可能</li>
                            <li><strong>拡張性</strong>：機能を追加しやすい設計</li>
                        </ul>
                    </div>

                    <!-- 実習 -->
                    <div class="exercise-container">
                        <h5>実習 4-2: ポリモーフィズムの実践</h5>
                        <p>動物園管理システムでポリモーフィズムの威力を実感しましょう。</p>

                        <pre class="code-block"><code class="language-java">public class Zoo {
    private Animal[] animals;  // 親クラス型の配列
    private int animalCount;
    
    public Zoo(int capacity) {
        animals = new Animal[capacity];
        animalCount = 0;
    }
    
    // 動物を追加（どんな動物でも受け入れ可能）
    public void addAnimal(Animal animal) {
        if (animalCount < animals.length) {
            animals[animalCount] = animal;
            animalCount++;
            System.out.println(animal.getName() + "を動物園に迎えました");
        } else {
            System.out.println("動物園の定員が満員です");
        }
    }
    
    // すべての動物の情報を表示
    public void showAllAnimals() {
        System.out.println("=== 動物園の動物一覧 ===");
        for (int i = 0; i < animalCount; i++) {
            System.out.println((i + 1) + ". " + animals[i].getName());
            animals[i].displayInfo();
            System.out.println();
        }
    }
    
    // すべての動物に餌をあげる
    public void feedAllAnimals(String food) {
        System.out.println("=== 餌やりの時間 ===");
        for (int i = 0; i < animalCount; i++) {
            animals[i].eat(food);
        }
    }
    
    // すべての動物の鳴き声を聞く（ポリモーフィズムの代表例）
    public void hearAllSounds() {
        System.out.println("=== 動物たちの鳴き声 ===");
        for (int i = 0; i < animalCount; i++) {
            animals[i].makeSound();  // 各動物の実際の型に応じたメソッドが呼ばれる
        }
    }
    
    // 特定の型の動物だけに特殊な行動をさせる
    public void performSpecialActions() {
        System.out.println("=== 特殊な行動 ===");
        for (int i = 0; i < animalCount; i++) {
            // instanceof演算子で実際の型をチェック
            if (animals[i] instanceof Dog) {
                Dog dog = (Dog) animals[i];  // ダウンキャスト
                dog.wagTail();
                dog.fetch("ボール");
            } else if (animals[i] instanceof Cat) {
                Cat cat = (Cat) animals[i];  // ダウンキャスト
                cat.purr();
                cat.climb();
            }
        }
    }
    
    public int getAnimalCount() {
        return animalCount;
    }
}</code></pre>

                        <h6>ZooTest.java</h6>
                        <pre class="code-block"><code class="language-java">public class ZooTest {
    public static void main(String[] args) {
        // 動物園を作成
        Zoo zoo = new Zoo(5);
        
        // 様々な動物を追加
        zoo.addAnimal(new Dog("ハチ", 5, 20.0, "秋田犬"));
        zoo.addAnimal(new Cat("ミケ", 3, 4.5, true));
        zoo.addAnimal(new Dog("コロ", 2, 8.0, "ダックスフント"));
        zoo.addAnimal(new Cat("シロ", 4, 5.2, false));
        
        System.out.println();
        
        // 動物園の状況確認
        zoo.showAllAnimals();
        
        // ポリモーフィズムの実演
        zoo.feedAllAnimals("特製フード");
        
        System.out.println();
        
        zoo.hearAllSounds();
        
        System.out.println();
        
        zoo.performSpecialActions();
        
        System.out.println();
        
        // 統計情報
        System.out.println("動物園には現在 " + zoo.getAnimalCount() + " 頭の動物がいます");
        
        // ポリモーフィズムの別の例：メソッドの引数として親クラス型を受け取る
        System.out.println("\n=== 獣医の診察 ===");
        Veterinarian vet = new Veterinarian("田中獣医師");
        
        for (int i = 0; i < zoo.getAnimalCount(); i++) {
            // どんな動物でも診察可能
            vet.examine(zoo.animals[i]);
        }
    }
}

// 獣医クラス（ポリモーフィズムの活用例）
class Veterinarian {
    private String name;
    
    public Veterinarian(String name) {
        this.name = name;
    }
    
    // Animal型の引数を受け取る（どんな動物でも診察可能）
    public void examine(Animal animal) {
        System.out.println(name + "が" + animal.getName() + "を診察しています");
        animal.makeSound();  // 動物の様子を確認
        System.out.println("診察完了: " + animal.getName() + "は健康です");
    }
}</code></pre>
                    </div>

                    <!-- 4.4 抽象クラス -->
                    <h3 class="section-title">4.4 抽象クラス（Abstract Class）</h3>
                    <p><strong>抽象クラス</strong>は、インスタンス化できないクラスで、他のクラスに継承されることを前提として設計されます。共通の機能を提供しつつ、具体的な実装を子クラスに委ねることができます。</p>

                    <div class="concept-card">
                        <h6>抽象クラスの特徴</h6>
                        <ul>
                            <li><strong>abstractキーワード</strong>で定義</li>
                            <li><strong>インスタンス化不可</strong>：直接newでオブジェクトを作成できない</li>
                            <li><strong>抽象メソッド</strong>：実装を持たず、子クラスでの実装を強制</li>
                            <li><strong>具象メソッド</strong>：通常のメソッドも定義可能</li>
                            <li><strong>コンストラクタ</strong>：持てるが、子クラスから呼び出される</li>
                        </ul>
                    </div>

                    <!-- 実習 -->
                    <div class="exercise-container">
                        <h5>実習 4-3: 図形描画システムの抽象クラス設計</h5>
                        <p>図形を描画するシステムで抽象クラスの活用方法を学びましょう。</p>

                        <pre class="code-block"><code class="language-java">// 抽象クラス：図形の基底クラス
public abstract class Shape {
    protected String color;
    protected double x, y;  // 図形の位置
    
    // コンストラクタ
    public Shape(String color, double x, double y) {
        this.color = color;
        this.x = x;
        this.y = y;
        System.out.println(color + "の図形を位置(" + x + ", " + y + ")に配置");
    }
    
    // 具象メソッド：すべての図形で共通の処理
    public void move(double deltaX, double deltaY) {
        x += deltaX;
        y += deltaY;
        System.out.println(color + "の図形を(" + x + ", " + y + ")に移動");
    }
    
    public void setColor(String color) {
        System.out.println("色を" + this.color + "から" + color + "に変更");
        this.color = color;
    }
    
    public void displayPosition() {
        System.out.println("現在位置: (" + x + ", " + y + ")");
    }
    
    // 抽象メソッド：子クラスで必ず実装が必要
    public abstract double calculateArea();      // 面積計算
    public abstract double calculatePerimeter(); // 周囲長計算  
    public abstract void draw();                 // 描画処理
    public abstract void resize(double factor);  // サイズ変更
    
    // getterメソッド
    public String getColor() { return color; }
    public double getX() { return x; }
    public double getY() { return y; }
}</code></pre>

                        <h6>Circle.java（円クラス）</h6>
                        <pre class="code-block"><code class="language-java">public class Circle extends Shape {
    private double radius;
    
    public Circle(String color, double x, double y, double radius) {
        super(color, x, y);  // 抽象クラスのコンストラクタ呼び出し
        this.radius = radius;
        System.out.println("半径" + radius + "の円を作成");
    }
    
    // 抽象メソッドの実装
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }
    
    @Override
    public void draw() {
        System.out.println("位置(" + x + ", " + y + ")に" + color + 
                          "の円（半径" + radius + "）を描画中...");
        System.out.println("  ○");
    }
    
    @Override
    public void resize(double factor) {
        double oldRadius = radius;
        radius *= factor;
        System.out.println("円のサイズを" + factor + "倍に変更: " +
                          "半径" + oldRadius + " → " + radius);
    }
    
    // Circle特有のメソッド
    public double getDiameter() {
        return radius * 2;
    }
    
    public double getRadius() {
        return radius;
    }
}</code></pre>

                        <h6>Rectangle.java（長方形クラス）</h6>
                        <pre class="code-block"><code class="language-java">public class Rectangle extends Shape {
    private double width;
    private double height;
    
    public Rectangle(String color, double x, double y, double width, double height) {
        super(color, x, y);
        this.width = width;
        this.height = height;
        System.out.println("幅" + width + "×高さ" + height + "の長方形を作成");
    }
    
    // 抽象メソッドの実装
    @Override
    public double calculateArea() {
        return width * height;
    }
    
    @Override
    public double calculatePerimeter() {
        return 2 * (width + height);
    }
    
    @Override
    public void draw() {
        System.out.println("位置(" + x + ", " + y + ")に" + color + 
                          "の長方形（" + width + "×" + height + "）を描画中...");
        System.out.println("  ■");
    }
    
    @Override
    public void resize(double factor) {
        double oldWidth = width, oldHeight = height;
        width *= factor;
        height *= factor;
        System.out.println("長方形のサイズを" + factor + "倍に変更: " +
                          oldWidth + "×" + oldHeight + " → " + width + "×" + height);
    }
    
    // Rectangle特有のメソッド
    public boolean isSquare() {
        return Math.abs(width - height) < 0.001;  // 浮動小数点の比較
    }
    
    public double getWidth() { return width; }
    public double getHeight() { return height; }
}</code></pre>

                        <h6>ShapeTest.java（テストクラス）</h6>
                        <pre class="code-block"><code class="language-java">public class ShapeTest {
    public static void main(String[] args) {
        System.out.println("=== 図形の作成 ===");
        
        // 各種図形を作成
        Circle circle = new Circle("赤", 10, 20, 5);
        Rectangle rectangle = new Rectangle("青", 30, 40, 8, 6);
        Rectangle square = new Rectangle("緑", 50, 60, 7, 7);
        
        // 抽象クラス型の配列でポリモーフィズムを実現
        Shape[] shapes = {circle, rectangle, square};
        
        System.out.println("\n=== 図形の描画 ===");
        for (Shape shape : shapes) {
            shape.draw();
        }
        
        System.out.println("\n=== 図形の情報 ===");
        for (int i = 0; i < shapes.length; i++) {
            Shape shape = shapes[i];
            System.out.println("図形 " + (i + 1) + ":");
            System.out.println("  面積: " + String.format("%.2f", shape.calculateArea()));
            System.out.println("  周囲長: " + String.format("%.2f", shape.calculatePerimeter()));
            shape.displayPosition();
            
            // 特定の型に対する特別な処理
            if (shape instanceof Rectangle) {
                Rectangle rect = (Rectangle) shape;
                if (rect.isSquare()) {
                    System.out.println("  この長方形は正方形です");
                }
            }
            
            System.out.println();
        }
        
        System.out.println("=== 図形の操作 ===");
        
        // 移動
        circle.move(5, -3);
        rectangle.setColor("黄");
        
        // サイズ変更
        circle.resize(1.5);
        square.resize(0.8);
        
        System.out.println("\n=== 変更後の描画 ===");
        for (Shape shape : shapes) {
            shape.draw();
        }
        
        // 抽象クラスはインスタンス化できないことを確認
        // Shape shape = new Shape("色", 0, 0);  // コンパイルエラー
        
        System.out.println("\n=== 図形工場（Factory Pattern的な使用例） ===");
        ShapeFactory factory = new ShapeFactory();
        Shape randomShape = factory.createRandomShape();
        randomShape.draw();
        System.out.println("面積: " + randomShape.calculateArea());
    }
}

// 図形ファクトリクラス（抽象クラスの活用例）
class ShapeFactory {
    public Shape createRandomShape() {
        double random = Math.random();
        
        if (random < 0.5) {
            return new Circle("ランダム色", Math.random() * 100, Math.random() * 100, 
                            Math.random() * 10 + 1);
        } else {
            return new Rectangle("ランダム色", Math.random() * 100, Math.random() * 100,
                               Math.random() * 10 + 1, Math.random() * 10 + 1);
        }
    }
}</code></pre>
                    </div>

                    <!-- 4.5 インターフェース -->
                    <h3 class="section-title">4.5 インターフェース（Interface）</h3>
                    <p><strong>インターフェース</strong>は、クラスが実装すべきメソッドの「契約」を定義する仕組みです。多重継承の代替手段として使われ、異なるクラス階層間での共通の操作を定義できます。</p>

                    <div class="mermaid">
                        graph TD
                            A[インターフェース: Drawable] --> B[draw メソッド]
                            A --> C[setColor メソッド]
                            
                            D[クラス: Circle] --> E[implements Drawable]
                            F[クラス: Square] --> G[implements Drawable]
                            H[クラス: Text] --> I[implements Drawable]
                            
                            E --> J[draw実装]
                            G --> K[draw実装]
                            I --> L[draw実装]
                    </div>

                    <h4>インターフェースの特徴</h4>
                    <ul>
                        <li><strong>抽象メソッドのみ</strong>：Java 8以前は実装を持てない（Java 8以降はdefaultメソッド可能）</li>
                        <li><strong>多重実装</strong>：一つのクラスが複数のインターフェースを実装可能</li>
                        <li><strong>public static final</strong>：定数のみ定義可能</li>
                        <li><strong>implementsキーワード</strong>：インターフェースの実装を宣言</li>
                    </ul>

                    <!-- 章のまとめ -->
                    <h3 class="section-title">章のまとめ</h3>
                    <p>この章では、オブジェクト指向プログラミングの高度な概念について学習しました：</p>

                    <ul>
                        <li><strong>継承</strong>：既存クラスの特徴を受け継ぐコードの再利用メカニズム</li>
                        <li><strong>メソッドオーバーライド</strong>：親クラスのメソッドを子クラスで再定義する仕組み</li>
                        <li><strong>ポリモーフィズム</strong>：同じインターフェースで異なる実装を統一的に扱う多態性</li>
                        <li><strong>抽象クラス</strong>：共通機能と強制実装を組み合わせた設計手法</li>
                        <li><strong>インターフェース</strong>：実装すべき操作の契約を定義する仕組み</li>
                    </ul>

                    <div class="highlight">
                        <h6>次章への準備</h6>
                        <p>次章では、Javaの標準ライブラリ（Java API）の基本的な使用方法について学習します。String操作、数値処理、日付時間処理、そしてコレクションフレームワークなど、実用的なプログラム開発に不可欠な要素を習得していきます。</p>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="java-learning-material-3.html" class="btn btn-secondary">← 前の章: オブジェクト指向入門</a>
                        <a href="java-learning-material-5.html" class="btn btn-primary">次の章: Java API基礎 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>

    <!-- Mermaid.js 初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>