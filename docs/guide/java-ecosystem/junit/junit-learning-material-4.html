<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JUnit学習教材 第4章 - テストライフサイクルとアノテーション</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }

        /* ナビゲーション */
        .navbar {
            background-color: #f57c00;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }

        /* タイトル */
        .chapter-title {
            color: #f57c00;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #f57c00;
            padding-bottom: 0.5rem;
        }

        .section-title {
            color: #ff9800;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #fff3e0;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #f57c00;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #f57c00 !important;
            color: white !important;
        }

        /* プリフォーマット */
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 1rem;
            overflow-x: auto;
        }

        code {
            background-color: #f8f9fa;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.875em;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">JUnit学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="../../../README.md">ホーム</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="README.md">JUnitガイド</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
                <div class="position-sticky pt-3">
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-1.html">第1章: JUnit基礎とセットアップ</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-2.html">第2章: 基本的なテストケース</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-3.html">第3章: アサーションとマッチャー</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="#chapter4">第4章: テストライフサイクル</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-5.html">第5章: パラメータ化テスト</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-6.html">第6章: 例外テストとタイムアウト</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-7.html">第7章: テストの組織化</a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第4章: テストライフサイクルとアノテーション</h1>
                </div>

                <div id="chapter4">
                    <h2 class="chapter-title">テストの前処理・後処理とライフサイクル管理</h2>
                    
                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>@BeforeEach、@AfterEachアノテーションの使用方法</li>
                            <li>@BeforeAll、@AfterAllアノテーションの使用方法</li>
                            <li>テストライフサイクルの実行順序</li>
                            <li>テストインスタンスの管理と@TestInstanceアノテーション</li>
                            <li>リソース管理のベストプラクティス</li>
                            <li>テストクラスの継承とライフサイクルメソッド</li>
                        </ul>
                    </div>

                    <h3 class="section-title">4.1 テストライフサイクルの概要</h3>
                    <p>JUnit 5では、テストの実行前後に特定の処理を行うためのライフサイクルアノテーションが提供されています。</p>
                    
                    <h4>ライフサイクルアノテーションの種類</h4>
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>アノテーション</th>
                                <th>実行タイミング</th>
                                <th>用途</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>@BeforeAll</td>
                                <td>クラス内の全テスト実行前（1回）</td>
                                <td>重い初期化処理、DB接続設定</td>
                            </tr>
                            <tr>
                                <td>@BeforeEach</td>
                                <td>各テストメソッド実行前</td>
                                <td>テストデータ準備、オブジェクト初期化</td>
                            </tr>
                            <tr>
                                <td>@AfterEach</td>
                                <td>各テストメソッド実行後</td>
                                <td>リソースクリーンアップ、状態リセット</td>
                            </tr>
                            <tr>
                                <td>@AfterAll</td>
                                <td>クラス内の全テスト実行後（1回）</td>
                                <td>リソース解放、接続クローズ</td>
                            </tr>
                        </tbody>
                    </table>

                    <!-- 実習1 -->
                    <div class="exercise-container">
                        <h5>実習 4-1: 基本的なライフサイクルメソッドの実装</h5>
                        <p>データベース操作をシミュレートするクラスで、ライフサイクルメソッドを実装します。</p>
                        <h6>手順</h6>
                        <ol>
                            <li>DatabaseServiceクラスを作成</li>
                            <li>各ライフサイクルアノテーションを使用</li>
                            <li>実行順序を確認</li>
                        </ol>
                        <h6>実行例</h6>
                        <p><strong>DatabaseService.java</strong></p>
                        <pre><code>import java.util.*;

public class DatabaseService {
    private List&lt;String&gt; records;
    private boolean connected;
    
    public void connect() {
        connected = true;
        System.out.println("Database connected");
    }
    
    public void disconnect() {
        connected = false;
        System.out.println("Database disconnected");
    }
    
    public void initializeData() {
        records = new ArrayList&lt;&gt;();
        records.add("record1");
        records.add("record2");
        System.out.println("Test data initialized");
    }
    
    public void clearData() {
        if (records != null) {
            records.clear();
        }
        System.out.println("Test data cleared");
    }
    
    public void addRecord(String record) {
        if (!connected) {
            throw new IllegalStateException("Database not connected");
        }
        records.add(record);
    }
    
    public List&lt;String&gt; getAllRecords() {
        if (!connected) {
            throw new IllegalStateException("Database not connected");
        }
        return new ArrayList&lt;&gt;(records);
    }
    
    public boolean isConnected() {
        return connected;
    }
}</code></pre>
                        <p><strong>DatabaseServiceTest.java</strong></p>
                        <pre><code>import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import java.util.List;

class DatabaseServiceTest {
    
    private static DatabaseService dbService;
    
    @BeforeAll
    static void setUpClass() {
        System.out.println("=== Test Class Setup ===");
        dbService = new DatabaseService();
        dbService.connect();
    }
    
    @AfterAll
    static void tearDownClass() {
        System.out.println("=== Test Class Cleanup ===");
        dbService.disconnect();
    }
    
    @BeforeEach
    void setUp() {
        System.out.println("--- Test Method Setup ---");
        dbService.initializeData();
    }
    
    @AfterEach
    void tearDown() {
        System.out.println("--- Test Method Cleanup ---");
        dbService.clearData();
    }
    
    @Test
    @DisplayName("レコード追加のテスト")
    void shouldAddRecord() {
        System.out.println("Executing: shouldAddRecord");
        
        dbService.addRecord("new record");
        List&lt;String&gt; records = dbService.getAllRecords();
        
        assertEquals(3, records.size());
        assertTrue(records.contains("new record"));
    }
    
    @Test
    @DisplayName("全レコード取得のテスト")
    void shouldGetAllRecords() {
        System.out.println("Executing: shouldGetAllRecords");
        
        List&lt;String&gt; records = dbService.getAllRecords();
        
        assertEquals(2, records.size());
        assertTrue(records.contains("record1"));
        assertTrue(records.contains("record2"));
    }
    
    @Test
    @DisplayName("接続状態確認のテスト")
    void shouldBeConnected() {
        System.out.println("Executing: shouldBeConnected");
        
        assertTrue(dbService.isConnected());
    }
}</code></pre>
                        <h6>期待される結果</h6>
                        <p>コンソール出力で実行順序が確認でき、各テストが独立して実行されることが分かります。</p>
                    </div>

                    <h3 class="section-title">4.2 @TestInstanceアノテーションとインスタンス管理</h3>
                    <p>デフォルトでは、JUnitは各テストメソッドごとに新しいテストクラスインスタンスを作成します。</p>

                    <h4>テストインスタンスのライフサイクル</h4>
                    <ul>
                        <li><strong>PER_METHOD（デフォルト）</strong>: テストメソッドごとに新しいインスタンス</li>
                        <li><strong>PER_CLASS</strong>: テストクラスごとに1つのインスタンス</li>
                    </ul>

                    <!-- 実習2 -->
                    <div class="exercise-container">
                        <h5>実習 4-2: テストインスタンス管理の比較</h5>
                        <p>PER_METHODとPER_CLASSの違いを実際に確認します。</p>
                        <h6>手順</h6>
                        <ol>
                            <li>デフォルト（PER_METHOD）でのテスト作成</li>
                            <li>@TestInstance(PER_CLASS)での同じテスト作成</li>
                            <li>インスタンス変数の状態変化を確認</li>
                        </ol>
                        <h6>実行例</h6>
                        <p><strong>PerMethodTest.java（デフォルト）</strong></p>
                        <pre><code>import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

class PerMethodTest {
    
    private int counter = 0;
    
    @BeforeEach
    void setUp() {
        counter++;
        System.out.println("PerMethod - setUp: counter = " + counter + 
                          ", instance = " + this.hashCode());
    }
    
    @Test
    void firstTest() {
        System.out.println("PerMethod - firstTest: counter = " + counter);
        assertEquals(1, counter);
    }
    
    @Test
    void secondTest() {
        System.out.println("PerMethod - secondTest: counter = " + counter);
        assertEquals(1, counter); // 常に1になる
    }
    
    @Test
    void thirdTest() {
        System.out.println("PerMethod - thirdTest: counter = " + counter);
        assertEquals(1, counter); // 常に1になる
    }
}</code></pre>
                        <p><strong>PerClassTest.java</strong></p>
                        <pre><code>import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class PerClassTest {
    
    private int counter = 0;
    
    @BeforeAll
    void setUpClass() {
        System.out.println("PerClass - setUpClass: instance = " + this.hashCode());
    }
    
    @BeforeEach
    void setUp() {
        counter++;
        System.out.println("PerClass - setUp: counter = " + counter + 
                          ", instance = " + this.hashCode());
    }
    
    @Test
    void firstTest() {
        System.out.println("PerClass - firstTest: counter = " + counter);
        assertEquals(1, counter);
    }
    
    @Test
    void secondTest() {
        System.out.println("PerClass - secondTest: counter = " + counter);
        assertEquals(2, counter); // 2になる
    }
    
    @Test
    void thirdTest() {
        System.out.println("PerClass - thirdTest: counter = " + counter);
        assertEquals(3, counter); // 3になる
    }
    
    @AfterAll
    void tearDownClass() {
        System.out.println("PerClass - tearDownClass: final counter = " + counter);
    }
}</code></pre>
                        <h6>期待される結果</h6>
                        <p>PER_METHODでは毎回新しいインスタンス、PER_CLASSでは同じインスタンスが使用されることが確認できます。</p>
                    </div>

                    <h3 class="section-title">4.3 リソース管理のベストプラクティス</h3>
                    <p>テストでのリソース管理は、テストの独立性と信頼性を確保するために重要です。</p>

                    <div class="warning">
                        <h6>リソース管理の注意点</h6>
                        <ul>
                            <li>ファイル、データベース接続、ネットワーク接続は必ず適切にクローズする</li>
                            <li>テスト間でのデータ汚染を避けるため、各テスト後に状態をリセット</li>
                            <li>重いリソースは@BeforeAll/@AfterAllで管理し、軽いリソースは@BeforeEach/@AfterEachで管理</li>
                        </ul>
                    </div>

                    <!-- 実習3 -->
                    <div class="exercise-container">
                        <h5>実習 4-3: ファイル操作とリソース管理</h5>
                        <p>一時ファイルを使用するテストで、適切なリソース管理を実装します。</p>
                        <h6>手順</h6>
                        <ol>
                            <li>FileManagerクラスを作成</li>
                            <li>一時ファイルの作成と削除を管理</li>
                            <li>例外が発生してもリソースが適切に解放されることを確認</li>
                        </ol>
                        <h6>実行例</h6>
                        <p><strong>FileManager.java</strong></p>
                        <pre><code>import java.io.*;
import java.nio.file.*;

public class FileManager {
    
    public void writeToFile(Path filePath, String content) throws IOException {
        Files.write(filePath, content.getBytes());
    }
    
    public String readFromFile(Path filePath) throws IOException {
        return Files.readString(filePath);
    }
    
    public boolean fileExists(Path filePath) {
        return Files.exists(filePath);
    }
    
    public long getFileSize(Path filePath) throws IOException {
        return Files.size(filePath);
    }
    
    public void deleteFile(Path filePath) throws IOException {
        Files.deleteIfExists(filePath);
    }
}</code></pre>
                        <p><strong>FileManagerTest.java</strong></p>
                        <pre><code>import org.junit.jupiter.api.*;
import org.junit.jupiter.api.io.TempDir;
import static org.junit.jupiter.api.Assertions.*;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;

class FileManagerTest {
    
    private static FileManager fileManager;
    
    @TempDir
    static Path tempDir; // JUnit 5の一時ディレクトリ機能
    
    private Path testFile;
    
    @BeforeAll
    static void setUpClass() {
        fileManager = new FileManager();
        System.out.println("Temp directory: " + tempDir);
    }
    
    @BeforeEach
    void setUp() {
        // 各テストで一意のファイル名を使用
        testFile = tempDir.resolve("test-" + System.nanoTime() + ".txt");
        System.out.println("Test file: " + testFile);
    }
    
    @AfterEach
    void tearDown() {
        // テスト後のクリーンアップ
        try {
            fileManager.deleteFile(testFile);
            System.out.println("Cleaned up: " + testFile);
        } catch (IOException e) {
            System.err.println("Cleanup failed: " + e.getMessage());
        }
    }
    
    @Test
    @DisplayName("ファイル書き込みと読み込みのテスト")
    void shouldWriteAndReadFile() throws IOException {
        String content = "Hello, JUnit 5!";
        
        fileManager.writeToFile(testFile, content);
        
        assertTrue(fileManager.fileExists(testFile));
        assertEquals(content, fileManager.readFromFile(testFile));
        assertTrue(fileManager.getFileSize(testFile) &gt; 0);
    }
    
    @Test
    @DisplayName("存在しないファイルの処理テスト")
    void shouldHandleNonExistentFile() {
        Path nonExistentFile = tempDir.resolve("non-existent.txt");
        
        assertFalse(fileManager.fileExists(nonExistentFile));
        assertThrows(IOException.class, () -&gt; {
            fileManager.readFromFile(nonExistentFile);
        });
    }
    
    @Test
    @DisplayName("ファイル削除のテスト")
    void shouldDeleteFile() throws IOException {
        String content = "Temporary content";
        fileManager.writeToFile(testFile, content);
        
        assertTrue(fileManager.fileExists(testFile));
        
        fileManager.deleteFile(testFile);
        
        assertFalse(fileManager.fileExists(testFile));
    }
}</code></pre>
                        <h6>期待される結果</h6>
                        <p>一時ファイルが適切に作成・削除され、テスト間でファイルが残らないことが確認できます。</p>
                    </div>

                    <h3 class="section-title">4.4 テストクラスの継承とライフサイクル</h3>
                    <p>テストクラスを継承する場合のライフサイクルメソッドの動作を理解しましょう。</p>

                    <!-- 実習4 -->
                    <div class="exercise-container">
                        <h5>実習 4-4: 継承階層でのライフサイクル</h5>
                        <p>基底テストクラスと具象テストクラスでのライフサイクル実行順序を確認します。</p>
                        <h6>手順</h6>
                        <ol>
                            <li>基底テストクラスにライフサイクルメソッドを定義</li>
                            <li>継承したテストクラスでもライフサイクルメソッドを定義</li>
                            <li>実行順序を確認</li>
                        </ol>
                        <h6>実行例</h6>
                        <p><strong>BaseServiceTest.java</strong></p>
                        <pre><code>import org.junit.jupiter.api.*;

abstract class BaseServiceTest {
    
    protected String serviceName;
    
    @BeforeAll
    static void baseSetUpClass() {
        System.out.println("Base: @BeforeAll executed");
    }
    
    @AfterAll
    static void baseTearDownClass() {
        System.out.println("Base: @AfterAll executed");
    }
    
    @BeforeEach
    void baseSetUp() {
        System.out.println("Base: @BeforeEach executed");
        serviceName = "BaseService";
    }
    
    @AfterEach
    void baseTearDown() {
        System.out.println("Base: @AfterEach executed");
        serviceName = null;
    }
    
    @Test
    void baseTest() {
        System.out.println("Base: baseTest executed with service: " + serviceName);
        Assertions.assertNotNull(serviceName);
    }
}</code></pre>
                        <p><strong>UserServiceTest.java</strong></p>
                        <pre><code>import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

class UserServiceTest extends BaseServiceTest {
    
    private UserService userService;
    
    @BeforeAll
    static void setUpClass() {
        System.out.println("UserService: @BeforeAll executed");
    }
    
    @AfterAll
    static void tearDownClass() {
        System.out.println("UserService: @AfterAll executed");
    }
    
    @BeforeEach
    void setUp() {
        System.out.println("UserService: @BeforeEach executed");
        userService = new UserService();
        serviceName = "UserService"; // 基底クラスの変数を上書き
    }
    
    @AfterEach
    void tearDown() {
        System.out.println("UserService: @AfterEach executed");
        userService = null;
    }
    
    @Test
    @DisplayName("ユーザーサービスのテスト")
    void shouldCreateUserService() {
        System.out.println("UserService: shouldCreateUserService executed");
        
        assertNotNull(userService);
        assertEquals("UserService", serviceName);
    }
    
    @Test
    @DisplayName("継承されたテストメソッド実行確認")
    void shouldExecuteInheritedTest() {
        System.out.println("UserService: shouldExecuteInheritedTest executed");
        
        // 基底クラスのbaseTest()も実行される
        assertEquals("UserService", serviceName);
    }
}

class UserService {
    // シンプルなサービスクラス
}</code></pre>
                        <h6>期待される結果</h6>
                        <p>継承階層での実行順序：基底クラス@BeforeAll → 子クラス@BeforeAll → 基底クラス@BeforeEach → 子クラス@BeforeEach → テスト実行 → 子クラス@AfterEach → 基底クラス@AfterEach → 子クラス@AfterAll → 基底クラス@AfterAll</p>
                    </div>

                    <h3 class="section-title">4.5 パフォーマンス考慮事項</h3>
                    <p>ライフサイクルメソッドの適切な使い分けにより、テスト実行時間を最適化できます。</p>

                    <h4>最適化のガイドライン</h4>
                    <ul>
                        <li><strong>重い処理は@BeforeAll/@AfterAll</strong>: データベース接続、大きなファイル読み込み</li>
                        <li><strong>軽い処理は@BeforeEach/@AfterEach</strong>: オブジェクト初期化、変数リセット</li>
                        <li><strong>テストの独立性を優先</strong>: パフォーマンスよりも正確性を重視</li>
                    </ul>

                    <!-- 実習5 -->
                    <div class="exercise-container">
                        <h5>実習 4-5: パフォーマンス測定と最適化</h5>
                        <p>重い初期化処理を含むテストで、適切なライフサイクル管理によるパフォーマンス改善を確認します。</p>
                        <h6>手順</h6>
                        <ol>
                            <li>重い処理をシミュレート</li>
                            <li>不適切な配置（@BeforeEach）でのテスト実行</li>
                            <li>適切な配置（@BeforeAll）での改善確認</li>
                        </ol>
                        <h6>実行例</h6>
                        <pre><code>import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class PerformanceOptimizedTest {
    
    private static final int HEAVY_OPERATION_DELAY = 1000; // 1秒
    private List&lt;String&gt; heavyData;
    private long startTime;
    
    @BeforeAll
    void setUpHeavyResource() {
        System.out.println("Setting up heavy resource...");
        startTime = System.currentTimeMillis();
        
        // 重い処理をシミュレート
        try {
            Thread.sleep(HEAVY_OPERATION_DELAY);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // 大量のテストデータを作成
        heavyData = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10000; i++) {
            heavyData.add("data-" + i);
        }
        
        long elapsed = System.currentTimeMillis() - startTime;
        System.out.println("Heavy resource setup completed in " + elapsed + "ms");
    }
    
    @BeforeEach
    void setUp() {
        System.out.println("Light setup for test method");
        // 軽い前処理のみ
    }
    
    @Test
    @DisplayName("データ検索テスト1")
    void shouldFindDataQuickly1() {
        long testStart = System.currentTimeMillis();
        
        assertTrue(heavyData.contains("data-5000"));
        assertEquals(10000, heavyData.size());
        
        long testElapsed = System.currentTimeMillis() - testStart;
        System.out.println("Test 1 completed in " + testElapsed + "ms");
    }
    
    @Test
    @DisplayName("データ検索テスト2")
    void shouldFindDataQuickly2() {
        long testStart = System.currentTimeMillis();
        
        assertTrue(heavyData.contains("data-7500"));
        assertFalse(heavyData.contains("non-existent"));
        
        long testElapsed = System.currentTimeMillis() - testStart;
        System.out.println("Test 2 completed in " + testElapsed + "ms");
    }
    
    @Test
    @DisplayName("データ検索テスト3")
    void shouldFindDataQuickly3() {
        long testStart = System.currentTimeMillis();
        
        String firstItem = heavyData.get(0);
        String lastItem = heavyData.get(heavyData.size() - 1);
        
        assertEquals("data-0", firstItem);
        assertEquals("data-9999", lastItem);
        
        long testElapsed = System.currentTimeMillis() - testStart;
        System.out.println("Test 3 completed in " + testElapsed + "ms");
    }
    
    @AfterAll
    void tearDownHeavyResource() {
        long totalElapsed = System.currentTimeMillis() - startTime;
        System.out.println("All tests completed in " + totalElapsed + "ms");
        heavyData = null;
    }
}</code></pre>
                        <h6>期待される結果</h6>
                        <p>重い初期化処理が1回だけ実行され、全体的なテスト実行時間が大幅に短縮されることが確認できます。</p>
                    </div>

                    <!-- 理解度確認 -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>@BeforeAllと@BeforeEachの実行タイミングと用途の違いを説明してください。</li>
                            <li>@TestInstance(TestInstance.Lifecycle.PER_CLASS)を使用する利点は何ですか？</li>
                            <li>テスト継承階層でのライフサイクルメソッドの実行順序を説明してください。</li>
                            <li>リソース管理で@AfterEachメソッドが重要な理由は何ですか？</li>
                            <li>重い初期化処理は@BeforeAllと@BeforeEachのどちらに配置すべきですか？その理由も説明してください。</li>
                            <li>@TempDirアノテーションの利点は何ですか？</li>
                        </ol>
                        <details>
                            <summary>解答例</summary>
                            <ol>
                                <li>@BeforeAll: 全テスト実行前に1回、重い初期化用。@BeforeEach: 各テスト前に毎回、軽い準備用</li>
                                <li>同一インスタンスでテストを実行でき、@BeforeAllでインスタンスメソッドが使用可能</li>
                                <li>基底クラス→子クラスの順で@BeforeAll/@BeforeEach、逆順で@AfterEach/@AfterAll</li>
                                <li>テスト間でのデータ汚染を防ぎ、テストの独立性を保つため</li>
                                <li>@BeforeAll。1回だけ実行されるため、複数テストで同じ重い処理を繰り返さずに済む</li>
                                <li>自動的に一時ディレクトリを作成・削除し、テスト後のクリーンアップを確実に行える</li>
                            </ol>
                        </details>
                    </div>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="junit-learning-material-3.html" class="btn btn-secondary">← 前の章</a>
                        <a href="junit-learning-material-5.html" class="btn btn-primary">次の章 →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>