<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JUnit学習教材 第4章 - テストライフサイクルとアノテーション</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        
        .navbar {
            background-color: #f57c00;
        }
        
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        
        .chapter-title {
            color: #f57c00;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #f57c00;
            padding-bottom: 0.5rem;
        }
        
        .section-title {
            color: #ff9800;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        
        .quiz-container {
            background-color: #fff3e0;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #f57c00;
        }
        
        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }
        
        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }
        
        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }
        
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }
        
        .nav-link.active {
            background-color: #f57c00 !important;
            color: white !important;
        }
    </style>
</head>
<body>
    <!-- Navigation bar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand">
                <strong>JUnit学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- Sidebar -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-1.html">
                                第1章: JUnit基礎とセットアップ
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-2.html">
                                第2章: 基本的なテストケースの作成
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-3.html">
                                第3章: アサーションとマッチャー
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="junit-learning-material-4.html">
                                第4章: テストライフサイクルとアノテーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-5.html">
                                第5章: パラメータ化テストと動的テスト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-6.html">
                                第6章: 例外テストとタイムアウト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-7.html">
                                第7章: テストの組織化とベストプラクティス
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- Main content -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第4章: テストライフサイクルとアノテーション</h1>
                </div>

                <div id="chapter4">
                    <h2 class="chapter-title">効率的なテスト準備とクリーンアップ</h2>
                    
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>JUnit 5のテストライフサイクルの理解</li>
                            <li>@BeforeEach、@AfterEachアノテーションを使ったテスト前後処理</li>
                            <li>@BeforeAll、@AfterAllアノテーションを使ったクラス単位の前後処理</li>
                            <li>適切なセットアップとクリーンアップの設計方法</li>
                            <li>テストの独立性を保つためのベストプラクティス</li>
                        </ul>
                    </div>

                    <h3 class="section-title">4.1 テストライフサイクルとは</h3>
                    
                    <p>テストライフサイクルとは、テストクラス内でテストメソッドが実行される際の一連の流れのことです。JUnit 5では、テストの前後に実行される処理を制御するためのアノテーションが提供されています。</p>

                    <div class="mermaid">
                        flowchart TD
                            A["テストクラス読み込み"] --> B["@BeforeAll実行"]
                            B --> C["テストメソッド1の実行開始"]
                            C --> D["@BeforeEach実行"]
                            D --> E["@Test メソッド実行"]
                            E --> F["@AfterEach実行"]
                            F --> G["テストメソッド2の実行開始"]
                            G --> H["@BeforeEach実行"]
                            H --> I["@Test メソッド実行"]
                            I --> J["@AfterEach実行"]
                            J --> K["すべてのテスト終了"]
                            K --> L["@AfterAll実行"]
                    </div>

                    <h4>4.1.1 ライフサイクルアノテーションの役割</h4>
                    <ul>
                        <li><strong>@BeforeAll</strong>：クラス内の全テストメソッドの実行前に一度だけ実行</li>
                        <li><strong>@BeforeEach</strong>：各テストメソッドの実行前に毎回実行</li>
                        <li><strong>@AfterEach</strong>：各テストメソッドの実行後に毎回実行</li>
                        <li><strong>@AfterAll</strong>：クラス内の全テストメソッドの実行後に一度だけ実行</li>
                    </ul>

                    <h3 class="section-title">4.2 @BeforeEach と @AfterEach</h3>
                    
                    <p>各テストメソッドの前後に実行される処理を定義します。テストデータの準備やクリーンアップに使用します。</p>

                    <h4>4.2.1 基本的な使用方法</h4>
                    
                    <pre class="code-block"><code class="language-java">import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

class DatabaseServiceTest {
    private DatabaseService databaseService;
    private TestDataGenerator dataGenerator;
    
    @BeforeEach
    void setUp() {
        System.out.println("テスト準備を開始");
        
        // テスト用のオブジェクトを初期化
        databaseService = new DatabaseService();
        dataGenerator = new TestDataGenerator();
        
        // テスト用データベースの準備
        databaseService.initializeTestDatabase();
        
        System.out.println("テスト準備完了");
    }
    
    @AfterEach
    void tearDown() {
        System.out.println("テスト後処理を開始");
        
        // テストデータのクリーンアップ
        if (databaseService != null) {
            databaseService.clearTestData();
        }
        
        // リソースの解放
        dataGenerator = null;
        
        System.out.println("テスト後処理完了");
    }
    
    @Test
    void データベースへのデータ挿入テスト() {
        // setUp()で準備されたオブジェクトを使用
        User testUser = dataGenerator.createTestUser("田中太郎", "tanaka@test.com");
        
        boolean result = databaseService.insertUser(testUser);
        
        assertTrue(result);
        // tearDown()でデータはクリーンアップされる
    }
    
    @Test
    void データベースからのデータ検索テスト() {
        // setUp()は毎回実行されるため、きれいな状態から開始
        User testUser = dataGenerator.createTestUser("佐藤花子", "sato@test.com");
        databaseService.insertUser(testUser);
        
        User foundUser = databaseService.findUserByEmail("sato@test.com");
        
        assertNotNull(foundUser);
        assertEquals("佐藤花子", foundUser.getName());
        // tearDown()でデータはクリーンアップされる
    }
}</code></pre>

                    <div class="highlight">
                        <h6><strong>@BeforeEach/@AfterEachの重要なポイント</strong></h6>
                        <ul>
                            <li><strong>独立性の確保</strong>：各テストが独立して実行できるように、毎回初期化する</li>
                            <li><strong>テストの順序依存を排除</strong>：どのテストから実行されても動作するように設計</li>
                            <li><strong>リソースの確実な解放</strong>：メモリリークや外部リソースの占有を防ぐ</li>
                        </ul>
                    </div>

                    <h4>4.2.2 実際のセットアップとクリーンアップの例</h4>
                    
                    <pre class="code-block"><code class="language-java">class FileOperationTest {
    private File testDirectory;
    private FileService fileService;
    
    @BeforeEach
    void setUp() throws IOException {
        // テスト専用のディレクトリを作成
        testDirectory = Files.createTempDirectory("junit-test").toFile();
        fileService = new FileService(testDirectory);
        
        // テスト用ファイルを準備
        File testFile = new File(testDirectory, "test.txt");
        Files.write(testFile.toPath(), "テストデータ".getBytes());
    }
    
    @AfterEach
    void tearDown() throws IOException {
        // テストディレクトリとその中身を削除
        if (testDirectory != null && testDirectory.exists()) {
            deleteDirectoryRecursively(testDirectory);
        }
    }
    
    @Test
    void ファイル読み込みテスト() throws IOException {
        String content = fileService.readFile("test.txt");
        assertEquals("テストデータ", content);
    }
    
    @Test
    void ファイル作成テスト() throws IOException {
        fileService.createFile("new-file.txt", "新しいデータ");
        
        File newFile = new File(testDirectory, "new-file.txt");
        assertTrue(newFile.exists());
        
        String content = Files.readString(newFile.toPath());
        assertEquals("新しいデータ", content);
    }
    
    private void deleteDirectoryRecursively(File directory) throws IOException {
        if (directory.isDirectory()) {
            File[] files = directory.listFiles();
            if (files != null) {
                for (File file : files) {
                    deleteDirectoryRecursively(file);
                }
            }
        }
        directory.delete();
    }
}</code></pre>

                    <h3 class="section-title">4.3 @BeforeAll と @AfterAll</h3>
                    
                    <p>テストクラス全体で一度だけ実行される処理を定義します。初期化に時間がかかる処理や、高コストなリソースの準備に使用します。</p>

                    <h4>4.3.1 基本的な使用方法</h4>
                    
                    <pre class="code-block"><code class="language-java">class DatabaseIntegrationTest {
    private static DatabaseConnection connection;
    private static TestDataSet testDataSet;
    
    @BeforeAll
    static void setUpClass() {
        System.out.println("データベース接続の初期化を開始");
        
        // 重いリソースの初期化（一度だけ実行）
        connection = DatabaseConnection.createConnection(
            "jdbc:h2:mem:testdb", "testuser", "testpass"
        );
        
        // テスト用のテーブル作成
        connection.execute("CREATE TABLE users (id INT, name VARCHAR(50), email VARCHAR(100))");
        connection.execute("CREATE TABLE products (id INT, name VARCHAR(50), price DECIMAL)");
        
        // 共通のテストデータを準備
        testDataSet = new TestDataSet();
        testDataSet.insertUser(1, "共通ユーザー1", "user1@test.com");
        testDataSet.insertUser(2, "共通ユーザー2", "user2@test.com");
        
        System.out.println("データベース初期化完了");
    }
    
    @AfterAll
    static void tearDownClass() {
        System.out.println("データベース接続のクリーンアップを開始");
        
        // データベース接続の切断
        if (connection != null) {
            connection.close();
        }
        
        System.out.println("データベースクリーンアップ完了");
    }
    
    @BeforeEach
    void setUp() {
        // 各テスト前の軽い準備処理
        connection.execute("DELETE FROM products");  // 商品テーブルのみクリーンアップ
    }
    
    @Test
    void ユーザー検索テスト() {
        // @BeforeAllで作成された共通データを使用
        User user = connection.findUserById(1);
        
        assertNotNull(user);
        assertEquals("共通ユーザー1", user.getName());
    }
    
    @Test
    void 商品登録テスト() {
        // @BeforeEachで商品テーブルはクリーンアップ済み
        connection.execute("INSERT INTO products VALUES (1, 'テスト商品', 1000)");
        
        Product product = connection.findProductById(1);
        assertNotNull(product);
        assertEquals("テスト商品", product.getName());
    }
}</code></pre>

                    <div class="warning">
                        <h6><strong>@BeforeAll/@AfterAllの注意事項</strong></h6>
                        <ul>
                            <li><strong>staticメソッドでなければならない</strong>：クラスレベルで実行されるため</li>
                            <li><strong>共有状態の管理に注意</strong>：全テストで共有されるため、状態変更に注意が必要</li>
                            <li><strong>例外処理の重要性</strong>：初期化に失敗すると全テストが実行できない</li>
                        </ul>
                    </div>

                    <div class="exercise-container">
                        <h5>実習 4-1: ショッピングカートシステムのテストライフサイクル</h5>
                        <p>ショッピングカート機能のテストで、適切なセットアップとクリーンアップを実装してみましょう。</p>
                        
                        <h6>手順1: テスト対象クラスの作成</h6>
                        <p><code>ShoppingCart.java</code>と関連クラスを作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import java.util.*;

public class ShoppingCart {
    private String userId;
    private List&lt;CartItem&gt; items = new ArrayList&lt;&gt;();
    private double discountRate = 0.0;
    
    public ShoppingCart(String userId) {
        this.userId = userId;
    }
    
    public void addItem(Product product, int quantity) {
        if (product == null || quantity <= 0) {
            throw new IllegalArgumentException("商品またはカテゴリが不正です");
        }
        
        CartItem existingItem = findItemByProduct(product);
        if (existingItem != null) {
            existingItem.setQuantity(existingItem.getQuantity() + quantity);
        } else {
            items.add(new CartItem(product, quantity));
        }
    }
    
    public void removeItem(Product product) {
        items.removeIf(item -> item.getProduct().equals(product));
    }
    
    public void applyDiscount(double discountRate) {
        if (discountRate < 0 || discountRate > 1) {
            throw new IllegalArgumentException("割引率は0-1の範囲で指定してください");
        }
        this.discountRate = discountRate;
    }
    
    public double calculateTotal() {
        double subtotal = items.stream()
            .mapToDouble(item -> item.getProduct().getPrice() * item.getQuantity())
            .sum();
        return subtotal * (1 - discountRate);
    }
    
    public int getItemCount() {
        return items.size();
    }
    
    public List&lt;CartItem&gt; getItems() {
        return new ArrayList&lt;&gt;(items);
    }
    
    public void clear() {
        items.clear();
        discountRate = 0.0;
    }
    
    private CartItem findItemByProduct(Product product) {
        return items.stream()
            .filter(item -> item.getProduct().equals(product))
            .findFirst()
            .orElse(null);
    }
}

// 商品クラス
class Product {
    private String id;
    private String name;
    private double price;
    
    public Product(String id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }
    
    // ゲッターとequals、hashCodeメソッド
    public String getId() { return id; }
    public String getName() { return name; }
    public double getPrice() { return price; }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Product product = (Product) o;
        return Objects.equals(id, product.id);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

// カートアイテムクラス
class CartItem {
    private Product product;
    private int quantity;
    
    public CartItem(Product product, int quantity) {
        this.product = product;
        this.quantity = quantity;
    }
    
    public Product getProduct() { return product; }
    public int getQuantity() { return quantity; }
    public void setQuantity(int quantity) { this.quantity = quantity; }
}</code></pre>

                        <h6>手順2: ライフサイクルを活用したテストクラスの作成</h6>
                        <p><code>ShoppingCartTest.java</code>を作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import java.util.logging.Logger;

class ShoppingCartTest {
    private static Logger logger = Logger.getLogger(ShoppingCartTest.class.getName());
    
    // クラスレベルで共有されるテストデータ
    private static Product laptop;
    private static Product mouse;
    private static Product keyboard;
    
    // 各テストで個別に使用されるオブジェクト
    private ShoppingCart cart;
    
    @BeforeAll
    static void setUpClass() {
        logger.info("=== テストクラス初期化開始 ===");
        
        // 共通のテスト商品データを作成（重い処理の想定）
        laptop = new Product("P001", "高性能ノートパソコン", 129800.0);
        mouse = new Product("P002", "ワイヤレスマウス", 3980.0);
        keyboard = new Product("P003", "メカニカルキーボード", 15800.0);
        
        logger.info("商品マスターデータを初期化しました");
        logger.info("=== テストクラス初期化完了 ===");
    }
    
    @BeforeEach
    void setUp() {
        logger.info("--- 個別テスト準備開始 ---");
        
        // 各テストで新しいショッピングカートを作成
        cart = new ShoppingCart("testuser001");
        
        // テスト実行前の状態を確認
        assertEquals(0, cart.getItemCount(), "カートは空の状態で開始される必要があります");
        
        logger.info("新しいショッピングカートを作成しました: " + cart);
        logger.info("--- 個別テスト準備完了 ---");
    }
    
    @AfterEach
    void tearDown() {
        logger.info("--- 個別テスト後処理開始 ---");
        
        // カートの状態をログに出力（デバッグ用）
        logger.info("テスト終了時のカート状態: アイテム数=" + cart.getItemCount());
        
        // カートをクリーンアップ
        if (cart != null) {
            cart.clear();
        }
        
        logger.info("カートをクリーンアップしました");
        logger.info("--- 個別テスト後処理完了 ---");
    }
    
    @AfterAll
    static void tearDownClass() {
        logger.info("=== テストクラス終了処理開始 ===");
        
        // 共有リソースのクリーンアップ
        laptop = null;
        mouse = null;
        keyboard = null;
        
        logger.info("共有リソースをクリーンアップしました");
        logger.info("=== すべてのテストが完了しました ===");
    }
    
    @Test
    void 商品追加の基本テスト() {
        // @BeforeAllで作成された商品データを使用
        cart.addItem(laptop, 1);
        
        assertEquals(1, cart.getItemCount());
        assertEquals(129800.0, cart.calculateTotal(), 0.01);
    }
    
    @Test
    void 複数商品追加テスト() {
        // 各テストは独立しているため、きれいなカートから開始
        cart.addItem(laptop, 1);
        cart.addItem(mouse, 2);
        cart.addItem(keyboard, 1);
        
        assertEquals(3, cart.getItemCount());
        
        double expectedTotal = 129800.0 + (3980.0 * 2) + 15800.0;
        assertEquals(expectedTotal, cart.calculateTotal(), 0.01);
    }
    
    @Test
    void 割引適用テスト() {
        cart.addItem(laptop, 1);
        cart.addItem(mouse, 1);
        
        // 10%割引を適用
        cart.applyDiscount(0.10);
        
        double expectedTotal = (129800.0 + 3980.0) * 0.90;
        assertEquals(expectedTotal, cart.calculateTotal(), 0.01);
    }
    
    @Test
    void 商品削除テスト() {
        // 商品を追加してから削除
        cart.addItem(laptop, 1);
        cart.addItem(mouse, 1);
        assertEquals(2, cart.getItemCount());
        
        cart.removeItem(laptop);
        assertEquals(1, cart.getItemCount());
        assertEquals(3980.0, cart.calculateTotal(), 0.01);
    }
    
    @Test
    void 同じ商品を複数回追加するテスト() {
        cart.addItem(mouse, 2);
        cart.addItem(mouse, 3);  // 既存の商品に追加
        
        assertEquals(1, cart.getItemCount());  // アイテムの種類は1つ
        
        CartItem mouseItem = cart.getItems().get(0);
        assertEquals(5, mouseItem.getQuantity());  // 数量は合計される
    }
    
    @Test
    void 不正な商品追加での例外テスト() {
        assertAll("不正な商品追加の検証",
            () -> assertThrows(IllegalArgumentException.class, 
                () -> cart.addItem(null, 1)),
            () -> assertThrows(IllegalArgumentException.class, 
                () -> cart.addItem(laptop, 0)),
            () -> assertThrows(IllegalArgumentException.class, 
                () -> cart.addItem(laptop, -1))
        );
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>テストを実行すると、以下のログの流れが確認できます：</p>
                        <ol>
                            <li>@BeforeAll：テストクラス全体の初期化（一度だけ）</li>
                            <li>@BeforeEach：各テストの前準備（テストごとに実行）</li>
                            <li>テスト実行</li>
                            <li>@AfterEach：各テストの後処理（テストごとに実行）</li>
                            <li>@AfterAll：テストクラス全体の終了処理（一度だけ）</li>
                        </ol>
                    </div>

                    <h3 class="section-title">4.4 テストの独立性を保つベストプラクティス</h3>
                    
                    <p>良いテストスイートでは、各テストが独立して実行できることが重要です。テストの順序に依存しない設計にしましょう。</p>

                    <h4>4.4.1 状態の分離</h4>
                    
                    <pre class="code-block"><code class="language-java">class UserManagerTest {
    private UserManager userManager;
    private List&lt;User&gt; testUsers;
    
    @BeforeEach
    void setUp() {
        // 毎回新しいインスタンスを作成
        userManager = new UserManager();
        
        // テストデータも毎回新しく作成
        testUsers = Arrays.asList(
            new User("user1", "田中太郎", "tanaka@example.com"),
            new User("user2", "佐藤花子", "sato@example.com")
        );
    }
    
    @Test
    void ユーザー追加テスト() {
        User newUser = testUsers.get(0);
        userManager.addUser(newUser);
        
        assertEquals(1, userManager.getUserCount());
        assertTrue(userManager.exists(newUser.getId()));
    }
    
    @Test
    void ユーザー削除テスト() {
        // 前のテストの影響を受けない（毎回@BeforeEachで初期化）
        User user1 = testUsers.get(0);
        User user2 = testUsers.get(1);
        
        userManager.addUser(user1);
        userManager.addUser(user2);
        assertEquals(2, userManager.getUserCount());
        
        userManager.removeUser(user1.getId());
        assertEquals(1, userManager.getUserCount());
        assertFalse(userManager.exists(user1.getId()));
    }
}</code></pre>

                    <h4>4.4.2 外部依存の分離</h4>
                    
                    <pre class="code-block"><code class="language-java">class EmailServiceTest {
    private EmailService emailService;
    private MockEmailProvider mockProvider;
    
    @BeforeEach
    void setUp() {
        // テスト用のモックオブジェクトを準備
        mockProvider = new MockEmailProvider();
        emailService = new EmailService(mockProvider);
        
        // モックの状態をリセット
        mockProvider.reset();
    }
    
    @Test
    void メール送信成功テスト() {
        Email email = new Email("test@example.com", "テスト件名", "テスト本文");
        
        boolean result = emailService.sendEmail(email);
        
        assertTrue(result);
        assertEquals(1, mockProvider.getSentEmailCount());
    }
    
    @Test
    void メール送信失敗テスト() {
        // モックで送信失敗を設定
        mockProvider.setShouldFail(true);
        
        Email email = new Email("test@example.com", "テスト件名", "テスト本文");
        
        boolean result = emailService.sendEmail(email);
        
        assertFalse(result);
        assertEquals(0, mockProvider.getSentEmailCount());
    }
    
    @AfterEach
    void tearDown() {
        // モックの状態をクリーンアップ
        if (mockProvider != null) {
            mockProvider.reset();
        }
    }
}</code></pre>

                    <div class="highlight">
                        <h6><strong>テスト独立性のポイント</strong></h6>
                        <ul>
                            <li><strong>新しいオブジェクト</strong>：@BeforeEachで毎回新しいインスタンスを作成</li>
                            <li><strong>状態のリセット</strong>：共有リソースは必ず初期状態に戻す</li>
                            <li><strong>テスト順序非依存</strong>：どの順序で実行されても同じ結果になるように設計</li>
                            <li><strong>外部依存の制御</strong>：データベースや外部API呼び出しはモック化</li>
                        </ul>
                    </div>

                    <h3 class="section-title">4.5 高度なライフサイクル管理</h3>
                    
                    <p>複雑なテストシナリオでは、より細かなライフサイクル制御が必要になることがあります。</p>

                    <h4>4.4.1 条件付きセットアップ</h4>
                    
                    <pre class="code-block"><code class="language-java">class ConditionalSetupTest {
    private TestEnvironment environment;
    private DatabaseService databaseService;
    
    @BeforeEach
    void setUp(TestInfo testInfo) {
        // テスト名に応じて異なるセットアップを実行
        String testName = testInfo.getDisplayName();
        
        if (testName.contains("データベース")) {
            environment = TestEnvironment.DATABASE;
            databaseService = new DatabaseService();
            databaseService.initializeTestDatabase();
        } else if (testName.contains("ファイル")) {
            environment = TestEnvironment.FILE_SYSTEM;
            // ファイルシステムの準備
        } else {
            environment = TestEnvironment.IN_MEMORY;
            // インメモリテストの準備
        }
        
        System.out.println("テスト環境: " + environment + " で初期化完了");
    }
    
    @Test
    void データベース統合テスト() {
        assertEquals(TestEnvironment.DATABASE, environment);
        assertNotNull(databaseService);
        // データベーステストの実行
    }
    
    @Test
    void ファイル操作テスト() {
        assertEquals(TestEnvironment.FILE_SYSTEM, environment);
        // ファイルテストの実行
    }
    
    @Test
    void 高速単体テスト() {
        assertEquals(TestEnvironment.IN_MEMORY, environment);
        // インメモリテストの実行
    }
}</code></pre>

                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li><strong>@BeforeEachアノテーションが付いたメソッドはいつ実行されますか？</strong>
                                <ul>
                                    <li>a) テストクラス読み込み時に一度だけ</li>
                                    <li>b) 各テストメソッドの実行前に毎回</li>
                                    <li>c) 全てのテスト終了後に一度だけ</li>
                                    <li>d) テスト失敗時のみ</li>
                                </ul>
                            </li>
                            <li><strong>@BeforeAllアノテーションが付いたメソッドの制約は何ですか？</strong>
                                <ul>
                                    <li>a) 引数を持つ必要がある</li>
                                    <li>b) staticメソッドでなければならない</li>
                                    <li>c) 戻り値を持つ必要がある</li>
                                    <li>d) privateメソッドでなければならない</li>
                                </ul>
                            </li>
                            <li><strong>テストの独立性を保つために最も重要なことは何ですか？</strong>
                                <ul>
                                    <li>a) テストメソッド名を統一する</li>
                                    <li>b) 各テストで新しいオブジェクトを使用する</li>
                                    <li>c) すべてのテストで同じデータを使用する</li>
                                    <li>d) テストの実行順序を固定する</li>
                                </ul>
                            </li>
                            <li><strong>@AfterEachメソッドが例外を投げた場合、どうなりますか？</strong>
                                <ul>
                                    <li>a) テスト結果には影響しない</li>
                                    <li>b) テストが失敗として扱われる</li>
                                    <li>c) 次のテストが実行されない</li>
                                    <li>d) プログラムが終了する</li>
                                </ul>
                            </li>
                        </ol>
                        
                        <details style="margin-top: 1rem;">
                            <summary><strong>解答を見る</strong></summary>
                            <div style="margin-top: 0.5rem;">
                                <p><strong>1.</strong> b) 各テストメソッドの実行前に毎回</p>
                                <p><strong>2.</strong> b) staticメソッドでなければならない</p>
                                <p><strong>3.</strong> b) 各テストで新しいオブジェクトを使用する</p>
                                <p><strong>4.</strong> b) テストが失敗として扱われる</p>
                            </div>
                        </details>
                    </div>

                    <!-- Chapter navigation -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="junit-learning-material-3.html" class="btn btn-secondary">← 前の章：アサーションとマッチャー</a>
                        <a href="junit-learning-material-5.html" class="btn btn-primary">次の章：パラメータ化テストと動的テスト →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js initialization -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js initialization -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>