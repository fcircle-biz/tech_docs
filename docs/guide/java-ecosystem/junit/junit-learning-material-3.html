<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JUnit学習教材 第3章 - アサーションとマッチャー</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        
        .navbar {
            background-color: #f57c00;
        }
        
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        
        .chapter-title {
            color: #f57c00;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #f57c00;
            padding-bottom: 0.5rem;
        }
        
        .section-title {
            color: #ff9800;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        
        .quiz-container {
            background-color: #fff3e0;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #f57c00;
        }
        
        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }
        
        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }
        
        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }
        
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }
        
        .nav-link.active {
            background-color: #f57c00 !important;
            color: white !important;
        }
    </style>
</head>
<body>
    <!-- Navigation bar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand">
                <strong>JUnit学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- Sidebar -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-1.html">
                                第1章: JUnit基礎とセットアップ
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-2.html">
                                第2章: 基本的なテストケースの作成
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="junit-learning-material-3.html">
                                第3章: アサーションとマッチャー
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-4.html">
                                第4章: テストライフサイクルとアノテーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-5.html">
                                第5章: パラメータ化テストと動的テスト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-6.html">
                                第6章: 例外テストとタイムアウト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-7.html">
                                第7章: テストの組織化とベストプラクティス
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- Main content -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第3章: アサーションとマッチャー</h1>
                </div>

                <div id="chapter3">
                    <h2 class="chapter-title">より詳細で読みやすい検証の実現</h2>
                    
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>JUnit 5の高度なアサーションメソッドを理解する</li>
                            <li>assertAll()による複数の検証をまとめて実行する方法</li>
                            <li>コレクションや配列の検証に特化したアサーション</li>
                            <li>浮動小数点数の比較における誤差の扱い方</li>
                            <li>より読みやすいテストコードを書くためのベストプラクティス</li>
                        </ul>
                    </div>

                    <h3 class="section-title">3.1 JUnit 5の高度なアサーション</h3>
                    
                    <p>JUnit 5では、基本的なアサーションに加えて、より複雑な検証や読みやすいテストコードを書くための高度なアサーションメソッドが提供されています。</p>

                    <div class="mermaid">
                        flowchart TD
                            A["JUnit 5のアサーション"] --> B["基本アサーション"]
                            A --> C["高度なアサーション"]
                            B --> D["assertEquals"]
                            B --> E["assertTrue/assertFalse"]
                            B --> F["assertNull/assertNotNull"]
                            C --> G["assertAll（まとめて検証）"]
                            C --> H["assertArrayEquals（配列比較）"]
                            C --> I["assertIterableEquals（コレクション比較）"]
                            C --> J["assertLines（文字列行比較）"]
                    </div>

                    <h4>3.1.1 assertAll() - 複数の検証をまとめて実行</h4>
                    <p><code>assertAll()</code>は、複数のアサーションをまとめて実行し、すべての結果を一度に確認できる優れた機能です：</p>

                    <pre class="code-block"><code class="language-java">@Test
void ユーザー情報のまとめて検証() {
    User user = new User("田中太郎", 30, "tanaka@example.com");
    
    // 従来の方法（最初の失敗で止まる）
    assertEquals("田中太郎", user.getName());
    assertEquals(30, user.getAge());
    assertEquals("tanaka@example.com", user.getEmail());
    
    // assertAll()を使用（すべての失敗を表示）
    assertAll("ユーザー情報の検証",
        () -> assertEquals("田中太郎", user.getName()),
        () -> assertEquals(30, user.getAge()),
        () -> assertEquals("tanaka@example.com", user.getEmail()),
        () -> assertTrue(user.isActive())
    );
}</code></pre>

                    <div class="highlight">
                        <h6><strong>assertAll()の利点</strong></h6>
                        <ul>
                            <li><strong>すべての失敗を確認</strong>：最初の失敗でテストが止まらず、すべての検証結果を確認できます</li>
                            <li><strong>効率的なデバッグ</strong>：一度の実行ですべての問題箇所が分かります</li>
                            <li><strong>論理的なグループ化</strong>：関連する検証をまとめて表現できます</li>
                        </ul>
                    </div>

                    <h4>3.1.2 assertArrayEquals() - 配列の比較</h4>
                    <p>配列の要素を順序も含めて比較します：</p>

                    <pre class="code-block"><code class="language-java">@Test
void 配列の比較テスト() {
    int[] expected = {1, 2, 3, 4, 5};
    int[] actual = {1, 2, 3, 4, 5};
    
    assertArrayEquals(expected, actual);
    
    // 異なる型の配列も比較可能
    String[] expectedStrings = {"apple", "banana", "orange"};
    String[] actualStrings = {"apple", "banana", "orange"};
    
    assertArrayEquals(expectedStrings, actualStrings);
}</code></pre>

                    <h4>3.1.3 assertIterableEquals() - コレクションの比較</h4>
                    <p>List、Set などのコレクションを比較します：</p>

                    <pre class="code-block"><code class="language-java">@Test
void コレクションの比較テスト() {
    List&lt;String&gt; expected = Arrays.asList("Java", "Python", "JavaScript");
    List&lt;String&gt; actual = programmingLanguageService.getPopularLanguages();
    
    assertIterableEquals(expected, actual);
    
    // 順序も重要（順序が異なれば失敗）
    List&lt;String&gt; differentOrder = Arrays.asList("Python", "Java", "JavaScript");
    // assertIterableEquals(expected, differentOrder);  // これは失敗する
}</code></pre>

                    <h3 class="section-title">3.2 浮動小数点数の比較</h3>
                    
                    <p>コンピュータの浮動小数点演算では、計算誤差により完全に一致しない場合があります。JUnit 5では、この問題に対処するための方法を提供しています。</p>

                    <h4>3.2.1 なぜ浮動小数点の比較は難しいのか</h4>
                    
                    <pre class="code-block"><code class="language-java">@Test
void 浮動小数点の問題を理解する() {
    double result = 0.1 + 0.2;
    System.out.println("0.1 + 0.2 = " + result);  // 0.30000000000000004
    
    // これは失敗する
    // assertEquals(0.3, result);
    
    // 正しい方法：許容誤差を指定
    assertEquals(0.3, result, 0.0001);
}</code></pre>

                    <h4>3.2.2 許容誤差を使った比較</h4>
                    
                    <pre class="code-block"><code class="language-java">@Test
void 許容誤差を使った浮動小数点テスト() {
    Calculator calculator = new Calculator();
    
    // 円の面積計算（π が含まれるため誤差が発生する可能性）
    double radius = 5.0;
    double expectedArea = Math.PI * radius * radius;
    double actualArea = calculator.calculateCircleArea(radius);
    
    // 0.001の誤差まで許容
    assertEquals(expectedArea, actualArea, 0.001);
    
    // より厳密な比較（小さい誤差）
    assertEquals(78.54, actualArea, 0.01, "半径5の円の面積");
}</code></pre>

                    <h3 class="section-title">3.3 文字列の高度な検証</h3>
                    
                    <p>文字列の検証では、完全一致以外にも様々なパターンが必要になります。</p>

                    <h4>3.3.1 文字列の含有、開始、終了の検証</h4>
                    
                    <pre class="code-block"><code class="language-java">@Test
void 文字列の詳細な検証() {
    String message = "Hello JUnit 5 World!";
    
    // 文字列が含まれているかの検証
    assertTrue(message.contains("JUnit"));
    assertTrue(message.contains("World"));
    
    // 開始と終了の検証
    assertTrue(message.startsWith("Hello"));
    assertTrue(message.endsWith("World!"));
    
    // 大文字小文字を無視した検証
    assertTrue(message.toLowerCase().contains("junit"));
    
    // 正規表現を使った検証
    assertTrue(message.matches(".*JUnit \\d+.*"));
}</code></pre>

                    <h4>3.3.2 複数行文字列の比較</h4>
                    
                    <pre class="code-block"><code class="language-java">@Test
void 複数行文字列の検証() {
    String expectedJson = """
        {
          "name": "田中太郎",
          "age": 30,
          "email": "tanaka@example.com"
        }""";
    
    String actualJson = jsonService.generateUserJson("田中太郎", 30, "tanaka@example.com");
    
    // 完全一致の比較
    assertEquals(expectedJson.trim(), actualJson.trim());
    
    // 行ごとの比較（順序重要）
    String[] expectedLines = expectedJson.split("\\n");
    String[] actualLines = actualJson.split("\\n");
    assertArrayEquals(expectedLines, actualLines);
}</code></pre>

                    <div class="exercise-container">
                        <h5>実習 3-1: 商品管理システムの詳細な検証</h5>
                        <p>商品管理システムで、様々なアサーションを使って包括的なテストを作成してみましょう。</p>
                        
                        <h6>手順1: テスト対象クラスの作成</h6>
                        <p><code>ProductManager.java</code>を作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import java.util.*;

public class ProductManager {
    private List&lt;Product&gt; products = new ArrayList&lt;&gt;();
    
    public void addProduct(Product product) {
        if (product == null) {
            throw new IllegalArgumentException("商品はnullにできません");
        }
        products.add(product);
    }
    
    public List&lt;Product&gt; getAllProducts() {
        return new ArrayList&lt;&gt;(products);
    }
    
    public List&lt;Product&gt; getProductsByCategory(String category) {
        return products.stream()
            .filter(p -&gt; p.getCategory().equals(category))
            .toList();
    }
    
    public double[] getPrices() {
        return products.stream()
            .mapToDouble(Product::getPrice)
            .toArray();
    }
    
    public double calculateAveragePrice() {
        return products.stream()
            .mapToDouble(Product::getPrice)
            .average()
            .orElse(0.0);
    }
    
    public String generateReport() {
        StringBuilder report = new StringBuilder();
        report.append("=== 商品レポート ===\n");
        report.append("商品数: ").append(products.size()).append("\n");
        report.append("平均価格: ").append(String.format("%.2f", calculateAveragePrice())).append("円\n");
        return report.toString();
    }
}

// Product クラス
class Product {
    private String name;
    private double price;
    private String category;
    
    public Product(String name, double price, String category) {
        this.name = name;
        this.price = price;
        this.category = category;
    }
    
    // ゲッター、equals、hashCode メソッド
    public String getName() { return name; }
    public double getPrice() { return price; }
    public String getCategory() { return category; }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Product product = (Product) o;
        return Double.compare(product.price, price) == 0 &&
               Objects.equals(name, product.name) &&
               Objects.equals(category, product.category);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, price, category);
    }
}</code></pre>

                        <h6>手順2: 包括的なテストクラスの作成</h6>
                        <p><code>ProductManagerTest.java</code>を作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;

class ProductManagerTest {
    private ProductManager manager;
    private Product laptop;
    private Product mouse;
    private Product keyboard;
    
    @BeforeEach
    void setUp() {
        manager = new ProductManager();
        laptop = new Product("ノートパソコン", 89800.0, "電子機器");
        mouse = new Product("ワイヤレスマウス", 2980.0, "電子機器");
        keyboard = new Product("メカニカルキーボード", 12800.0, "電子機器");
    }
    
    @Test
    void 商品追加の詳細検証() {
        manager.addProduct(laptop);
        manager.addProduct(mouse);
        
        List&lt;Product&gt; products = manager.getAllProducts();
        
        // assertAll()で複数の検証をまとめて実行
        assertAll("商品追加の検証",
            () -> assertEquals(2, products.size()),
            () -> assertTrue(products.contains(laptop)),
            () -> assertTrue(products.contains(mouse)),
            () -> assertFalse(products.isEmpty())
        );
    }
    
    @Test
    void カテゴリ別商品取得の検証() {
        manager.addProduct(laptop);
        manager.addProduct(mouse);
        manager.addProduct(keyboard);
        
        List&lt;Product&gt; expectedElectronics = Arrays.asList(laptop, mouse, keyboard);
        List&lt;Product&gt; actualElectronics = manager.getProductsByCategory("電子機器");
        
        // コレクションの順序を含めた比較
        assertIterableEquals(expectedElectronics, actualElectronics);
    }
    
    @Test
    void 価格配列の検証() {
        manager.addProduct(laptop);
        manager.addProduct(mouse);
        manager.addProduct(keyboard);
        
        double[] expectedPrices = {89800.0, 2980.0, 12800.0};
        double[] actualPrices = manager.getPrices();
        
        // 配列の比較
        assertArrayEquals(expectedPrices, actualPrices);
    }
    
    @Test
    void 平均価格計算の検証() {
        manager.addProduct(laptop);
        manager.addProduct(mouse);
        manager.addProduct(keyboard);
        
        double expectedAverage = (89800.0 + 2980.0 + 12800.0) / 3.0;
        double actualAverage = manager.calculateAveragePrice();
        
        // 浮動小数点の比較（許容誤差付き）
        assertEquals(expectedAverage, actualAverage, 0.01);
    }
    
    @Test
    void レポート生成の文字列検証() {
        manager.addProduct(laptop);
        manager.addProduct(mouse);
        
        String report = manager.generateReport();
        
        // 文字列の詳細な検証
        assertAll("レポート内容の検証",
            () -> assertTrue(report.contains("商品レポート")),
            () -> assertTrue(report.contains("商品数: 2")),
            () -> assertTrue(report.contains("平均価格:")),
            () -> assertTrue(report.endsWith("円\n"))
        );
    }
    
    @Test
    void null商品追加で例外発生の検証() {
        IllegalArgumentException exception = assertThrows(
            IllegalArgumentException.class,
            () -> manager.addProduct(null)
        );
        
        assertEquals("商品はnullにできません", exception.getMessage());
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>すべてのテストが成功し、以下の検証方法が使われていることを確認してください：</p>
                        <ul>
                            <li>assertAll()による複数検証の一括実行</li>
                            <li>assertIterableEquals()によるコレクションの比較</li>
                            <li>assertArrayEquals()による配列の比較</li>
                            <li>許容誤差付きの浮動小数点比較</li>
                            <li>文字列の含有・終了文字の検証</li>
                        </ul>
                    </div>

                    <h3 class="section-title">3.4 カスタムエラーメッセージとLambda式</h3>
                    
                    <p>JUnit 5では、失敗時により詳細な情報を提供するカスタムメッセージや、Lambda式を使った動的なメッセージ生成が可能です。</p>

                    <h4>3.4.1 静的なカスタムメッセージ</h4>
                    
                    <pre class="code-block"><code class="language-java">@Test
void カスタムメッセージを使った検証() {
    int score = 85;
    int passingScore = 80;
    
    assertTrue(score >= passingScore, 
        String.format("スコア %d は合格点 %d を上回る必要があります", score, passingScore));
    
    List&lt;String&gt; students = Arrays.asList("田中", "佐藤", "鈴木");
    assertFalse(students.isEmpty(), "学生リストが空になってはいけません");
}</code></pre>

                    <h4>3.4.2 Lambda式を使った動的メッセージ</h4>
                    <p>メッセージの生成にコストがかかる場合、Lambda式を使って遅延評価できます：</p>

                    <pre class="code-block"><code class="language-java">@Test
void Lambda式を使った動的メッセージ() {
    List&lt;Product&gt; products = getExpensiveProductList();  // 重い処理
    
    assertFalse(products.isEmpty(), 
        () -> "商品リストが空です。現在の商品数: " + products.size() + 
              ", 最終更新: " + new Date());
    
    Product mostExpensive = findMostExpensiveProduct(products);
    assertTrue(mostExpensive.getPrice() > 1000,
        () -> String.format("最も高価な商品 '%s' の価格 %.2f円が期待値を下回っています",
                           mostExpensive.getName(), mostExpensive.getPrice()));
}</code></pre>

                    <div class="highlight">
                        <h6><strong>Lambda式メッセージの利点</strong></h6>
                        <ul>
                            <li><strong>パフォーマンス向上</strong>：テストが成功した場合、メッセージは生成されません</li>
                            <li><strong>動的情報</strong>：実行時の状態を含む詳細なメッセージを生成できます</li>
                            <li><strong>複雑な計算</strong>：重い処理を含むメッセージも効率的に扱えます</li>
                        </ul>
                    </div>

                    <h3 class="section-title">3.5 テスト可読性向上のベストプラクティス</h3>
                    
                    <p>アサーションを使ったテストコードの可読性を向上させるためのテクニックを学びましょう。</p>

                    <h4>3.5.1 意図を明確にする検証の書き方</h4>
                    
                    <pre class="code-block"><code class="language-java">@Test
void 読みやすい検証の書き方() {
    OrderService orderService = new OrderService();
    Customer customer = new Customer("田中太郎", CustomerType.PREMIUM);
    List&lt;Item&gt; items = Arrays.asList(
        new Item("商品A", 1000, 2),
        new Item("商品B", 1500, 1)
    );
    
    Order order = orderService.createOrder(customer, items);
    
    // 意図が明確な検証
    assertAll("注文作成の検証",
        () -> assertNotNull(order, "注文オブジェクトが作成されること"),
        () -> assertEquals(customer, order.getCustomer(), "顧客情報が正しく設定されること"),
        () -> assertEquals(2, order.getItems().size(), "注文項目数が正しいこと"),
        () -> assertEquals(3500.0, order.getTotalAmount(), 0.01, "合計金額が正しく計算されること"),
        () -> assertTrue(order.getDiscount() > 0, "プレミアム顧客には割引が適用されること")
    );
}</code></pre>

                    <h4>3.5.2 ヘルパーメソッドによる検証の整理</h4>
                    
                    <pre class="code-block"><code class="language-java">@Test
void ヘルパーメソッドを使った検証() {
    User user = userService.registerUser("田中太郎", "tanaka@example.com", "password123");
    
    assertValidUser(user);
    assertUserHasDefaultSettings(user);
}

// ヘルパーメソッド：再利用可能な検証ロジック
private void assertValidUser(User user) {
    assertAll("有効なユーザーの検証",
        () -> assertNotNull(user, "ユーザーオブジェクトが存在すること"),
        () -> assertNotNull(user.getId(), "ユーザーIDが設定されていること"),
        () -> assertTrue(user.getId() > 0, "ユーザーIDが正の値であること"),
        () -> assertNotNull(user.getCreatedAt(), "作成日時が設定されていること"),
        () -> assertTrue(user.isActive(), "ユーザーがアクティブ状態であること")
    );
}

private void assertUserHasDefaultSettings(User user) {
    UserSettings settings = user.getSettings();
    assertAll("デフォルト設定の検証",
        () -> assertNotNull(settings, "ユーザー設定が存在すること"),
        () -> assertTrue(settings.isEmailNotificationEnabled(), "メール通知がデフォルトで有効であること"),
        () -> assertEquals(Locale.JAPANESE, settings.getLocale(), "デフォルトロケールが日本語であること")
    );
}</code></pre>

                    <div class="exercise-container">
                        <h5>実習 3-2: 学生成績管理システムの高度な検証</h5>
                        <p>学生の成績を管理するシステムで、様々なアサーション技法を組み合わせて使ってみましょう。</p>
                        
                        <h6>手順1: システムの実装</h6>
                        <p><code>GradeManager.java</code>を作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import java.util.*;
import java.util.stream.Collectors;

public class GradeManager {
    private Map&lt;String, List&lt;Double&gt;&gt; studentGrades = new HashMap&lt;&gt;();
    
    public void addGrade(String studentName, double grade) {
        if (grade < 0 || grade > 100) {
            throw new IllegalArgumentException("成績は0-100の範囲で入力してください");
        }
        studentGrades.computeIfAbsent(studentName, k -> new ArrayList&lt;&gt;()).add(grade);
    }
    
    public double calculateAverage(String studentName) {
        List&lt;Double&gt; grades = studentGrades.get(studentName);
        if (grades == null || grades.isEmpty()) {
            return 0.0;
        }
        return grades.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);
    }
    
    public String getGradeLetter(String studentName) {
        double average = calculateAverage(studentName);
        if (average >= 90) return "A";
        if (average >= 80) return "B";
        if (average >= 70) return "C";
        if (average >= 60) return "D";
        return "F";
    }
    
    public List&lt;String&gt; getTopStudents(int count) {
        return studentGrades.entrySet().stream()
            .sorted((e1, e2) -> Double.compare(calculateAverage(e2.getKey()), calculateAverage(e1.getKey())))
            .limit(count)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
    }
    
    public String generateReport() {
        StringBuilder report = new StringBuilder();
        report.append("=== 成績レポート ===\n");
        report.append("登録学生数: ").append(studentGrades.size()).append("\n");
        
        studentGrades.forEach((name, grades) -> {
            double avg = calculateAverage(name);
            report.append(String.format("%s: %.2f (%s)\n", name, avg, getGradeLetter(name)));
        });
        
        return report.toString();
    }
}</code></pre>

                        <h6>手順2: 高度な検証テストの作成</h6>
                        <p><code>GradeManagerTest.java</code>を作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;

class GradeManagerTest {
    private GradeManager gradeManager;
    
    @BeforeEach
    void setUp() {
        gradeManager = new GradeManager();
    }
    
    @Test
    void 複数科目の成績追加と平均計算() {
        // テストデータの準備
        gradeManager.addGrade("田中太郎", 85.5);
        gradeManager.addGrade("田中太郎", 92.0);
        gradeManager.addGrade("田中太郎", 78.3);
        
        double expectedAverage = (85.5 + 92.0 + 78.3) / 3.0;
        double actualAverage = gradeManager.calculateAverage("田中太郎");
        
        // 浮動小数点の精密な比較
        assertEquals(expectedAverage, actualAverage, 0.001,
            () -> String.format("平均点の計算が正しくありません。期待値: %.3f, 実際値: %.3f", 
                               expectedAverage, actualAverage));
    }
    
    @Test
    void 成績文字評価の境界値テスト() {
        // 境界値のテストデータを準備
        Map&lt;String, String&gt; testCases = Map.of(
            "優秀な学生", "A",  // 90点台
            "良い学生", "B",    // 80点台
            "普通の学生", "C",  // 70点台
            "努力が必要な学生", "D",  // 60点台
            "不合格学生", "F"   // 60点未満
        );
        
        gradeManager.addGrade("優秀な学生", 95.0);
        gradeManager.addGrade("良い学生", 85.0);
        gradeManager.addGrade("普通の学生", 75.0);
        gradeManager.addGrade("努力が必要な学生", 65.0);
        gradeManager.addGrade("不合格学生", 55.0);
        
        // assertAll()で全パターンをまとめて検証
        assertAll("成績文字評価の検証",
            testCases.entrySet().stream()
                .map(entry -> () -> assertEquals(entry.getValue(), 
                                               gradeManager.getGradeLetter(entry.getKey()),
                                               entry.getKey() + "の評価が正しくありません"))
                .toArray(org.junit.jupiter.api.function.Executable[]::new)
        );
    }
    
    @Test
    void トップ学生ランキングの順序検証() {
        // 複数学生のデータを追加
        gradeManager.addGrade("田中", 95.0);
        gradeManager.addGrade("佐藤", 87.5);
        gradeManager.addGrade("鈴木", 92.3);
        gradeManager.addGrade("山田", 88.7);
        
        List&lt;String&gt; expectedRanking = Arrays.asList("田中", "鈴木", "山田");
        List&lt;String&gt; actualRanking = gradeManager.getTopStudents(3);
        
        // 順序を含むリスト比較
        assertIterableEquals(expectedRanking, actualRanking, "ランキングの順序が正しくありません");
    }
    
    @Test
    void レポート生成の詳細検証() {
        gradeManager.addGrade("田中", 85.0);
        gradeManager.addGrade("佐藤", 92.5);
        
        String report = gradeManager.generateReport();
        
        // 文字列の複合的な検証
        assertAll("レポート内容の検証",
            () -> assertTrue(report.contains("成績レポート"), "レポートタイトルが含まれていること"),
            () -> assertTrue(report.contains("登録学生数: 2"), "正しい学生数が表示されること"),
            () -> assertTrue(report.contains("田中: 85.00 (B)"), "田中の成績が正しく表示されること"),
            () -> assertTrue(report.contains("佐藤: 92.50 (A)"), "佐藤の成績が正しく表示されること"),
            () -> assertTrue(report.endsWith("\n"), "レポートが改行で終わっていること")
        );
    }
    
    @Test
    void 不正な成績値での例外検証() {
        // 複数の不正値をテスト
        assertAll("不正な成績値の検証",
            () -> {
                Exception exception = assertThrows(IllegalArgumentException.class, 
                    () -> gradeManager.addGrade("田中", -10.0));
                assertTrue(exception.getMessage().contains("0-100の範囲"));
            },
            () -> {
                Exception exception = assertThrows(IllegalArgumentException.class, 
                    () -> gradeManager.addGrade("佐藤", 150.0));
                assertTrue(exception.getMessage().contains("0-100の範囲"));
            }
        );
    }
    
    // ヘルパーメソッド
    private void assertStudentHasGrades(String studentName, double expectedAverage, String expectedGrade) {
        assertAll(studentName + "の成績検証",
            () -> assertTrue(gradeManager.calculateAverage(studentName) > 0, "成績が記録されていること"),
            () -> assertEquals(expectedAverage, gradeManager.calculateAverage(studentName), 0.01, "平均点が正しいこと"),
            () -> assertEquals(expectedGrade, gradeManager.getGradeLetter(studentName), "評価が正しいこと")
        );
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>このテストは以下の高度なアサーション技法を実践しています：</p>
                        <ul>
                            <li>assertAll()による複数検証の効率的な実行</li>
                            <li>Lambda式を使った動的エラーメッセージ</li>
                            <li>境界値テストでの包括的な検証</li>
                            <li>順序付きコレクションの正確な比較</li>
                            <li>ヘルパーメソッドによる検証ロジックの再利用</li>
                        </ul>
                    </div>

                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li><strong>assertAll()の主な利点は何ですか？</strong>
                                <ul>
                                    <li>a) テストの実行速度が向上する</li>
                                    <li>b) 最初の失敗でテストを停止できる</li>
                                    <li>c) すべての検証結果を一度に確認できる</li>
                                    <li>d) メモリ使用量が削減される</li>
                                </ul>
                            </li>
                            <li><strong>浮動小数点数の比較で許容誤差が必要な理由は何ですか？</strong>
                                <ul>
                                    <li>a) プログラムの実行速度を向上させるため</li>
                                    <li>b) コンピュータの演算誤差により完全一致しない場合があるため</li>
                                    <li>c) コードの可読性を向上させるため</li>
                                    <li>d) メモリ使用量を削減するため</li>
                                </ul>
                            </li>
                            <li><strong>assertIterableEquals()と assertArrayEquals()の違いは何ですか？</strong>
                                <ul>
                                    <li>a) 機能に違いはない</li>
                                    <li>b) assertIterableEquals()はコレクション、assertArrayEquals()は配列用</li>
                                    <li>c) assertArrayEquals()の方が高速</li>
                                    <li>d) assertIterableEquals()は順序を無視する</li>
                                </ul>
                            </li>
                            <li><strong>Lambda式を使ったエラーメッセージの利点は何ですか？</strong>
                                <ul>
                                    <li>a) 常にメッセージが生成される</li>
                                    <li>b) テストが失敗した時のみメッセージが生成される</li>
                                    <li>c) エラーメッセージが短くなる</li>
                                    <li>d) 日本語が使用できなくなる</li>
                                </ul>
                            </li>
                        </ol>
                        
                        <details style="margin-top: 1rem;">
                            <summary><strong>解答を見る</strong></summary>
                            <div style="margin-top: 0.5rem;">
                                <p><strong>1.</strong> c) すべての検証結果を一度に確認できる</p>
                                <p><strong>2.</strong> b) コンピュータの演算誤差により完全一致しない場合があるため</p>
                                <p><strong>3.</strong> b) assertIterableEquals()はコレクション、assertArrayEquals()は配列用</p>
                                <p><strong>4.</strong> b) テストが失敗した時のみメッセージが生成される（遅延評価）</p>
                            </div>
                        </details>
                    </div>

                    <!-- Chapter navigation -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="junit-learning-material-2.html" class="btn btn-secondary">← 前の章：基本的なテストケースの作成</a>
                        <a href="junit-learning-material-4.html" class="btn btn-primary">次の章：テストライフサイクルとアノテーション →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js initialization -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js initialization -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>