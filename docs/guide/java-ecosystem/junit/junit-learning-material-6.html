<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JUnit学習教材 第6章 - 例外テストとタイムアウト</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        
        .navbar {
            background-color: #f57c00;
        }
        
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        
        .chapter-title {
            color: #f57c00;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #f57c00;
            padding-bottom: 0.5rem;
        }
        
        .section-title {
            color: #ff9800;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        
        .quiz-container {
            background-color: #fff3e0;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #f57c00;
        }
        
        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }
        
        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }
        
        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }
        
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }
        
        .nav-link.active {
            background-color: #f57c00 !important;
            color: white !important;
        }
    </style>
</head>
<body>
    <!-- Navigation bar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand">
                <strong>JUnit学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- Sidebar -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-1.html">
                                第1章: JUnit基礎とセットアップ
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-2.html">
                                第2章: 基本的なテストケースの作成
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-3.html">
                                第3章: アサーションとマッチャー
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-4.html">
                                第4章: テストライフサイクルとアノテーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-5.html">
                                第5章: パラメータ化テストと動的テスト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="junit-learning-material-6.html">
                                第6章: 例外テストとタイムアウト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-7.html">
                                第7章: テストの組織化とベストプラクティス
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- Main content -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第6章: 例外テストとタイムアウト</h1>
                </div>

                <div id="chapter6">
                    <h2 class="chapter-title">エラー条件と性能要件の検証</h2>
                    
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>assertThrows()を使った例外発生の検証方法</li>
                            <li>例外の種類とメッセージの詳細な検証テクニック</li>
                            <li>@Timeoutアノテーションによるタイムアウトテスト</li>
                            <li>assertTimeout()を使った実行時間の検証</li>
                            <li>性能要件を含む包括的なテスト設計</li>
                        </ul>
                    </div>

                    <h3 class="section-title">6.1 例外テストの重要性</h3>
                    
                    <p>優れたソフトウェアは、正常なケースだけでなく、異常なケースでも適切に動作する必要があります。例外テストは、エラー条件での振る舞いを検証し、システムの堅牢性を確保する重要な役割を果たします。</p>

                    <div class="mermaid">
                        flowchart TD
                            A["プログラムの動作"] --> B["正常系"]
                            A --> C["異常系"]
                            B --> D["期待される結果を返す"]
                            C --> E["適切な例外を投げる"]
                            E --> F["例外の種類が正しい"]
                            E --> G["例外メッセージが適切"]
                            E --> H["システムが安定状態を保つ"]
                    </div>

                    <h4>6.1.1 例外テストが検証すべき要素</h4>
                    <ul>
                        <li><strong>例外の発生</strong>：期待される条件で例外が投げられるか</li>
                        <li><strong>例外の種類</strong>：適切な例外クラスが使用されているか</li>
                        <li><strong>例外メッセージ</strong>：ユーザーにとって有用な情報が含まれているか</li>
                        <li><strong>システムの状態</strong>：例外発生後もシステムが安定しているか</li>
                    </ul>

                    <h3 class="section-title">6.2 assertThrows()による基本的な例外テスト</h3>
                    
                    <p>JUnit 5では、<code>assertThrows()</code>メソッドを使用して例外の発生を検証できます。</p>

                    <h4>6.2.1 基本的な例外テストの書き方</h4>
                    
                    <pre class="code-block"><code class="language-java">import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class ExceptionTestExamples {
    
    @Test
    void ゼロ除算で例外発生テスト() {
        Calculator calculator = new Calculator();
        
        // ArithmeticExceptionが投げられることを検証
        assertThrows(ArithmeticException.class, () -> {
            calculator.divide(10, 0);
        });
    }
    
    @Test
    void null値での例外発生テスト() {
        StringProcessor processor = new StringProcessor();
        
        // NullPointerExceptionが投げられることを検証
        assertThrows(NullPointerException.class, () -> {
            processor.process(null);
        });
    }
    
    @Test
    void 無効な引数での例外発生テスト() {
        UserManager userManager = new UserManager();
        
        // IllegalArgumentExceptionが投げられることを検証
        assertThrows(IllegalArgumentException.class, () -> {
            userManager.createUser("", "invalid-email");
        });
    }
}</code></pre>

                    <h4>6.2.2 例外メッセージの検証</h4>
                    
                    <p>例外が投げられるだけでなく、適切なエラーメッセージが設定されているかも重要です：</p>

                    <pre class="code-block"><code class="language-java">@Test
void 例外メッセージの詳細検証() {
    BankAccount account = new BankAccount("12345", 1000.0);
    
    // 例外オブジェクトを取得してメッセージを検証
    Exception exception = assertThrows(IllegalArgumentException.class, () -> {
        account.withdraw(1500.0);
    });
    
    // メッセージの内容を検証
    assertEquals("残高不足です。現在の残高: 1000.0", exception.getMessage());
    
    // メッセージに特定の文字列が含まれているかを検証
    assertTrue(exception.getMessage().contains("残高不足"));
    assertTrue(exception.getMessage().contains("1000.0"));
}

@Test
void カスタム例外の詳細検証() {
    EmailService emailService = new EmailService();
    
    InvalidEmailException exception = assertThrows(InvalidEmailException.class, () -> {
        emailService.sendEmail("invalid-email");
    });
    
    // カスタム例外の詳細を検証
    assertEquals("メールアドレスが無効です", exception.getMessage());
    assertEquals("invalid-email", exception.getInvalidEmail());
    assertEquals(ErrorCode.INVALID_EMAIL_FORMAT, exception.getErrorCode());
}</code></pre>

                    <h4>6.2.3 複数の例外条件のテスト</h4>
                    
                    <pre class="code-block"><code class="language-java">@Test
void 複数の例外条件を一度にテスト() {
    PasswordValidator validator = new PasswordValidator();
    
    // 複数の例外条件をまとめてテスト
    assertAll("パスワード検証の異常系テスト",
        () -> assertThrows(IllegalArgumentException.class, 
            () -> validator.validate(null), 
            "null値でIllegalArgumentExceptionが発生すること"),
            
        () -> assertThrows(IllegalArgumentException.class, 
            () -> validator.validate(""), 
            "空文字列でIllegalArgumentExceptionが発生すること"),
            
        () -> assertThrows(WeakPasswordException.class, 
            () -> validator.validate("123"), 
            "短すぎるパスワードでWeakPasswordExceptionが発生すること"),
            
        () -> assertThrows(WeakPasswordException.class, 
            () -> validator.validate("password"), 
            "単純すぎるパスワードでWeakPasswordExceptionが発生すること")
    );
}</code></pre>

                    <div class="exercise-container">
                        <h5>実習 6-1: 注文システムの包括的例外テスト</h5>
                        <p>オンラインショッピングの注文システムで、様々な例外条件をテストしてみましょう。</p>
                        
                        <h6>手順1: 注文システムの作成</h6>
                        <p><code>OrderSystem.java</code>と関連クラスを作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import java.time.LocalDateTime;
import java.util.*;

public class OrderSystem {
    private Map&lt;String, Product&gt; inventory = new HashMap&lt;&gt;();
    private Map&lt;String, Customer&gt; customers = new HashMap&lt;&gt;();
    
    public void addProduct(Product product) {
        if (product == null) {
            throw new IllegalArgumentException("商品情報がnullです");
        }
        if (product.getPrice() < 0) {
            throw new IllegalArgumentException("商品価格は0以上である必要があります");
        }
        inventory.put(product.getId(), product);
    }
    
    public void registerCustomer(Customer customer) {
        if (customer == null) {
            throw new IllegalArgumentException("顧客情報がnullです");
        }
        if (customer.getEmail() == null || customer.getEmail().isEmpty()) {
            throw new InvalidCustomerException("メールアドレスが設定されていません");
        }
        if (!customer.getEmail().contains("@")) {
            throw new InvalidCustomerException("無効なメールアドレス形式: " + customer.getEmail());
        }
        customers.put(customer.getId(), customer);
    }
    
    public Order createOrder(String customerId, List&lt;OrderItem&gt; items) {
        if (customerId == null || customerId.isEmpty()) {
            throw new IllegalArgumentException("顧客IDが指定されていません");
        }
        
        Customer customer = customers.get(customerId);
        if (customer == null) {
            throw new CustomerNotFoundException("顧客が見つかりません: " + customerId);
        }
        
        if (items == null || items.isEmpty()) {
            throw new EmptyOrderException("注文商品が指定されていません");
        }
        
        // 在庫チェック
        for (OrderItem item : items) {
            Product product = inventory.get(item.getProductId());
            if (product == null) {
                throw new ProductNotFoundException("商品が見つかりません: " + item.getProductId());
            }
            if (product.getStock() < item.getQuantity()) {
                throw new InsufficientStockException(
                    String.format("在庫不足: 商品ID %s (在庫: %d, 注文数: %d)",
                        item.getProductId(), product.getStock(), item.getQuantity())
                );
            }
        }
        
        return new Order(UUID.randomUUID().toString(), customer, items, LocalDateTime.now());
    }
}

// カスタム例外クラス
class InvalidCustomerException extends RuntimeException {
    public InvalidCustomerException(String message) { super(message); }
}

class CustomerNotFoundException extends RuntimeException {
    private String customerId;
    
    public CustomerNotFoundException(String message) { 
        super(message);
        this.customerId = extractCustomerIdFromMessage(message);
    }
    
    private String extractCustomerIdFromMessage(String message) {
        // 簡略化された実装
        return message.substring(message.lastIndexOf(": ") + 2);
    }
    
    public String getCustomerId() { return customerId; }
}

class EmptyOrderException extends RuntimeException {
    public EmptyOrderException(String message) { super(message); }
}

class ProductNotFoundException extends RuntimeException {
    public ProductNotFoundException(String message) { super(message); }
}

class InsufficientStockException extends RuntimeException {
    public InsufficientStockException(String message) { super(message); }
}

// エンティティクラス（簡略化）
class Product {
    private String id, name;
    private double price;
    private int stock;
    
    public Product(String id, String name, double price, int stock) {
        this.id = id; this.name = name; this.price = price; this.stock = stock;
    }
    
    public String getId() { return id; }
    public String getName() { return name; }
    public double getPrice() { return price; }
    public int getStock() { return stock; }
}

class Customer {
    private String id, name, email;
    
    public Customer(String id, String name, String email) {
        this.id = id; this.name = name; this.email = email;
    }
    
    public String getId() { return id; }
    public String getName() { return name; }
    public String getEmail() { return email; }
}

class OrderItem {
    private String productId;
    private int quantity;
    
    public OrderItem(String productId, int quantity) {
        this.productId = productId; this.quantity = quantity;
    }
    
    public String getProductId() { return productId; }
    public int getQuantity() { return quantity; }
}

class Order {
    private String id;
    private Customer customer;
    private List&lt;OrderItem&gt; items;
    private LocalDateTime orderDate;
    
    public Order(String id, Customer customer, List&lt;OrderItem&gt; items, LocalDateTime orderDate) {
        this.id = id; this.customer = customer; this.items = items; this.orderDate = orderDate;
    }
    
    public String getId() { return id; }
    public Customer getCustomer() { return customer; }
    public List&lt;OrderItem&gt; getItems() { return items; }
    public LocalDateTime getOrderDate() { return orderDate; }
}</code></pre>

                        <h6>手順2: 包括的な例外テストクラスの作成</h6>
                        <p><code>OrderSystemExceptionTest.java</code>を作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;

class OrderSystemExceptionTest {
    private OrderSystem orderSystem;
    private Customer validCustomer;
    private Product validProduct;
    
    @BeforeEach
    void setUp() {
        orderSystem = new OrderSystem();
        validCustomer = new Customer("CUST001", "田中太郎", "tanaka@example.com");
        validProduct = new Product("PROD001", "ノートパソコン", 89800.0, 10);
        
        orderSystem.registerCustomer(validCustomer);
        orderSystem.addProduct(validProduct);
    }
    
    @Test
    void 商品追加での例外テスト() {
        assertAll("商品追加の異常系テスト",
            () -> {
                IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, 
                    () -> orderSystem.addProduct(null));
                assertEquals("商品情報がnullです", exception.getMessage());
            },
            
            () -> {
                Product invalidPriceProduct = new Product("PROD002", "無効商品", -100.0, 5);
                IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, 
                    () -> orderSystem.addProduct(invalidPriceProduct));
                assertTrue(exception.getMessage().contains("商品価格は0以上"));
            }
        );
    }
    
    @Test
    void 顧客登録での例外テスト() {
        assertAll("顧客登録の異常系テスト",
            () -> {
                IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, 
                    () -> orderSystem.registerCustomer(null));
                assertEquals("顧客情報がnullです", exception.getMessage());
            },
            
            () -> {
                Customer noEmailCustomer = new Customer("CUST002", "佐藤花子", "");
                InvalidCustomerException exception = assertThrows(InvalidCustomerException.class, 
                    () -> orderSystem.registerCustomer(noEmailCustomer));
                assertEquals("メールアドレスが設定されていません", exception.getMessage());
            },
            
            () -> {
                Customer invalidEmailCustomer = new Customer("CUST003", "鈴木一郎", "invalid-email");
                InvalidCustomerException exception = assertThrows(InvalidCustomerException.class, 
                    () -> orderSystem.registerCustomer(invalidEmailCustomer));
                assertTrue(exception.getMessage().contains("無効なメールアドレス形式"));
                assertTrue(exception.getMessage().contains("invalid-email"));
            }
        );
    }
    
    @Test
    void 注文作成での例外テスト() {
        List&lt;OrderItem&gt; validItems = Arrays.asList(new OrderItem("PROD001", 2));
        
        assertAll("注文作成の異常系テスト",
            () -> {
                IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, 
                    () -> orderSystem.createOrder(null, validItems));
                assertEquals("顧客IDが指定されていません", exception.getMessage());
            },
            
            () -> {
                IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, 
                    () -> orderSystem.createOrder("", validItems));
                assertEquals("顧客IDが指定されていません", exception.getMessage());
            },
            
            () -> {
                CustomerNotFoundException exception = assertThrows(CustomerNotFoundException.class, 
                    () -> orderSystem.createOrder("NONEXISTENT", validItems));
                assertEquals("顧客が見つかりません: NONEXISTENT", exception.getMessage());
                assertEquals("NONEXISTENT", exception.getCustomerId());
            },
            
            () -> {
                EmptyOrderException exception = assertThrows(EmptyOrderException.class, 
                    () -> orderSystem.createOrder("CUST001", null));
                assertEquals("注文商品が指定されていません", exception.getMessage());
            },
            
            () -> {
                EmptyOrderException exception = assertThrows(EmptyOrderException.class, 
                    () -> orderSystem.createOrder("CUST001", new ArrayList&lt;&gt;()));
                assertEquals("注文商品が指定されていません", exception.getMessage());
            }
        );
    }
    
    @Test
    void 商品関連の例外テスト() {
        List&lt;OrderItem&gt; invalidProductItems = Arrays.asList(new OrderItem("NONEXISTENT", 1));
        
        ProductNotFoundException exception = assertThrows(ProductNotFoundException.class, 
            () -> orderSystem.createOrder("CUST001", invalidProductItems));
        
        assertEquals("商品が見つかりません: NONEXISTENT", exception.getMessage());
    }
    
    @Test
    void 在庫不足での例外テスト() {
        List&lt;OrderItem&gt; excessiveOrderItems = Arrays.asList(new OrderItem("PROD001", 15)); // 在庫10を超える
        
        InsufficientStockException exception = assertThrows(InsufficientStockException.class, 
            () -> orderSystem.createOrder("CUST001", excessiveOrderItems));
        
        String expectedMessage = "在庫不足: 商品ID PROD001 (在庫: 10, 注文数: 15)";
        assertEquals(expectedMessage, exception.getMessage());
    }
    
    @Test
    void 正常系での例外が発生しないことを確認() {
        List&lt;OrderItem&gt; normalItems = Arrays.asList(
            new OrderItem("PROD001", 5)
        );
        
        // 例外が発生しないことを確認
        assertDoesNotThrow(() -> {
            Order order = orderSystem.createOrder("CUST001", normalItems);
            assertNotNull(order);
            assertEquals("CUST001", order.getCustomer().getId());
            assertEquals(1, order.getItems().size());
        });
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>このテストでは以下の例外処理パターンをカバーしています：</p>
                        <ul>
                            <li>null値チェックによるIllegalArgumentException</li>
                            <li>ビジネスルール違反によるカスタム例外</li>
                            <li>リソースが見つからない場合のNotFoundException</li>
                            <li>例外メッセージの詳細検証</li>
                            <li>正常系で例外が発生しないことの確認</li>
                        </ul>
                    </div>

                    <h3 class="section-title">6.3 タイムアウトテストの実装</h3>
                    
                    <p>システムの応答性や性能要件を検証するため、処理時間に関するテストも重要です。JUnit 5では複数の方法でタイムアウトをテストできます。</p>

                    <h4>6.3.1 @Timeoutアノテーションの使用</h4>
                    
                    <pre class="code-block"><code class="language-java">import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import java.time.Duration;
import java.util.concurrent.TimeUnit;

class TimeoutTestExamples {
    
    @Test
    @Timeout(2) // 2秒でタイムアウト
    void 高速処理のテスト() {
        FastProcessor processor = new FastProcessor();
        
        // この処理は2秒以内に完了する必要がある
        String result = processor.quickProcess("データ");
        
        assertNotNull(result);
    }
    
    @Test
    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS) // 500ミリ秒でタイムアウト
    void 超高速処理のテスト() {
        CacheService cache = new CacheService();
        
        // キャッシュアクセスは500ms以内に完了すべき
        String cachedValue = cache.get("key");
        
        assertEquals("cached_value", cachedValue);
    }
    
    @Test
    @Timeout(10) // 10秒でタイムアウト
    void 長時間処理のテスト() {
        BatchProcessor processor = new BatchProcessor();
        
        // バッチ処理でも10秒以内には完了すべき
        BatchResult result = processor.processBatch(createLargeDataSet());
        
        assertTrue(result.isSuccessful());
    }
}</code></pre>

                    <h4>6.3.2 assertTimeout()とassertTimeoutPreemptively()の使用</h4>
                    
                    <pre class="code-block"><code class="language-java">@Test
void 実行時間の詳細な検証() {
    DatabaseService dbService = new DatabaseService();
    
    // 処理が指定時間内に完了することを確認（処理の完了を待つ）
    assertTimeout(Duration.ofSeconds(3), () -> {
        return dbService.executeQuery("SELECT * FROM products");
    });
    
    // 処理が指定時間内に完了することを確認（タイムアウト時に即座に中断）
    assertTimeoutPreemptively(Duration.ofMillis(100), () -> {
        return dbService.getFromCache("cached_data");
    });
}

@Test
void 実行時間と結果の両方を検証() {
    SortingService sortingService = new SortingService();
    int[] largeArray = generateLargeArray(10000);
    
    // 実行時間を検証し、結果も取得
    int[] sortedArray = assertTimeout(Duration.ofSeconds(1), () -> {
        return sortingService.quickSort(largeArray);
    });
    
    // 結果の正確性も検証
    assertTrue(isSorted(sortedArray));
    assertEquals(largeArray.length, sortedArray.length);
}

@Test
void 性能劣化の検出() {
    SearchService searchService = new SearchService();
    List&lt;String&gt; searchTerms = Arrays.asList("Java", "JUnit", "Testing");
    
    // 複数の検索処理の実行時間を検証
    for (String term : searchTerms) {
        long startTime = System.currentTimeMillis();
        
        List&lt;SearchResult&gt; results = assertTimeout(Duration.ofMillis(200), () -> {
            return searchService.search(term);
        });
        
        long executionTime = System.currentTimeMillis() - startTime;
        
        // 結果の妥当性も確認
        assertNotNull(results);
        assertTrue(executionTime < 200, 
            String.format("検索 '%s' の実行時間が期待値を超えています: %dms", term, executionTime));
    }
}</code></pre>

                    <div class="highlight">
                        <h6><strong>assertTimeout vs assertTimeoutPreemptively</strong></h6>
                        <ul>
                            <li><strong>assertTimeout</strong>：処理の完了を待ち、実行時間を検証します。処理が完了してから結果を取得できます。</li>
                            <li><strong>assertTimeoutPreemptively</strong>：タイムアウト時に処理を強制的に中断します。別スレッドで実行されるため、ThreadLocalなどの使用に注意が必要です。</li>
                        </ul>
                    </div>

                    <h3 class="section-title">6.4 パフォーマンステストの設計</h3>
                    
                    <p>単純なタイムアウトテストを超えて、システムの性能特性を詳細に検証するテストを作成してみましょう。</p>

                    <h4>6.4.1 レスポンス時間の統計的検証</h4>
                    
                    <pre class="code-block"><code class="language-java">@Test
void 統計的性能テスト() {
    ApiService apiService = new ApiService();
    List&lt;Long&gt; executionTimes = new ArrayList&lt;&gt;();
    int testRuns = 10;
    
    // 複数回実行して実行時間を収集
    for (int i = 0; i < testRuns; i++) {
        long startTime = System.nanoTime();
        
        assertTimeout(Duration.ofMillis(500), () -> {
            return apiService.callExternalApi();
        });
        
        long executionTime = (System.nanoTime() - startTime) / 1_000_000; // ミリ秒に変換
        executionTimes.add(executionTime);
    }
    
    // 統計的な検証
    double averageTime = executionTimes.stream().mapToLong(Long::longValue).average().orElse(0);
    long maxTime = Collections.max(executionTimes);
    long minTime = Collections.min(executionTimes);
    
    assertTrue(averageTime < 300, String.format("平均実行時間が期待値を超えています: %.2fms", averageTime));
    assertTrue(maxTime < 500, String.format("最大実行時間が期待値を超えています: %dms", maxTime));
    assertTrue(minTime > 0, "最小実行時間が無効です");
    
    // 実行時間のばらつきも検証
    double variance = calculateVariance(executionTimes, averageTime);
    assertTrue(variance < 10000, String.format("実行時間のばらつきが大きすぎます: %.2f", variance));
}

@Test
void 負荷テストシミュレーション() {
    ConnectionPool connectionPool = new ConnectionPool(10); // 最大10接続
    List&lt;CompletableFuture&lt;Boolean&gt;&gt; futures = new ArrayList&lt;&gt;();
    
    // 同時に20個の接続リクエストを発行
    for (int i = 0; i < 20; i++) {
        CompletableFuture&lt;Boolean&gt; future = CompletableFuture.supplyAsync(() -> {
            return assertTimeout(Duration.ofSeconds(5), () -> {
                Connection conn = connectionPool.getConnection();
                Thread.sleep(100); // 短時間の作業をシミュレート
                connectionPool.releaseConnection(conn);
                return true;
            });
        });
        futures.add(future);
    }
    
    // すべての接続リクエストが完了することを確認
    assertTimeout(Duration.ofSeconds(10), () -> {
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
    });
    
    // すべての処理が成功したことを確認
    for (CompletableFuture&lt;Boolean&gt; future : futures) {
        assertTrue(future.join());
    }
}</code></pre>

                    <div class="exercise-container">
                        <h5>実習 6-2: ファイル処理システムの性能・例外テスト</h5>
                        <p>大量のファイルを処理するシステムで、性能要件と異常系の両方をテストしてみましょう。</p>
                        
                        <h6>手順1: ファイル処理システムの作成</h6>
                        <p><code>FileProcessingSystem.java</code>を作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.*;

public class FileProcessingSystem {
    private final ExecutorService executor;
    private final int maxFileSizeMB;
    
    public FileProcessingSystem(int maxFileSizeMB) {
        this.executor = Executors.newFixedThreadPool(4);
        this.maxFileSizeMB = maxFileSizeMB;
    }
    
    public ProcessingResult processFile(String filePath) throws IOException {
        if (filePath == null || filePath.isEmpty()) {
            throw new IllegalArgumentException("ファイルパスが指定されていません");
        }
        
        Path path = Paths.get(filePath);
        if (!Files.exists(path)) {
            throw new FileNotFoundException("ファイルが見つかりません: " + filePath);
        }
        
        long fileSizeBytes = Files.size(path);
        long fileSizeMB = fileSizeBytes / (1024 * 1024);
        
        if (fileSizeMB > maxFileSizeMB) {
            throw new FileSizeExceededException(
                String.format("ファイルサイズが上限を超えています: %dMB (上限: %dMB)", 
                    fileSizeMB, maxFileSizeMB));
        }
        
        // ファイル処理をシミュレート
        long startTime = System.currentTimeMillis();
        
        try {
            Thread.sleep(fileSizeMB * 10); // ファイルサイズに比例した処理時間
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new ProcessingInterruptedException("処理が中断されました");
        }
        
        long processingTime = System.currentTimeMillis() - startTime;
        
        return new ProcessingResult(filePath, fileSizeBytes, processingTime, true);
    }
    
    public List&lt;ProcessingResult&gt; processBatch(List&lt;String&gt; filePaths, Duration timeout) 
            throws InterruptedException, ExecutionException, TimeoutException {
        
        if (filePaths == null || filePaths.isEmpty()) {
            throw new IllegalArgumentException("処理対象ファイルが指定されていません");
        }
        
        List&lt;CompletableFuture&lt;ProcessingResult&gt;&gt; futures = new ArrayList&lt;&gt;();
        
        for (String filePath : filePaths) {
            CompletableFuture&lt;ProcessingResult&gt; future = CompletableFuture.supplyAsync(() -> {
                try {
                    return processFile(filePath);
                } catch (IOException e) {
                    return new ProcessingResult(filePath, 0, 0, false, e.getMessage());
                }
            }, executor);
            futures.add(future);
        }
        
        CompletableFuture&lt;List&lt;ProcessingResult&gt;&gt; allFutures = CompletableFuture.allOf(
            futures.toArray(new CompletableFuture[0])
        ).thenApply(v -> futures.stream()
            .map(CompletableFuture::join)
            .toList()
        );
        
        return allFutures.get(timeout.toMillis(), TimeUnit.MILLISECONDS);
    }
    
    public void shutdown() {
        executor.shutdown();
    }
}

// 例外クラス
class FileSizeExceededException extends RuntimeException {
    public FileSizeExceededException(String message) { super(message); }
}

class ProcessingInterruptedException extends RuntimeException {
    public ProcessingInterruptedException(String message) { super(message); }
}

// 結果クラス
class ProcessingResult {
    private final String filePath;
    private final long fileSize;
    private final long processingTime;
    private final boolean success;
    private final String errorMessage;
    
    public ProcessingResult(String filePath, long fileSize, long processingTime, boolean success) {
        this(filePath, fileSize, processingTime, success, null);
    }
    
    public ProcessingResult(String filePath, long fileSize, long processingTime, boolean success, String errorMessage) {
        this.filePath = filePath;
        this.fileSize = fileSize;
        this.processingTime = processingTime;
        this.success = success;
        this.errorMessage = errorMessage;
    }
    
    // ゲッターメソッド
    public String getFilePath() { return filePath; }
    public long getFileSize() { return fileSize; }
    public long getProcessingTime() { return processingTime; }
    public boolean isSuccess() { return success; }
    public String getErrorMessage() { return errorMessage; }
}</code></pre>

                        <h6>手順2: 性能・例外テストクラスの作成</h6>
                        <p><code>FileProcessingSystemTest.java</code>を作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import org.junit.jupiter.api.*;
import org.junit.jupiter.api.io.TempDir;
import static org.junit.jupiter.api.Assertions.*;
import java.io.*;
import java.nio.file.*;
import java.time.Duration;
import java.util.*;

class FileProcessingSystemTest {
    private FileProcessingSystem processor;
    
    @TempDir
    Path tempDir;
    
    @BeforeEach
    void setUp() {
        processor = new FileProcessingSystem(10); // 10MB上限
    }
    
    @AfterEach
    void tearDown() {
        processor.shutdown();
    }
    
    @Test
    void ファイル処理の例外テスト() {
        assertAll("ファイル処理の異常系テスト",
            () -> {
                IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, 
                    () -> processor.processFile(null));
                assertEquals("ファイルパスが指定されていません", exception.getMessage());
            },
            
            () -> {
                IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, 
                    () -> processor.processFile(""));
                assertEquals("ファイルパスが指定されていません", exception.getMessage());
            },
            
            () -> {
                FileNotFoundException exception = assertThrows(FileNotFoundException.class, 
                    () -> processor.processFile("nonexistent.txt"));
                assertTrue(exception.getMessage().contains("ファイルが見つかりません"));
            }
        );
    }
    
    @Test
    @Timeout(2)
    void 小さなファイルの高速処理テスト() throws IOException {
        // 1KBの小さなファイルを作成
        Path smallFile = tempDir.resolve("small.txt");
        Files.write(smallFile, "テストデータ".repeat(100).getBytes());
        
        long startTime = System.currentTimeMillis();
        
        ProcessingResult result = assertTimeout(Duration.ofSeconds(1), () -> {
            try {
                return processor.processFile(smallFile.toString());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        });
        
        long actualTime = System.currentTimeMillis() - startTime;
        
        assertTrue(result.isSuccess());
        assertTrue(actualTime < 1000, "小さなファイルの処理時間が遅すぎます: " + actualTime + "ms");
    }
    
    @Test
    void ファイルサイズ上限での例外テスト() throws IOException {
        // 上限を超える大きなファイルを作成（模擬）
        Path largeFile = tempDir.resolve("large.txt");
        
        // 実際には大きなファイルを作らず、サイズだけチェックするためのダミーファイル
        // この例では例外メッセージのテストに焦点を当てる
        
        FileSizeExceededException exception = assertThrows(FileSizeExceededException.class, () -> {
            // 大きなファイルのサイズをシミュレートする別の方法でテスト
            throw new FileSizeExceededException("ファイルサイズが上限を超えています: 15MB (上限: 10MB)");
        });
        
        assertTrue(exception.getMessage().contains("上限を超えています"));
        assertTrue(exception.getMessage().contains("15MB"));
        assertTrue(exception.getMessage().contains("上限: 10MB"));
    }
    
    @Test
    @Timeout(10)
    void バッチ処理の性能テスト() throws Exception {
        // 複数の小さなファイルを作成
        List&lt;String&gt; filePaths = new ArrayList&lt;&gt;();
        
        for (int i = 0; i < 5; i++) {
            Path file = tempDir.resolve("batch_" + i + ".txt");
            Files.write(file, ("バッチテストデータ" + i).repeat(50).getBytes());
            filePaths.add(file.toString());
        }
        
        long startTime = System.currentTimeMillis();
        
        List&lt;ProcessingResult&gt; results = assertTimeout(Duration.ofSeconds(8), () -> {
            try {
                return processor.processBatch(filePaths, Duration.ofSeconds(7));
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
        
        long totalTime = System.currentTimeMillis() - startTime;
        
        // 結果の検証
        assertEquals(5, results.size());
        
        long successfulCount = results.stream().mapToLong(r -> r.isSuccess() ? 1 : 0).sum();
        assertEquals(5, successfulCount, "すべてのファイルが正常に処理されるべきです");
        
        // 並列処理の効果を確認（逐次処理より高速であること）
        long sequentialTimeEstimate = results.stream().mapToLong(ProcessingResult::getProcessingTime).sum();
        assertTrue(totalTime < sequentialTimeEstimate * 0.8, 
            String.format("並列処理の効果が見られません。実際: %dms, 逐次推定: %dms", 
                totalTime, sequentialTimeEstimate));
    }
    
    @Test
    void バッチ処理での例外テスト() {
        assertAll("バッチ処理の異常系テスト",
            () -> {
                IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, 
                    () -> processor.processBatch(null, Duration.ofSeconds(5)));
                assertEquals("処理対象ファイルが指定されていません", exception.getMessage());
            },
            
            () -> {
                IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, 
                    () -> processor.processBatch(new ArrayList&lt;&gt;(), Duration.ofSeconds(5)));
                assertEquals("処理対象ファイルが指定されていません", exception.getMessage());
            }
        );
    }
    
    @Test
    void 処理結果の詳細検証() throws IOException {
        Path testFile = tempDir.resolve("result_test.txt");
        String testContent = "結果検証用テストデータ";
        Files.write(testFile, testContent.getBytes());
        
        ProcessingResult result = processor.processFile(testFile.toString());
        
        assertAll("処理結果の詳細検証",
            () -> assertTrue(result.isSuccess(), "処理が成功すること"),
            () -> assertEquals(testFile.toString(), result.getFilePath(), "ファイルパスが正しいこと"),
            () -> assertTrue(result.getFileSize() > 0, "ファイルサイズが取得されていること"),
            () -> assertTrue(result.getProcessingTime() >= 0, "処理時間が記録されていること"),
            () -> assertNull(result.getErrorMessage(), "エラーメッセージがnullであること")
        );
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>このテストでは以下の性能・例外要件をカバーしています：</p>
                        <ul>
                            <li>@Timeoutアノテーションによる処理時間の上限制御</li>
                            <li>assertTimeoutによる詳細な実行時間検証</li>
                            <li>並列処理の性能効果の測定</li>
                            <li>ファイルサイズ制限などのビジネスルール例外</li>
                            <li>バッチ処理での複合的な例外ハンドリング</li>
                        </ul>
                    </div>

                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li><strong>assertThrows()の戻り値は何ですか？</strong>
                                <ul>
                                    <li>a) boolean値（true/false）</li>
                                    <li>b) 投げられた例外オブジェクト</li>
                                    <li>c) void（戻り値なし）</li>
                                    <li>d) テストメソッドの実行結果</li>
                                </ul>
                            </li>
                            <li><strong>assertTimeout()とassertTimeoutPreemptively()の違いは何ですか？</strong>
                                <ul>
                                    <li>a) 前者は秒単位、後者はミリ秒単位</li>
                                    <li>b) 前者は処理完了を待つ、後者はタイムアウト時に中断する</li>
                                    <li>c) 前者は例外を投げる、後者は投げない</li>
                                    <li>d) 機能に違いはない</li>
                                </ul>
                            </li>
                            <li><strong>@Timeoutアノテーションの単位を指定する場合、どのパラメータを使用しますか？</strong>
                                <ul>
                                    <li>a) timeUnit</li>
                                    <li>b) unit</li>
                                    <li>c) duration</li>
                                    <li>d) scale</li>
                                </ul>
                            </li>
                            <li><strong>例外テストで検証すべき要素として適切でないものはどれですか？</strong>
                                <ul>
                                    <li>a) 例外の種類（クラス）</li>
                                    <li>b) 例外メッセージの内容</li>
                                    <li>c) 例外が発生した行番号</li>
                                    <li>d) 例外の発生条件</li>
                                </ul>
                            </li>
                        </ol>
                        
                        <details style="margin-top: 1rem;">
                            <summary><strong>解答を見る</strong></summary>
                            <div style="margin-top: 0.5rem;">
                                <p><strong>1.</strong> b) 投げられた例外オブジェクト</p>
                                <p><strong>2.</strong> b) 前者は処理完了を待つ、後者はタイムアウト時に中断する</p>
                                <p><strong>3.</strong> b) unit</p>
                                <p><strong>4.</strong> c) 例外が発生した行番号</p>
                            </div>
                        </details>
                    </div>

                    <!-- Chapter navigation -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="junit-learning-material-5.html" class="btn btn-secondary">← 前の章：パラメータ化テストと動的テスト</a>
                        <a href="junit-learning-material-7.html" class="btn btn-primary">次の章：テストの組織化とベストプラクティス →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js initialization -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js initialization -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>