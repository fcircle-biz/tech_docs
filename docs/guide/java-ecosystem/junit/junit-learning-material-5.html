<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JUnit学習教材 第5章 - パラメータ化テストと動的テスト</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        
        .navbar {
            background-color: #f57c00;
        }
        
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        
        .chapter-title {
            color: #f57c00;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #f57c00;
            padding-bottom: 0.5rem;
        }
        
        .section-title {
            color: #ff9800;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        
        .quiz-container {
            background-color: #fff3e0;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #f57c00;
        }
        
        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }
        
        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }
        
        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }
        
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }
        
        .nav-link.active {
            background-color: #f57c00 !important;
            color: white !important;
        }
    </style>
</head>
<body>
    <!-- Navigation bar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand">
                <strong>JUnit学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- Sidebar -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-1.html">
                                第1章: JUnit基礎とセットアップ
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-2.html">
                                第2章: 基本的なテストケースの作成
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-3.html">
                                第3章: アサーションとマッチャー
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-4.html">
                                第4章: テストライフサイクルとアノテーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="junit-learning-material-5.html">
                                第5章: パラメータ化テストと動的テスト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-6.html">
                                第6章: 例外テストとタイムアウト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-7.html">
                                第7章: テストの組織化とベストプラクティス
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- Main content -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第5章: パラメータ化テストと動的テスト</h1>
                </div>

                <div id="chapter5">
                    <h2 class="chapter-title">効率的なテストケース生成と実行</h2>
                    
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>パラメータ化テストの基本概念と利点を理解する</li>
                            <li>@ValueSource、@CsvSource、@CsvFileSourceの使い方を習得する</li>
                            <li>@MethodSourceを使用した複雑なテストデータの提供</li>
                            <li>@DynamicTestを使った実行時テスト生成</li>
                            <li>効率的なテストデータ管理のベストプラクティス</li>
                        </ul>
                    </div>

                    <h3 class="section-title">5.1 パラメータ化テストとは</h3>
                    
                    <p>パラメータ化テストは、同じテストロジックを異なるデータセットで複数回実行する仕組みです。従来のテストメソッドをコピーして値だけを変更する必要がなくなり、テストコードがよりDRY（Don't Repeat Yourself）になります。</p>

                    <div class="mermaid">
                        flowchart TD
                            A["従来のテスト"] --> B["テストメソッド1"]
                            A --> C["テストメソッド2"]
                            A --> D["テストメソッド3"]
                            B --> E["同じロジック、異なるデータ"]
                            C --> E
                            D --> E
                            
                            F["パラメータ化テスト"] --> G["1つのテストメソッド"]
                            G --> H["複数のデータセット"]
                            H --> I["自動的に複数回実行"]
                    </div>

                    <h4>5.1.1 パラメータ化テストの利点</h4>
                    <ul>
                        <li><strong>コードの重複削減</strong>：同じテストロジックを何度も書く必要がない</li>
                        <li><strong>保守性向上</strong>：テストロジックを1箇所で管理できる</li>
                        <li><strong>網羅性向上</strong>：多くのテストケースを効率的に作成できる</li>
                        <li><strong>可読性向上</strong>：テストデータとロジックが分離される</li>
                    </ul>

                    <h3 class="section-title">5.2 @ValueSourceを使ったシンプルなパラメータ化</h3>
                    
                    <p>最もシンプルなパラメータ化テストは、@ValueSourceアノテーションを使用します。</p>

                    <h4>5.2.1 基本的な使用方法</h4>
                    
                    <pre class="code-block"><code class="language-java">import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import static org.junit.jupiter.api.Assertions.*;

class MathUtilsTest {
    
    @ParameterizedTest
    @ValueSource(ints = {1, 2, 3, 5, 8, 13, 21})
    void 正の数値で絶対値テスト(int number) {
        MathUtils mathUtils = new MathUtils();
        
        int result = mathUtils.abs(number);
        
        assertEquals(number, result);
    }
    
    @ParameterizedTest
    @ValueSource(ints = {-1, -2, -5, -10, -100})
    void 負の数値で絶対値テスト(int number) {
        MathUtils mathUtils = new MathUtils();
        
        int result = mathUtils.abs(number);
        
        assertEquals(-number, result);  // 負の数の絶対値は正の数
    }
    
    @ParameterizedTest
    @ValueSource(strings = {"hello", "world", "junit", "testing"})
    void 文字列の大文字変換テスト(String input) {
        StringProcessor processor = new StringProcessor();
        
        String result = processor.toUpperCase(input);
        
        assertEquals(input.toUpperCase(), result);
        assertFalse(result.isEmpty());
    }
}</code></pre>

                    <h4>5.2.2 様々なデータ型での@ValueSource</h4>
                    
                    <pre class="code-block"><code class="language-java">class ValueSourceExamplesTest {
    
    @ParameterizedTest
    @ValueSource(strings = {"", "  ", "\t", "\n"})
    void 空または空白文字列のテスト(String input) {
        assertTrue(input.trim().isEmpty());
    }
    
    @ParameterizedTest
    @ValueSource(doubles = {0.1, 0.5, 1.0, 2.5, 10.0})
    void 正の浮動小数点数のテスト(double number) {
        assertTrue(number > 0);
        assertFalse(Double.isNaN(number));
    }
    
    @ParameterizedTest
    @ValueSource(booleans = {true, false})
    void ブール値のテスト(boolean value) {
        assertEquals(value, Boolean.valueOf(value));
    }
    
    @ParameterizedTest
    @ValueSource(longs = {1L, 100L, 1000L, 1000000L})
    void 大きな数値のテスト(long number) {
        assertTrue(number > 0);
        assertTrue(Long.toString(number).length() > 0);
    }
}</code></pre>

                    <div class="highlight">
                        <h6><strong>@ValueSourceで使用できるデータ型</strong></h6>
                        <ul>
                            <li><strong>strings</strong>：文字列の配列</li>
                            <li><strong>ints</strong>：整数の配列</li>
                            <li><strong>longs</strong>：長整数の配列</li>
                            <li><strong>doubles</strong>：浮動小数点数の配列</li>
                            <li><strong>floats</strong>：単精度浮動小数点数の配列</li>
                            <li><strong>booleans</strong>：真偽値の配列</li>
                            <li><strong>chars</strong>：文字の配列</li>
                            <li><strong>shorts</strong>：短整数の配列</li>
                            <li><strong>bytes</strong>：バイトの配列</li>
                        </ul>
                    </div>

                    <h3 class="section-title">5.3 @CsvSourceによる複数パラメータのテスト</h3>
                    
                    <p>複数のパラメータを組み合わせてテストする場合は、@CsvSourceを使用します。</p>

                    <h4>5.3.1 基本的なCSVパラメータ</h4>
                    
                    <pre class="code-block"><code class="language-java">class CalculatorParameterizedTest {
    
    @ParameterizedTest
    @CsvSource({
        "1, 1, 2",
        "2, 3, 5", 
        "10, 15, 25",
        "-1, 1, 0",
        "0, 0, 0"
    })
    void 加算テスト(int a, int b, int expected) {
        Calculator calculator = new Calculator();
        
        int result = calculator.add(a, b);
        
        assertEquals(expected, result);
    }
    
    @ParameterizedTest
    @CsvSource({
        "10, 2, 5",
        "15, 3, 5",
        "20, 4, 5",
        "100, 10, 10"
    })
    void 除算テスト(int dividend, int divisor, int expected) {
        Calculator calculator = new Calculator();
        
        int result = calculator.divide(dividend, divisor);
        
        assertEquals(expected, result);
    }
    
    @ParameterizedTest
    @CsvSource({
        "hello, 5",
        "world, 5",
        "junit, 5",
        "testing, 7",
        "parameterized, 12"
    })
    void 文字列長さテスト(String input, int expectedLength) {
        assertEquals(expectedLength, input.length());
    }
}</code></pre>

                    <h4>5.3.2 文字列を含むCSVデータ</h4>
                    
                    <pre class="code-block"><code class="language-java">class UserValidationTest {
    
    @ParameterizedTest
    @CsvSource({
        "'田中太郎', 'tanaka@example.com', true",
        "'', 'test@example.com', false",
        "'山田花子', '', false",
        "'鈴木一郎', 'invalid-email', false",
        "'佐藤次郎', 'sato@test.co.jp', true"
    })
    void ユーザー検証テスト(String name, String email, boolean expectedValid) {
        UserValidator validator = new UserValidator();
        User user = new User(name, email);
        
        boolean isValid = validator.isValid(user);
        
        assertEquals(expectedValid, isValid);
    }
    
    @ParameterizedTest
    @CsvSource(value = {
        "強力なパスワード123!:true",
        "weak:false", 
        "12345678:false",
        "StrongPass123!:true",
        "password:false"
    }, delimiter = ':')
    void パスワード強度テスト(String password, boolean expectedStrong) {
        PasswordValidator validator = new PasswordValidator();
        
        boolean isStrong = validator.isStrong(password);
        
        assertEquals(expectedStrong, isStrong);
    }
}</code></pre>

                    <div class="exercise-container">
                        <h5>実習 5-1: 成績評価システムのパラメータ化テスト</h5>
                        <p>学生の成績を評価するシステムで、様々なパラメータ化テストを作成してみましょう。</p>
                        
                        <h6>手順1: テスト対象クラスの作成</h6>
                        <p><code>GradeEvaluator.java</code>を作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">public class GradeEvaluator {
    
    public String getLetterGrade(int score) {
        if (score < 0 || score > 100) {
            throw new IllegalArgumentException("スコアは0-100の範囲で入力してください");
        }
        
        if (score >= 90) return "A";
        if (score >= 80) return "B";
        if (score >= 70) return "C";
        if (score >= 60) return "D";
        return "F";
    }
    
    public boolean isPassingGrade(String letterGrade) {
        return !"F".equals(letterGrade);
    }
    
    public double calculateGPA(String letterGrade) {
        switch (letterGrade) {
            case "A": return 4.0;
            case "B": return 3.0;
            case "C": return 2.0;
            case "D": return 1.0;
            case "F": return 0.0;
            default: throw new IllegalArgumentException("無効な成績: " + letterGrade);
        }
    }
    
    public String getGradeComment(int score) {
        String grade = getLetterGrade(score);
        switch (grade) {
            case "A": return "優秀";
            case "B": return "良好";
            case "C": return "普通";
            case "D": return "要努力";
            case "F": return "不合格";
            default: return "不明";
        }
    }
}</code></pre>

                        <h6>手順2: パラメータ化テストクラスの作成</h6>
                        <p><code>GradeEvaluatorTest.java</code>を作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.junit.jupiter.params.provider.CsvSource;
import static org.junit.jupiter.api.Assertions.*;

class GradeEvaluatorTest {
    private final GradeEvaluator evaluator = new GradeEvaluator();
    
    @ParameterizedTest
    @ValueSource(ints = {90, 95, 100})
    void A評価のテスト(int score) {
        String grade = evaluator.getLetterGrade(score);
        assertEquals("A", grade);
        assertTrue(evaluator.isPassingGrade(grade));
    }
    
    @ParameterizedTest
    @ValueSource(ints = {80, 85, 89})
    void B評価のテスト(int score) {
        String grade = evaluator.getLetterGrade(score);
        assertEquals("B", grade);
        assertTrue(evaluator.isPassingGrade(grade));
    }
    
    @ParameterizedTest
    @ValueSource(ints = {0, 30, 59})
    void F評価のテスト(int score) {
        String grade = evaluator.getLetterGrade(score);
        assertEquals("F", grade);
        assertFalse(evaluator.isPassingGrade(grade));
    }
    
    @ParameterizedTest
    @CsvSource({
        "95, A, 4.0, 優秀",
        "85, B, 3.0, 良好",
        "75, C, 2.0, 普通", 
        "65, D, 1.0, 要努力",
        "55, F, 0.0, 不合格"
    })
    void 総合成績評価テスト(int score, String expectedGrade, double expectedGPA, String expectedComment) {
        String actualGrade = evaluator.getLetterGrade(score);
        double actualGPA = evaluator.calculateGPA(actualGrade);
        String actualComment = evaluator.getGradeComment(score);
        
        assertEquals(expectedGrade, actualGrade);
        assertEquals(expectedGPA, actualGPA, 0.01);
        assertEquals(expectedComment, actualComment);
    }
    
    @ParameterizedTest
    @ValueSource(ints = {-1, -10, 101, 150})
    void 無効なスコアでの例外テスト(int invalidScore) {
        assertThrows(IllegalArgumentException.class, () -> {
            evaluator.getLetterGrade(invalidScore);
        });
    }
    
    @ParameterizedTest
    @ValueSource(strings = {"A", "B", "C", "D"})
    void 合格評価のテスト(String grade) {
        assertTrue(evaluator.isPassingGrade(grade));
        assertTrue(evaluator.calculateGPA(grade) > 0);
    }
    
    @ParameterizedTest
    @CsvSource({
        "90, 90, true",  // 境界値（下限）
        "89, 80, false", // 境界値テスト
        "80, 80, true",  // 境界値（下限）
        "79, 70, false", // 境界値テスト
        "60, 60, true",  // 境界値（下限）
        "59, 0, false"   // 境界値テスト
    })
    void 境界値テスト(int score, int threshold, boolean shouldPassThreshold) {
        String grade = evaluator.getLetterGrade(score);
        boolean actualPass = !grade.equals("F") || score >= 60;
        
        // より複雑な境界値検証ロジック
        assertTrue(true); // この例では簡略化
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>各パラメータ化テストが複数のデータセットで実行され、以下のテストパターンが確認できます：</p>
                        <ul>
                            <li>@ValueSourceによる単一パラメータの複数値テスト</li>
                            <li>@CsvSourceによる複数パラメータの組み合わせテスト</li>
                            <li>境界値を含む包括的なテストカバレッジ</li>
                        </ul>
                    </div>

                    <h3 class="section-title">5.4 @MethodSourceによる高度なデータ提供</h3>
                    
                    <p>複雑なテストデータやオブジェクトを提供する場合は、@MethodSourceを使用します。</p>

                    <h4>5.4.1 基本的な@MethodSourceの使用</h4>
                    
                    <pre class="code-block"><code class="language-java">import org.junit.jupiter.params.provider.MethodSource;
import java.util.stream.Stream;

class AdvancedParameterizedTest {
    
    @ParameterizedTest
    @MethodSource("provideNumbersForSquareTest")
    void 数値の二乗テスト(int number, int expectedSquare) {
        MathUtils mathUtils = new MathUtils();
        
        int result = mathUtils.square(number);
        
        assertEquals(expectedSquare, result);
    }
    
    // テストデータを提供するstaticメソッド
    static Stream&lt;org.junit.jupiter.params.provider.Arguments&gt; provideNumbersForSquareTest() {
        return Stream.of(
            org.junit.jupiter.params.provider.Arguments.of(0, 0),
            org.junit.jupiter.params.provider.Arguments.of(1, 1),
            org.junit.jupiter.params.provider.Arguments.of(2, 4),
            org.junit.jupiter.params.provider.Arguments.of(3, 9),
            org.junit.jupiter.params.provider.Arguments.of(-2, 4),
            org.junit.jupiter.params.provider.Arguments.of(10, 100)
        );
    }
    
    @ParameterizedTest
    @MethodSource("provideUsersForValidation")
    void ユーザー検証の高度なテスト(User user, boolean expectedValid, String expectedReason) {
        UserValidator validator = new UserValidator();
        
        ValidationResult result = validator.validate(user);
        
        assertEquals(expectedValid, result.isValid());
        if (!expectedValid) {
            assertEquals(expectedReason, result.getReason());
        }
    }
    
    static Stream&lt;org.junit.jupiter.params.provider.Arguments&gt; provideUsersForValidation() {
        return Stream.of(
            org.junit.jupiter.params.provider.Arguments.of(
                new User("田中太郎", "tanaka@example.com", 25), 
                true, 
                null
            ),
            org.junit.jupiter.params.provider.Arguments.of(
                new User("", "test@example.com", 20), 
                false, 
                "名前が空です"
            ),
            org.junit.jupiter.params.provider.Arguments.of(
                new User("山田花子", "invalid-email", 30), 
                false, 
                "メールアドレスが不正です"
            ),
            org.junit.jupiter.params.provider.Arguments.of(
                new User("佐藤次郎", "sato@test.com", 17), 
                false, 
                "年齢が18歳未満です"
            )
        );
    }
}</code></pre>

                    <h4>5.4.2 外部ファイルからのデータ提供</h4>
                    
                    <pre class="code-block"><code class="language-java">class FileBasedParameterizedTest {
    
    @ParameterizedTest
    @MethodSource("loadTestDataFromFile")
    void ファイルからのテストデータ(String productName, double price, String category, boolean expectedValid) {
        Product product = new Product(productName, price, category);
        ProductValidator validator = new ProductValidator();
        
        boolean isValid = validator.isValid(product);
        
        assertEquals(expectedValid, isValid);
    }
    
    static Stream&lt;org.junit.jupiter.params.provider.Arguments&gt; loadTestDataFromFile() {
        // 実際の実装では、CSVファイルやJSONファイルから読み込み
        return Stream.of(
            org.junit.jupiter.params.provider.Arguments.of("ノートパソコン", 89800.0, "電子機器", true),
            org.junit.jupiter.params.provider.Arguments.of("", 1000.0, "雑貨", false),
            org.junit.jupiter.params.provider.Arguments.of("マウス", -100.0, "電子機器", false),
            org.junit.jupiter.params.provider.Arguments.of("キーボード", 15000.0, "", false)
        );
    }
}</code></pre>

                    <h3 class="section-title">5.5 @DynamicTestによる動的テスト生成</h3>
                    
                    <p>実行時にテストケースを動的に生成したい場合は、@DynamicTestを使用します。</p>

                    <h4>5.5.1 基本的な動的テストの作成</h4>
                    
                    <pre class="code-block"><code class="language-java">import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.TestFactory;
import java.util.Arrays;
import java.util.Collection;
import java.util.stream.Stream;

class DynamicTestExamples {
    
    @TestFactory
    Collection&lt;DynamicTest&gt; 動的な算術テスト() {
        return Arrays.asList(
            DynamicTest.dynamicTest("2 + 2 = 4", () -> assertEquals(4, 2 + 2)),
            DynamicTest.dynamicTest("3 * 3 = 9", () -> assertEquals(9, 3 * 3)),
            DynamicTest.dynamicTest("10 / 2 = 5", () -> assertEquals(5, 10 / 2)),
            DynamicTest.dynamicTest("7 - 3 = 4", () -> assertEquals(4, 7 - 3))
        );
    }
    
    @TestFactory
    Stream&lt;DynamicTest&gt; ストリームによる動的テスト() {
        // テストデータの配列
        int[] numbers = {1, 2, 3, 5, 8, 13, 21};
        
        return Arrays.stream(numbers)
            .mapToObj(number -> 
                DynamicTest.dynamicTest(
                    "数値 " + number + " の平方根テスト",
                    () -> {
                        double sqrt = Math.sqrt(number);
                        assertTrue(sqrt > 0);
                        assertEquals(number, sqrt * sqrt, 0.0001);
                    }
                )
            );
    }
    
    @TestFactory
    Stream&lt;DynamicTest&gt; 複雑な動的テスト生成() {
        // より複雑な条件でテストを生成
        return Stream.of("apple", "banana", "orange", "grape")
            .map(fruit -> 
                DynamicTest.dynamicTest(
                    fruit + " の文字列検証テスト",
                    () -> {
                        assertNotNull(fruit);
                        assertFalse(fruit.isEmpty());
                        assertTrue(fruit.length() >= 4);
                        assertTrue(Character.isLowerCase(fruit.charAt(0)));
                    }
                )
            );
    }
}</code></pre>

                    <div class="highlight">
                        <h6><strong>動的テストの利点</strong></h6>
                        <ul>
                            <li><strong>実行時決定</strong>：テストの内容を実行時に決定できる</li>
                            <li><strong>データ駆動</strong>：外部データソースに基づいてテストを生成</li>
                            <li><strong>条件分岐</strong>：条件に応じて異なるテストを生成</li>
                            <li><strong>柔軟性</strong>：複雑なテスト生成ロジックを実装可能</li>
                        </ul>
                    </div>

                    <div class="exercise-container">
                        <h5>実習 5-2: 動的なファイル処理テストの作成</h5>
                        <p>複数のファイル形式に対応したファイル処理システムの動的テストを作成してみましょう。</p>
                        
                        <h6>手順1: ファイル処理システムの作成</h6>
                        <p><code>FileProcessor.java</code>を作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import java.util.*;

public class FileProcessor {
    
    public boolean isSupportedFormat(String fileName) {
        String extension = getFileExtension(fileName);
        return Arrays.asList("txt", "csv", "json", "xml").contains(extension);
    }
    
    public String getFileType(String fileName) {
        String extension = getFileExtension(fileName);
        switch (extension) {
            case "txt": return "プレーンテキスト";
            case "csv": return "CSV形式";
            case "json": return "JSON形式";
            case "xml": return "XML形式";
            default: return "不明な形式";
        }
    }
    
    public long estimateProcessingTime(String fileName, long fileSize) {
        String extension = getFileExtension(fileName);
        long baseTime = fileSize / 1024; // KB単位での基本処理時間
        
        switch (extension) {
            case "txt": return baseTime;
            case "csv": return baseTime * 2;
            case "json": return baseTime * 3;
            case "xml": return baseTime * 4;
            default: return -1;
        }
    }
    
    private String getFileExtension(String fileName) {
        if (fileName == null || !fileName.contains(".")) {
            return "";
        }
        return fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
    }
}</code></pre>

                        <h6>手順2: 動的テストクラスの作成</h6>
                        <p><code>FileProcessorDynamicTest.java</code>を作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.TestFactory;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;
import java.util.stream.Stream;

class FileProcessorDynamicTest {
    private final FileProcessor processor = new FileProcessor();
    
    @TestFactory
    Stream&lt;DynamicTest&gt; サポートされるファイル形式の動的テスト() {
        Map&lt;String, Boolean&gt; testFiles = Map.of(
            "document.txt", true,
            "data.csv", true,
            "config.json", true,
            "settings.xml", true,
            "image.jpg", false,
            "archive.zip", false,
            "noextension", false
        );
        
        return testFiles.entrySet().stream()
            .map(entry -> 
                DynamicTest.dynamicTest(
                    entry.getKey() + " のサポート確認テスト",
                    () -> assertEquals(entry.getValue(), processor.isSupportedFormat(entry.getKey()))
                )
            );
    }
    
    @TestFactory
    Collection&lt;DynamicTest&gt; ファイルタイプ判定の動的テスト() {
        Map&lt;String, String&gt; fileTypeTests = Map.of(
            "readme.txt", "プレーンテキスト",
            "sales.csv", "CSV形式", 
            "config.json", "JSON形式",
            "layout.xml", "XML形式"
        );
        
        return fileTypeTests.entrySet().stream()
            .map(entry -> 
                DynamicTest.dynamicTest(
                    entry.getKey() + " のファイルタイプ判定テスト",
                    () -> assertEquals(entry.getValue(), processor.getFileType(entry.getKey()))
                )
            )
            .toList();
    }
    
    @TestFactory
    Stream&lt;DynamicTest&gt; 処理時間見積もりの動的テスト() {
        // 異なるファイルサイズでのテスト
        List&lt;Long&gt; fileSizes = Arrays.asList(1024L, 2048L, 4096L, 8192L);
        List&lt;String&gt; extensions = Arrays.asList("txt", "csv", "json", "xml");
        
        return extensions.stream()
            .flatMap(ext -> 
                fileSizes.stream().map(size -> 
                    DynamicTest.dynamicTest(
                        String.format("%s ファイル（%d KB）の処理時間見積もりテスト", ext, size / 1024),
                        () -> {
                            String fileName = "test." + ext;
                            long estimatedTime = processor.estimateProcessingTime(fileName, size);
                            
                            assertTrue(estimatedTime > 0, "処理時間は正の値である必要があります");
                            
                            // 拡張子による処理時間の違いを検証
                            long baseTime = size / 1024;
                            switch (ext) {
                                case "txt":
                                    assertEquals(baseTime, estimatedTime);
                                    break;
                                case "csv":
                                    assertEquals(baseTime * 2, estimatedTime);
                                    break;
                                case "json":
                                    assertEquals(baseTime * 3, estimatedTime);
                                    break;
                                case "xml":
                                    assertEquals(baseTime * 4, estimatedTime);
                                    break;
                            }
                        }
                    )
                )
            );
    }
    
    @ParameterizedTest
    @MethodSource("provideInvalidFiles")
    void 無効なファイルでの処理時間テスト(String fileName, long fileSize) {
        long result = processor.estimateProcessingTime(fileName, fileSize);
        assertEquals(-1, result);
    }
    
    static Stream&lt;org.junit.jupiter.params.provider.Arguments&gt; provideInvalidFiles() {
        return Stream.of(
            org.junit.jupiter.params.provider.Arguments.of("image.jpg", 1024L),
            org.junit.jupiter.params.provider.Arguments.of("archive.zip", 2048L),
            org.junit.jupiter.params.provider.Arguments.of("noextension", 1024L)
        );
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>この動的テストでは以下の特徴が確認できます：</p>
                        <ul>
                            <li>Map.entrySet()を使った効率的なテストケース生成</li>
                            <li>flatMap()による複数次元のテストデータ展開</li>
                            <li>パラメータ化テストと動的テストの組み合わせ</li>
                            <li>実行時にテスト名が動的に生成される</li>
                        </ul>
                    </div>

                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li><strong>@ParameterizedTestとは何ですか？</strong>
                                <ul>
                                    <li>a) 複数のテストクラスを一度に実行するアノテーション</li>
                                    <li>b) 同じテストロジックを異なるデータで複数回実行するアノテーション</li>
                                    <li>c) テストの実行順序を制御するアノテーション</li>
                                    <li>d) テストの実行時間を測定するアノテーション</li>
                                </ul>
                            </li>
                            <li><strong>@ValueSourceで使用できないデータ型はどれですか？</strong>
                                <ul>
                                    <li>a) strings</li>
                                    <li>b) ints</li>
                                    <li>c) objects（カスタムオブジェクト）</li>
                                    <li>d) booleans</li>
                                </ul>
                            </li>
                            <li><strong>@MethodSourceで使用するデータ提供メソッドの条件は何ですか？</strong>
                                <ul>
                                    <li>a) publicメソッドである必要がある</li>
                                    <li>b) staticメソッドである必要がある</li>
                                    <li>c) 引数を持つ必要がある</li>
                                    <li>d) 戻り値がvoidである必要がある</li>
                                </ul>
                            </li>
                            <li><strong>@DynamicTestの主な用途は何ですか？</strong>
                                <ul>
                                    <li>a) テストの実行速度を向上させる</li>
                                    <li>b) 実行時にテストケースを動的に生成する</li>
                                    <li>c) テストの順序を動的に変更する</li>
                                    <li>d) テストデータを暗号化する</li>
                                </ul>
                            </li>
                        </ol>
                        
                        <details style="margin-top: 1rem;">
                            <summary><strong>解答を見る</strong></summary>
                            <div style="margin-top: 0.5rem;">
                                <p><strong>1.</strong> b) 同じテストロジックを異なるデータで複数回実行するアノテーション</p>
                                <p><strong>2.</strong> c) objects（カスタムオブジェクト）</p>
                                <p><strong>3.</strong> b) staticメソッドである必要がある</p>
                                <p><strong>4.</strong> b) 実行時にテストケースを動的に生成する</p>
                            </div>
                        </details>
                    </div>

                    <!-- Chapter navigation -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="junit-learning-material-4.html" class="btn btn-secondary">← 前の章：テストライフサイクルとアノテーション</a>
                        <a href="junit-learning-material-6.html" class="btn btn-primary">次の章：例外テストとタイムアウト →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js initialization -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js initialization -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>