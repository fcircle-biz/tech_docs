<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JUnit学習教材 第7章 - テストの組織化とベストプラクティス</title>
    
    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
        }
        
        .navbar {
            background-color: #f57c00;
        }
        
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
        
        .chapter-title {
            color: #f57c00;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #f57c00;
            padding-bottom: 0.5rem;
        }
        
        .section-title {
            color: #ff9800;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
        }
        
        .quiz-container {
            background-color: #fff3e0;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #f57c00;
        }
        
        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }
        
        .highlight {
            background-color: #ffecb3;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }
        
        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }
        
        .code-block {
            background-color: #1e1e1e;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
        }
        
        .nav-link.active {
            background-color: #f57c00 !important;
            color: white !important;
        }
    </style>
</head>
<body>
    <!-- Navigation bar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand">
                <strong>JUnit学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- Sidebar -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-1.html">
                                第1章: JUnit基礎とセットアップ
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-2.html">
                                第2章: 基本的なテストケースの作成
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-3.html">
                                第3章: アサーションとマッチャー
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-4.html">
                                第4章: テストライフサイクルとアノテーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-5.html">
                                第5章: パラメータ化テストと動的テスト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="junit-learning-material-6.html">
                                第6章: 例外テストとタイムアウト
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="junit-learning-material-7.html">
                                第7章: テストの組織化とベストプラクティス
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- Main content -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第7章: テストの組織化とベストプラクティス</h1>
                </div>

                <div id="chapter7">
                    <h2 class="chapter-title">保守しやすいテストスイートの構築</h2>
                    
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>@Nestedによる階層的なテスト構造の設計</li>
                            <li>@Tagによるテストの分類と選択実行</li>
                            <li>条件付きテスト実行（@EnabledOnOs、@DisabledIfなど）</li>
                            <li>テストコードの可読性と保守性を向上させるベストプラクティス</li>
                            <li>継続的インテグレーション（CI）でのテスト実行戦略</li>
                        </ul>
                    </div>

                    <h3 class="section-title">7.1 @Nestedによる階層的テスト構造</h3>
                    
                    <p>複雑なクラスやシステムをテストする際、関連するテストケースをグループ化して階層構造を作ることで、テストの理解しやすさと保守性を向上させることができます。</p>

                    <div class="mermaid">
                        flowchart TD
                            A["UserServiceTest"] --> B["@Nested ユーザー登録機能"]
                            A --> C["@Nested ユーザー検索機能"]
                            A --> D["@Nested ユーザー更新機能"]
                            B --> E["正常系テスト"]
                            B --> F["異常系テスト"]
                            B --> G["境界値テスト"]
                            C --> H["ID検索テスト"]
                            C --> I["メール検索テスト"]
                            D --> J["情報更新テスト"]
                            D --> K["パスワード更新テスト"]
                    </div>

                    <h4>7.1.1 基本的な@Nestedの使用方法</h4>
                    
                    <pre class="code-block"><code class="language-java">import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;

@DisplayName("UserService のテスト")
class UserServiceTest {
    private UserService userService;
    
    @BeforeEach
    void setUp() {
        userService = new UserService();
    }
    
    @Nested
    @DisplayName("ユーザー登録機能")
    class UserRegistrationTests {
        
        @Nested
        @DisplayName("正常系")
        class SuccessfulRegistration {
            
            @Test
            @DisplayName("有効な情報でユーザー登録が成功する")
            void 有効な情報での登録成功() {
                User newUser = new User("田中太郎", "tanaka@example.com", "strongPassword123!");
                
                User registeredUser = userService.register(newUser);
                
                assertNotNull(registeredUser);
                assertEquals("田中太郎", registeredUser.getName());
                assertTrue(registeredUser.isActive());
            }
            
            @Test
            @DisplayName("最小長のパスワードで登録が成功する")
            void 最小長パスワードでの登録成功() {
                User newUser = new User("佐藤花子", "sato@example.com", "Pass123!");
                
                assertDoesNotThrow(() -> userService.register(newUser));
            }
        }
        
        @Nested
        @DisplayName("異常系")
        class FailedRegistration {
            
            @Test
            @DisplayName("無効なメールアドレスで登録が失敗する")
            void 無効メールでの登録失敗() {
                User invalidUser = new User("山田太郎", "invalid-email", "password123");
                
                assertThrows(InvalidEmailException.class, 
                    () -> userService.register(invalidUser));
            }
            
            @Test
            @DisplayName("弱いパスワードで登録が失敗する")
            void 弱いパスワードでの登録失敗() {
                User weakPasswordUser = new User("鈴木一郎", "suzuki@example.com", "123");
                
                assertThrows(WeakPasswordException.class, 
                    () -> userService.register(weakPasswordUser));
            }
        }
    }
    
    @Nested
    @DisplayName("ユーザー検索機能")
    class UserSearchTests {
        private User existingUser;
        
        @BeforeEach
        void setUpUser() {
            existingUser = new User("検索テスト用ユーザー", "search@example.com", "password123");
            userService.register(existingUser);
        }
        
        @Test
        @DisplayName("IDによるユーザー検索が成功する")
        void IDでの検索成功() {
            User foundUser = userService.findById(existingUser.getId());
            
            assertNotNull(foundUser);
            assertEquals(existingUser.getName(), foundUser.getName());
        }
        
        @Test
        @DisplayName("存在しないIDでの検索が空の結果を返す")
        void 存在しないIDでの検索() {
            User foundUser = userService.findById("nonexistent-id");
            
            assertNull(foundUser);
        }
    }
}</code></pre>

                    <h4>7.1.2 ネストした構造での共有セットアップ</h4>
                    
                    <pre class="code-block"><code class="language-java">@DisplayName("BankAccount のテスト")
class BankAccountTest {
    
    @Nested
    @DisplayName("残高十分な口座での操作")
    class SufficientBalanceTests {
        private BankAccount account;
        
        @BeforeEach
        void setUp() {
            account = new BankAccount("12345", 10000.0); // 十分な残高
        }
        
        @Test
        @DisplayName("出金操作が成功する")
        void 出金成功() {
            account.withdraw(5000.0);
            assertEquals(5000.0, account.getBalance(), 0.01);
        }
        
        @Test
        @DisplayName("残高の範囲内での複数回出金")
        void 複数回出金() {
            account.withdraw(3000.0);
            account.withdraw(2000.0);
            assertEquals(5000.0, account.getBalance(), 0.01);
        }
        
        @Nested
        @DisplayName("VIP顧客の特別操作")
        class VipCustomerTests {
            
            @BeforeEach
            void setUpVip() {
                account.setCustomerType(CustomerType.VIP);
            }
            
            @Test
            @DisplayName("VIP顧客は手数料が免除される")
            void VIP手数料免除() {
                double beforeBalance = account.getBalance();
                account.transferWithFee(1000.0, "67890");
                
                assertEquals(beforeBalance - 1000.0, account.getBalance(), 0.01);
            }
        }
    }
    
    @Nested
    @DisplayName("残高不足な口座での操作")
    class InsufficientBalanceTests {
        private BankAccount account;
        
        @BeforeEach
        void setUp() {
            account = new BankAccount("54321", 100.0); // 少ない残高
        }
        
        @Test
        @DisplayName("残高を超える出金で例外が発生する")
        void 出金失敗() {
            assertThrows(InsufficientBalanceException.class, 
                () -> account.withdraw(500.0));
        }
        
        @Test
        @DisplayName("残高不足後も口座状態が正常に保たれる")
        void 口座状態の整合性() {
            assertThrows(InsufficientBalanceException.class, 
                () -> account.withdraw(500.0));
            
            // 例外発生後も残高は変わらない
            assertEquals(100.0, account.getBalance(), 0.01);
        }
    }
}</code></pre>

                    <div class="highlight">
                        <h6><strong>@Nestedテストの利点</strong></h6>
                        <ul>
                            <li><strong>論理的なグループ化</strong>：関連するテストケースを明確にまとめられる</li>
                            <li><strong>階層的セットアップ</strong>：各レベルで適切な初期化処理を定義可能</li>
                            <li><strong>テスト結果の可読性</strong>：階層構造でテスト実行結果が見やすくなる</li>
                            <li><strong>保守性向上</strong>：機能ごとにテストを整理できるため、変更時の影響範囲が明確</li>
                        </ul>
                    </div>

                    <h3 class="section-title">7.2 @Tagによるテストの分類と選択実行</h3>
                    
                    <p>大規模なプロジェクトでは、すべてのテストを常に実行するのは時間がかかります。@Tagアノテーションを使ってテストを分類し、必要に応じて特定のカテゴリのテストだけを実行できます。</p>

                    <h4>7.2.1 基本的なタグの使用</h4>
                    
                    <pre class="code-block"><code class="language-java">import org.junit.jupiter.api.Tag;

class ProductServiceTest {
    
    @Test
    @Tag("fast")
    @DisplayName("商品情報の基本検証")
    void 商品情報基本検証() {
        Product product = new Product("商品A", 1000.0);
        
        assertEquals("商品A", product.getName());
        assertEquals(1000.0, product.getPrice());
    }
    
    @Test
    @Tag("database")
    @Tag("integration")
    @DisplayName("データベースからの商品取得")
    void データベース商品取得() {
        ProductService service = new ProductService();
        
        Product product = service.findById("PROD001");
        
        assertNotNull(product);
    }
    
    @Test
    @Tag("slow")
    @Tag("performance")
    @DisplayName("大量データでの性能テスト")
    void 大量データ性能テスト() {
        ProductService service = new ProductService();
        List&lt;Product&gt; products = generateLargeProductList(10000);
        
        long startTime = System.currentTimeMillis();
        service.processBulkInsert(products);
        long duration = System.currentTimeMillis() - startTime;
        
        assertTrue(duration < 30000, "バルクインサートは30秒以内に完了すべき");
    }
    
    @Test
    @Tag("security")
    @DisplayName("権限チェックのテスト")
    void 権限チェック() {
        ProductService service = new ProductService();
        User unauthorizedUser = new User("guest", UserRole.GUEST);
        
        assertThrows(UnauthorizedException.class, 
            () -> service.deleteProduct("PROD001", unauthorizedUser));
    }
}</code></pre>

                    <h4>7.2.2 環境別・目的別のタグ戦略</h4>
                    
                    <pre class="code-block"><code class="language-java">class ComprehensiveTestSuite {
    
    @Test
    @Tag("unit")
    @Tag("fast")
    void 単体テスト() {
        // 高速な単体テスト
    }
    
    @Test
    @Tag("integration") 
    @Tag("database")
    void 統合テスト() {
        // データベースとの統合テスト
    }
    
    @Test
    @Tag("e2e")
    @Tag("slow")
    void エンドツーエンドテスト() {
        // 完全なワークフローテスト
    }
    
    @Test
    @Tag("smoke")
    @Tag("production")
    void スモークテスト() {
        // 本番環境での基本動作確認
    }
    
    @Test
    @Tag("regression") 
    @Tag("bug-fix")
    void 回帰テスト() {
        // バグ修正の検証
    }
    
    @Test
    @Tag("load")
    @Tag("performance")
    void 負荷テスト() {
        // 性能・負荷テスト
    }
}</code></pre>

                    <h4>7.2.3 Mavenでのタグベース実行</h4>
                    
                    <pre class="code-block"><code class="language-xml">&lt;!-- pom.xml での設定例 --&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
    &lt;configuration&gt;
        &lt;!-- 高速テストのみ実行 --&gt;
        &lt;groups&gt;fast&lt;/groups&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>

                    <h4>7.2.4 Gradleでのタグベース実行</h4>
                    
                    <pre class="code-block"><code class="language-bash"># build.gradle での設定例
test {
    useJUnitPlatform {
        includeTags 'fast'
        excludeTags 'slow', 'integration'
    }
}

# コマンドラインでの実行例
./gradlew test -Dtest.includeTags=fast
./gradlew test -Dtest.excludeTags=slow,integration</code></pre>

                    <h3 class="section-title">7.3 条件付きテスト実行</h3>
                    
                    <p>実行環境や条件に応じてテストを有効化・無効化することで、不要なテスト失敗を避け、効率的なテスト実行を実現できます。</p>

                    <h4>7.3.1 OS固有のテスト</h4>
                    
                    <pre class="code-block"><code class="language-java">import org.junit.jupiter.api.condition.*;

class PlatformSpecificTests {
    
    @Test
    @EnabledOnOs(OS.WINDOWS)
    @DisplayName("Windows固有の機能テスト")
    void Windows固有テスト() {
        WindowsSpecificService service = new WindowsSpecificService();
        assertTrue(service.isWindowsFeatureAvailable());
    }
    
    @Test
    @EnabledOnOs({OS.LINUX, OS.MAC})
    @DisplayName("Unix系OS固有の機能テスト")
    void Unix系テスト() {
        UnixService service = new UnixService();
        assertNotNull(service.getUnixProcessList());
    }
    
    @Test
    @DisabledOnOs(OS.WINDOWS)
    @DisplayName("Windows以外での実行テスト")
    void Windows以外でのテスト() {
        // Windowsでは実行されない
        assertTrue(System.getProperty("file.separator").equals("/"));
    }
}</code></pre>

                    <h4>7.3.2 Java バージョン固有のテスト</h4>
                    
                    <pre class="code-block"><code class="language-java">class JavaVersionSpecificTests {
    
    @Test
    @EnabledOnJre(JRE.JAVA_11)
    @DisplayName("Java 11固有機能のテスト")
    void Java11テスト() {
        // Java 11の機能をテスト
        String result = String.isBlank() ? "blank" : "not blank";
        assertEquals("blank", result);
    }
    
    @Test
    @EnabledOnJre({JRE.JAVA_17, JRE.JAVA_18})
    @DisplayName("Java 17以降の機能テスト")
    void 新機能テスト() {
        // Java 17以降の機能をテスト
    }
    
    @Test
    @EnabledForJreRange(min = JRE.JAVA_11, max = JRE.JAVA_17)
    @DisplayName("Java 11-17での機能テスト")
    void 範囲指定テスト() {
        // 特定バージョン範囲でのみ実行
    }
    
    @Test
    @DisabledForJreRange(min = JRE.JAVA_8, max = JRE.JAVA_10)
    @DisplayName("古いJavaバージョンでは無効")
    void 新しいバージョン必須テスト() {
        // Java 11以降でのみ実行される
    }
}</code></pre>

                    <h4>7.3.3 システムプロパティによる条件付き実行</h4>
                    
                    <pre class="code-block"><code class="language-java">class SystemPropertyBasedTests {
    
    @Test
    @EnabledIfSystemProperty(named = "environment", matches = "production")
    @DisplayName("本番環境でのみ実行されるテスト")
    void 本番環境テスト() {
        ProductionService service = new ProductionService();
        assertTrue(service.isProductionMode());
    }
    
    @Test
    @EnabledIfSystemProperty(named = "test.database.enabled", matches = "true")
    @DisplayName("データベーステストが有効な場合のみ実行")
    void データベース有効時テスト() {
        DatabaseService db = new DatabaseService();
        assertNotNull(db.getConnection());
    }
    
    @Test
    @DisabledIfSystemProperty(named = "ci.server", matches = "true")
    @DisplayName("CI環境では無効化されるテスト")
    void ローカル開発環境テスト() {
        // CI環境では実行されない（例：GUI関連テスト）
    }
    
    @Test
    @EnabledIfSystemProperty(named = "java.version", matches = ".*17.*")
    @DisplayName("Java 17でのみ有効")
    void Java17固有テスト() {
        // Java 17が検出された場合のみ実行
    }
}</code></pre>

                    <h4>7.3.4 カスタム条件による制御</h4>
                    
                    <pre class="code-block"><code class="language-java">class CustomConditionalTests {
    
    @Test
    @EnabledIf("isProductionEnvironment")
    @DisplayName("カスタム条件での制御")
    void カスタム条件テスト() {
        // isProductionEnvironment()がtrueの場合のみ実行
    }
    
    @Test
    @DisabledIf("isDatabaseUnavailable") 
    @DisplayName("データベース利用不可時は無効")
    void データベース必須テスト() {
        // データベースが利用可能な場合のみ実行
    }
    
    // カスタム条件メソッド
    static boolean isProductionEnvironment() {
        return "production".equals(System.getProperty("env"));
    }
    
    static boolean isDatabaseUnavailable() {
        try {
            DatabaseConnectionPool.getInstance().getConnection().close();
            return false;
        } catch (Exception e) {
            return true;
        }
    }
}</code></pre>

                    <div class="exercise-container">
                        <h5>実習 7-1: eコマースシステムの完全なテストスイート構築</h5>
                        <p>複雑なeコマースシステムを題材に、@Nested、@Tag、条件付き実行を組み合わせた包括的なテストスイートを構築してみましょう。</p>
                        
                        <h6>手順1: eコマースシステムのコア機能を作成</h6>
                        <p><code>ECommerceSystem.java</code>と関連クラスを作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import java.util.*;
import java.time.LocalDateTime;

// メインのeコマースシステム
public class ECommerceSystem {
    private UserManager userManager = new UserManager();
    private ProductManager productManager = new ProductManager();
    private OrderManager orderManager = new OrderManager();
    private PaymentProcessor paymentProcessor = new PaymentProcessor();
    
    public UserManager getUserManager() { return userManager; }
    public ProductManager getProductManager() { return productManager; }
    public OrderManager getOrderManager() { return orderManager; }
    public PaymentProcessor getPaymentProcessor() { return paymentProcessor; }
}

// ユーザー管理
class UserManager {
    private Map&lt;String, User&gt; users = new HashMap&lt;&gt;();
    
    public User registerUser(String name, String email, String password) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("名前は必須です");
        }
        if (!isValidEmail(email)) {
            throw new IllegalArgumentException("無効なメールアドレス");
        }
        if (!isStrongPassword(password)) {
            throw new IllegalArgumentException("パスワードが弱すぎます");
        }
        
        User user = new User(UUID.randomUUID().toString(), name, email, password);
        users.put(user.getId(), user);
        return user;
    }
    
    public User authenticate(String email, String password) {
        return users.values().stream()
            .filter(u -> u.getEmail().equals(email) && u.getPassword().equals(password))
            .findFirst()
            .orElseThrow(() -> new AuthenticationException("認証失敗"));
    }
    
    private boolean isValidEmail(String email) {
        return email != null && email.contains("@") && email.contains(".");
    }
    
    private boolean isStrongPassword(String password) {
        return password != null && password.length() >= 8;
    }
}

// 商品管理  
class ProductManager {
    private Map&lt;String, Product&gt; products = new HashMap&lt;&gt;();
    
    public void addProduct(Product product) {
        if (product == null) throw new IllegalArgumentException("商品がnullです");
        products.put(product.getId(), product);
    }
    
    public Product findProduct(String productId) {
        return products.get(productId);
    }
    
    public List&lt;Product&gt; searchProducts(String keyword) {
        return products.values().stream()
            .filter(p -> p.getName().toLowerCase().contains(keyword.toLowerCase()))
            .toList();
    }
    
    public boolean updateStock(String productId, int quantity) {
        Product product = products.get(productId);
        if (product == null) return false;
        
        product.setStock(product.getStock() + quantity);
        return true;
    }
}

// 注文管理
class OrderManager {
    private Map&lt;String, Order&gt; orders = new HashMap&lt;&gt;();
    private ProductManager productManager;
    
    public OrderManager() {
        this.productManager = new ProductManager();
    }
    
    public Order createOrder(User user, List&lt;OrderItem&gt; items) {
        if (user == null) throw new IllegalArgumentException("ユーザーが必要です");
        if (items == null || items.isEmpty()) throw new IllegalArgumentException("注文商品が必要です");
        
        // 在庫チェック
        for (OrderItem item : items) {
            Product product = productManager.findProduct(item.getProductId());
            if (product == null) {
                throw new IllegalArgumentException("商品が見つかりません: " + item.getProductId());
            }
            if (product.getStock() < item.getQuantity()) {
                throw new IllegalArgumentException("在庫不足: " + product.getName());
            }
        }
        
        Order order = new Order(UUID.randomUUID().toString(), user, items, LocalDateTime.now());
        orders.put(order.getId(), order);
        return order;
    }
    
    public Order findOrder(String orderId) {
        return orders.get(orderId);
    }
}

// 決済処理
class PaymentProcessor {
    public PaymentResult processPayment(Order order, PaymentMethod paymentMethod) {
        if (order == null) throw new IllegalArgumentException("注文が必要です");
        if (paymentMethod == null) throw new IllegalArgumentException("決済方法が必要です");
        
        double amount = order.getTotalAmount();
        
        // 決済処理のシミュレーション
        try {
            Thread.sleep(100); // 決済処理時間のシミュレート
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        boolean success = amount > 0 && amount <= paymentMethod.getLimit();
        return new PaymentResult(success, success ? null : "決済限度額を超えています");
    }
}

// エンティティクラス
class User {
    private String id, name, email, password;
    
    public User(String id, String name, String email, String password) {
        this.id = id; this.name = name; this.email = email; this.password = password;
    }
    
    public String getId() { return id; }
    public String getName() { return name; }
    public String getEmail() { return email; }
    public String getPassword() { return password; }
}

class Product {
    private String id, name;
    private double price;
    private int stock;
    
    public Product(String id, String name, double price, int stock) {
        this.id = id; this.name = name; this.price = price; this.stock = stock;
    }
    
    public String getId() { return id; }
    public String getName() { return name; }
    public double getPrice() { return price; }
    public int getStock() { return stock; }
    public void setStock(int stock) { this.stock = stock; }
}

class Order {
    private String id;
    private User user;
    private List&lt;OrderItem&gt; items;
    private LocalDateTime orderDate;
    
    public Order(String id, User user, List&lt;OrderItem&gt; items, LocalDateTime orderDate) {
        this.id = id; this.user = user; this.items = items; this.orderDate = orderDate;
    }
    
    public String getId() { return id; }
    public User getUser() { return user; }
    public List&lt;OrderItem&gt; getItems() { return items; }
    public LocalDateTime getOrderDate() { return orderDate; }
    
    public double getTotalAmount() {
        return items.stream().mapToDouble(item -> item.getPrice() * item.getQuantity()).sum();
    }
}

class OrderItem {
    private String productId;
    private int quantity;
    private double price;
    
    public OrderItem(String productId, int quantity, double price) {
        this.productId = productId; this.quantity = quantity; this.price = price;
    }
    
    public String getProductId() { return productId; }
    public int getQuantity() { return quantity; }
    public double getPrice() { return price; }
}

class PaymentMethod {
    private String type;
    private double limit;
    
    public PaymentMethod(String type, double limit) {
        this.type = type; this.limit = limit;
    }
    
    public String getType() { return type; }
    public double getLimit() { return limit; }
}

class PaymentResult {
    private boolean success;
    private String errorMessage;
    
    public PaymentResult(boolean success, String errorMessage) {
        this.success = success; this.errorMessage = errorMessage;
    }
    
    public boolean isSuccess() { return success; }
    public String getErrorMessage() { return errorMessage; }
}

// カスタム例外
class AuthenticationException extends RuntimeException {
    public AuthenticationException(String message) { super(message); }
}</code></pre>

                        <h6>手順2: 包括的なテストスイートの作成</h6>
                        <p><code>ECommerceSystemComprehensiveTest.java</code>を作成します：</p>
                        
                        <pre class="code-block"><code class="language-java">import org.junit.jupiter.api.*;
import org.junit.jupiter.api.condition.*;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;

@DisplayName("eコマースシステム 包括的テストスイート")
@Tag("e-commerce")
class ECommerceSystemComprehensiveTest {
    private ECommerceSystem eCommerceSystem;
    
    @BeforeEach
    void setUp() {
        eCommerceSystem = new ECommerceSystem();
    }
    
    @Nested
    @DisplayName("ユーザー管理機能")
    @Tag("user-management")
    class UserManagementTests {
        
        @Nested
        @DisplayName("ユーザー登録")
        class UserRegistrationTests {
            
            @Test
            @Tag("fast")
            @Tag("unit")
            @DisplayName("有効な情報でユーザー登録成功")
            void 有効情報での登録成功() {
                UserManager userManager = eCommerceSystem.getUserManager();
                
                User user = userManager.registerUser("田中太郎", "tanaka@example.com", "password123");
                
                assertAll("ユーザー登録結果の検証",
                    () -> assertNotNull(user.getId()),
                    () -> assertEquals("田中太郎", user.getName()),
                    () -> assertEquals("tanaka@example.com", user.getEmail())
                );
            }
            
            @Test
            @Tag("fast")
            @Tag("validation")
            @DisplayName("無効な入力での登録失敗")
            void 無効入力での登録失敗() {
                UserManager userManager = eCommerceSystem.getUserManager();
                
                assertAll("入力検証テスト",
                    () -> assertThrows(IllegalArgumentException.class,
                        () -> userManager.registerUser("", "email@example.com", "password123")),
                    () -> assertThrows(IllegalArgumentException.class,
                        () -> userManager.registerUser("田中太郎", "invalid-email", "password123")),
                    () -> assertThrows(IllegalArgumentException.class,
                        () -> userManager.registerUser("田中太郎", "email@example.com", "weak"))
                );
            }
        }
        
        @Nested
        @DisplayName("ユーザー認証")
        class UserAuthenticationTests {
            private User testUser;
            
            @BeforeEach
            void setUpUser() {
                UserManager userManager = eCommerceSystem.getUserManager();
                testUser = userManager.registerUser("認証テスト", "auth@example.com", "password123");
            }
            
            @Test
            @Tag("security")
            @Tag("fast")
            @DisplayName("正しい認証情報での認証成功")
            void 認証成功() {
                UserManager userManager = eCommerceSystem.getUserManager();
                
                User authenticatedUser = userManager.authenticate("auth@example.com", "password123");
                
                assertEquals(testUser.getId(), authenticatedUser.getId());
            }
            
            @Test
            @Tag("security")
            @Tag("fast")
            @DisplayName("間違った認証情報での認証失敗")
            void 認証失敗() {
                UserManager userManager = eCommerceSystem.getUserManager();
                
                assertThrows(AuthenticationException.class,
                    () -> userManager.authenticate("auth@example.com", "wrongpassword"));
            }
        }
    }
    
    @Nested
    @DisplayName("商品管理機能")
    @Tag("product-management")
    class ProductManagementTests {
        private Product testProduct;
        
        @BeforeEach
        void setUpProduct() {
            testProduct = new Product("PROD001", "テスト商品", 1000.0, 10);
            eCommerceSystem.getProductManager().addProduct(testProduct);
        }
        
        @Test
        @Tag("fast")
        @Tag("unit")
        @DisplayName("商品検索機能")
        void 商品検索() {
            ProductManager productManager = eCommerceSystem.getProductManager();
            
            List&lt;Product&gt; results = productManager.searchProducts("テスト");
            
            assertEquals(1, results.size());
            assertEquals("テスト商品", results.get(0).getName());
        }
        
        @Test
        @Tag("inventory")
        @Tag("fast")
        @DisplayName("在庫更新機能")
        void 在庫更新() {
            ProductManager productManager = eCommerceSystem.getProductManager();
            
            boolean updated = productManager.updateStock("PROD001", 5);
            
            assertTrue(updated);
            assertEquals(15, productManager.findProduct("PROD001").getStock());
        }
        
        @Test
        @Tag("database")
        @Tag("integration")
        @EnabledIfSystemProperty(named = "integration.tests.enabled", matches = "true")
        @DisplayName("大量商品データでの検索性能テスト")
        void 大量データ検索性能() {
            ProductManager productManager = eCommerceSystem.getProductManager();
            
            // 大量のテストデータを追加
            for (int i = 0; i < 10000; i++) {
                productManager.addProduct(new Product("PROD" + i, "商品" + i, 1000.0 + i, 10));
            }
            
            long startTime = System.currentTimeMillis();
            List&lt;Product&gt; results = productManager.searchProducts("商品");
            long duration = System.currentTimeMillis() - startTime;
            
            assertTrue(duration < 1000, "大量データ検索は1秒以内に完了すべき");
            assertFalse(results.isEmpty());
        }
    }
    
    @Nested
    @DisplayName("注文管理機能")
    @Tag("order-management")
    class OrderManagementTests {
        private User testUser;
        private Product testProduct;
        
        @BeforeEach
        void setUpOrderTest() {
            UserManager userManager = eCommerceSystem.getUserManager();
            testUser = userManager.registerUser("注文テスト", "order@example.com", "password123");
            
            testProduct = new Product("ORDER_PROD", "注文テスト商品", 1500.0, 20);
            eCommerceSystem.getProductManager().addProduct(testProduct);
        }
        
        @Test
        @Tag("business-logic")
        @Tag("fast")
        @DisplayName("注文作成成功")
        void 注文作成成功() {
            OrderManager orderManager = eCommerceSystem.getOrderManager();
            List&lt;OrderItem&gt; items = Arrays.asList(
                new OrderItem("ORDER_PROD", 2, 1500.0)
            );
            
            Order order = orderManager.createOrder(testUser, items);
            
            assertAll("注文作成結果の検証",
                () -> assertNotNull(order.getId()),
                () -> assertEquals(testUser.getId(), order.getUser().getId()),
                () -> assertEquals(1, order.getItems().size()),
                () -> assertEquals(3000.0, order.getTotalAmount(), 0.01)
            );
        }
        
        @Test
        @Tag("business-logic") 
        @Tag("validation")
        @DisplayName("在庫不足での注文失敗")
        void 在庫不足での注文失敗() {
            OrderManager orderManager = eCommerceSystem.getOrderManager();
            List&lt;OrderItem&gt; items = Arrays.asList(
                new OrderItem("ORDER_PROD", 25, 1500.0) // 在庫20を超える
            );
            
            assertThrows(IllegalArgumentException.class,
                () -> orderManager.createOrder(testUser, items));
        }
    }
    
    @Nested
    @DisplayName("決済処理機能")
    @Tag("payment")
    class PaymentProcessingTests {
        private Order testOrder;
        
        @BeforeEach
        void setUpPaymentTest() {
            UserManager userManager = eCommerceSystem.getUserManager();
            User user = userManager.registerUser("決済テスト", "payment@example.com", "password123");
            
            List&lt;OrderItem&gt; items = Arrays.asList(
                new OrderItem("PAY_PROD", 1, 5000.0)
            );
            OrderManager orderManager = eCommerceSystem.getOrderManager();
            testOrder = orderManager.createOrder(user, items);
        }
        
        @Test
        @Tag("payment")
        @Tag("fast")
        @DisplayName("決済成功")
        @Timeout(2)
        void 決済成功() {
            PaymentProcessor processor = eCommerceSystem.getPaymentProcessor();
            PaymentMethod creditCard = new PaymentMethod("CREDIT_CARD", 100000.0);
            
            PaymentResult result = processor.processPayment(testOrder, creditCard);
            
            assertTrue(result.isSuccess());
            assertNull(result.getErrorMessage());
        }
        
        @Test
        @Tag("payment")
        @Tag("fast")
        @DisplayName("決済限度額超過での失敗")
        void 決済限度額超過失敗() {
            PaymentProcessor processor = eCommerceSystem.getPaymentProcessor();
            PaymentMethod limitedCard = new PaymentMethod("DEBIT_CARD", 1000.0); // 限度額が注文金額以下
            
            PaymentResult result = processor.processPayment(testOrder, limitedCard);
            
            assertFalse(result.isSuccess());
            assertNotNull(result.getErrorMessage());
            assertTrue(result.getErrorMessage().contains("限度額"));
        }
        
        @Test
        @Tag("payment")
        @Tag("performance")
        @Tag("load")
        @EnabledIfSystemProperty(named = "load.tests.enabled", matches = "true")
        @DisplayName("決済処理の負荷テスト")
        void 決済負荷テスト() {
            PaymentProcessor processor = eCommerceSystem.getPaymentProcessor();
            PaymentMethod creditCard = new PaymentMethod("CREDIT_CARD", 1000000.0);
            
            List&lt;PaymentResult&gt; results = new ArrayList&lt;&gt;();
            long startTime = System.currentTimeMillis();
            
            // 100回の決済を並行処理
            for (int i = 0; i < 100; i++) {
                PaymentResult result = processor.processPayment(testOrder, creditCard);
                results.add(result);
            }
            
            long duration = System.currentTimeMillis() - startTime;
            
            assertTrue(duration < 30000, "100回の決済処理は30秒以内に完了すべき");
            assertEquals(100, results.size());
            
            long successCount = results.stream().mapToLong(r -> r.isSuccess() ? 1 : 0).sum();
            assertEquals(100, successCount, "すべての決済が成功すべき");
        }
    }
    
    @Nested
    @DisplayName("システム統合テスト")
    @Tag("integration")
    @Tag("e2e")
    class SystemIntegrationTests {
        
        @Test
        @Tag("workflow")
        @Tag("slow")
        @DisplayName("完全なeコマースワークフローテスト")
        @Timeout(5)
        void 完全ワークフロー() {
            // 1. ユーザー登録
            UserManager userManager = eCommerceSystem.getUserManager();
            User user = userManager.registerUser("統合テスト", "integration@example.com", "password123");
            
            // 2. 商品追加
            ProductManager productManager = eCommerceSystem.getProductManager();
            Product product = new Product("INTEGRATION_PROD", "統合テスト商品", 2000.0, 50);
            productManager.addProduct(product);
            
            // 3. 注文作成
            OrderManager orderManager = eCommerceSystem.getOrderManager();
            List&lt;OrderItem&gt; items = Arrays.asList(new OrderItem("INTEGRATION_PROD", 3, 2000.0));
            Order order = orderManager.createOrder(user, items);
            
            // 4. 決済処理
            PaymentProcessor paymentProcessor = eCommerceSystem.getPaymentProcessor();
            PaymentMethod creditCard = new PaymentMethod("CREDIT_CARD", 100000.0);
            PaymentResult paymentResult = paymentProcessor.processPayment(order, creditCard);
            
            // 5. 結果検証
            assertAll("完全ワークフローの検証",
                () -> assertNotNull(user.getId(), "ユーザーが作成されること"),
                () -> assertEquals("統合テスト商品", product.getName(), "商品が正しく登録されること"),
                () -> assertEquals(6000.0, order.getTotalAmount(), 0.01, "注文金額が正しいこと"),
                () -> assertTrue(paymentResult.isSuccess(), "決済が成功すること")
            );
        }
        
        @Test
        @Tag("smoke")
        @Tag("production")
        @EnabledOnOs({OS.LINUX, OS.MAC})
        @DisplayName("本番環境スモークテスト")
        void 本番環境スモークテスト() {
            // システムの基本的な動作確認
            assertAll("スモークテスト",
                () -> assertNotNull(eCommerceSystem.getUserManager(), "ユーザー管理が利用可能"),
                () -> assertNotNull(eCommerceSystem.getProductManager(), "商品管理が利用可能"),
                () -> assertNotNull(eCommerceSystem.getOrderManager(), "注文管理が利用可能"),
                () -> assertNotNull(eCommerceSystem.getPaymentProcessor(), "決済処理が利用可能")
            );
        }
    }
}</code></pre>

                        <h6>期待される結果</h6>
                        <p>このテストスイートでは以下の組織化手法が実践されています：</p>
                        <ul>
                            <li>@Nestedによる機能別・テスト種類別の階層化</li>
                            <li>@Tagによる実行種別の分類（fast, slow, integration, unit等）</li>
                            <li>条件付き実行による環境固有テストの制御</li>
                            <li>@Timeoutによる性能要件の検証</li>
                            <li>包括的なワークフローテストによる統合確認</li>
                        </ul>
                    </div>

                    <h3 class="section-title">7.4 テストコードの品質向上ベストプラクティス</h3>
                    
                    <p>保守しやすく理解しやすいテストコードを書くための実践的なガイドラインをまとめます。</p>

                    <h4>7.4.1 テスト命名のベストプラクティス</h4>
                    
                    <pre class="code-block"><code class="language-java">class TestNamingBestPractices {
    
    // 良い例：何をテストするかが明確
    @Test
    @DisplayName("有効期限切れのクレジットカードで決済すると例外が発生する")
    void 有効期限切れカードでの決済で例外発生() {
        CreditCard expiredCard = new CreditCard("1234-5678-9012-3456", 
            LocalDate.of(2020, 12, 31)); // 過去の日付
        PaymentRequest request = new PaymentRequest(1000.0, expiredCard);
        
        assertThrows(ExpiredCardException.class, 
            () -> paymentService.processPayment(request));
    }
    
    // 良い例：英語での命名パターン
    @Test
    @DisplayName("Should throw exception when processing payment with expired credit card")
    void shouldThrowExceptionWhenProcessingPaymentWithExpiredCreditCard() {
        // テストロジック
    }
    
    // 悪い例：曖昧な命名
    @Test
    void test1() { /* 何をテストするか不明 */ }
    
    @Test
    void paymentTest() { /* 決済の何をテストするか不明確 */ }
}</code></pre>

                    <h4>7.4.2 テストデータ管理の最適化</h4>
                    
                    <pre class="code-block"><code class="language-java">class TestDataManagement {
    
    // テストデータビルダーパターンの使用
    static class UserTestDataBuilder {
        private String name = "デフォルト太郎";
        private String email = "default@example.com";
        private String password = "password123";
        private UserType type = UserType.REGULAR;
        
        public UserTestDataBuilder withName(String name) {
            this.name = name; return this;
        }
        
        public UserTestDataBuilder withEmail(String email) {
            this.email = email; return this;
        }
        
        public UserTestDataBuilder asVipUser() {
            this.type = UserType.VIP; return this;
        }
        
        public User build() {
            return new User(name, email, password, type);
        }
    }
    
    @Test
    void VIPユーザーの特別割引テスト() {
        User vipUser = new UserTestDataBuilder()
            .withName("VIP田中")
            .withEmail("vip@example.com")
            .asVipUser()
            .build();
        
        DiscountService discountService = new DiscountService();
        double discount = discountService.calculateDiscount(vipUser, 10000.0);
        
        assertEquals(1000.0, discount, 0.01); // VIPは10%割引
    }
    
    // テストデータのファクトリーメソッド
    private Product createValidProduct() {
        return new Product("PROD001", "テスト商品", 1000.0, 10);
    }
    
    private Product createOutOfStockProduct() {
        return new Product("PROD002", "在庫切れ商品", 2000.0, 0);
    }
    
    private Order createSampleOrder() {
        User user = new UserTestDataBuilder().build();
        List&lt;OrderItem&gt; items = Arrays.asList(
            new OrderItem("PROD001", 2, 1000.0)
        );
        return new Order(UUID.randomUUID().toString(), user, items, LocalDateTime.now());
    }
}</code></pre>

                    <h4>7.4.3 アサーションの改善</h4>
                    
                    <pre class="code-block"><code class="language-java">class ImprovedAssertions {
    
    @Test
    void 商品検索結果の詳細検証() {
        ProductService service = new ProductService();
        
        List&lt;Product&gt; results = service.searchByCategory("電子機器");
        
        // assertAll()で関連する検証をまとめる
        assertAll("商品検索結果の包括検証",
            () -> assertFalse(results.isEmpty(), "検索結果が空でないこと"),
            () -> assertTrue(results.size() <= 100, "検索結果は100件以下であること"),
            () -> assertTrue(results.stream().allMatch(p -> p.getCategory().equals("電子機器")), 
                "すべての商品が電子機器カテゴリであること"),
            () -> assertTrue(results.stream().allMatch(p -> p.isActive()), 
                "すべての商品がアクティブ状態であること"),
            () -> assertEquals(results.stream().sorted((a, b) -> a.getName().compareTo(b.getName())).toList(), 
                results, "結果が名前順でソートされていること")
        );
    }
    
    @Test
    void 注文の詳細な状態検証() {
        OrderService orderService = new OrderService();
        CreateOrderRequest request = new CreateOrderRequest(
            "USER001", 
            Arrays.asList(new OrderItem("PROD001", 2, 1500.0))
        );
        
        Order order = orderService.createOrder(request);
        
        // カスタムアサーションメソッドの使用
        assertValidOrder(order);
        assertOrderContainsProduct(order, "PROD001");
        assertOrderTotal(order, 3000.0);
    }
    
    // カスタムアサーションメソッド
    private void assertValidOrder(Order order) {
        assertAll("有効な注文の検証",
            () -> assertNotNull(order.getId(), "注文IDが設定されていること"),
            () -> assertNotNull(order.getOrderDate(), "注文日時が設定されていること"),
            () -> assertTrue(order.getOrderDate().isBefore(LocalDateTime.now().plusMinutes(1)), 
                "注文日時が現在時刻に近いこと"),
            () -> assertNotNull(order.getUser(), "注文者情報が設定されていること"),
            () -> assertFalse(order.getItems().isEmpty(), "注文商品が存在すること")
        );
    }
    
    private void assertOrderContainsProduct(Order order, String productId) {
        boolean containsProduct = order.getItems().stream()
            .anyMatch(item -> item.getProductId().equals(productId));
        assertTrue(containsProduct, String.format("注文に商品 %s が含まれていること", productId));
    }
    
    private void assertOrderTotal(Order order, double expectedTotal) {
        assertEquals(expectedTotal, order.getTotalAmount(), 0.01,
            String.format("注文合計金額が %.2f円であること", expectedTotal));
    }
}</code></pre>

                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li><strong>@Nestedアノテーションの主な利点は何ですか？</strong>
                                <ul>
                                    <li>a) テストの実行速度が向上する</li>
                                    <li>b) 関連するテストケースを階層的に整理できる</li>
                                    <li>c) テストの並列実行が可能になる</li>
                                    <li>d) メモリ使用量が削減される</li>
                                </ul>
                            </li>
                            <li><strong>@Tagアノテーションの用途として最も適切なものはどれですか？</strong>
                                <ul>
                                    <li>a) テストメソッドに固有IDを付与する</li>
                                    <li>b) テストを分類し、選択的に実行する</li>
                                    <li>c) テストの実行順序を制御する</li>
                                    <li>d) テスト結果にメタデータを追加する</li>
                                </ul>
                            </li>
                            <li><strong>@EnabledOnOsアノテーションが最も有用なケースはどれですか？</strong>
                                <ul>
                                    <li>a) データベース接続テスト</li>
                                    <li>b) OS固有の機能をテストする場合</li>
                                    <li>c) 性能テストの実行制御</li>
                                    <li>d) セキュリティテストの有効化</li>
                                </ul>
                            </li>
                            <li><strong>良いテストコードの特徴として最も重要でないものはどれですか？</strong>
                                <ul>
                                    <li>a) テストの意図が明確である</li>
                                    <li>b) テストが独立して実行できる</li>
                                    <li>c) 実行時間が可能な限り短い</li>
                                    <li>d) コード行数が少ない</li>
                                </ul>
                            </li>
                        </ol>
                        
                        <details style="margin-top: 1rem;">
                            <summary><strong>解答を見る</strong></summary>
                            <div style="margin-top: 0.5rem;">
                                <p><strong>1.</strong> b) 関連するテストケースを階層的に整理できる</p>
                                <p><strong>2.</strong> b) テストを分類し、選択的に実行する</p>
                                <p><strong>3.</strong> b) OS固有の機能をテストする場合</p>
                                <p><strong>4.</strong> d) コード行数が少ない（コードの短さよりも明確性が重要）</p>
                            </div>
                        </details>
                    </div>

                    <h3 class="section-title">7.5 まとめと次のステップ</h3>
                    
                    <p>この章で学習した内容により、JUnit 5を使用した包括的なテスト戦略を構築できるようになりました。</p>

                    <h4>7.5.1 習得したスキル</h4>
                    <ul>
                        <li>@Nestedによる階層的テスト構造の設計</li>
                        <li>@Tagによるテストの分類と選択実行</li>
                        <li>条件付きテスト実行による環境適応</li>
                        <li>保守しやすいテストコードの作成技法</li>
                        <li>CI/CDでの効率的なテスト実行戦略</li>
                    </ul>

                    <h4>7.5.2 推奨される次の学習ステップ</h4>
                    
                    <div class="highlight">
                        <h6><strong>さらなる学習へのロードマップ</strong></h6>
                        <ul>
                            <li><strong>モッキングライブラリ</strong>：Mockitoを使った高度なテスト技法</li>
                            <li><strong>統合テスト</strong>：Spring Boot Testによる包括的な統合テスト</li>
                            <li><strong>テスト駆動開発</strong>：TDDの実践とベストプラクティス</li>
                            <li><strong>継続的テスト</strong>：CI/CDパイプラインでの自動テスト戦略</li>
                            <li><strong>性能テスト</strong>：JMHやGatlingを使った詳細な性能検証</li>
                        </ul>
                    </div>

                    <div class="warning">
                        <h6><strong>実践での注意点</strong></h6>
                        <ul>
                            <li>テストの実行時間とカバレッジのバランスを考慮する</li>
                            <li>チーム全体でテスト戦略とベストプラクティスを共有する</li>
                            <li>継続的にテストコードをリファクタリングして品質を保つ</li>
                            <li>本番環境での障害を検証するためのテストケースを追加する</li>
                        </ul>
                    </div>

                    <!-- Chapter navigation -->
                    <div class="d-flex justify-content-between mt-4">
                        <a href="junit-learning-material-6.html" class="btn btn-secondary">← 前の章：例外テストとタイムアウト</a>
                        <a href="../README.html" class="btn btn-primary">学習ガイド目次に戻る →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Highlight.js initialization -->
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid.js initialization -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>