<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AWS学習教材 第8章 - サーバーレスコンピューティング（Lambda・API Gateway）</title>

    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">

    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>

    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
            line-height: 1.8;
        }

        /* ナビゲーション - AWS Orange */
        .navbar {
            background-color: #FF9900;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 1rem;
        }

        /* タイトル */
        .chapter-title {
            color: #FF9900;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 3px solid #FF9900;
            padding-bottom: 0.5rem;
            font-weight: bold;
        }

        .section-title {
            color: #EC7211;
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #FFF3E0;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #FF9900;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #fff9e6;
            border-radius: 8px;
            padding: 1.2rem;
            margin: 1.5rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            color: white;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #FF9900 !important;
            color: white !important;
            border-radius: 5px;
        }

        .nav-link {
            color: #333;
            transition: all 0.3s;
        }

        .nav-link:hover {
            background-color: #FFF3E0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">
                <strong>AWS学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="aws-learning-material-1.html">
                                第1章: AWS入門とアカウント設定
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="aws-learning-material-2.html">
                                第2章: コンピューティングとネットワークの基礎
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="aws-learning-material-3.html">
                                第3章: ストレージサービス
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="aws-learning-material-4.html">
                                第4章: データベースサービス
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="aws-learning-material-5.html">
                                第5章: ネットワークとコンテンツ配信
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="aws-learning-material-6.html">
                                第6章: セキュリティとアクセス管理
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="aws-learning-material-7.html">
                                第7章: 監視と運用管理
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="aws-learning-material-8.html">
                                第8章: サーバーレスコンピューティング
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="aws-learning-material-9.html">
                                第9章: コンテナサービス
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="aws-learning-material-10.html">
                                第10章: ベストプラクティスとコスト最適化
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第8章: サーバーレスコンピューティング（Lambda・API Gateway）</h1>
                </div>

                <div id="chapter8">
                    <!-- 章タイトル -->
                    <h2 class="chapter-title">サーバー管理不要のイベント駆動アーキテクチャ</h2>

                    <!-- 学習目標 -->
                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>Lambda関数を作成し、イベント駆動で実行する方法</li>
                            <li>API Gatewayでサーバーレスなバックエンドを構築する方法</li>
                            <li>S3、DynamoDB、SNSなどとLambdaを連携する方法</li>
                            <li>サーバーレスアーキテクチャの設計パターンの理解</li>
                            <li>Lambda関数のベストプラクティスとコスト最適化</li>
                        </ul>
                    </div>

                    <!-- セクション1: AWS Lambdaの基礎 -->
                    <h3 class="section-title">8.1 AWS Lambda とは</h3>
                    <p>
                        <strong>AWS Lambda</strong>は、<strong>サーバーレスコンピューティング</strong>を実現するサービスです。
                        サーバーレスとは、サーバーの管理（プロビジョニング、パッチ適用、スケーリング等）を
                        AWSが完全に担当し、開発者はコードの実装に集中できる環境を指します。
                    </p>

                    <h4>8.1.1 サーバーレスの概念とメリット</h4>
                    <p>従来のサーバーベースアーキテクチャとの比較：</p>
                    <table class="table table-bordered">
                        <thead class="table-light">
                            <tr>
                                <th>観点</th>
                                <th>従来のサーバーベース（EC2）</th>
                                <th>サーバーレス（Lambda）</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>サーバー管理</strong></td>
                                <td>必要（OS、パッチ、スケーリング）</td>
                                <td>不要（AWSが管理）</td>
                            </tr>
                            <tr>
                                <td><strong>課金</strong></td>
                                <td>稼働時間に対して課金</td>
                                <td>実行時間とリクエスト数に対して課金</td>
                            </tr>
                            <tr>
                                <td><strong>スケーリング</strong></td>
                                <td>手動またはAuto Scaling設定</td>
                                <td>自動的に並列実行数が増減</td>
                            </tr>
                            <tr>
                                <td><strong>最小課金単位</strong></td>
                                <td>1時間（または1秒）</td>
                                <td>100ms単位</td>
                            </tr>
                            <tr>
                                <td><strong>コールドスタート</strong></td>
                                <td>なし</td>
                                <td>あり（初回実行時の遅延）</td>
                            </tr>
                        </tbody>
                    </table>

                    <p>Lambdaのメリット：</p>
                    <ul>
                        <li><strong>運用コスト削減</strong>：サーバー管理、パッチ適用が不要</li>
                        <li><strong>コスト効率</strong>：実際の実行時間のみ課金（アイドル時間の課金なし）</li>
                        <li><strong>自動スケーリング</strong>：リクエスト増加に応じて自動的に並列実行</li>
                        <li><strong>高可用性</strong>：複数のAZで自動的に実行</li>
                        <li><strong>統合性</strong>：他のAWSサービスとシームレスに連携</li>
                    </ul>

                    <div class="mermaid">
                        flowchart LR
                            subgraph Traditional[従来のアーキテクチャ]
                                T1[常時稼働<br/>EC2インスタンス]
                                T2[アイドル時間も課金]
                                T3[手動スケーリング]
                            end
                            subgraph Serverless[サーバーレス]
                                S1[イベント駆動<br/>Lambda関数]
                                S2[実行時のみ課金]
                                S3[自動スケーリング]
                            end
                            Traditional -->|移行| Serverless
                    </div>

                    <h4>8.1.2 Lambda関数の作成とデプロイ</h4>
                    <p>Lambda関数を作成する手順：</p>
                    <ol>
                        <li>Lambdaコンソールで「Create function」</li>
                        <li>ランタイムを選択（Python、Node.js、Java、Go、Ruby、.NET等）</li>
                        <li>関数コードを記述（インラインエディタまたはZIPアップロード）</li>
                        <li>実行ロールを設定（他のAWSサービスへのアクセス権限）</li>
                        <li>メモリサイズとタイムアウトを設定</li>
                        <li>デプロイして実行</li>
                    </ol>

                    <p>基本的なLambda関数の例（Python）：</p>
                    <pre class="code-block"><code class="language-python">import json

def lambda_handler(event, context):
    """
    Lambda関数のエントリーポイント
    Args:
        event: イベントデータ（トリガーから渡される情報）
        context: 実行コンテキスト（関数名、残り時間等）
    Returns:
        レスポンス辞書
    """
    # イベントデータから名前を取得
    name = event.get('name', 'World')

    # レスポンスを返す
    return {
        'statusCode': 200,
        'body': json.dumps({
            'message': f'Hello, {name}!',
            'requestId': context.request_id
        })
    }
# シンプルなHello World関数</code></pre>

                    <h4>8.1.3 ランタイムと関数設定</h4>
                    <p><strong>ランタイム</strong>：Lambda関数を実行する環境</p>
                    <ul>
                        <li><strong>Python</strong>：3.9、3.10、3.11、3.12（データ処理、機械学習に人気）</li>
                        <li><strong>Node.js</strong>：18.x、20.x（Web APIに人気）</li>
                        <li><strong>Java</strong>：11、17、21（エンタープライズアプリケーション）</li>
                        <li><strong>Go</strong>：1.x（高速実行、低メモリ）</li>
                        <li><strong>.NET</strong>：6、8（Windowsアプリケーション）</li>
                        <li><strong>Ruby</strong>：3.2、3.3（スクリプティング）</li>
                        <li><strong>カスタムランタイム</strong>：独自のランタイムを構築可能</li>
                    </ul>

                    <p><strong>メモリ設定</strong>：128MB～10,240MB（128MB単位）</p>
                    <ul>
                        <li>メモリ増加に比例してCPU性能も向上</li>
                        <li>メモリが多いほど高速だが、コストも増加</li>
                    </ul>

                    <p><strong>タイムアウト</strong>：最大15分（900秒）</p>
                    <ul>
                        <li>長時間処理にはEC2やECSが適している</li>
                    </ul>

                    <div class="exercise-container">
                        <h5>実習 8-1: Hello Worldラムダ関数の作成とテスト</h5>
                        <p>最初のLambda関数を作成し、テストイベントで実行してみましょう。</p>
                        <h6>手順</h6>
                        <ol>
                            <li>Lambdaコンソールで「Create function」</li>
                            <li>「Author from scratch」を選択</li>
                            <li>関数名：<code>HelloWorldFunction</code></li>
                            <li>ランタイム：Python 3.12</li>
                            <li>「Create function」でデフォルト設定のまま作成</li>
                            <li>コードエディタで以下のコードに変更：
<pre class="code-block"><code class="language-python">import json

def lambda_handler(event, context):
    name = event.get('name', 'World')
    message = f'Hello, {name}!'

    return {
        'statusCode': 200,
        'body': json.dumps({'message': message})
    }</code></pre>
                            </li>
                            <li>「Deploy」でデプロイ</li>
                            <li>「Test」タブでテストイベントを作成：
<pre class="code-block"><code class="language-json">{
  "name": "AWS Lambda"
}</code></pre>
                            </li>
                            <li>「Test」を実行し、レスポンスを確認</li>
                            <li>CloudWatch Logsでログを確認</li>
                        </ol>
                        <h6>確認ポイント</h6>
                        <ul>
                            <li>テスト実行が成功し、「Hello, AWS Lambda!」が返されること</li>
                            <li>実行時間とメモリ使用量が表示されること</li>
                            <li>CloudWatch Logsにログが記録されていること</li>
                        </ul>
                    </div>

                    <!-- セクション2: Lambdaのトリガーとイベントソース -->
                    <h3 class="section-title">8.2 Lambdaのトリガーとイベントソース</h3>
                    <p>
                        Lambda関数は<strong>イベント駆動</strong>で実行されます。
                        様々なAWSサービスがイベントソースとなり、Lambda関数をトリガーできます。
                    </p>

                    <h4>8.2.1 主要なイベントソース</h4>
                    <table class="table table-bordered">
                        <thead class="table-light">
                            <tr>
                                <th>イベントソース</th>
                                <th>トリガーのタイミング</th>
                                <th>ユースケース</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>API Gateway</strong></td>
                                <td>HTTPリクエスト受信時</td>
                                <td>RESTful API、Webアプリケーション</td>
                            </tr>
                            <tr>
                                <td><strong>S3</strong></td>
                                <td>オブジェクト作成/削除時</td>
                                <td>画像処理、ログ分析、バックアップ</td>
                            </tr>
                            <tr>
                                <td><strong>DynamoDB Streams</strong></td>
                                <td>テーブル更新時</td>
                                <td>レプリケーション、変更通知</td>
                            </tr>
                            <tr>
                                <td><strong>SNS</strong></td>
                                <td>トピックへのメッセージ発行時</td>
                                <td>非同期処理、通知処理</td>
                            </tr>
                            <tr>
                                <td><strong>SQS</strong></td>
                                <td>キューにメッセージ追加時</td>
                                <td>バッチ処理、ワークフロー</td>
                            </tr>
                            <tr>
                                <td><strong>EventBridge</strong></td>
                                <td>スケジュール実行、イベントパターンマッチ</td>
                                <td>定期実行、イベントルーティング</td>
                            </tr>
                            <tr>
                                <td><strong>Kinesis</strong></td>
                                <td>ストリームレコード受信時</td>
                                <td>リアルタイムデータ処理</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="mermaid">
                        flowchart TD
                            subgraph Triggers[イベントソース]
                                API[API Gateway<br/>HTTPリクエスト]
                                S3[S3<br/>オブジェクト作成]
                                DDB[DynamoDB<br/>テーブル更新]
                                EB[EventBridge<br/>スケジュール実行]
                                SQS[SQS<br/>メッセージ追加]
                            end
                            subgraph Lambda[Lambda関数]
                                L[関数実行]
                            end
                            subgraph Actions[アクション]
                                A1[他のサービスを呼び出し]
                                A2[データ処理]
                                A3[通知送信]
                            end

                            API --> L
                            S3 --> L
                            DDB --> L
                            EB --> L
                            SQS --> L
                            L --> A1
                            L --> A2
                            L --> A3
                    </div>

                    <h4>8.2.2 S3イベントトリガーの実装</h4>
                    <p>
                        S3バケットにファイルがアップロードされたときに、自動的にLambda関数を実行できます。
                        典型的なユースケース：
                    </p>
                    <ul>
                        <li>画像のサムネイル生成</li>
                        <li>動画のトランスコーディング</li>
                        <li>CSVファイルのデータベース取り込み</li>
                        <li>ログファイルの解析</li>
                    </ul>

                    <p>サムネイル生成関数の例（Python + Pillow）：</p>
                    <pre class="code-block"><code class="language-python">import boto3
from PIL import Image
import io

s3 = boto3.client('s3')

def lambda_handler(event, context):
    # S3イベントからバケット名とオブジェクトキーを取得
    bucket = event['Records'][0]['s3']['bucket']['name']
    key = event['Records'][0]['s3']['object']['key']

    # 画像をダウンロード
    response = s3.get_object(Bucket=bucket, Key=key)
    image_content = response['Body'].read()

    # サムネイルを生成
    image = Image.open(io.BytesIO(image_content))
    image.thumbnail((200, 200))

    # サムネイルをバッファに保存
    buffer = io.BytesIO()
    image.save(buffer, 'JPEG')
    buffer.seek(0)

    # サムネイルをS3にアップロード
    thumbnail_key = f'thumbnails/{key}'
    s3.put_object(Bucket=bucket, Key=thumbnail_key, Body=buffer)

    return {'statusCode': 200, 'body': 'Thumbnail created'}
# 画像アップロード時に自動でサムネイル生成</code></pre>

                    <h4>8.2.3 EventBridgeによるスケジュール実行</h4>
                    <p>
                        <strong>Amazon EventBridge</strong>（旧CloudWatch Events）を使用すると、
                        定期的にLambda関数を実行できます。Cron式またはRate式でスケジュールを指定します。
                    </p>
                    <p>スケジュール式の例：</p>
                    <ul>
                        <li><code>rate(5 minutes)</code>：5分ごと</li>
                        <li><code>rate(1 hour)</code>：1時間ごと</li>
                        <li><code>cron(0 12 * * ? *)</code>：毎日正午（UTC）</li>
                        <li><code>cron(0 18 ? * MON-FRI *)</code>：平日の18時（UTC）</li>
                    </ul>

                    <!-- セクション3: Amazon API Gateway -->
                    <h3 class="section-title">8.3 Amazon API Gateway</h3>

                    <h4>8.3.1 API Gatewayとは</h4>
                    <p>
                        <strong>Amazon API Gateway</strong>は、フルマネージドなAPIサービスで、
                        RESTful APIやWebSocket APIを作成・公開・管理できます。
                        Lambda関数のフロントエンドとして機能し、HTTPSエンドポイントを提供します。
                    </p>

                    <p>API Gatewayの機能：</p>
                    <ul>
                        <li><strong>HTTPSエンドポイントの自動作成</strong>：独自ドメイン設定可能</li>
                        <li><strong>認証・認可</strong>：IAM、Cognito、カスタムオーソライザー</li>
                        <li><strong>レート制限</strong>：API使用量の制御</li>
                        <li><strong>キャッシング</strong>：レスポンスのキャッシュによる高速化</li>
                        <li><strong>モニタリング</strong>：CloudWatchとの統合</li>
                    </ul>

                    <h4>8.3.2 REST APIとHTTP APIの違い</h4>
                    <table class="table table-bordered">
                        <thead class="table-light">
                            <tr>
                                <th>機能</th>
                                <th>REST API</th>
                                <th>HTTP API</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>コスト</strong></td>
                                <td>標準</td>
                                <td>最大71%安い</td>
                            </tr>
                            <tr>
                                <td><strong>レイテンシー</strong></td>
                                <td>標準</td>
                                <td>より低い</td>
                            </tr>
                            <tr>
                                <td><strong>認証</strong></td>
                                <td>IAM、Cognito、Lambda、APIキー</td>
                                <td>IAM、Cognito、JWT</td>
                            </tr>
                            <tr>
                                <td><strong>キャッシング</strong></td>
                                <td>あり</td>
                                <td>なし</td>
                            </tr>
                            <tr>
                                <td><strong>推奨ユースケース</strong></td>
                                <td>高度な機能が必要な場合</td>
                                <td>シンプルなAPI、低コスト重視</td>
                            </tr>
                        </tbody>
                    </table>

                    <h4>8.3.3 APIの作成とLambda統合</h4>
                    <p>API GatewayとLambdaを統合する手順：</p>
                    <ol>
                        <li>API Gatewayコンソールで「Create API」</li>
                        <li>REST APIまたはHTTP APIを選択</li>
                        <li>リソース（URLパス）を作成：<code>/users</code>、<code>/users/{id}</code></li>
                        <li>メソッド（GET、POST、PUT、DELETE）を作成</li>
                        <li>統合タイプで「Lambda Function」を選択</li>
                        <li>Lambda関数を指定（Lambda Proxy統合を有効化推奨）</li>
                        <li>APIをデプロイしてエンドポイントを取得</li>
                    </ol>

                    <div class="mermaid">
                        flowchart LR
                            Client[クライアント<br/>ブラウザ/モバイルアプリ] -->|HTTPS リクエスト| API[API Gateway<br/>HTTPSエンドポイント]
                            API -->|認証・認可| Auth[認証チェック]
                            Auth -->|OK| Lambda[Lambda関数]
                            Lambda -->|DynamoDB操作| DDB[(DynamoDB)]
                            Lambda -->|レスポンス| API
                            API -->|JSON レスポンス| Client
                    </div>

                    <h4>8.3.4 Lambda Proxy統合</h4>
                    <p>
                        <strong>Lambda Proxy統合</strong>を使用すると、HTTPリクエスト全体（ヘッダー、クエリパラメータ、ボディ）が
                        Lambda関数のeventオブジェクトに渡されます。
                    </p>
                    <pre class="code-block"><code class="language-python">import json

def lambda_handler(event, context):
    # HTTPメソッドを取得
    http_method = event['httpMethod']

    # パスパラメータを取得
    path_params = event.get('pathParameters', {})

    # クエリパラメータを取得
    query_params = event.get('queryStringParameters', {})

    # リクエストボディを取得
    body = json.loads(event.get('body', '{}'))

    # レスポンスを返す（API Gateway形式）
    return {
        'statusCode': 200,
        'headers': {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'  # CORS対応
        },
        'body': json.dumps({
            'message': 'Success',
            'method': http_method
        })
    }
# API Gatewayからのリクエストを処理</code></pre>

                    <div class="exercise-container">
                        <h5>実習 8-2: API Gateway + Lambda でRESTful APIの構築</h5>
                        <p>簡単なユーザー管理APIを作成してみましょう。</p>
                        <h6>手順</h6>
                        <ol>
                            <li>Lambda関数を作成（<code>UserAPIFunction</code>）：
<pre class="code-block"><code class="language-python">import json

users = {
    "1": {"id": "1", "name": "Alice", "email": "alice@example.com"},
    "2": {"id": "2", "name": "Bob", "email": "bob@example.com"}
}

def lambda_handler(event, context):
    method = event['httpMethod']
    path = event['path']

    if method == 'GET' and path == '/users':
        return {
            'statusCode': 200,
            'body': json.dumps(list(users.values()))
        }

    elif method == 'GET' and '/users/' in path:
        user_id = event['pathParameters']['id']
        user = users.get(user_id)
        if user:
            return {'statusCode': 200, 'body': json.dumps(user)}
        else:
            return {'statusCode': 404, 'body': json.dumps({'error': 'User not found'})}

    return {'statusCode': 400, 'body': json.dumps({'error': 'Invalid request'})}</code></pre>
                            </li>
                            <li>API Gatewayで「Create API」→「REST API」</li>
                            <li>リソース<code>/users</code>を作成</li>
                            <li>メソッド「GET」を作成し、Lambda関数に統合（Proxy統合を有効化）</li>
                            <li>リソース<code>/users/{id}</code>を作成</li>
                            <li>メソッド「GET」を作成し、Lambda関数に統合</li>
                            <li>「Deploy API」でステージ<code>prod</code>にデプロイ</li>
                            <li>エンドポイントURLをコピーし、ブラウザまたはcurlでテスト：
<pre class="code-block"><code class="language-bash"># 全ユーザー取得
curl https://your-api-id.execute-api.ap-northeast-1.amazonaws.com/prod/users

# 特定ユーザー取得
curl https://your-api-id.execute-api.ap-northeast-1.amazonaws.com/prod/users/1</code></pre>
                            </li>
                        </ol>
                        <h6>確認ポイント</h6>
                        <ul>
                            <li><code>GET /users</code>で全ユーザーのリストが返されること</li>
                            <li><code>GET /users/1</code>で特定のユーザー情報が返されること</li>
                            <li>存在しないユーザーIDで404エラーが返されること</li>
                        </ul>
                    </div>

                    <!-- セクション4: サーバーレスアプリケーションの構築 -->
                    <h3 class="section-title">8.4 サーバーレスアプリケーションの構築</h3>

                    <h4>8.4.1 サーバーレスアーキテクチャの設計パターン</h4>
                    <p>典型的なサーバーレスアーキテクチャパターン：</p>

                    <p><strong>1. API + Lambda + DynamoDBの3層構成</strong></p>
                    <ul>
                        <li>API Gateway：フロントエンド（HTTPSエンドポイント）</li>
                        <li>Lambda：ビジネスロジック</li>
                        <li>DynamoDB：データ永続化</li>
                    </ul>

                    <div class="mermaid">
                        flowchart LR
                            Client[クライアント] -->|HTTPS| API[API Gateway]
                            API -->|トリガー| Lambda[Lambda関数]
                            Lambda -->|CRUD操作| DDB[(DynamoDB)]
                            Lambda -->|レスポンス| API
                            API -->|JSON| Client
                    </div>

                    <p><strong>2. S3静的サイト + API Gatewayのフルサーバーレス構成</strong></p>
                    <ul>
                        <li>S3：静的コンテンツ（HTML、CSS、JavaScript）</li>
                        <li>CloudFront：グローバル配信</li>
                        <li>API Gateway + Lambda：バックエンドAPI</li>
                        <li>DynamoDB：データストレージ</li>
                    </ul>

                    <p><strong>3. イベント駆動の非同期処理</strong></p>
                    <ul>
                        <li>S3にファイルアップロード → Lambda実行 → 処理結果をDynamoDBに保存</li>
                        <li>SQSキューにメッセージ追加 → Lambda実行 → バッチ処理</li>
                    </ul>

                    <h4>8.4.2 認証・認可（Amazon Cognito）</h4>
                    <p>
                        <strong>Amazon Cognito</strong>は、ユーザー認証とアクセス制御を提供するマネージドサービスです。
                    </p>
                    <p>Cognitoの主要機能：</p>
                    <ul>
                        <li><strong>ユーザープール</strong>：サインアップ、サインイン、ユーザー管理</li>
                        <li><strong>IDプール</strong>：一時的なAWS認証情報の発行</li>
                        <li><strong>ソーシャルログイン</strong>：Google、Facebook等との統合</li>
                        <li><strong>MFA</strong>：多要素認証のサポート</li>
                    </ul>

                    <p>API GatewayとCognitoの統合：</p>
                    <ol>
                        <li>Cognitoユーザープールを作成</li>
                        <li>API Gatewayでオーソライザーを作成（Cognito User Pool）</li>
                        <li>メソッドの認証でオーソライザーを選択</li>
                        <li>クライアントはCognitoからJWTトークンを取得し、Authorizationヘッダーに含めてリクエスト</li>
                    </ol>

                    <!-- セクション5: サーバーレスのベストプラクティス -->
                    <h3 class="section-title">8.5 サーバーレスのベストプラクティス</h3>

                    <h4>8.5.1 コールドスタート対策</h4>
                    <p>
                        <strong>コールドスタート</strong>とは、Lambda関数が初めて実行される際、または一定期間実行されなかった後に
                        再実行される際の初期化遅延のことです。
                    </p>
                    <p>コールドスタート対策：</p>
                    <ul>
                        <li><strong>メモリサイズの最適化</strong>：メモリを増やすとCPU性能も向上し、起動時間が短縮</li>
                        <li><strong>プロビジョンド同時実行数</strong>：事前に関数を初期化して待機（有料）</li>
                        <li><strong>依存関係の最小化</strong>：不要なライブラリを削除し、デプロイパッケージを小さく</li>
                        <li><strong>Lambda Layersの活用</strong>：共通ライブラリを分離してデプロイサイズを削減</li>
                        <li><strong>コネクションの再利用</strong>：データベース接続をグローバルスコープで初期化</li>
                    </ul>

                    <pre class="code-block"><code class="language-python"># 悪い例：毎回新しい接続を作成
def lambda_handler(event, context):
    db_client = create_db_connection()  # 毎回実行される
    result = db_client.query("SELECT ...")
    return result

# 良い例：接続をグローバルスコープで再利用
import boto3

dynamodb = boto3.resource('dynamodb')  # 関数外で初期化（再利用される）
table = dynamodb.Table('MyTable')

def lambda_handler(event, context):
    result = table.get_item(Key={'id': '123'})  # 接続を再利用
    return result
# コネクションプールの再利用でパフォーマンス向上</code></pre>

                    <h4>8.5.2 エラーハンドリングとリトライ</h4>
                    <p>Lambda関数のエラーハンドリング：</p>
                    <ul>
                        <li><strong>例外のキャッチ</strong>：try-except文で適切なエラーレスポンスを返す</li>
                        <li><strong>Dead Letter Queue（DLQ）</strong>：処理失敗時にSQSまたはSNSに送信</li>
                        <li><strong>リトライポリシー</strong>：非同期実行の場合、最大2回自動リトライ</li>
                        <li><strong>デスティネーション</strong>：成功/失敗時の送信先を設定</li>
                    </ul>

                    <h4>8.5.3 Lambda Layersによるコード共有</h4>
                    <p>
                        <strong>Lambda Layers</strong>は、複数のLambda関数で共有できるライブラリやカスタムランタイムを管理する機能です。
                    </p>
                    <p>Layersの利点：</p>
                    <ul>
                        <li>デプロイパッケージサイズの削減</li>
                        <li>共通ライブラリの一元管理</li>
                        <li>デプロイ時間の短縮</li>
                    </ul>

                    <h4>8.5.4 コスト最適化のヒント</h4>
                    <p>Lambda関数のコストを最適化する方法：</p>
                    <ul>
                        <li><strong>適切なメモリサイズ</strong>：AWS Lambda Power Tuningツールで最適値を測定</li>
                        <li><strong>実行時間の短縮</strong>：効率的なコード、並列処理の活用</li>
                        <li><strong>無料枠の活用</strong>：月間100万リクエスト、40万GB秒の無料枠</li>
                        <li><strong>不要な実行の削減</strong>：フィルタリング、条件付きトリガーの設定</li>
                    </ul>

                    <!-- 理解度確認クイズ -->
                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li>
                                <strong>サーバーレスアーキテクチャの主なメリットを3つ挙げてください。</strong>
                                <details>
                                    <summary>解答例を表示</summary>
                                    <p>
                                        1. <strong>運用コスト削減</strong>：サーバー管理、パッチ適用が不要<br>
                                        2. <strong>コスト効率</strong>：実際の実行時間のみ課金（アイドル時間の課金なし）<br>
                                        3. <strong>自動スケーリング</strong>：リクエスト増加に応じて自動的に並列実行数が増減
                                    </p>
                                </details>
                            </li>
                            <li>
                                <strong>Lambda関数のコールドスタートとは何ですか？どのように対策できますか？</strong>
                                <details>
                                    <summary>解答例を表示</summary>
                                    <p>
                                        コールドスタートとは、Lambda関数が初めて実行される際、または一定期間実行されなかった後に再実行される際の初期化遅延です。<br>
                                        対策：メモリサイズの最適化、プロビジョンド同時実行数の設定、依存関係の最小化、Lambda Layersの活用、
                                        データベース接続のグローバルスコープでの初期化などがあります。
                                    </p>
                                </details>
                            </li>
                            <li>
                                <strong>API GatewayのREST APIとHTTP APIの主な違いは何ですか？</strong>
                                <details>
                                    <summary>解答例を表示</summary>
                                    <p>
                                        HTTP APIはREST APIと比べて最大71%安く、レイテンシーも低いですが、
                                        REST APIにある一部の高度な機能（レスポンスキャッシング、APIキー認証など）がサポートされていません。
                                        シンプルなAPIや低コスト重視の場合はHTTP API、高度な機能が必要な場合はREST APIを選択します。
                                    </p>
                                </details>
                            </li>
                            <li>
                                <strong>Lambda Proxy統合を使用する利点は何ですか？</strong>
                                <details>
                                    <summary>解答例を表示</summary>
                                    <p>
                                        Lambda Proxy統合を使用すると、HTTPリクエスト全体（ヘッダー、クエリパラメータ、パスパラメータ、ボディ）が
                                        Lambda関数のeventオブジェクトに渡されます。これにより、API Gatewayでの複雑なマッピング設定が不要になり、
                                        Lambda関数内でリクエストの全情報にアクセスできます。
                                    </p>
                                </details>
                            </li>
                            <li>
                                <strong>Lambda関数のメモリサイズを増やすと、どのような影響がありますか？</strong>
                                <details>
                                    <summary>解答例を表示</summary>
                                    <p>
                                        メモリサイズを増やすと、それに比例してCPU性能も向上するため、実行時間が短縮される可能性があります。
                                        ただし、メモリが多いほど課金額も増加するため、AWS Lambda Power Tuningツール等で最適なメモリサイズを測定することが推奨されます。
                                    </p>
                                </details>
                            </li>
                            <li>
                                <strong>サーバーレスアーキテクチャでよく使われる「API + Lambda + DynamoDB」の3層構成の各層の役割を説明してください。</strong>
                                <details>
                                    <summary>解答例を表示</summary>
                                    <p>
                                        <strong>API Gateway</strong>：フロントエンド層。HTTPSエンドポイントを提供し、クライアントからのリクエストを受け付ける。<br>
                                        <strong>Lambda</strong>：ビジネスロジック層。リクエストを処理し、データベース操作やビジネスルールを実行する。<br>
                                        <strong>DynamoDB</strong>：データ永続化層。NoSQLデータベースとしてデータを保存・取得する。
                                    </p>
                                </details>
                            </li>
                        </ol>
                    </div>

                    <!-- まとめ -->
                    <h3 class="section-title">まとめ</h3>
                    <p>この章では、AWSのサーバーレスコンピューティングについて学習しました：</p>
                    <ul>
                        <li><strong>Lambda</strong>：サーバー管理不要のイベント駆動型コンピューティングサービス</li>
                        <li><strong>イベントソース</strong>：S3、DynamoDB、SNS、EventBridge等との統合</li>
                        <li><strong>API Gateway</strong>：RESTful APIの作成とLambdaとの統合</li>
                        <li><strong>サーバーレスアーキテクチャ</strong>：API + Lambda + DynamoDBの3層構成パターン</li>
                        <li><strong>ベストプラクティス</strong>：コールドスタート対策、エラーハンドリング、コスト最適化</li>
                    </ul>
                    <p>
                        次の章では、コンテナ技術を使ったモダンなアプリケーション実行環境であるECSとEKSについて学習します。
                    </p>

                    <!-- 章間ナビゲーション -->
                    <div class="d-flex justify-content-between mt-5 mb-4">
                        <a href="aws-learning-material-7.html" class="btn btn-secondary">← 前の章：監視と運用管理</a>
                        <a href="aws-learning-material-9.html" class="btn btn-primary">次の章：コンテナサービス →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- フッター -->
    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Highlight.js 初期化 -->
    <script>hljs.highlightAll();</script>

    <!-- Mermaid.js 初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>
