<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DevOps学習教材 第4章 - コンテナ技術とDocker</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        body { font-family: 'Noto Sans JP', sans-serif; padding-top: 56px; }
        .navbar { background-color: #0d6efd; }
        .sidebar { position: sticky; top: 70px; height: calc(100vh - 70px); overflow-y: auto; background-color: #f8f9fa; padding: 1rem; }
        .chapter-title { color: #0d6efd; margin-top: 1.5rem; margin-bottom: 1rem; border-bottom: 2px solid #0d6efd; padding-bottom: 0.5rem; }
        .section-title { color: #0dcaf0; margin-top: 1.2rem; margin-bottom: 0.8rem; }
        .quiz-container { background-color: #cfe2ff; border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; border-left: 4px solid #0d6efd; }
        .exercise-container { background-color: #f3e5f5; border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; border-left: 4px solid #9c27b0; }
        .highlight { background-color: #fff3cd; border-radius: 8px; padding: 1rem; margin: 1rem 0; border-left: 4px solid #ffc107; }
        .warning { background-color: #ffebee; border-radius: 8px; padding: 1rem; margin: 1rem 0; border-left: 4px solid #f44336; }
        .info-box { background-color: #e7f3ff; border-radius: 8px; padding: 1rem; margin: 1rem 0; border-left: 4px solid #0d6efd; }
        .code-block { background-color: #1e1e1e; color: white; border-radius: 5px; padding: 1rem; margin: 1rem 0; }
        .nav-link.active { background-color: #0d6efd !important; color: white !important; border-radius: 5px; }
        .nav-link { color: #333; transition: all 0.3s; }
        .nav-link:hover { background-color: #e7f3ff; border-radius: 5px; }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">DevOps学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link" href="devops-learning-material-3.html">第3章</a></li>
                    <li class="nav-item"><a class="nav-link active" href="#chapter4">第4章</a></li>
                    <li class="nav-item"><a class="nav-link" href="devops-learning-material-5.html">第5章</a></li>
                    <li class="nav-item"><a class="nav-link" href="README.html">目次</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="devops-learning-material-1.html">
                                第1章: DevOpsの基礎と文化
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="devops-learning-material-2.html">
                                第2章: バージョン管理とGit戦略
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="devops-learning-material-3.html">
                                第3章: CI/CD基礎
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="devops-learning-material-4.html">
                                第4章: コンテナ技術とDocker
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="devops-learning-material-5.html">
                                第5章: Kubernetesとコンテナオーケストレーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="devops-learning-material-6.html">
                                第6章: Infrastructure as Code (IaC)
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="devops-learning-material-7.html">
                                第7章: クラウドプラットフォームとDevOps
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="devops-learning-material-8.html">
                                第8章: モニタリング、ロギング、オブザーバビリティ
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="devops-learning-material-9.html">
                                第9章: セキュリティとDevSecOps
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="devops-learning-material-10.html">
                                第10章: DevOps実践とベストプラクティス
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第4章: コンテナ技術とDocker</h1>
                </div>

                <div id="chapter4">
                    <h2 class="chapter-title">アプリケーションのパッケージング</h2>

                    <div class="highlight">
                        <h5>この章で学ぶこと</h5>
                        <ul>
                            <li>DevOpsにおけるコンテナ技術の役割を理解する</li>
                            <li>Dockerfileのベストプラクティスを習得する</li>
                            <li>コンテナイメージのタグ戦略を学ぶ</li>
                            <li>CI/CDパイプラインにコンテナビルドを統合する</li>
                            <li>イメージの脆弱性スキャンを実践する</li>
                        </ul>
                    </div>

                    <h3 class="section-title" id="section4-1">4.1 DevOpsにおけるコンテナの役割</h3>

                    <p>コンテナ技術は、DevOpsにおいて「どこでも動く」環境の一貫性を実現し、デプロイメントを劇的に簡素化します。</p>

                    <h4>コンテナがDevOpsにもたらすメリット</h4>

                    <div class="mermaid">
                        flowchart LR
                            A["従来の課題<br/>（動作環境の不一致）"] --> B["開発環境"]
                            A --> C["テスト環境"]
                            A --> D["本番環境"]

                            E["コンテナ化"] --> F["どこでも同じ<br/>コンテナが動作"]
                            F --> B2["開発"]
                            F --> C2["テスト"]
                            F --> D2["本番"]
                    </div>

                    <ul>
                        <li><strong>環境の一貫性</strong>: "Works on my machine"問題の解決。開発・テスト・本番で同じコンテナイメージを使用</li>
                        <li><strong>移植性</strong>: クラウド、オンプレミス、ローカルマシンなど、どこでも実行可能</li>
                        <li><strong>迅速なデプロイ</strong>: 数秒でコンテナを起動・停止できる</li>
                        <li><strong>リソース効率</strong>: VMより軽量で、同じハードウェアでより多くのアプリケーションを実行</li>
                        <li><strong>マイクロサービスに最適</strong>: 小さな独立したサービスを個別にデプロイ・スケール</li>
                    </ul>

                    <h4>コンテナ vs 仮想マシン（VM）</h4>

                    <table class="table table-bordered">
                        <thead class="table-primary">
                            <tr><th>観点</th><th>コンテナ</th><th>仮想マシン（VM）</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>起動時間</td><td>数秒</td><td>数分</td></tr>
                            <tr><td>サイズ</td><td>数MB〜数百MB</td><td>数GB〜数十GB</td></tr>
                            <tr><td>リソース効率</td><td>高い（ホストOSを共有）</td><td>低い（各VMがフルOSを持つ）</td></tr>
                            <tr><td>分離レベル</td><td>プロセスレベル</td><td>完全な仮想化</td></tr>
                            <tr><td>適用シーン</td><td>マイクロサービス、CI/CD</td><td>完全な分離が必要な場合</td></tr>
                        </tbody>
                    </table>

                    <h3 class="section-title" id="section4-2">4.2 Dockerfileのベストプラクティス</h3>

                    <p>効率的で安全なDockerイメージを作成するためのベストプラクティスを学びます。</p>

                    <h4>マルチステージビルド</h4>

                    <p>マルチステージビルドは、ビルド環境と実行環境を分離し、最終イメージのサイズを劇的に削減します。</p>

                    <pre class="code-block"><code class="language-bash"># マルチステージビルドの例（Node.js）

# ===== ステージ1: ビルド環境 =====
FROM node:18 AS builder

WORKDIR /app

# 依存関係のインストール（レイヤーキャッシュを活用）
COPY package*.json ./
RUN npm ci --only=production

# ソースコードのコピーとビルド
COPY . .
RUN npm run build

# ===== ステージ2: 実行環境 =====
FROM node:18-slim

WORKDIR /app

# ビルド成果物のみをコピー（ソースコードや開発ツールは含まれない）
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY package.json ./

# 非rootユーザーで実行
RUN useradd -m appuser
USER appuser

EXPOSE 3000
CMD ["node", "dist/index.js"]</code></pre>

                    <div class="info-box">
                        <h6>マルチステージビルドのメリット</h6>
                        <ul>
                            <li><strong>イメージサイズ削減</strong>: ビルドツールを含まない（例: 1GB → 100MB）</li>
                            <li><strong>セキュリティ向上</strong>: 攻撃対象が減る</li>
                            <li><strong>ビルド効率化</strong>: 中間レイヤーをキャッシュ</li>
                        </ul>
                    </div>

                    <h4>レイヤーキャッシュの最適化</h4>

                    <p>Dockerは各命令を個別のレイヤーとして保存します。変更が少ないレイヤーを先に配置することでビルドを高速化します。</p>

                    <pre class="code-block"><code class="language-bash"># ❌ 非効率な例
FROM python:3.11-slim
WORKDIR /app
COPY . .  # ソースコード変更のたびに全て再ビルド
RUN pip install -r requirements.txt

# ✅ 効率的な例
FROM python:3.11-slim
WORKDIR /app

# 1. 依存関係ファイルのみコピー（変更頻度が低い）
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 2. ソースコードをコピー（変更頻度が高い）
COPY . .

CMD ["python", "app.py"]</code></pre>

                    <h4>セキュリティのベストプラクティス</h4>

                    <pre class="code-block"><code class="language-bash"># セキュアなDockerfileの例

FROM node:18-slim

# 1. 最新のセキュリティパッチを適用
RUN apt-get update && apt-get upgrade -y && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production && \
    npm cache clean --force

COPY . .

# 2. 非rootユーザーで実行
RUN groupadd -r appuser && useradd -r -g appuser appuser
RUN chown -R appuser:appuser /app
USER appuser

# 3. ヘルスチェックの追加
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD node healthcheck.js || exit 1

EXPOSE 3000
CMD ["node", "server.js"]</code></pre>

                    <h3 class="section-title" id="section4-3">4.3 CI/CDとコンテナ統合</h3>

                    <h4>GitHub Actionsでのコンテナビルド</h4>

                    <pre class="code-block"><code class="language-yaml"># .github/workflows/docker-build.yml
name: Docker Build and Push

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=sha

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max</code></pre>

                    <h4>コンテナイメージのタグ戦略</h4>

                    <div class="info-box">
                        <h6>推奨されるタグ戦略</h6>
                        <ul>
                            <li><strong>セマンティックバージョニング</strong>: <code>v1.2.3</code>、<code>v1.2</code>、<code>v1</code></li>
                            <li><strong>Git SHA</strong>: <code>sha-abc123</code>（特定コミットの追跡）</li>
                            <li><strong>ブランチ名</strong>: <code>main</code>、<code>develop</code></li>
                            <li><strong>環境</strong>: <code>staging</code>、<code>production</code></li>
                            <li><strong>latest</strong>: 最新の安定版（注意: 本番では避ける）</li>
                        </ul>
                    </div>

                    <h4>イメージの脆弱性スキャン（Trivy）</h4>

                    <pre class="code-block"><code class="language-yaml"># .github/workflows/security-scan.yml
name: Security Scan

on:
  push:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 1'  # 毎週月曜日に実行

jobs:
  scan:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Build Docker image
        run: docker build -t myapp:latest .

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'myapp:latest'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Fail on HIGH or CRITICAL vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'myapp:latest'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'</code></pre>

                    <div class="exercise-container">
                        <h5>実習 4-1: マルチステージビルドの実践</h5>
                        <p>Node.jsアプリケーションでマルチステージビルドを実践し、イメージサイズを最適化します。</p>

                        <h6>手順</h6>
                        <ol>
                            <li>シンプルなNode.jsアプリケーションを作成</li>
                            <li>マルチステージビルドのDockerfileを作成</li>
                            <li>イメージをビルドしてサイズを比較</li>
                            <li>GitHub Actionsで自動ビルド</li>
                        </ol>

                        <h6>1. アプリケーションの作成</h6>
                        <pre class="code-block"><code class="language-bash">mkdir docker-app && cd docker-app
npm init -y
npm install express</code></pre>

                        <pre class="code-block"><code class="language-javascript">// index.js
const express = require('express');
const app = express();

app.get('/', (req, res) => {
    res.json({ message: 'Hello from Docker!', version: '1.0.0' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});</code></pre>

                        <h6>2. Dockerfileの作成</h6>
                        <pre class="code-block"><code class="language-bash"># Dockerfile
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .

FROM node:18-slim
WORKDIR /app
COPY --from=builder /app .
RUN useradd -m appuser && chown -R appuser:appuser /app
USER appuser
EXPOSE 3000
CMD ["node", "index.js"]</code></pre>

                        <h6>3. ビルドと実行</h6>
                        <pre class="code-block"><code class="language-bash"># ビルド
docker build -t myapp:1.0.0 .

# イメージサイズの確認
docker images myapp:1.0.0

# 実行
docker run -p 3000:3000 myapp:1.0.0

# テスト
curl http://localhost:3000</code></pre>

                        <h6>期待される結果</h6>
                        <ul>
                            <li>マルチステージビルドにより、イメージサイズが大幅に削減される</li>
                            <li>コンテナが正常に起動し、APIレスポンスが返される</li>
                            <li>非rootユーザーで安全に実行される</li>
                        </ul>
                    </div>

                    <div class="quiz-container">
                        <h5>理解度確認クイズ</h5>
                        <ol>
                            <li><strong>Q: コンテナが仮想マシンより優れている点を3つ挙げてください。</strong><br>
                                A: 起動時間が速い（数秒）、リソース効率が高い（ホストOSを共有）、イメージサイズが小さい（数MB〜数百MB）。</li>
                            <li><strong>Q: マルチステージビルドの目的は何ですか？</strong><br>
                                A: ビルド環境と実行環境を分離し、最終イメージのサイズを削減すること。ビルドツールや中間ファイルを含まないため、セキュリティも向上します。</li>
                            <li><strong>Q: Dockerfileでレイヤーキャッシュを最適化するコツは何ですか？</strong><br>
                                A: 変更頻度が低いファイル（依存関係ファイル）を先にコピーし、変更頻度が高いファイル（ソースコード）を後にコピーすること。</li>
                            <li><strong>Q: 本番環境で「latest」タグを避けるべき理由は何ですか？</strong><br>
                                A: latestタグは常に最新版を指すため、意図しないバージョンがデプロイされるリスクがあります。代わりに具体的なバージョン（v1.2.3等）を使用すべきです。</li>
                            <li><strong>Q: Trivyなどの脆弱性スキャナーを使う目的は何ですか？</strong><br>
                                A: コンテナイメージに含まれるセキュリティ脆弱性を自動的に検出し、本番環境にデプロイする前に修正するためです。</li>
                        </ol>
                    </div>

                    <h3 class="section-title">まとめ</h3>
                    <div class="highlight">
                        <h6>重要ポイント</h6>
                        <ul>
                            <li>コンテナは環境の一貫性と移植性を実現し、DevOpsに不可欠</li>
                            <li>マルチステージビルドでイメージサイズを最適化</li>
                            <li>レイヤーキャッシュを活用してビルドを高速化</li>
                            <li>セマンティックバージョニングとGit SHAでタグを管理</li>
                            <li>脆弱性スキャンをCI/CDパイプラインに統合</li>
                        </ul>
                    </div>

                    <p>次の章では、「Kubernetesとコンテナオーケストレーション」について学びます。複数のコンテナを効率的に管理・スケーリングする方法を習得します。</p>

                    <div class="d-flex justify-content-between mt-4">
                        <a href="devops-learning-material-3.html" class="btn btn-secondary">← 前の章: CI/CD基礎</a>
                        <a href="devops-learning-material-5.html" class="btn btn-primary">次の章: Kubernetes →</a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <footer class="bg-dark text-white mt-5">
        <div class="container-fluid py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-0">© 2025 F-Circle. All rights reserved.<br>
本資料はAIツールを活用し、人間による編集・監修のもと作成されています。無断転載・再配布を禁じます。</p>
                </div>
            </div>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>mermaid.initialize({ startOnLoad: true, theme: 'default' });</script>
</body>
</html>