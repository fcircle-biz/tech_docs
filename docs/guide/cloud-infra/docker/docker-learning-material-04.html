<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker学習教材 第4章 - Dockerfileによるイメージ作成</title>

    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">

    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>

    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
            line-height: 1.8;
        }

        /* ナビゲーション - Docker Blue */
        .navbar {
            background-color: #2496ED;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 1rem;
        }

        /* タイトル */
        .chapter-title {
            color: #2496ED;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 3px solid #2496ED;
            padding-bottom: 0.5rem;
            font-weight: bold;
        }

        .section-title {
            color: #1D63ED;
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e7f3ff;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #2496ED;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #fff9e6;
            border-radius: 8px;
            padding: 1.2rem;
            margin: 1.5rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            color: white;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
        }

        pre code.hljs {
            background-color: #1e1e1e;
            padding: 1rem;
            border-radius: 5px;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #2496ED !important;
            color: white !important;
            border-radius: 5px;
        }

        .nav-link {
            color: #333;
            transition: all 0.3s;
        }

        .nav-link:hover {
            background-color: #e7f3ff;
            border-radius: 5px;
        }

        /* Mermaid図表 */
        .mermaid {
            text-align: center;
            margin: 2rem 0;
        }

        /* ナビゲーションボタン */
        .chapter-nav {
            margin: 2rem 0;
        }

        /* 折りたたみコンテンツ */
        .collapse-trigger {
            cursor: pointer;
            color: #2496ED;
            user-select: none;
        }

        .collapse-trigger:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">
                <i class="fab fa-docker"></i>
                <strong>Docker学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-01.html">
                                第1章: Dockerとは何か
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-02.html">
                                第2章: 環境構築と基本操作
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-03.html">
                                第3章: イメージの理解と管理
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="docker-learning-material-04.html">
                                第4章: Dockerfileによるイメージ作成
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-05.html">
                                第5章: Docker Compose
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-06.html">
                                第6章: ボリュームとデータ永続化
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-07.html">
                                第7章: ネットワークとコンテナ間通信
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-08.html">
                                第8章: マルチコンテナアプリケーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-09.html">
                                第9章: ベストプラクティスとセキュリティ
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-10.html">
                                第10章: 本番環境へのデプロイ
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第4章: Dockerfileによるイメージ作成</h1>
                </div>

                <!-- 学習目標 -->
                <div class="highlight">
                    <h4>学習目標</h4>
                    <ul>
                        <li>Dockerfileの基本構文と記述ルールを理解する</li>
                        <li>主要な命令（FROM、RUN、COPY、CMD等）の使い分けができる</li>
                        <li>レイヤーキャッシュの仕組みを理解し、効率的なビルドを実現する</li>
                        <li>マルチステージビルドでイメージサイズを最適化する</li>
                        <li>実践的なDockerfileを作成し、独自のイメージをビルドできる</li>
                    </ul>
                </div>

                <!-- はじめに -->
                <section id="intro">
                    <h2 class="section-title">はじめに</h2>
                    <p>
                        前章では、Docker Hubから既存のイメージを取得して使用する方法を学びました。しかし、実際の開発では、自分のアプリケーションをコンテナ化するために<strong>独自のイメージを作成</strong>する必要があります。
                    </p>
                    <p>
                        この章では、<strong>Dockerfile</strong>というテキストファイルを使って、イメージを自動的に構築する方法を学びます。Dockerfileは「イメージの設計図」であり、アプリケーションの実行環境を再現可能な形で定義できます。
                    </p>
                    <p>
                        Dockerfileを使うことで、開発環境と本番環境を同じ設定で統一したり、チーム全体で同じ環境を共有したり、CI/CDパイプラインで自動的にイメージをビルドしたりできるようになります。
                    </p>
                </section>

                <!-- Dockerfileとは -->
                <section id="what-is-dockerfile">
                    <h2 class="section-title">Dockerfileとは</h2>

                    <h3>Dockerfileの役割</h3>
                    <p>
                        <strong>Dockerfile</strong>は、Dockerイメージを作成するための手順書です。どのベースイメージから始めるか、どんなソフトウェアをインストールするか、どのファイルをコピーするか、どのコマンドを実行するかなどを、テキスト形式で記述します。
                    </p>

                    <div class="mermaid">
                        graph LR
                            A[Dockerfile] -->|docker build| B[Dockerイメージ]
                            B -->|docker run| C[コンテナ]
                            style A fill:#fff9e6
                            style B fill:#e7f3ff
                            style C fill:#e8f5e9
                    </div>

                    <h3>Dockerfileのメリット</h3>
                    <ul>
                        <li><strong>再現性</strong>：同じDockerfileからは常に同じイメージが生成される</li>
                        <li><strong>バージョン管理</strong>：Gitなどで履歴を追跡し、変更を管理できる</li>
                        <li><strong>自動化</strong>：ビルドプロセスを自動化し、手動作業を削減</li>
                        <li><strong>共有</strong>：チームメンバーと環境設定を簡単に共有できる</li>
                        <li><strong>ドキュメント</strong>：環境構築手順が明示的に記録される</li>
                    </ul>

                    <h3>Dockerfileの命名</h3>
                    <p>
                        慣習として、ファイル名は<code>Dockerfile</code>（大文字のDで拡張子なし）とします。特定の環境用に複数のDockerfileを使い分ける場合は、<code>Dockerfile.dev</code>や<code>Dockerfile.prod</code>のように接尾辞を付けることもあります。
                    </p>
                </section>

                <!-- 基本構文とルール -->
                <section id="basic-syntax">
                    <h2 class="section-title">基本構文とルール</h2>

                    <h3>基本的な記述形式</h3>
                    <p>Dockerfileは、<strong>命令</strong>と<strong>引数</strong>で構成されます。命令は慣習的に大文字で記述します。</p>

                    <pre class="code-block"><code class="language-dockerfile"># コメントは # で始まる

INSTRUCTION arguments
INSTRUCTION arguments
...</code></pre>

                    <h3>最小限のDockerfile例</h3>
                    <p>最もシンプルなDockerfileの例を見てみましょう：</p>

                    <pre class="code-block"><code class="language-dockerfile"># ベースイメージを指定
FROM ubuntu:22.04

# コマンドを実行
RUN echo "Hello from Dockerfile!"</code></pre>

                    <h3>Dockerfileの記述ルール</h3>
                    <div class="warning">
                        <h5>重要なルール</h5>
                        <ul>
                            <li><strong>FROM命令が最初</strong>：ほぼすべてのDockerfileは<code>FROM</code>で始まる（例外：マルチステージビルド）</li>
                            <li><strong>命令は順番に実行</strong>：上から下へ順番に処理される</li>
                            <li><strong>各命令がレイヤーを作成</strong>：命令ごとに新しいイメージレイヤーが追加される</li>
                            <li><strong>コメントは#で始める</strong>：行の先頭に#を付けるとコメント扱い</li>
                            <li><strong>バックスラッシュで改行</strong>：長い命令は<code>\</code>で複数行に分割できる</li>
                        </ul>
                    </div>

                    <h3>複数行の記述例</h3>
                    <pre class="code-block"><code class="language-dockerfile"># バックスラッシュで改行して可読性を向上
RUN apt-get update && \
    apt-get install -y \
        curl \
        git \
        vim && \
    apt-get clean</code></pre>
                </section>

                <!-- 主要な命令 -->
                <section id="main-instructions">
                    <h2 class="section-title">主要な命令</h2>

                    <h3>FROM - ベースイメージの指定</h3>
                    <p>
                        <code>FROM</code>は、イメージ作成の出発点となるベースイメージを指定します。ほぼすべてのDockerfileはこの命令で始まります。
                    </p>

                    <pre class="code-block"><code class="language-dockerfile"># 公式イメージを使用
FROM ubuntu:22.04

# 特定バージョンを指定
FROM node:18-alpine

# 最新版を使用（非推奨：再現性が低い）
FROM python:latest</code></pre>

                    <div class="highlight">
                        <strong>ベストプラクティス：</strong>
                        <ul>
                            <li>公式イメージを優先的に使用する</li>
                            <li>バージョンを明示的に指定する（<code>:latest</code>は避ける）</li>
                            <li>可能な限り軽量なイメージ（Alpine Linux等）を選択する</li>
                        </ul>
                    </div>

                    <h3>RUN - コマンドの実行</h3>
                    <p>
                        <code>RUN</code>は、イメージビルド時にコマンドを実行します。パッケージのインストールやファイルの作成など、環境構築に使用します。
                    </p>

                    <pre class="code-block"><code class="language-dockerfile"># シェル形式（推奨）
RUN apt-get update && apt-get install -y nginx

# exec形式
RUN ["apt-get", "install", "-y", "nginx"]

# 複数のコマンドを実行
RUN apt-get update && \
    apt-get install -y \
        python3 \
        python3-pip && \
    pip3 install flask</code></pre>

                    <div class="warning">
                        <strong>注意：</strong>レイヤー数を減らすため、関連する複数のコマンドは<code>&&</code>で連結して1つの<code>RUN</code>命令にまとめるのが推奨されます。
                    </div>

                    <h3>COPY - ファイルのコピー</h3>
                    <p>
                        <code>COPY</code>は、ホストマシンからコンテナイメージにファイルやディレクトリをコピーします。
                    </p>

                    <pre class="code-block"><code class="language-dockerfile"># ファイルをコピー
COPY app.py /app/app.py

# ディレクトリをコピー
COPY ./src /app/src

# 複数のファイルをコピー
COPY package.json package-lock.json /app/

# ワイルドカードを使用
COPY *.py /app/</code></pre>

                    <h3>ADD - ファイルの追加（拡張版COPY）</h3>
                    <p>
                        <code>ADD</code>は<code>COPY</code>と似ていますが、追加機能があります：
                    </p>
                    <ul>
                        <li>URLからファイルをダウンロード</li>
                        <li>tarアーカイブの自動展開</li>
                    </ul>

                    <pre class="code-block"><code class="language-dockerfile"># URLからダウンロード
ADD https://example.com/file.zip /tmp/

# tarファイルを自動展開
ADD archive.tar.gz /app/</code></pre>

                    <div class="highlight">
                        <strong>ベストプラクティス：</strong>基本的には<code>COPY</code>を使用し、<code>ADD</code>の特殊機能が必要な場合のみ使用します。
                    </div>

                    <h3>WORKDIR - 作業ディレクトリの設定</h3>
                    <p>
                        <code>WORKDIR</code>は、以降の命令（<code>RUN</code>、<code>CMD</code>、<code>COPY</code>等）で使用される作業ディレクトリを設定します。
                    </p>

                    <pre class="code-block"><code class="language-dockerfile"># 作業ディレクトリを設定（存在しない場合は自動作成）
WORKDIR /app

# これ以降のコマンドは /app で実行される
COPY . .
RUN npm install</code></pre>

                    <div class="highlight">
                        <strong>推奨：</strong><code>cd</code>コマンドではなく<code>WORKDIR</code>を使用することで、パスが明確になります。
                    </div>

                    <h3>ENV - 環境変数の設定</h3>
                    <p>
                        <code>ENV</code>は、コンテナ内で使用される環境変数を設定します。
                    </p>

                    <pre class="code-block"><code class="language-dockerfile"># 環境変数を設定
ENV APP_HOME=/app
ENV NODE_ENV=production

# 複数の環境変数を一度に設定
ENV APP_HOME=/app \
    NODE_ENV=production \
    PORT=8080

# 設定した環境変数を使用
WORKDIR $APP_HOME</code></pre>

                    <h3>EXPOSE - ポートの公開</h3>
                    <p>
                        <code>EXPOSE</code>は、コンテナがリッスンするポート番号を宣言します（ドキュメントの役割が主）。
                    </p>

                    <pre class="code-block"><code class="language-dockerfile"># ポート8080を公開
EXPOSE 8080

# 複数のポートを公開
EXPOSE 8080 8443</code></pre>

                    <div class="warning">
                        <strong>注意：</strong><code>EXPOSE</code>だけではポートは公開されません。<code>docker run -p</code>オプションで実際にマッピングする必要があります。
                    </div>

                    <h3>CMD - デフォルトコマンドの指定</h3>
                    <p>
                        <code>CMD</code>は、コンテナ起動時に実行されるデフォルトのコマンドを指定します。Dockerfileに1つだけ記述できます（複数ある場合は最後のものが有効）。
                    </p>

                    <pre class="code-block"><code class="language-dockerfile"># exec形式（推奨）
CMD ["python3", "app.py"]

# シェル形式
CMD python3 app.py

# 引数のみ指定（ENTRYPOINTと併用）
CMD ["--port", "8080"]</code></pre>

                    <h3>ENTRYPOINT - 実行ファイルの指定</h3>
                    <p>
                        <code>ENTRYPOINT</code>は、コンテナを実行ファイルのように扱う際に使用します。<code>CMD</code>と組み合わせて使用されることが多いです。
                    </p>

                    <pre class="code-block"><code class="language-dockerfile"># ENTRYPOINTで実行ファイルを指定
ENTRYPOINT ["python3"]

# CMDでデフォルト引数を指定
CMD ["app.py"]

# docker run時に引数を上書き可能
# docker run myimage main.py  → python3 main.py が実行される</code></pre>

                    <h3>CMDとENTRYPOINTの違い</h3>
                    <div class="mermaid">
                        graph TD
                            A[コンテナ起動] --> B{ENTRYPOINT設定あり?}
                            B -->|はい| C[ENTRYPOINTを実行]
                            B -->|いいえ| D[CMDを実行]
                            C --> E{CMD設定あり?}
                            E -->|はい| F[CMDを引数として使用]
                            E -->|いいえ| G[ENTRYPOINTのみ実行]
                            D --> H[終了]
                            F --> H
                            G --> H
                    </div>

                    <div class="highlight">
                        <strong>使い分けのポイント：</strong>
                        <ul>
                            <li><code>CMD</code>：コマンド全体を上書きされても良い場合</li>
                            <li><code>ENTRYPOINT</code>：必ず実行したいコマンドがある場合</li>
                            <li>組み合わせ：<code>ENTRYPOINT</code>で実行ファイル、<code>CMD</code>でデフォルト引数</li>
                        </ul>
                    </div>

                    <h3>USER - 実行ユーザーの指定</h3>
                    <p>
                        <code>USER</code>は、以降のコマンドを実行するユーザーを指定します。セキュリティ上、rootユーザー以外での実行が推奨されます。
                    </p>

                    <pre class="code-block"><code class="language-dockerfile"># ユーザーを作成
RUN useradd -m -s /bin/bash appuser

# 作成したユーザーに切り替え
USER appuser

# これ以降のコマンドは appuser として実行される
WORKDIR /home/appuser/app
CMD ["python3", "app.py"]</code></pre>
                </section>

                <!-- ビルドプロセスの理解 -->
                <section id="build-process">
                    <h2 class="section-title">ビルドプロセスの理解</h2>

                    <h3>docker buildコマンド</h3>
                    <p>
                        Dockerfileからイメージを作成するには、<code>docker build</code>コマンドを使用します。
                    </p>

                    <pre class="code-block"><code class="language-bash"># 基本的なビルド（カレントディレクトリのDockerfileを使用）
docker build .

# タグを付けてビルド
docker build -t myapp:1.0 .

# 別のDockerfileを指定
docker build -f Dockerfile.dev -t myapp:dev .

# ビルドコンテキストを指定
docker build -t myapp:1.0 /path/to/context</code></pre>

                    <h3>ビルドコンテキストとは</h3>
                    <p>
                        <strong>ビルドコンテキスト</strong>は、<code>docker build</code>コマンドに指定するディレクトリのことです。Dockerデーモンは、このディレクトリ内のファイルをすべて読み込み、Dockerfileの<code>COPY</code>や<code>ADD</code>で使用できるようにします。
                    </p>

                    <div class="mermaid">
                        graph LR
                            A[ローカルディレクトリ] -->|ビルドコンテキスト送信| B[Dockerデーモン]
                            B -->|Dockerfileを解析| C[イメージ構築]
                            C --> D[完成イメージ]
                            style A fill:#fff9e6
                            style B fill:#e7f3ff
                            style D fill:#e8f5e9
                    </div>

                    <div class="warning">
                        <strong>注意：</strong>ビルドコンテキストが大きいと、ビルド時間が長くなります。不要なファイルは<code>.dockerignore</code>で除外しましょう。
                    </div>

                    <h3>ビルドプロセスの流れ</h3>
                    <ol>
                        <li>Dockerクライアントがビルドコンテキストをデーモンに送信</li>
                        <li>Dockerfileを上から順番に読み込む</li>
                        <li>各命令を実行して新しいレイヤーを作成</li>
                        <li>すべてのレイヤーを重ねて最終イメージを生成</li>
                        <li>指定されたタグでイメージを保存</li>
                    </ol>

                    <h3>ビルド例：シンプルなNode.jsアプリ</h3>
                    <p>実際のビルドプロセスを見てみましょう：</p>

                    <pre class="code-block"><code class="language-dockerfile"># Dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["node", "server.js"]</code></pre>

                    <pre class="code-block"><code class="language-bash"># ビルド実行
docker build -t nodeapp:1.0 .

# 出力例：
# Step 1/7 : FROM node:18-alpine
# Step 2/7 : WORKDIR /app
# Step 3/7 : COPY package*.json ./
# Step 4/7 : RUN npm install
# Step 5/7 : COPY . .
# Step 6/7 : EXPOSE 3000
# Step 7/7 : CMD ["node", "server.js"]
# Successfully built abc123def456
# Successfully tagged nodeapp:1.0</code></pre>
                </section>

                <!-- レイヤーキャッシュ -->
                <section id="layer-cache">
                    <h2 class="section-title">レイヤーキャッシュの活用</h2>

                    <h3>レイヤーキャッシュとは</h3>
                    <p>
                        Dockerは、各命令の結果を<strong>レイヤー</strong>として保存し、次回のビルド時に再利用します。これにより、変更のない部分をスキップして、ビルドを高速化できます。
                    </p>

                    <div class="mermaid">
                        graph TD
                            A[Dockerfileの命令] --> B{変更あり?}
                            B -->|なし| C[キャッシュを使用]
                            B -->|あり| D[命令を実行]
                            C --> E[次の命令へ]
                            D --> F[以降のキャッシュは無効]
                            F --> E
                    </div>

                    <h3>キャッシュが無効になる条件</h3>
                    <ul>
                        <li>Dockerfileの命令が変更された</li>
                        <li><code>COPY</code>や<code>ADD</code>でコピーするファイルの内容が変更された</li>
                        <li>親レイヤーのキャッシュが無効化された（連鎖的に無効化）</li>
                    </ul>

                    <h3>非効率なDockerfileの例</h3>
                    <pre class="code-block"><code class="language-dockerfile"># 悪い例：コードを先にコピーしてから依存関係をインストール
FROM node:18-alpine
WORKDIR /app
COPY . .                    # アプリコード変更のたびにキャッシュ無効
RUN npm install             # 毎回実行される（遅い！）
CMD ["node", "server.js"]</code></pre>

                    <h3>効率的なDockerfileの例</h3>
                    <pre class="code-block"><code class="language-dockerfile"># 良い例：依存関係ファイルを先にコピー
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./       # package.json変更時のみキャッシュ無効
RUN npm install             # 依存関係が変わらなければキャッシュ使用
COPY . .                    # アプリコードは最後にコピー
CMD ["node", "server.js"]</code></pre>

                    <div class="highlight">
                        <strong>最適化のポイント：</strong>
                        <ul>
                            <li>変更頻度の低いものを上に配置</li>
                            <li>変更頻度の高いものを下に配置</li>
                            <li>依存関係のインストールは先に実行</li>
                            <li>アプリケーションコードは最後にコピー</li>
                        </ul>
                    </div>

                    <h3>キャッシュを使わずにビルド</h3>
                    <pre class="code-block"><code class="language-bash"># キャッシュを無視して完全に再ビルド
docker build --no-cache -t myapp:1.0 .</code></pre>
                </section>

                <!-- マルチステージビルド -->
                <section id="multistage-build">
                    <h2 class="section-title">マルチステージビルド</h2>

                    <h3>マルチステージビルドとは</h3>
                    <p>
                        <strong>マルチステージビルド</strong>は、1つのDockerfile内で複数の<code>FROM</code>命令を使用し、ビルドステージを分ける手法です。これにより、ビルドツールを含まない軽量な最終イメージを作成できます。
                    </p>

                    <h3>なぜマルチステージビルドが必要か</h3>
                    <p>
                        アプリケーションのビルドには多くのツール（コンパイラ、ビルドツール、開発用ライブラリ等）が必要ですが、実行時には不要です。マルチステージビルドを使うことで、ビルドツールを含まない最小限のイメージを作成できます。
                    </p>

                    <div class="mermaid">
                        graph LR
                            A[ステージ1: ビルド] -->|成果物をコピー| B[ステージ2: 実行]
                            A -.->|破棄| C[ビルドツール]
                            B --> D[軽量な最終イメージ]
                            style A fill:#fff9e6
                            style B fill:#e7f3ff
                            style D fill:#e8f5e9
                    </div>

                    <h3>マルチステージビルドの例：Go言語</h3>
                    <pre class="code-block"><code class="language-dockerfile"># ステージ1: ビルド
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY . .
RUN go build -o myapp

# ステージ2: 実行（軽量）
FROM alpine:latest
WORKDIR /app
COPY --from=builder /app/myapp .
CMD ["./myapp"]</code></pre>

                    <p>
                        この例では、<code>golang:1.21-alpine</code>（約300MB）でビルドし、実行には<code>alpine:latest</code>（約5MB）を使用します。最終イメージサイズは大幅に削減されます。
                    </p>

                    <h3>マルチステージビルドの例：Node.js</h3>
                    <pre class="code-block"><code class="language-dockerfile"># ステージ1: 依存関係のインストールとビルド
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

# ステージ2: 実行環境
FROM node:18-alpine
WORKDIR /app
# builder ステージから必要なファイルのみコピー
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
COPY package*.json ./
USER node
CMD ["node", "dist/server.js"]</code></pre>

                    <h3>ステージに名前を付ける</h3>
                    <p>
                        <code>AS</code>キーワードでステージに名前を付けることで、可読性が向上し、後のステージから参照しやすくなります。
                    </p>

                    <pre class="code-block"><code class="language-dockerfile"># 複数のステージに名前を付ける
FROM node:18-alpine AS dependencies
WORKDIR /app
COPY package*.json ./
RUN npm ci

FROM node:18-alpine AS builder
WORKDIR /app
COPY --from=dependencies /app/node_modules ./node_modules
COPY . .
RUN npm run build

FROM node:18-alpine AS production
WORKDIR /app
COPY --from=builder /app/dist ./dist
CMD ["node", "dist/server.js"]</code></pre>

                    <div class="highlight">
                        <strong>メリット：</strong>
                        <ul>
                            <li>最終イメージサイズの大幅削減（数百MB→数十MB）</li>
                            <li>セキュリティ向上（ビルドツールを本番環境に含めない）</li>
                            <li>ビルドプロセスの明確化</li>
                        </ul>
                    </div>
                </section>

                <!-- 実践的な例 -->
                <section id="practical-examples">
                    <h2 class="section-title">実践的なDockerfile例</h2>

                    <h3>Python/Flask アプリケーション</h3>
                    <pre class="code-block"><code class="language-dockerfile"># Python公式イメージをベースに使用
FROM python:3.11-slim

# 作業ディレクトリを設定
WORKDIR /app

# 依存関係ファイルをコピー（キャッシュ効率化）
COPY requirements.txt .

# 依存関係をインストール
RUN pip install --no-cache-dir -r requirements.txt

# アプリケーションコードをコピー
COPY . .

# 非rootユーザーを作成して切り替え
RUN useradd -m -s /bin/bash appuser && \
    chown -R appuser:appuser /app
USER appuser

# ポート公開
EXPOSE 5000

# 環境変数設定
ENV FLASK_APP=app.py
ENV FLASK_ENV=production

# アプリケーション起動
CMD ["flask", "run", "--host=0.0.0.0"]</code></pre>

                    <h3>React フロントエンドアプリケーション</h3>
                    <pre class="code-block"><code class="language-dockerfile"># マルチステージビルド

# ステージ1: ビルド
FROM node:18-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# ステージ2: 本番環境（Nginx）
FROM nginx:alpine
# ビルド成果物をNginxの公開ディレクトリにコピー
COPY --from=build /app/build /usr/share/nginx/html
# カスタムNginx設定をコピー（オプション）
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]</code></pre>

                    <h3>Java/Spring Boot アプリケーション</h3>
                    <pre class="code-block"><code class="language-dockerfile"># マルチステージビルド

# ステージ1: ビルド
FROM maven:3.9-eclipse-temurin-17 AS build
WORKDIR /app
# pom.xmlを先にコピー（依存関係キャッシュ）
COPY pom.xml .
RUN mvn dependency:go-offline
# ソースコードをコピーしてビルド
COPY src ./src
RUN mvn clean package -DskipTests

# ステージ2: 実行
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app
# ビルドステージからJARファイルをコピー
COPY --from=build /app/target/*.jar app.jar
# 非rootユーザーで実行
RUN addgroup -S spring && adduser -S spring -G spring
USER spring
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]</code></pre>
                </section>

                <!-- .dockerignore活用 -->
                <section id="dockerignore">
                    <h2 class="section-title">.dockerignoreファイルの活用</h2>

                    <h3>.dockerignoreとは</h3>
                    <p>
                        <code>.dockerignore</code>ファイルは、ビルドコンテキストから除外するファイルやディレクトリを指定します。<code>.gitignore</code>と同様の記法で記述します。
                    </p>

                    <h3>.dockerignoreの必要性</h3>
                    <ul>
                        <li><strong>ビルド高速化</strong>：不要なファイルをDockerデーモンに送信しない</li>
                        <li><strong>イメージサイズ削減</strong>：不要なファイルがイメージに含まれない</li>
                        <li><strong>セキュリティ</strong>：機密情報をイメージに含めない</li>
                    </ul>

                    <h3>.dockerignoreの例</h3>
                    <pre class="code-block"><code class="language-plaintext"># Git関連
.git
.gitignore

# 依存関係（再インストールするため除外）
node_modules
__pycache__
*.pyc

# ビルド成果物
dist
build
target
*.jar
*.war

# ログファイル
*.log
logs

# 環境設定ファイル（機密情報を含む可能性）
.env
.env.local
*.secret

# IDE設定
.vscode
.idea
*.swp

# ドキュメント
README.md
docs

# テストファイル
tests
*.test.js

# Docker関連
Dockerfile
docker-compose.yml
.dockerignore</code></pre>

                    <h3>ワイルドカードと例外指定</h3>
                    <pre class="code-block"><code class="language-plaintext"># すべての.mdファイルを除外
*.md

# ただしREADME.mdは含める
!README.md

# tempディレクトリを除外
temp/

# すべての.logファイルを除外（サブディレクトリ含む）
**/*.log</code></pre>

                    <div class="highlight">
                        <strong>ベストプラクティス：</strong>プロジェクトのルートディレクトリに<code>.dockerignore</code>を作成し、ビルドに不要なファイルを除外しましょう。
                    </div>
                </section>

                <!-- 実習課題 -->
                <section id="exercises">
                    <h2 class="section-title">実習課題</h2>

                    <div class="exercise-container">
                        <h4>実習1：シンプルなPython Webアプリのコンテナ化</h4>
                        <p><strong>目的：</strong>基本的なDockerfileを作成し、Pythonアプリケーションをコンテナ化する</p>

                        <p><strong>手順：</strong></p>
                        <ol>
                            <li>次の内容で<code>app.py</code>を作成：
                                <pre class="code-block"><code class="language-python">from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello from Docker!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)</code></pre>
                            </li>
                            <li><code>requirements.txt</code>を作成：
                                <pre class="code-block"><code class="language-plaintext">flask==2.3.0</code></pre>
                            </li>
                            <li><code>Dockerfile</code>を作成（ヒント：<code>python:3.11-slim</code>をベースに使用）</li>
                            <li>イメージをビルド：<code>docker build -t flask-app:1.0 .</code></li>
                            <li>コンテナを起動：<code>docker run -p 5000:5000 flask-app:1.0</code></li>
                            <li>ブラウザで<code>http://localhost:5000</code>にアクセスして確認</li>
                        </ol>

                        <p><strong>確認ポイント：</strong></p>
                        <ul>
                            <li>イメージが正常にビルドされたか</li>
                            <li>コンテナが起動し、Webページが表示されるか</li>
                            <li>レイヤーキャッシュが適切に機能しているか（再ビルド時）</li>
                        </ul>
                    </div>

                    <div class="exercise-container">
                        <h4>実習2：マルチステージビルドでイメージを最適化</h4>
                        <p><strong>目的：</strong>マルチステージビルドを使用してイメージサイズを削減する</p>

                        <p><strong>手順：</strong></p>
                        <ol>
                            <li>実習1のDockerfileを、マルチステージビルドに書き換える</li>
                            <li>ビルドステージで依存関係をインストール</li>
                            <li>実行ステージでは必要最小限のファイルのみコピー</li>
                            <li>両方のイメージをビルドし、サイズを比較：
                                <pre class="code-block"><code class="language-bash">docker images | grep flask-app</code></pre>
                            </li>
                        </ol>

                        <p><strong>確認ポイント：</strong></p>
                        <ul>
                            <li>マルチステージビルド版のイメージサイズが小さくなったか</li>
                            <li>アプリケーションが正常に動作するか</li>
                        </ul>
                    </div>

                    <div class="exercise-container">
                        <h4>実習3：.dockerignoreの活用</h4>
                        <p><strong>目的：</strong>.dockerignoreを使ってビルドを最適化する</p>

                        <p><strong>手順：</strong></p>
                        <ol>
                            <li>プロジェクトディレクトリに不要なファイルを作成（<code>test.log</code>、<code>temp/</code>等）</li>
                            <li><code>.dockerignore</code>ファイルを作成し、不要なファイルを除外</li>
                            <li>イメージをビルド</li>
                            <li>イメージ内にファイルが含まれていないことを確認：
                                <pre class="code-block"><code class="language-bash">docker run --rm flask-app:1.0 ls -la</code></pre>
                            </li>
                        </ol>

                        <p><strong>確認ポイント：</strong></p>
                        <ul>
                            <li>.dockerignoreで指定したファイルが除外されているか</li>
                            <li>ビルド時間が短縮されたか</li>
                        </ul>
                    </div>
                </section>

                <!-- 理解度確認クイズ -->
                <section id="quiz">
                    <h2 class="section-title">理解度確認クイズ</h2>

                    <div class="quiz-container">
                        <h4>Q1: Dockerfileの基本</h4>
                        <p>Dockerfileで必ず最初に記述する命令はどれですか？</p>
                        <ol type="a">
                            <li>RUN</li>
                            <li>COPY</li>
                            <li>FROM</li>
                            <li>CMD</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer1">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer1">
                            <div class="alert alert-info">
                                <strong>答え：c) FROM</strong><br>
                                Dockerfileはほぼ必ず<code>FROM</code>命令で始まります。これはベースイメージを指定する命令で、イメージ構築の出発点となります。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q2: COPYとADDの違い</h4>
                        <p>一般的に推奨される命令はどちらで、その理由は何ですか？</p>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer2">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer2">
                            <div class="alert alert-info">
                                <strong>答え：COPY</strong><br>
                                基本的には<code>COPY</code>が推奨されます。理由は：
                                <ul>
                                    <li>動作が明確でシンプル</li>
                                    <li>予期しない挙動（tarの自動展開等）がない</li>
                                    <li><code>ADD</code>の特殊機能（URL取得、tar展開）が必要な場合のみ使用する</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q3: レイヤーキャッシュの最適化</h4>
                        <p>次のDockerfileで、<code>app.py</code>を変更するたびに<code>npm install</code>が実行されます。どう改善すべきですか？</p>
                        <pre class="code-block"><code class="language-dockerfile">FROM node:18-alpine
WORKDIR /app
COPY . .
RUN npm install
CMD ["node", "server.js"]</code></pre>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer3">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer3">
                            <div class="alert alert-info">
                                <strong>改善例：</strong>
<pre class="code-block"><code class="language-dockerfile">FROM node:18-alpine
WORKDIR /app
# 依存関係ファイルを先にコピー
COPY package*.json ./
RUN npm install
# アプリコードは最後にコピー
COPY . .
CMD ["node", "server.js"]</code></pre>
                                <p>
                                    <code>package.json</code>を先にコピーすることで、依存関係が変わらない限り<code>npm install</code>のキャッシュが有効になります。
                                </p>
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q4: CMDとENTRYPOINTの違い</h4>
                        <p>次のDockerfileで、<code>docker run myimage --verbose</code>を実行した時の動作を説明してください。</p>
                        <pre class="code-block"><code class="language-dockerfile">FROM alpine
ENTRYPOINT ["echo"]
CMD ["Hello"]</code></pre>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer4">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer4">
                            <div class="alert alert-info">
                                <strong>実行されるコマンド：</strong><code>echo --verbose</code><br>
                                <ul>
                                    <li><code>ENTRYPOINT</code>で指定された<code>echo</code>は必ず実行される</li>
                                    <li><code>CMD</code>の<code>Hello</code>はデフォルト引数（上書き可能）</li>
                                    <li><code>docker run</code>で指定した<code>--verbose</code>が<code>CMD</code>を上書き</li>
                                    <li>結果：<code>--verbose</code>という文字列が出力される</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q5: マルチステージビルドのメリット</h4>
                        <p>マルチステージビルドを使用する主なメリットを3つ挙げてください。</p>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer5">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer5">
                            <div class="alert alert-info">
                                <strong>主なメリット：</strong>
                                <ol>
                                    <li><strong>イメージサイズの削減</strong>：ビルドツールを最終イメージに含めない</li>
                                    <li><strong>セキュリティ向上</strong>：本番環境に開発用ツールを含めない</li>
                                    <li><strong>ビルドプロセスの明確化</strong>：ビルドと実行の責務を分離</li>
                                </ol>
                                <p>
                                    例：Go言語の場合、ビルドイメージは300MB以上ですが、最終イメージは10MB未満にできます。
                                </p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- ナビゲーション -->
                <div class="chapter-nav">
                    <a href="docker-learning-material-03.html" class="btn btn-outline-primary">&larr; 前の章へ</a>
                    <a href="docker-learning-material-05.html" class="btn btn-primary">次の章へ &rarr;</a>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Highlight.js初期化 -->
    <script>
        hljs.highlightAll();
    </script>

    <!-- Mermaid初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>
