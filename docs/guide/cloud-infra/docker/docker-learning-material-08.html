<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker学習教材 第8章 - マルチコンテナアプリケーションの構築</title>

    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">

    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>

    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>

    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
            line-height: 1.8;
        }

        /* ナビゲーション - Docker Blue */
        .navbar {
            background-color: #2496ED;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 1rem;
        }

        /* タイトル */
        .chapter-title {
            color: #2496ED;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 3px solid #2496ED;
            padding-bottom: 0.5rem;
            font-weight: bold;
        }

        .section-title {
            color: #1D63ED;
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e7f3ff;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #2496ED;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #fff9e6;
            border-radius: 8px;
            padding: 1.2rem;
            margin: 1.5rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            color: white;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
        }

        pre code.hljs {
            background-color: #1e1e1e;
            padding: 1rem;
            border-radius: 5px;
        }

        /* Mermaid図表 */
        .mermaid {
            text-align: center;
            margin: 2rem 0;
        }

        /* ナビゲーションボタン */
        .chapter-nav {
            margin: 2rem 0;
        }

        /* サイドバーリンク */
        .sidebar a {
            color: #2496ED;
            text-decoration: none;
        }

        .sidebar a:hover {
            text-decoration: underline;
        }

        /* 折りたたみコンテンツ */
        .collapse-trigger {
            cursor: pointer;
            color: #2496ED;
            user-select: none;
        }

        .collapse-trigger:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Docker学習教材</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="docker-learning-material-01.html">第1章</a></li>
                    <li class="nav-item"><a class="nav-link" href="docker-learning-material-02.html">第2章</a></li>
                    <li class="nav-item"><a class="nav-link" href="docker-learning-material-03.html">第3章</a></li>
                    <li class="nav-item"><a class="nav-link" href="docker-learning-material-04.html">第4章</a></li>
                    <li class="nav-item"><a class="nav-link" href="docker-learning-material-05.html">第5章</a></li>
                    <li class="nav-item"><a class="nav-link" href="docker-learning-material-06.html">第6章</a></li>
                    <li class="nav-item"><a class="nav-link" href="docker-learning-material-07.html">第7章</a></li>
                    <li class="nav-item"><a class="nav-link active" href="docker-learning-material-08.html">第8章</a></li>
                    <li class="nav-item"><a class="nav-link" href="docker-learning-material-09.html">第9章</a></li>
                    <li class="nav-item"><a class="nav-link" href="docker-learning-material-10.html">第10章</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav class="col-md-3 col-lg-2 d-md-block sidebar">
                <h5 class="mt-3">目次</h5>
                <ul class="nav flex-column">
                    <li class="nav-item"><a href="#intro">はじめに</a></li>
                    <li class="nav-item"><a href="#architecture">3層アーキテクチャ</a></li>
                    <li class="nav-item"><a href="#dependencies">依存関係管理</a></li>
                    <li class="nav-item"><a href="#healthcheck">ヘルスチェック</a></li>
                    <li class="nav-item"><a href="#logging">ログ管理</a></li>
                    <li class="nav-item"><a href="#reverse-proxy">リバースプロキシ</a></li>
                    <li class="nav-item"><a href="#environment-config">環境別設定</a></li>
                    <li class="nav-item"><a href="#project">実践プロジェクト</a></li>
                    <li class="nav-item"><a href="#exercises">実習課題</a></li>
                    <li class="nav-item"><a href="#quiz">理解度確認クイズ</a></li>
                </ul>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <h1 class="chapter-title">第8章 - マルチコンテナアプリケーションの構築</h1>

                <!-- 学習目標 -->
                <div class="highlight">
                    <h4>学習目標</h4>
                    <ul>
                        <li>3層アーキテクチャ（フロントエンド、バックエンド、データベース）をコンテナ化できる</li>
                        <li>サービス間の依存関係を適切に管理できる</li>
                        <li>ヘルスチェックを実装し、サービスの健全性を監視できる</li>
                        <li>リバースプロキシを導入し、トラフィックを制御できる</li>
                        <li>環境別（開発・本番）の設定を管理できる</li>
                    </ul>
                </div>

                <!-- はじめに -->
                <section id="intro">
                    <h2 class="section-title">はじめに</h2>
                    <p>
                        これまでの章で学んだ知識（Dockerfile、Docker Compose、ボリューム、ネットワーク）を統合し、実践的なマルチコンテナアプリケーションを構築します。
                    </p>
                    <p>
                        この章では、フロントエンド、バックエンドAPI、データベースから成る典型的なWebアプリケーションをDockerで構築し、本番環境に近い構成を実現します。
                    </p>
                </section>

                <!-- 3層アーキテクチャ -->
                <section id="architecture">
                    <h2 class="section-title">3層アーキテクチャの理解</h2>

                    <h3>3層アーキテクチャとは</h3>
                    <p>
                        3層アーキテクチャは、アプリケーションを<strong>プレゼンテーション層</strong>、<strong>アプリケーション層</strong>、<strong>データ層</strong>の3つに分離する設計パターンです。
                    </p>

                    <div class="mermaid">
                        graph TD
                            A[ユーザー] -->|HTTP/HTTPS| B[プレゼンテーション層<br/>React/Vue]
                            B -->|REST API| C[アプリケーション層<br/>Node.js/Python]
                            C -->|SQL| D[データ層<br/>PostgreSQL/MySQL]
                            style B fill:#e7f3ff
                            style C fill:#fff9e6
                            style D fill:#f3e5f5
                    </div>

                    <h3>各層の役割</h3>
                    <table class="table table-bordered">
                        <thead class="table-light">
                            <tr>
                                <th>層</th>
                                <th>役割</th>
                                <th>技術例</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>プレゼンテーション層</td>
                                <td>ユーザーインターフェース、表示ロジック</td>
                                <td>React、Vue.js、Angular</td>
                            </tr>
                            <tr>
                                <td>アプリケーション層</td>
                                <td>ビジネスロジック、API提供</td>
                                <td>Node.js、Python、Java</td>
                            </tr>
                            <tr>
                                <td>データ層</td>
                                <td>データ永続化、データ管理</td>
                                <td>PostgreSQL、MySQL、MongoDB</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>Dockerでの実装</h3>
                    <p>
                        各層を独立したコンテナとして実装することで、以下の利点が得られます：
                    </p>
                    <ul>
                        <li><strong>独立したスケーリング</strong>：負荷に応じて各層を個別にスケール</li>
                        <li><strong>技術スタックの柔軟性</strong>：各層で最適な技術を選択可能</li>
                        <li><strong>保守性向上</strong>：変更の影響範囲が限定される</li>
                        <li><strong>開発の並行化</strong>：チームが並行して開発可能</li>
                    </ul>
                </section>

                <!-- 依存関係管理 -->
                <section id="dependencies">
                    <h2 class="section-title">サービス間の依存関係管理</h2>

                    <h3>depends_onの基本</h3>
                    <p>
                        <code>depends_on</code>は、サービスの起動順序を制御しますが、サービスの「準備完了」を保証しません。
                    </p>

                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  web:
    build: ./frontend
    depends_on:
      - api  # apiの後に起動

  api:
    build: ./backend
    depends_on:
      - db   # dbの後に起動

  db:
    image: postgres:15</code></pre>

                    <h3>問題点：起動順序≠準備完了</h3>
                    <p>
                        データベースコンテナは起動しても、PostgreSQLが接続を受け付けるまでには数秒かかります。その間にバックエンドが接続を試みるとエラーになります。
                    </p>

                    <div class="warning">
                        <h5>典型的な問題</h5>
                        <pre class="code-block"><code class="language-plaintext">api    | Error: Connection to database failed
api    | ECONNREFUSED 172.18.0.2:5432
api exited with code 1</code></pre>
                    </div>

                    <h3>解決策1：アプリケーション側でリトライ</h3>
                    <p>
                        最も推奨される方法は、アプリケーションコードにリトライロジックを実装することです。
                    </p>

                    <pre class="code-block"><code class="language-javascript">// Node.js 例
async function connectToDatabase(retries = 5) {
  for (let i = 0; i < retries; i++) {
    try {
      await db.connect();
      console.log('Database connected');
      return;
    } catch (err) {
      console.log(`Connection attempt ${i + 1} failed, retrying...`);
      await sleep(3000);  // 3秒待機
    }
  }
  throw new Error('Failed to connect to database');
}</code></pre>

                    <h3>解決策2：wait-for-itスクリプト</h3>
                    <p>
                        外部スクリプトを使用して、依存サービスの準備完了を待つ方法もあります。
                    </p>

                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  api:
    build: ./backend
    command: sh -c './wait-for-it.sh db:5432 -- npm start'
    depends_on:
      - db

  db:
    image: postgres:15</code></pre>

                    <h3>解決策3：ヘルスチェック（次のセクションで詳述）</h3>
                    <p>
                        Docker Composeのヘルスチェック機能を使用して、サービスの準備完了を確認します。
                    </p>
                </section>

                <!-- ヘルスチェック -->
                <section id="healthcheck">
                    <h2 class="section-title">ヘルスチェックの実装</h2>

                    <h3>ヘルスチェックとは</h3>
                    <p>
                        ヘルスチェックは、コンテナが正常に動作しているかを定期的に確認する仕組みです。Dockerfileまたはdocker-compose.ymlで定義できます。
                    </p>

                    <h3>Dockerfileでのヘルスチェック</h3>
                    <pre class="code-block"><code class="language-dockerfile">FROM postgres:15

# ヘルスチェックを定義
HEALTHCHECK --interval=10s --timeout=3s --retries=3 \
  CMD pg_isready -U postgres || exit 1</code></pre>

                    <h3>Docker Composeでのヘルスチェック</h3>
                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: secret
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 3s
      retries: 3
      start_period: 10s

  api:
    build: ./backend
    depends_on:
      db:
        condition: service_healthy  # dbのヘルスチェックが成功してから起動
    environment:
      DATABASE_URL: postgres://postgres:secret@db:5432/mydb</code></pre>

                    <h3>ヘルスチェックのパラメータ</h3>
                    <ul>
                        <li><code>test</code>：実行するコマンド</li>
                        <li><code>interval</code>：チェックの間隔（デフォルト：30秒）</li>
                        <li><code>timeout</code>：タイムアウト時間（デフォルト：30秒）</li>
                        <li><code>retries</code>：失敗と判定するまでのリトライ回数（デフォルト：3回）</li>
                        <li><code>start_period</code>：初回チェックまでの猶予期間（デフォルト：0秒）</li>
                    </ul>

                    <h3>ヘルスチェック状態の確認</h3>
                    <pre class="code-block"><code class="language-bash"># ヘルスチェック状態を確認
docker ps

# 出力例：
# STATUS
# Up 2 minutes (healthy)

# 詳細情報
docker inspect --format='{{.State.Health.Status}}' container-name</code></pre>

                    <h3>Webアプリケーションのヘルスチェック</h3>
                    <pre class="code-block"><code class="language-yaml">services:
  api:
    build: ./backend
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    ports:
      - "8000:8000"</code></pre>

                    <pre class="code-block"><code class="language-javascript">// Express.js でのヘルスチェックエンドポイント
app.get('/health', (req, res) => {
  // データベース接続などをチェック
  if (db.isConnected()) {
    res.status(200).json({ status: 'healthy' });
  } else {
    res.status(503).json({ status: 'unhealthy' });
  }
});</code></pre>
                </section>

                <!-- ログ管理 -->
                <section id="logging">
                    <h2 class="section-title">ログ管理とモニタリング</h2>

                    <h3>Dockerのログドライバー</h3>
                    <p>
                        Dockerは、標準出力（stdout）と標準エラー出力（stderr）をキャプチャし、ログとして保存します。
                    </p>

                    <pre class="code-block"><code class="language-bash"># ログを表示
docker logs container-name

# リアルタイムでログをフォロー
docker logs -f container-name

# 最新100行のみ表示
docker logs --tail 100 container-name

# タイムスタンプ付きで表示
docker logs -t container-name</code></pre>

                    <h3>Docker Composeでのログ設定</h3>
                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  api:
    build: ./backend
    logging:
      driver: "json-file"
      options:
        max-size: "10m"     # ログファイルの最大サイズ
        max-file: "3"       # 保持するファイル数
        labels: "app=api"   # メタデータ</code></pre>

                    <h3>集中ログ管理</h3>
                    <p>
                        本番環境では、すべてのログを一箇所に集約して管理することが推奨されます。
                    </p>

                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  web:
    build: ./frontend
    logging:
      driver: syslog
      options:
        syslog-address: "tcp://logs.example.com:514"

  api:
    build: ./backend
    volumes:
      - ./logs:/var/log/app  # ログをホストに保存</code></pre>

                    <h3>構造化ログの実装</h3>
                    <p>
                        JSON形式のログを出力することで、ログ分析ツールで処理しやすくなります。
                    </p>

                    <pre class="code-block"><code class="language-javascript">// Winston を使った構造化ログ
const winston = require('winston');

const logger = winston.createLogger({
  format: winston.format.json(),
  transports: [
    new winston.transports.Console()
  ]
});

logger.info('User logged in', {
  userId: 123,
  ip: '192.168.1.1',
  timestamp: new Date().toISOString()
});</code></pre>
                </section>

                <!-- リバースプロキシ -->
                <section id="reverse-proxy">
                    <h2 class="section-title">Nginxリバースプロキシの導入</h2>

                    <h3>リバースプロキシの役割</h3>
                    <p>
                        リバースプロキシは、クライアントとバックエンドサービスの間に配置され、以下の役割を果たします：
                    </p>
                    <ul>
                        <li><strong>ロードバランシング</strong>：複数のバックエンドに負荷を分散</li>
                        <li><strong>SSL/TLS終端</strong>：HTTPS通信の暗号化・復号化</li>
                        <li><strong>静的ファイル配信</strong>：画像、CSS、JSなどを直接配信</li>
                        <li><strong>キャッシング</strong>：レスポンスをキャッシュして高速化</li>
                        <li><strong>セキュリティ</strong>：バックエンドを直接公開しない</li>
                    </ul>

                    <div class="mermaid">
                        graph LR
                            A[クライアント] -->|HTTPS| B[Nginx<br/>リバースプロキシ]
                            B -->|/| C[Reactフロントエンド]
                            B -->|/api| D[Node.jsバックエンド]
                            D -->|DB接続| E[PostgreSQL]
                            style B fill:#e7f3ff
                    </div>

                    <h3>Nginx設定ファイル</h3>
                    <pre class="code-block"><code class="language-nginx"># nginx.conf
upstream backend {
    server api:8000;
}

server {
    listen 80;
    server_name localhost;

    # フロントエンド（静的ファイル）
    location / {
        root /usr/share/nginx/html;
        try_files $uri $uri/ /index.html;
    }

    # バックエンドAPI
    location /api/ {
        proxy_pass http://backend/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}</code></pre>

                    <h3>Docker Compose統合</h3>
                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./frontend/build:/usr/share/nginx/html:ro
    depends_on:
      - api
    networks:
      - frontend

  api:
    build: ./backend
    expose:
      - "8000"  # 外部公開せず、nginxからのみアクセス可
    networks:
      - frontend
      - backend

  db:
    image: postgres:15
    networks:
      - backend  # データベースはバックエンドのみアクセス可

networks:
  frontend:
  backend:</code></pre>
                </section>

                <!-- 環境別設定 -->
                <section id="environment-config">
                    <h2 class="section-title">環境別設定の管理</h2>

                    <h3>開発環境と本番環境の違い</h3>
                    <table class="table table-bordered">
                        <thead class="table-light">
                            <tr>
                                <th>項目</th>
                                <th>開発環境</th>
                                <th>本番環境</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>デバッグ</td>
                                <td>有効</td>
                                <td>無効</td>
                            </tr>
                            <tr>
                                <td>ホットリロード</td>
                                <td>有効</td>
                                <td>無効</td>
                            </tr>
                            <tr>
                                <td>ソースマップ</td>
                                <td>有効</td>
                                <td>無効</td>
                            </tr>
                            <tr>
                                <td>最適化</td>
                                <td>最小限</td>
                                <td>最大限</td>
                            </tr>
                            <tr>
                                <td>ログレベル</td>
                                <td>DEBUG</td>
                                <td>INFO/WARNING</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>複数のComposeファイル</h3>
                    <p>
                        環境ごとに異なる設定ファイルを用意し、組み合わせて使用します。
                    </p>

                    <h4>docker-compose.yml（共通設定）</h4>
                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  api:
    build: ./backend
    environment:
      DATABASE_URL: ${DATABASE_URL}

  db:
    image: postgres:15
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:</code></pre>

                    <h4>docker-compose.dev.yml（開発環境）</h4>
                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  api:
    volumes:
      - ./backend/src:/app/src  # ホットリロード
    environment:
      NODE_ENV: development
      DEBUG: "true"
    command: npm run dev

  db:
    ports:
      - "5432:5432"  # ローカルから直接アクセス可能</code></pre>

                    <h4>docker-compose.prod.yml（本番環境）</h4>
                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  api:
    environment:
      NODE_ENV: production
    restart: always
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '0.5'
          memory: 512M

  db:
    restart: always
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G</code></pre>

                    <h3>環境別の起動</h3>
                    <pre class="code-block"><code class="language-bash"># 開発環境
docker compose -f docker-compose.yml -f docker-compose.dev.yml up

# 本番環境
docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d</code></pre>

                    <h3>.envファイルの管理</h3>
                    <pre class="code-block"><code class="language-bash"># .env.development
DATABASE_URL=postgres://dev:devpass@db:5432/devdb
API_KEY=dev-api-key
DEBUG=true

# .env.production
DATABASE_URL=postgres://prod:prodpass@db:5432/proddb
API_KEY=prod-api-key
DEBUG=false</code></pre>

                    <pre class="code-block"><code class="language-bash"># 環境ファイルを指定して起動
docker compose --env-file .env.development up</code></pre>
                </section>

                <!-- 実践プロジェクト -->
                <section id="project">
                    <h2 class="section-title">実践プロジェクト：Todo管理アプリ</h2>

                    <h3>プロジェクト構成</h3>
                    <pre class="code-block"><code class="language-plaintext">todo-app/
├── docker-compose.yml
├── docker-compose.dev.yml
├── docker-compose.prod.yml
├── .env.example
├── nginx/
│   └── nginx.conf
├── frontend/
│   ├── Dockerfile
│   ├── package.json
│   └── src/
├── backend/
│   ├── Dockerfile
│   ├── package.json
│   └── src/
└── database/
    └── init.sql</code></pre>

                    <h3>完全なdocker-compose.yml</h3>
                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  # Nginxリバースプロキシ
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - frontend_build:/usr/share/nginx/html:ro
    depends_on:
      frontend:
        condition: service_healthy
      api:
        condition: service_healthy
    networks:
      - frontend
    restart: unless-stopped

  # Reactフロントエンド
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    volumes:
      - frontend_build:/app/build
    environment:
      - REACT_APP_API_URL=${API_URL}
    healthcheck:
      test: ["CMD", "test", "-f", "/app/build/index.html"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - frontend

  # Node.js バックエンドAPI
  api:
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      - DATABASE_URL=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}
      - REDIS_URL=redis://cache:6379
      - NODE_ENV=${NODE_ENV}
    depends_on:
      db:
        condition: service_healthy
      cache:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - frontend
      - backend
    restart: unless-stopped

  # PostgreSQLデータベース
  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 10s
    networks:
      - backend
    restart: unless-stopped

  # Redisキャッシュ
  cache:
    image: redis:7-alpine
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    networks:
      - backend
    restart: unless-stopped

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
    internal: true  # 外部からの接続を遮断

volumes:
  postgres_data:
  frontend_build:</code></pre>

                    <h3>起動と確認</h3>
                    <pre class="code-block"><code class="language-bash"># 環境変数ファイルを作成
cp .env.example .env

# ビルドと起動
docker compose up --build -d

# ヘルスチェック状態の確認
docker compose ps

# ログ確認
docker compose logs -f

# ブラウザでアクセス
# http://localhost</code></pre>
                </section>

                <!-- 実習課題 -->
                <section id="exercises">
                    <h2 class="section-title">実習課題</h2>

                    <div class="exercise-container">
                        <h4>実習1：3層アーキテクチャの構築</h4>
                        <p><strong>目的：</strong>フロントエンド、バックエンド、データベースの3層構成を構築する</p>

                        <p><strong>要件：</strong></p>
                        <ul>
                            <li>React（または任意のフロントエンド）コンテナ</li>
                            <li>Node.js（または任意のバックエンド）APIコンテナ</li>
                            <li>PostgreSQLデータベースコンテナ</li>
                            <li>各層が適切なネットワークで分離されている</li>
                            <li>データは永続化されている</li>
                        </ul>
                    </div>

                    <div class="exercise-container">
                        <h4>実習2：ヘルスチェックの実装</h4>
                        <p><strong>目的：</strong>すべてのサービスにヘルスチェックを追加する</p>

                        <p><strong>手順：</strong></p>
                        <ol>
                            <li>データベースにヘルスチェックを追加</li>
                            <li>バックエンドAPIに<code>/health</code>エンドポイントを実装</li>
                            <li><code>depends_on</code>で<code>condition: service_healthy</code>を使用</li>
                            <li>起動時にヘルスチェックが正常に動作することを確認</li>
                        </ol>
                    </div>

                    <div class="exercise-container">
                        <h4>実習3：Nginxリバースプロキシの導入</h4>
                        <p><strong>目的：</strong>Nginxでフロントエンドとバックエンドを統合する</p>

                        <p><strong>手順：</strong></p>
                        <ol>
                            <li>Nginxコンテナを追加</li>
                            <li><code>/</code>をフロントエンドに、<code>/api</code>をバックエンドにルーティング</li>
                            <li>Nginxのみがポート80を公開</li>
                            <li>バックエンドとフロントエンドは外部に公開しない</li>
                        </ol>
                    </div>
                </section>

                <!-- 理解度確認クイズ -->
                <section id="quiz">
                    <h2 class="section-title">理解度確認クイズ</h2>

                    <div class="quiz-container">
                        <h4>Q1: 3層アーキテクチャ</h4>
                        <p>3層アーキテクチャの層に含まれないものはどれですか？</p>
                        <ol type="a">
                            <li>プレゼンテーション層</li>
                            <li>アプリケーション層</li>
                            <li>データ層</li>
                            <li>ネットワーク層</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer1">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer1">
                            <div class="alert alert-info">
                                <strong>答え：d) ネットワーク層</strong><br>
                                3層アーキテクチャは、プレゼンテーション層、アプリケーション層、データ層で構成されます。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q2: depends_onの制限</h4>
                        <p><code>depends_on</code>が保証しないものはどれですか？</p>
                        <ol type="a">
                            <li>起動順序</li>
                            <li>サービスの準備完了</li>
                            <li>コンテナの作成順序</li>
                            <li>ネットワークの作成</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer2">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer2">
                            <div class="alert alert-info">
                                <strong>答え：b) サービスの準備完了</strong><br>
                                <code>depends_on</code>は起動順序を制御しますが、サービスが実際に準備完了するまでは待ちません。ヘルスチェックと組み合わせて使用する必要があります。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q3: ヘルスチェック</h4>
                        <p>ヘルスチェックの<code>interval</code>パラメータの意味は何ですか？</p>
                        <ol type="a">
                            <li>タイムアウト時間</li>
                            <li>チェックの間隔</li>
                            <li>リトライ回数</li>
                            <li>初回チェックまでの猶予</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer3">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer3">
                            <div class="alert alert-info">
                                <strong>答え：b) チェックの間隔</strong><br>
                                <code>interval</code>は、ヘルスチェックを実行する間隔を指定します。デフォルトは30秒です。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q4: リバースプロキシの役割</h4>
                        <p>リバースプロキシの役割でないものはどれですか？</p>
                        <ol type="a">
                            <li>ロードバランシング</li>
                            <li>SSL/TLS終端</li>
                            <li>データベースのレプリケーション</li>
                            <li>静的ファイル配信</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer4">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer4">
                            <div class="alert alert-info">
                                <strong>答え：c) データベースのレプリケーション</strong><br>
                                リバースプロキシは、Webサーバーとして機能し、ロードバランシング、SSL/TLS終端、静的ファイル配信などを行いますが、データベースのレプリケーションは行いません。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q5: 環境別設定</h4>
                        <p>開発環境と本番環境で異なる設定ファイルを使用する方法として正しいものはどれですか？</p>
                        <ol type="a">
                            <li>1つのdocker-compose.ymlですべて管理</li>
                            <li>環境ごとに完全に別のファイルを作成</li>
                            <li>共通設定と環境固有設定を分けて、組み合わせて使用</li>
                            <li>Docker Composeは環境別設定に対応していない</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer5">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer5">
                            <div class="alert alert-info">
                                <strong>答え：c) 共通設定と環境固有設定を分けて、組み合わせて使用</strong><br>
                                <code>docker-compose.yml</code>（共通）、<code>docker-compose.dev.yml</code>、<code>docker-compose.prod.yml</code>のように分けて、<code>-f</code>オプションで組み合わせて使用するのがベストプラクティスです。
                            </div>
                        </div>
                    </div>
                </section>

                <!-- ナビゲーション -->
                <div class="chapter-nav">
                    <a href="docker-learning-material-07.html" class="btn btn-outline-primary">&larr; 前の章へ</a>
                    <a href="docker-learning-material-09.html" class="btn btn-primary">次の章へ &rarr;</a>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Highlight.js初期化 -->
    <script>
        hljs.highlightAll();
    </script>

    <!-- Mermaid初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>
