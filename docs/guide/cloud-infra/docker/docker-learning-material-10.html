<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker学習教材 第10章 - 本番環境へのデプロイとオーケストレーション入門</title>

    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">

    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>

    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>

    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
            line-height: 1.8;
        }

        /* ナビゲーション - Docker Blue */
        .navbar {
            background-color: #2496ED;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 1rem;
        }

        /* タイトル */
        .chapter-title {
            color: #2496ED;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 3px solid #2496ED;
            padding-bottom: 0.5rem;
            font-weight: bold;
        }

        .section-title {
            color: #1D63ED;
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e7f3ff;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #2496ED;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #fff9e6;
            border-radius: 8px;
            padding: 1.2rem;
            margin: 1.5rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            color: white;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
        }

        pre code.hljs {
            background-color: #1e1e1e;
            padding: 1rem;
            border-radius: 5px;
        }

        /* ナビゲーション */
        .nav-link.active {
            background-color: #2496ED !important;
            color: white !important;
            border-radius: 5px;
        }

        .nav-link {
            color: #333;
            transition: all 0.3s;
        }

        .nav-link:hover {
            background-color: #e7f3ff;
            border-radius: 5px;
        }

        /* Mermaid図表 */
        .mermaid {
            text-align: center;
            margin: 2rem 0;
        }

        /* ナビゲーションボタン */
        .chapter-nav {
            margin: 2rem 0;
        }

        /* 折りたたみコンテンツ */
        .collapse-trigger {
            cursor: pointer;
            color: #2496ED;
            user-select: none;
        }

        .collapse-trigger:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">
                <i class="fab fa-docker"></i>
                <strong>Docker学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-01.html">
                                第1章: Dockerとは何か
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-02.html">
                                第2章: 環境構築と基本操作
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-03.html">
                                第3章: イメージの理解と管理
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-04.html">
                                第4章: Dockerfileによるイメージ作成
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-05.html">
                                第5章: Docker Compose
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-06.html">
                                第6章: ボリュームとデータ永続化
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-07.html">
                                第7章: ネットワークとコンテナ間通信
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-08.html">
                                第8章: マルチコンテナアプリケーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-09.html">
                                第9章: ベストプラクティスとセキュリティ
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="docker-learning-material-10.html">
                                第10章: 本番環境へのデプロイ
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第10章: 本番環境へのデプロイとオーケストレーション入門</h1>
                </div>

                <!-- 学習目標 -->
                <div class="highlight">
                    <h4>学習目標</h4>
                    <ul>
                        <li>本番環境でのDocker運用の考慮事項を理解する</li>
                        <li>コンテナレジストリを使ってイメージを管理できる</li>
                        <li>Docker Swarmの基礎を理解する</li>
                        <li>Kubernetesの基本概念を理解する</li>
                        <li>CI/CDパイプラインでDockerを活用できる</li>
                        <li>次のステップへの道筋を描ける</li>
                    </ul>
                </div>

                <!-- はじめに -->
                <section id="intro">
                    <h2 class="section-title">はじめに</h2>
                    <p>
                        これまでの章で、Dockerの基礎から実践的な使い方まで学んできました。最終章では、Dockerアプリケーションを本番環境にデプロイし、大規模に運用するための知識を習得します。
                    </p>
                    <p>
                        本番環境では、開発環境とは異なる要件（高可用性、スケーラビリティ、セキュリティ、監視）が求められます。この章では、これらの要件に対応する方法と、次のステップとなるコンテナオーケストレーションの基礎を学びます。
                    </p>
                </section>

                <!-- 本番環境の考慮事項 -->
                <section id="production-considerations">
                    <h2 class="section-title">本番環境での考慮事項</h2>

                    <h3>開発環境と本番環境の違い</h3>
                    <table class="table table-bordered">
                        <thead class="table-light">
                            <tr>
                                <th>観点</th>
                                <th>開発環境</th>
                                <th>本番環境</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>可用性</td>
                                <td>低（単一インスタンス）</td>
                                <td>高（冗長化、自動復旧）</td>
                            </tr>
                            <tr>
                                <td>スケーラビリティ</td>
                                <td>不要</td>
                                <td>自動スケーリング</td>
                            </tr>
                            <tr>
                                <td>セキュリティ</td>
                                <td>緩い</td>
                                <td>厳格（最小権限、暗号化）</td>
                            </tr>
                            <tr>
                                <td>監視</td>
                                <td>基本的なログ</td>
                                <td>包括的なモニタリング</td>
                            </tr>
                            <tr>
                                <td>デプロイ</td>
                                <td>手動</td>
                                <td>自動化（CI/CD）</td>
                            </tr>
                            <tr>
                                <td>データ</td>
                                <td>テストデータ</td>
                                <td>本番データ（バックアップ必須）</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>本番環境で重要な要素</h3>

                    <h4>1. 高可用性（High Availability）</h4>
                    <ul>
                        <li>複数のコンテナインスタンスを実行</li>
                        <li>ロードバランサーで負荷分散</li>
                        <li>障害時の自動復旧</li>
                        <li>ゼロダウンタイムデプロイ</li>
                    </ul>

                    <h4>2. スケーラビリティ（Scalability）</h4>
                    <ul>
                        <li>水平スケーリング（インスタンス数の増減）</li>
                        <li>垂直スケーリング（リソースの増減）</li>
                        <li>自動スケーリング（負荷に応じて）</li>
                    </ul>

                    <h4>3. セキュリティ</h4>
                    <ul>
                        <li>最小権限の原則</li>
                        <li>シークレット管理</li>
                        <li>ネットワークセグメンテーション</li>
                        <li>定期的な脆弱性スキャン</li>
                    </ul>

                    <h4>4. 監視とロギング</h4>
                    <ul>
                        <li>アプリケーションメトリクスの収集</li>
                        <li>集中ログ管理</li>
                        <li>アラート設定</li>
                        <li>パフォーマンス監視</li>
                    </ul>

                    <div class="mermaid">
                        graph TD
                            A[本番環境の要件] --> B[高可用性]
                            A --> C[スケーラビリティ]
                            A --> D[セキュリティ]
                            A --> E[監視・ロギング]
                            B --> F[冗長化]
                            B --> G[自動復旧]
                            C --> H[水平スケール]
                            C --> I[自動スケール]
                            D --> J[最小権限]
                            D --> K[暗号化]
                            E --> L[メトリクス収集]
                            E --> M[集中ログ]
                    </div>
                </section>

                <!-- コンテナレジストリ -->
                <section id="registry">
                    <h2 class="section-title">コンテナレジストリ</h2>

                    <h3>レジストリとは</h3>
                    <p>
                        <strong>コンテナレジストリ</strong>は、Dockerイメージを保存・配布するためのサービスです。GitHubがソースコードのリポジトリであるように、レジストリはコンテナイメージのリポジトリです。
                    </p>

                    <h3>主要なレジストリサービス</h3>

                    <h4>1. Docker Hub（公式）</h4>
                    <ul>
                        <li>無料プラン：パブリックリポジトリ無制限、プライベート1個</li>
                        <li>有料プラン：プライベートリポジトリ増加</li>
                        <li>公式イメージが豊富</li>
                    </ul>

                    <pre class="code-block"><code class="language-bash"># Docker Hubにログイン
docker login

# イメージをタグ付け
docker tag myapp:latest username/myapp:latest

# Docker Hubにプッシュ
docker push username/myapp:latest

# プルして使用
docker pull username/myapp:latest</code></pre>

                    <h4>2. GitHub Container Registry (ghcr.io)</h4>
                    <pre class="code-block"><code class="language-bash"># GitHub Container Registryにログイン
echo $GITHUB_TOKEN | docker login ghcr.io -u username --password-stdin

# イメージをタグ付け
docker tag myapp:latest ghcr.io/username/myapp:latest

# プッシュ
docker push ghcr.io/username/myapp:latest</code></pre>

                    <h4>3. AWS ECR（Amazon Elastic Container Registry）</h4>
                    <pre class="code-block"><code class="language-bash"># ECRにログイン
aws ecr get-login-password --region ap-northeast-1 | \
  docker login --username AWS --password-stdin \
  123456789012.dkr.ecr.ap-northeast-1.amazonaws.com

# リポジトリ作成
aws ecr create-repository --repository-name myapp

# プッシュ
docker tag myapp:latest 123456789012.dkr.ecr.ap-northeast-1.amazonaws.com/myapp:latest
docker push 123456789012.dkr.ecr.ap-northeast-1.amazonaws.com/myapp:latest</code></pre>

                    <h4>4. Google Container Registry (GCR)</h4>
                    <pre class="code-block"><code class="language-bash"># GCRにログイン
gcloud auth configure-docker

# プッシュ
docker tag myapp:latest gcr.io/project-id/myapp:latest
docker push gcr.io/project-id/myapp:latest</code></pre>

                    <h3>プライベートレジストリのセルフホスティング</h3>
                    <pre class="code-block"><code class="language-bash"># Docker Registryコンテナを起動
docker run -d \
  -p 5000:5000 \
  --name registry \
  -v /mnt/registry:/var/lib/registry \
  registry:2

# プライベートレジストリにプッシュ
docker tag myapp:latest localhost:5000/myapp:latest
docker push localhost:5000/myapp:latest</code></pre>
                </section>

                <!-- Docker Swarm -->
                <section id="swarm">
                    <h2 class="section-title">Docker Swarmの基礎</h2>

                    <h3>Docker Swarmとは</h3>
                    <p>
                        <strong>Docker Swarm</strong>は、Dockerネイティブのコンテナオーケストレーションツールです。複数のDockerホストをクラスタ化し、サービスのデプロイ、スケーリング、管理を自動化します。
                    </p>

                    <div class="mermaid">
                        graph TD
                            A[Swarmクラスタ] --> B[Manager Node]
                            A --> C[Worker Node 1]
                            A --> D[Worker Node 2]
                            A --> E[Worker Node 3]
                            B -->|管理| C
                            B -->|管理| D
                            B -->|管理| E
                            C -->|コンテナ実行| F[Task]
                            D -->|コンテナ実行| G[Task]
                            E -->|コンテナ実行| H[Task]
                            style B fill:#2496ED,color:#fff
                    </div>

                    <h3>Swarmの初期化</h3>
                    <pre class="code-block"><code class="language-bash"># Swarmモードを初期化（マネージャーノード）
docker swarm init --advertise-addr 192.168.1.10

# 出力されたトークンを使ってワーカーノードを追加
# ワーカーノードで実行：
docker swarm join --token SWMTKN-1-xxxxx 192.168.1.10:2377

# ノードの確認
docker node ls</code></pre>

                    <h3>サービスのデプロイ</h3>
                    <pre class="code-block"><code class="language-bash"># サービスを作成（3つのレプリカ）
docker service create \
  --name web \
  --replicas 3 \
  -p 80:80 \
  nginx:alpine

# サービスの確認
docker service ls
docker service ps web

# スケーリング
docker service scale web=5

# ローリングアップデート
docker service update --image nginx:latest web</code></pre>

                    <h3>Swarmスタックのデプロイ</h3>
                    <pre class="code-block"><code class="language-yaml"># docker-stack.yml
version: '3.8'

services:
  web:
    image: myapp:latest
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
    ports:
      - "80:80"
    networks:
      - webnet

  db:
    image: postgres:15
    deploy:
      placement:
        constraints:
          - node.role == manager
    volumes:
      - db-data:/var/lib/postgresql/data
    networks:
      - webnet

networks:
  webnet:

volumes:
  db-data:</code></pre>

                    <pre class="code-block"><code class="language-bash"># スタックをデプロイ
docker stack deploy -c docker-stack.yml myapp

# スタックの確認
docker stack ls
docker stack services myapp

# スタックの削除
docker stack rm myapp</code></pre>

                    <div class="highlight">
                        <h5>Docker Swarmの特徴</h5>
                        <ul>
                            <li>設定が簡単（Dockerに組み込み）</li>
                            <li>Docker Composeファイルと互換性が高い</li>
                            <li>小〜中規模のクラスタに適している</li>
                            <li>学習コストが低い</li>
                        </ul>
                    </div>
                </section>

                <!-- Kubernetes入門 -->
                <section id="kubernetes-intro">
                    <h2 class="section-title">Kubernetes入門</h2>

                    <h3>Kubernetesとは</h3>
                    <p>
                        <strong>Kubernetes</strong>（K8s）は、Googleが開発したコンテナオーケストレーションプラットフォームで、業界標準となっています。大規模なコンテナ環境を自動化、管理、スケーリングするための強力なツールです。
                    </p>

                    <h3>KubernetesとDocker Swarmの比較</h3>
                    <table class="table table-bordered">
                        <thead class="table-light">
                            <tr>
                                <th>項目</th>
                                <th>Docker Swarm</th>
                                <th>Kubernetes</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>学習コスト</td>
                                <td>低い</td>
                                <td>高い</td>
                            </tr>
                            <tr>
                                <td>セットアップ</td>
                                <td>簡単</td>
                                <td>複雑</td>
                            </tr>
                            <tr>
                                <td>スケール</td>
                                <td>小〜中規模</td>
                                <td>大規模</td>
                            </tr>
                            <tr>
                                <td>エコシステム</td>
                                <td>小さい</td>
                                <td>非常に大きい</td>
                            </tr>
                            <tr>
                                <td>クラウドサポート</td>
                                <td>限定的</td>
                                <td>すべての主要クラウド</td>
                            </tr>
                            <tr>
                                <td>コミュニティ</td>
                                <td>小さい</td>
                                <td>非常に大きい</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>Kubernetesの基本概念</h3>

                    <div class="mermaid">
                        graph TD
                            A[Kubernetesクラスタ] --> B[コントロールプレーン]
                            A --> C[ワーカーノード1]
                            A --> D[ワーカーノード2]
                            B --> E[API Server]
                            B --> F[Scheduler]
                            B --> G[Controller Manager]
                            C --> H[Pod]
                            C --> I[Pod]
                            D --> J[Pod]
                            H --> K[コンテナ]
                            style B fill:#2496ED,color:#fff
                    </div>

                    <h4>主要コンポーネント</h4>
                    <ul>
                        <li><strong>Pod</strong>：1つ以上のコンテナをグループ化した最小デプロイ単位</li>
                        <li><strong>Deployment</strong>：Podのレプリカを管理し、宣言的にアップデート</li>
                        <li><strong>Service</strong>：Podへのネットワークアクセスを提供</li>
                        <li><strong>ConfigMap/Secret</strong>：設定情報と機密情報の管理</li>
                        <li><strong>Namespace</strong>：リソースの論理的な分離</li>
                    </ul>

                    <h3>簡単なKubernetesデプロイ例</h3>
                    <pre class="code-block"><code class="language-yaml"># deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        ports:
        - containerPort: 8000
---
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
spec:
  type: LoadBalancer
  selector:
    app: myapp
  ports:
  - port: 80
    targetPort: 8000</code></pre>

                    <pre class="code-block"><code class="language-bash"># デプロイ
kubectl apply -f deployment.yaml

# 確認
kubectl get deployments
kubectl get pods
kubectl get services

# スケーリング
kubectl scale deployment myapp --replicas=5

# ローリングアップデート
kubectl set image deployment/myapp myapp=myapp:v2</code></pre>

                    <h3>ローカルKubernetes環境</h3>
                    <ul>
                        <li><strong>Minikube</strong>：ローカルでKubernetesクラスタを実行</li>
                        <li><strong>Kind</strong>：DockerコンテナでKubernetesノードを実行</li>
                        <li><strong>Docker Desktop</strong>：組み込みKubernetes（Windows/Mac）</li>
                    </ul>

                    <pre class="code-block"><code class="language-bash"># Minikubeのインストールと起動
brew install minikube  # macOS
minikube start

# Kubernetesクラスタが利用可能に
kubectl cluster-info
kubectl get nodes</code></pre>
                </section>

                <!-- デプロイ戦略 -->
                <section id="deployment">
                    <h2 class="section-title">デプロイ戦略</h2>

                    <h3>1. ローリングアップデート</h3>
                    <p>
                        古いバージョンのコンテナを徐々に新しいバージョンに置き換えます。ゼロダウンタイムを実現できます。
                    </p>

                    <pre class="code-block"><code class="language-yaml"># docker-compose.yml
version: '3.8'

services:
  web:
    image: myapp:v2
    deploy:
      replicas: 5
      update_config:
        parallelism: 1      # 一度に1つずつ更新
        delay: 10s          # 各更新の間隔
        failure_action: rollback  # 失敗時はロールバック
        order: start-first  # 新しいコンテナを起動してから古いものを停止</code></pre>

                    <h3>2. ブルーグリーンデプロイ</h3>
                    <p>
                        2つの環境（Blue/Green）を用意し、トラフィックを一気に切り替えます。
                    </p>

                    <div class="mermaid">
                        graph LR
                            A[ロードバランサー] -->|100%| B[Blue環境<br/>v1.0]
                            A -.->|0%| C[Green環境<br/>v2.0<br/>準備中]
                            D[切り替え後] -->|0%| E[Blue環境<br/>v1.0]
                            D -->|100%| F[Green環境<br/>v2.0]
                            style B fill:#e7f3ff
                            style F fill:#c8e6c9
                    </div>

                    <h3>3. カナリアデプロイ</h3>
                    <p>
                        新バージョンに少量のトラフィック（例：10%）を流し、問題がなければ徐々に増やします。
                    </p>

                    <pre class="code-block"><code class="language-yaml"># Kubernetesでのカナリアデプロイ
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-stable
spec:
  replicas: 9  # 90%
  template:
    metadata:
      labels:
        app: myapp
        version: stable
    spec:
      containers:
      - name: myapp
        image: myapp:v1
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-canary
spec:
  replicas: 1  # 10%
  template:
    metadata:
      labels:
        app: myapp
        version: canary
    spec:
      containers:
      - name: myapp
        image: myapp:v2</code></pre>

                    <h3>ロールバック</h3>
                    <pre class="code-block"><code class="language-bash"># Docker Swarmでのロールバック
docker service rollback web

# Kubernetesでのロールバック
kubectl rollout undo deployment/myapp

# 特定のリビジョンにロールバック
kubectl rollout undo deployment/myapp --to-revision=2</code></pre>
                </section>

                <!-- モニタリングとロギング -->
                <section id="monitoring">
                    <h2 class="section-title">モニタリングとロギング</h2>

                    <h3>メトリクス収集：Prometheus</h3>
                    <p>
                        Prometheusは、時系列データベースとして、アプリケーションとインフラのメトリクスを収集・保存します。
                    </p>

                    <pre class="code-block"><code class="language-yaml"># docker-compose.yml
version: '3.8'

services:
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'

  node-exporter:
    image: prom/node-exporter:latest
    ports:
      - "9100:9100"

volumes:
  prometheus_data:</code></pre>

                    <h3>可視化：Grafana</h3>
                    <pre class="code-block"><code class="language-yaml">  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana
    depends_on:
      - prometheus

volumes:
  grafana_data:</code></pre>

                    <h3>ログ収集：ELKスタック</h3>
                    <p>
                        Elasticsearch、Logstash、Kibanaを使った集中ログ管理システムです。
                    </p>

                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    ports:
      - "9200:9200"

  logstash:
    image: docker.elastic.co/logstash/logstash:8.11.0
    volumes:
      - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf
    depends_on:
      - elasticsearch

  kibana:
    image: docker.elastic.co/kibana/kibana:8.11.0
    ports:
      - "5601:5601"
    depends_on:
      - elasticsearch</code></pre>

                    <h3>アラート設定</h3>
                    <pre class="code-block"><code class="language-yaml"># prometheus.yml
alerting:
  alertmanagers:
    - static_configs:
        - targets: ['alertmanager:9093']

rule_files:
  - 'alerts.yml'</code></pre>

                    <pre class="code-block"><code class="language-yaml"># alerts.yml
groups:
  - name: example
    rules:
      - alert: HighCPUUsage
        expr: cpu_usage > 80
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High CPU usage detected"</code></pre>
                </section>

                <!-- CI/CDパイプライン -->
                <section id="ci-cd">
                    <h2 class="section-title">CI/CDパイプラインの構築</h2>

                    <h3>CI/CDワークフローの概要</h3>
                    <div class="mermaid">
                        graph LR
                            A[コード変更] --> B[Git Push]
                            B --> C[CI: テスト実行]
                            C --> D[CI: Dockerイメージビルド]
                            D --> E[イメージをレジストリにプッシュ]
                            E --> F[CD: ステージング環境にデプロイ]
                            F --> G[CD: 本番環境にデプロイ]
                            style C fill:#e7f3ff
                            style D fill:#e7f3ff
                            style F fill:#fff9e6
                            style G fill:#c8e6c9
                    </div>

                    <h3>GitHub Actionsでの完全なCI/CDパイプライン</h3>
                    <pre class="code-block"><code class="language-yaml"># .github/workflows/deploy.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Run tests
        run: |
          docker compose run --rm test

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

      - name: Run security scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

  deploy-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - name: Deploy to staging
        run: |
          # SSH経由でステージング環境にデプロイ
          ssh deploy@staging.example.com \
            "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} && \
             docker service update --image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} staging_web"

  deploy-production:
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment: production
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Deploy to production
        run: |
          ssh deploy@prod.example.com \
            "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} && \
             docker service update --image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} prod_web"</code></pre>
                </section>

                <!-- 次のステップ -->
                <section id="next-steps">
                    <h2 class="section-title">次のステップ</h2>

                    <h3>学習を続けるために</h3>

                    <h4>1. Kubernetesを深く学ぶ</h4>
                    <ul>
                        <li>Kubernetesの公式チュートリアル</li>
                        <li>Certified Kubernetes Administrator (CKA) 認定</li>
                        <li>Helm（Kubernetesパッケージマネージャー）</li>
                        <li>Kubernetesオペレーターパターン</li>
                    </ul>

                    <h4>2. クラウドプラットフォーム</h4>
                    <ul>
                        <li><strong>AWS</strong>：ECS、EKS、Fargateを学習</li>
                        <li><strong>Google Cloud</strong>：GKE、Cloud Runを学習</li>
                        <li><strong>Azure</strong>：AKS、Azure Container Instancesを学習</li>
                    </ul>

                    <h4>3. マイクロサービスアーキテクチャ</h4>
                    <ul>
                        <li>サービスメッシュ（Istio、Linkerd）</li>
                        <li>API Gateway（Kong、Traefik）</li>
                        <li>サービスディスカバリー（Consul、etcd）</li>
                        <li>分散トレーシング（Jaeger、Zipkin）</li>
                    </ul>

                    <h4>4. インフラストラクチャ as コード</h4>
                    <ul>
                        <li>Terraform - インフラのプロビジョニング</li>
                        <li>Ansible - 設定管理</li>
                        <li>ArgoCD - GitOps デプロイ</li>
                    </ul>

                    <h4>5. オブザーバビリティ</h4>
                    <ul>
                        <li>Prometheusとアラート設定の深掘り</li>
                        <li>Grafana Lokiでログ管理</li>
                        <li>OpenTelemetryで分散トレーシング</li>
                    </ul>

                    <h3>推奨学習リソース</h3>

                    <h4>書籍</h4>
                    <ul>
                        <li>「Docker/Kubernetes 実践コンテナ開発入門」</li>
                        <li>「Kubernetes完全ガイド」</li>
                        <li>「マイクロサービスパターン」</li>
                    </ul>

                    <h4>オンラインコース</h4>
                    <ul>
                        <li>Udemy - Docker & Kubernetes: The Complete Guide</li>
                        <li>Coursera - Google Cloud Platform Fundamentals</li>
                        <li>Linux Academy - Kubernetes courses</li>
                    </ul>

                    <h4>コミュニティ</h4>
                    <ul>
                        <li>Docker Community Forums</li>
                        <li>Kubernetes Slack</li>
                        <li>Cloud Native Computing Foundation (CNCF)</li>
                    </ul>

                    <div class="highlight">
                        <h5>学習の継続</h5>
                        <p>
                            Dockerの学習は終わりではなく、始まりです。実際のプロジェクトでDockerを使用し、問題に直面し、解決することで真のスキルが身につきます。小さなプロジェクトから始めて、徐々に複雑なシステムに挑戦しましょう。
                        </p>
                    </div>
                </section>

                <!-- 実習課題 -->
                <section id="exercises">
                    <h2 class="section-title">実習課題</h2>

                    <div class="exercise-container">
                        <h4>実習1：コンテナレジストリの使用</h4>
                        <p><strong>目的：</strong>イメージをレジストリにプッシュ・プルする</p>

                        <p><strong>手順：</strong></p>
                        <ol>
                            <li>Docker Hubまたは GitHub Container Registryにアカウント作成</li>
                            <li>ログインして認証</li>
                            <li>自作のイメージをタグ付け</li>
                            <li>レジストリにプッシュ</li>
                            <li>ローカルのイメージを削除</li>
                            <li>レジストリからプルして動作確認</li>
                        </ol>
                    </div>

                    <div class="exercise-container">
                        <h4>実習2：CI/CDパイプラインの構築</h4>
                        <p><strong>目的：</strong>GitHub Actionsで自動ビルド・テスト・デプロイを実装する</p>

                        <p><strong>手順：</strong></p>
                        <ol>
                            <li>GitHubリポジトリを作成</li>
                            <li>.github/workflows/ci.ymlを作成</li>
                            <li>テスト自動実行を設定</li>
                            <li>Dockerイメージの自動ビルドを設定</li>
                            <li>コードをプッシュしてワークフローが動作することを確認</li>
                        </ol>
                    </div>

                    <div class="exercise-container">
                        <h4>実習3：モニタリングシステムの構築</h4>
                        <p><strong>目的：</strong>PrometheusとGrafanaでアプリケーションを監視する</p>

                        <p><strong>手順：</strong></p>
                        <ol>
                            <li>docker-compose.ymlでPrometheus + Grafanaを起動</li>
                            <li>アプリケーションのメトリクスをPrometheusで収集</li>
                            <li>Grafanaでダッシュボードを作成</li>
                            <li>CPU、メモリ、リクエスト数などを可視化</li>
                            <li>アラート条件を設定</li>
                        </ol>
                    </div>
                </section>

                <!-- 理解度確認クイズ -->
                <section id="quiz">
                    <h2 class="section-title">理解度確認クイズ</h2>

                    <div class="quiz-container">
                        <h4>Q1: コンテナレジストリ</h4>
                        <p>コンテナレジストリの主な役割は何ですか？</p>
                        <ol type="a">
                            <li>コンテナを実行する</li>
                            <li>Dockerイメージを保存・配布する</li>
                            <li>コンテナをオーケストレーションする</li>
                            <li>ログを収集する</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer1">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer1">
                            <div class="alert alert-info">
                                <strong>答え：b) Dockerイメージを保存・配布する</strong><br>
                                コンテナレジストリは、Dockerイメージを保存し、チーム間や異なる環境間で配布するためのサービスです。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q2: Docker SwarmとKubernetes</h4>
                        <p>Docker Swarmと比較したKubernetesの特徴として正しいものはどれですか？</p>
                        <ol type="a">
                            <li>学習コストが低い</li>
                            <li>セットアップが簡単</li>
                            <li>大規模環境に適している</li>
                            <li>Dockerに組み込まれている</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer2">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer2">
                            <div class="alert alert-info">
                                <strong>答え：c) 大規模環境に適している</strong><br>
                                Kubernetesは複雑ですが、大規模なコンテナ環境に適しており、豊富な機能とエコシステムを持っています。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q3: デプロイ戦略</h4>
                        <p>ローリングアップデートの説明として正しいものはどれですか？</p>
                        <ol type="a">
                            <li>全コンテナを一度に停止して更新</li>
                            <li>古いバージョンを徐々に新しいバージョンに置き換える</li>
                            <li>2つの環境を用意してトラフィックを切り替える</li>
                            <li>新バージョンに少量のトラフィックを流す</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer3">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer3">
                            <div class="alert alert-info">
                                <strong>答え：b) 古いバージョンを徐々に新しいバージョンに置き換える</strong><br>
                                ローリングアップデートは、ダウンタイムなしで段階的にコンテナを更新する戦略です。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q4: モニタリング</h4>
                        <p>Prometheusの主な役割は何ですか？</p>
                        <ol type="a">
                            <li>ログの収集</li>
                            <li>メトリクスの収集と保存</li>
                            <li>イメージのビルド</li>
                            <li>コンテナのオーケストレーション</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer4">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer4">
                            <div class="alert alert-info">
                                <strong>答え：b) メトリクスの収集と保存</strong><br>
                                Prometheusは、時系列データベースとして、アプリケーションやインフラのメトリクスを収集・保存します。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q5: CI/CD</h4>
                        <p>CI/CDパイプラインに含まれない工程はどれですか？</p>
                        <ol type="a">
                            <li>テストの自動実行</li>
                            <li>Dockerイメージのビルド</li>
                            <li>手動でのコード変更</li>
                            <li>自動デプロイ</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer5">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer5">
                            <div class="alert alert-info">
                                <strong>答え：c) 手動でのコード変更</strong><br>
                                CI/CDパイプラインは、コードのコミット後の工程（テスト、ビルド、デプロイ）を自動化するものです。コード変更自体は開発者が行いますが、それ以降は自動化されます。
                            </div>
                        </div>
                    </div>
                </section>

                <!-- ナビゲーション -->
                <div class="chapter-nav">
                    <a href="docker-learning-material-09.html" class="btn btn-outline-primary">&larr; 前の章へ</a>
                    <a href="../README.html" class="btn btn-success">学習完了 - TOPへ戻る</a>
                </div>

                <!-- 完了メッセージ -->
                <div class="alert alert-success mt-4" role="alert">
                    <h4 class="alert-heading">おめでとうございます！</h4>
                    <p>
                        Docker学習教材の全10章を完了しました。これでDockerの基礎から本番環境へのデプロイまで、一通りの知識を習得しました。
                    </p>
                    <hr>
                    <p class="mb-0">
                        次は実際のプロジェクトでDockerを活用し、Kubernetes等のさらなる学習に進みましょう。継続的な学習と実践が、真のスキル向上につながります。
                    </p>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Highlight.js初期化 -->
    <script>
        hljs.highlightAll();
    </script>

    <!-- Mermaid初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>
