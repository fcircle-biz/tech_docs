<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker学習教材 第9章 - Dockerのベストプラクティスとセキュリティ</title>

    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">

    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>

    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
            line-height: 1.8;
        }

        /* ナビゲーション - Docker Blue */
        .navbar {
            background-color: #2496ED;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 1rem;
        }

        /* タイトル */
        .chapter-title {
            color: #2496ED;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 3px solid #2496ED;
            padding-bottom: 0.5rem;
            font-weight: bold;
        }

        .section-title {
            color: #1D63ED;
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e7f3ff;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #2496ED;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #fff9e6;
            border-radius: 8px;
            padding: 1.2rem;
            margin: 1.5rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            color: white;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
        }

        pre code.hljs {
            background-color: #1e1e1e;
            padding: 1rem;
            border-radius: 5px;
        }

        /* Mermaid図表 */
        .mermaid {
            text-align: center;
            margin: 2rem 0;
        }

        /* ナビゲーションボタン */
        .chapter-nav {
            margin: 2rem 0;
        }

        /* サイドバーリンク */
        .sidebar a {
            color: #2496ED;
            text-decoration: none;
        }

        .sidebar a:hover {
            text-decoration: underline;
        }

        /* 折りたたみコンテンツ */
        .collapse-trigger {
            cursor: pointer;
            color: #2496ED;
            user-select: none;
        }

        .collapse-trigger:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">
                <i class="fab fa-docker"></i>
                <strong>Docker学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-01.html">
                                第1章: Dockerとは何か
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-02.html">
                                第2章: 環境構築と基本操作
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-03.html">
                                第3章: イメージの理解と管理
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-04.html">
                                第4章: Dockerfileによるイメージ作成
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-05.html">
                                第5章: Docker Compose
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-06.html">
                                第6章: ボリュームとデータ永続化
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-07.html">
                                第7章: ネットワークとコンテナ間通信
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-08.html">
                                第8章: マルチコンテナアプリケーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="docker-learning-material-09.html">
                                第9章: ベストプラクティスとセキュリティ
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-10.html">
                                第10章: 本番環境へのデプロイ
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <h1 class="chapter-title">第9章 - Dockerのベストプラクティスとセキュリティ</h1>

                <!-- 学習目標 -->
                <div class="highlight">
                    <h4>学習目標</h4>
                    <ul>
                        <li>イメージサイズを最適化する手法を習得する</li>
                        <li>Dockerのセキュリティベストプラクティスを理解する</li>
                        <li>脆弱性診断ツールを使用してイメージをスキャンできる</li>
                        <li>機密情報を安全に管理する方法を学ぶ</li>
                        <li>リソース制限を設定し、システムを保護できる</li>
                    </ul>
                </div>

                <!-- はじめに -->
                <section id="intro">
                    <h2 class="section-title">はじめに</h2>
                    <p>
                        Dockerを本番環境で使用する際には、パフォーマンス、セキュリティ、保守性を考慮した最適化が必要です。この章では、プロフェッショナルな環境で求められるベストプラクティスを学びます。
                    </p>
                    <p>
                        適切な最適化とセキュリティ対策により、高速で安全、かつ保守しやすいコンテナアプリケーションを構築できます。
                    </p>
                </section>

                <!-- イメージ最適化 -->
                <section id="image-optimization">
                    <h2 class="section-title">イメージサイズの最適化</h2>

                    <h3>なぜイメージサイズが重要か</h3>
                    <ul>
                        <li><strong>ビルド時間の短縮</strong>：小さいイメージは速くビルドできる</li>
                        <li><strong>デプロイの高速化</strong>：レジストリとの通信が速くなる</li>
                        <li><strong>ストレージコストの削減</strong>：保存容量が減る</li>
                        <li><strong>セキュリティ向上</strong>：攻撃対象となるコンポーネントが減る</li>
                        <li><strong>起動時間の短縮</strong>：イメージのプル時間が減る</li>
                    </ul>

                    <h3>最適化手法1：Alpine Linuxの使用</h3>
                    <p>
                        Alpine Linuxは、約5MBの超軽量Linuxディストリビューションです。多くの公式イメージにAlpine版が用意されています。
                    </p>

                    <pre class="code-block"><code class="language-dockerfile"># 通常版（約1GB）
FROM node:18
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
CMD ["node", "server.js"]

# Alpine版（約150MB）
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
CMD ["node", "server.js"]</code></pre>

                    <h3>最適化手法2：マルチステージビルド</h3>
                    <p>
                        ビルドツールを最終イメージに含めないことで、大幅にサイズを削減できます。
                    </p>

                    <pre class="code-block"><code class="language-dockerfile"># 最適化前（約500MB）
FROM node:18
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
CMD ["node", "dist/server.js"]

# 最適化後（約100MB）
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
USER node
CMD ["node", "dist/server.js"]</code></pre>

                    <h3>最適化手法3：不要なファイルの除外</h3>
                    <pre class="code-block"><code class="language-dockerfile"># .dockerignore
node_modules
npm-debug.log
.git
.gitignore
README.md
.env
*.md
.vscode
.idea
tests
*.test.js
coverage</code></pre>

                    <h3>最適化手法4：レイヤーの最小化</h3>
                    <pre class="code-block"><code class="language-dockerfile"># 悪い例：レイヤーが多い
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get install -y git
RUN apt-get install -y vim

# 良い例：レイヤーをまとめる
RUN apt-get update && \
    apt-get install -y \
        curl \
        git \
        vim && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*</code></pre>

                    <h3>イメージサイズの確認</h3>
                    <pre class="code-block"><code class="language-bash"># イメージサイズを確認
docker images

# 特定のイメージの詳細
docker history myapp:latest

# イメージのレイヤー構造を表示
docker image inspect myapp:latest</code></pre>

                    <h3>Distroless イメージ</h3>
                    <p>
                        Googleが提供するDistrolessイメージは、アプリケーション実行に必要な最小限のコンポーネントのみを含みます。
                    </p>

                    <pre class="code-block"><code class="language-dockerfile">FROM golang:1.21 AS builder
WORKDIR /app
COPY . .
RUN CGO_ENABLED=0 go build -o myapp

FROM gcr.io/distroless/static-debian11
COPY --from=builder /app/myapp /
CMD ["/myapp"]

# 最終イメージサイズ：約10MB</code></pre>
                </section>

                <!-- レイヤーキャッシュ活用 -->
                <section id="layer-cache">
                    <h2 class="section-title">レイヤーキャッシュの効果的な活用</h2>

                    <h3>キャッシュ戦略</h3>
                    <p>
                        Dockerfileの命令順序を最適化することで、ビルド時間を大幅に短縮できます。
                    </p>

                    <h3>ベストプラクティス</h3>
                    <pre class="code-block"><code class="language-dockerfile"># 良い例：依存関係を先にインストール
FROM node:18-alpine

WORKDIR /app

# 1. package.jsonのみコピー（変更頻度：低）
COPY package*.json ./

# 2. 依存関係をインストール（キャッシュされやすい）
RUN npm ci --only=production

# 3. アプリケーションコードをコピー（変更頻度：高）
COPY . .

CMD ["node", "server.js"]</code></pre>

                    <pre class="code-block"><code class="language-dockerfile"># 悪い例：すべてを一度にコピー
FROM node:18-alpine
WORKDIR /app
COPY . .  # コード変更のたびにnpm installが実行される
RUN npm install
CMD ["node", "server.js"]</code></pre>

                    <h3>ビルド時のキャッシュ活用</h3>
                    <pre class="code-block"><code class="language-bash"># キャッシュを使ってビルド
docker build -t myapp:latest .

# キャッシュを無視して完全再ビルド
docker build --no-cache -t myapp:latest .

# BuildKitを使った高度なキャッシュ
DOCKER_BUILDKIT=1 docker build -t myapp:latest .</code></pre>
                </section>

                <!-- セキュリティ -->
                <section id="security">
                    <h2 class="section-title">Dockerセキュリティのベストプラクティス</h2>

                    <h3>1. 非rootユーザーの使用</h3>
                    <p>
                        コンテナをrootユーザーで実行すると、セキュリティリスクが高まります。必ず非rootユーザーを使用しましょう。
                    </p>

                    <pre class="code-block"><code class="language-dockerfile"># 推奨：非rootユーザーで実行
FROM node:18-alpine

WORKDIR /app

# アプリケーション用ユーザーを作成
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# ファイルをコピー
COPY --chown=nodejs:nodejs package*.json ./
RUN npm ci --only=production

COPY --chown=nodejs:nodejs . .

# 非rootユーザーに切り替え
USER nodejs

CMD ["node", "server.js"]</code></pre>

                    <div class="warning">
                        <h5>セキュリティリスク：rootユーザー</h5>
                        <p>
                            コンテナがrootユーザーで実行されている場合、コンテナが侵害されると、攻撃者はroot権限を取得する可能性があります。
                        </p>
                    </div>

                    <h3>2. 最小権限の原則</h3>
                    <p>
                        コンテナには必要最小限の権限のみを付与します。
                    </p>

                    <pre class="code-block"><code class="language-bash"># 読み取り専用のルートファイルシステム
docker run --read-only --tmpfs /tmp myapp

# capabilityを削除
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE myapp

# seccompプロファイルを適用
docker run --security-opt seccomp=default.json myapp</code></pre>

                    <h3>3. 信頼できるベースイメージの使用</h3>
                    <ul>
                        <li>公式イメージを優先的に使用</li>
                        <li>イメージの作成者を確認</li>
                        <li>タグを明示的に指定（<code>:latest</code>を避ける）</li>
                        <li>定期的にイメージを更新</li>
                    </ul>

                    <pre class="code-block"><code class="language-dockerfile"># 良い例
FROM node:18.17.1-alpine3.18

# 悪い例（バージョン不明確）
FROM node:latest</code></pre>

                    <h3>4. 機密情報をイメージに含めない</h3>
                    <pre class="code-block"><code class="language-dockerfile"># 悪い例：パスワードがハードコード
ENV DATABASE_PASSWORD=mysecretpassword

# 良い例：環境変数として外部から注入
ENV DATABASE_PASSWORD=""</code></pre>

                    <pre class="code-block"><code class="language-bash"># 実行時に環境変数を渡す
docker run -e DATABASE_PASSWORD=secret myapp

# または.envファイルから読み込む
docker run --env-file .env myapp</code></pre>

                    <h3>5. ネットワークセキュリティ</h3>
                    <pre class="code-block"><code class="language-yaml"># docker-compose.yml
version: '3.8'

services:
  web:
    networks:
      - frontend
  api:
    networks:
      - frontend
      - backend
  db:
    networks:
      - backend

networks:
  frontend:
  backend:
    internal: true  # 外部からの接続を遮断</code></pre>
                </section>

                <!-- 脆弱性診断 -->
                <section id="vulnerability-scan">
                    <h2 class="section-title">脆弱性診断ツール</h2>

                    <h3>Docker Scout（Docker公式）</h3>
                    <pre class="code-block"><code class="language-bash"># イメージをスキャン
docker scout cves myapp:latest

# 詳細な脆弱性レポート
docker scout cves --format json myapp:latest

# 推奨事項を表示
docker scout recommendations myapp:latest</code></pre>

                    <h3>Trivy（オープンソース）</h3>
                    <p>
                        Trivyは、コンテナイメージの脆弱性をスキャンする人気のツールです。
                    </p>

                    <pre class="code-block"><code class="language-bash"># Trivyのインストール
brew install aquasecurity/trivy/trivy  # macOS
# または
curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

# イメージをスキャン
trivy image myapp:latest

# 重大度の高い脆弱性のみ表示
trivy image --severity HIGH,CRITICAL myapp:latest

# JSON形式で出力
trivy image --format json --output result.json myapp:latest</code></pre>

                    <h3>CI/CDでの自動スキャン</h3>
                    <pre class="code-block"><code class="language-yaml"># .github/workflows/docker-scan.yml
name: Docker Security Scan

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Build Docker image
        run: docker build -t myapp:${{ github.sha }} .

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: myapp:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'</code></pre>

                    <h3>脆弱性への対応</h3>
                    <ol>
                        <li><strong>定期的なスキャン</strong>：週次または月次でイメージをスキャン</li>
                        <li><strong>ベースイメージの更新</strong>：最新版に定期的に更新</li>
                        <li><strong>依存関係の更新</strong>：ライブラリやパッケージを最新に保つ</li>
                        <li><strong>重大度の評価</strong>：CRITICAL/HIGH → MEDIUM → LOWの順で対応</li>
                    </ol>
                </section>

                <!-- シークレット管理 -->
                <section id="secrets">
                    <h2 class="section-title">シークレット管理</h2>

                    <h3>シークレット管理の原則</h3>
                    <ul>
                        <li>イメージにシークレットを含めない</li>
                        <li>環境変数でシークレットを渡す（開発環境）</li>
                        <li>本番環境では専用のシークレット管理ツールを使用</li>
                        <li>シークレットのローテーション</li>
                    </ul>

                    <h3>Docker Secrets（Swarm）</h3>
                    <pre class="code-block"><code class="language-bash"># シークレットを作成
echo "my_db_password" | docker secret create db_password -

# サービスでシークレットを使用
docker service create \
  --name myapp \
  --secret db_password \
  myapp:latest</code></pre>

                    <h3>環境変数ファイル</h3>
                    <pre class="code-block"><code class="language-bash"># .env（Gitignoreに追加）
DB_PASSWORD=secret_password
API_KEY=api_key_value

# .env.example（リポジトリに含める）
DB_PASSWORD=your_password_here
API_KEY=your_api_key_here</code></pre>

                    <h3>ビルド時のシークレット（BuildKit）</h3>
                    <pre class="code-block"><code class="language-dockerfile"># Dockerfile
FROM node:18-alpine

WORKDIR /app

# BuildKitのシークレット機能を使用
RUN --mount=type=secret,id=npmrc,dst=/root/.npmrc \
    npm install

COPY . .
CMD ["node", "server.js"]</code></pre>

                    <pre class="code-block"><code class="language-bash"># ビルド時にシークレットを渡す
DOCKER_BUILDKIT=1 docker build \
  --secret id=npmrc,src=$HOME/.npmrc \
  -t myapp:latest .</code></pre>

                    <h3>外部シークレット管理ツール</h3>
                    <ul>
                        <li><strong>AWS Secrets Manager</strong>：AWS環境でのシークレット管理</li>
                        <li><strong>HashiCorp Vault</strong>：エンタープライズ向けシークレット管理</li>
                        <li><strong>Google Secret Manager</strong>：GCP環境でのシークレット管理</li>
                        <li><strong>Azure Key Vault</strong>：Azure環境でのシークレット管理</li>
                    </ul>
                </section>

                <!-- リソース制限 -->
                <section id="resource-limits">
                    <h2 class="section-title">リソース制限</h2>

                    <h3>なぜリソース制限が必要か</h3>
                    <p>
                        コンテナにリソース制限を設定することで、以下のメリットがあります：
                    </p>
                    <ul>
                        <li>1つのコンテナがホスト全体のリソースを独占するのを防ぐ</li>
                        <li>メモリリークなどの問題を早期に検出</li>
                        <li>予測可能なパフォーマンス</li>
                        <li>複数のコンテナを安全に共存させる</li>
                    </ul>

                    <h3>CPUとメモリの制限</h3>
                    <pre class="code-block"><code class="language-bash"># メモリ制限（512MB）
docker run -m 512m myapp

# CPU制限（0.5コア = 50%）
docker run --cpus=0.5 myapp

# 両方を制限
docker run -m 512m --cpus=0.5 myapp

# メモリ予約（最低保証）
docker run --memory-reservation=256m -m 512m myapp</code></pre>

                    <h3>Docker Composeでのリソース制限</h3>
                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  web:
    image: myapp
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M

  db:
    image: postgres:15
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M</code></pre>

                    <h3>リソース使用状況の監視</h3>
                    <pre class="code-block"><code class="language-bash"># リアルタイムでリソース使用状況を表示
docker stats

# 特定のコンテナのみ
docker stats container-name

# 1回だけ表示（継続監視しない）
docker stats --no-stream</code></pre>

                    <h3>PIDs制限</h3>
                    <pre class="code-block"><code class="language-bash"># プロセス数を制限（フォーク爆弾対策）
docker run --pids-limit 100 myapp</code></pre>
                </section>

                <!-- Dockerfileベストプラクティス -->
                <section id="dockerfile-best">
                    <h2 class="section-title">Dockerfileベストプラクティス まとめ</h2>

                    <h3>完璧なDockerfileの例</h3>
                    <pre class="code-block"><code class="language-dockerfile"># 1. 明確なバージョン指定
FROM node:18.17.1-alpine3.18 AS builder

# 2. メタデータを追加
LABEL maintainer="your-email@example.com"
LABEL version="1.0"
LABEL description="Production-ready Node.js application"

# 3. 作業ディレクトリを設定
WORKDIR /app

# 4. 依存関係ファイルを先にコピー（キャッシュ最適化）
COPY package*.json ./

# 5. セキュリティアップデートと依存関係インストール
RUN apk update && apk upgrade && \
    npm ci --only=production && \
    npm cache clean --force

# 6. アプリケーションコードをコピー
COPY . .

# 7. ビルド実行
RUN npm run build

# 8. 本番用の最小イメージ
FROM node:18.17.1-alpine3.18

WORKDIR /app

# 9. 非rootユーザーを作成
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# 10. ビルド成果物のみコピー
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/package*.json ./

# 11. 非rootユーザーに切り替え
USER nodejs

# 12. ポートを文書化
EXPOSE 8000

# 13. ヘルスチェックを追加
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s \
  CMD node healthcheck.js

# 14. シグナルハンドリング
STOPSIGNAL SIGTERM

# 15. ENTRYPOINTとCMDを適切に使用
CMD ["node", "dist/server.js"]</code></pre>

                    <h3>チェックリスト</h3>
                    <div class="highlight">
                        <ul>
                            <li>✓ 明確なバージョンタグを使用</li>
                            <li>✓ Alpineまたは軽量イメージを使用</li>
                            <li>✓ マルチステージビルドを活用</li>
                            <li>✓ レイヤーキャッシュを最適化</li>
                            <li>✓ .dockerignoreで不要ファイルを除外</li>
                            <li>✓ 非rootユーザーで実行</li>
                            <li>✓ ヘルスチェックを実装</li>
                            <li>✓ シークレットをハードコードしない</li>
                            <li>✓ ラベルでメタデータを追加</li>
                            <li>✓ 1コンテナ = 1プロセス</li>
                        </ul>
                    </div>
                </section>

                <!-- CI/CD統合 -->
                <section id="ci-cd">
                    <h2 class="section-title">CI/CDパイプラインでのDocker活用</h2>

                    <h3>GitHub Actionsでの自動ビルド</h3>
                    <pre class="code-block"><code class="language-yaml"># .github/workflows/docker-build.yml
name: Docker Build and Push

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=sha

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Run Trivy scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results.sarif'</code></pre>

                    <h3>GitLab CI/CDでのDocker活用</h3>
                    <pre class="code-block"><code class="language-yaml"># .gitlab-ci.yml
stages:
  - build
  - test
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA

test:
  stage: test
  image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  script:
    - npm test

deploy:
  stage: deploy
  only:
    - main
  script:
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:latest</code></pre>
                </section>

                <!-- 実習課題 -->
                <section id="exercises">
                    <h2 class="section-title">実習課題</h2>

                    <div class="exercise-container">
                        <h4>実習1：イメージサイズの最適化</h4>
                        <p><strong>目的：</strong>既存のDockerfileを最適化してイメージサイズを削減する</p>

                        <p><strong>手順：</strong></p>
                        <ol>
                            <li>現在のイメージサイズを確認</li>
                            <li>Alpine Linuxベースのイメージに変更</li>
                            <li>マルチステージビルドを導入</li>
                            <li>.dockerignoreを作成</li>
                            <li>最適化後のサイズを確認し、削減率を計算</li>
                        </ol>
                    </div>

                    <div class="exercise-container">
                        <h4>実習2：セキュリティ強化</h4>
                        <p><strong>目的：</strong>Dockerfileをセキュアにする</p>

                        <p><strong>手順：</strong></p>
                        <ol>
                            <li>非rootユーザーを作成して使用</li>
                            <li>明確なバージョンタグを指定</li>
                            <li>ヘルスチェックを追加</li>
                            <li>Trivyで脆弱性スキャンを実行</li>
                            <li>検出された脆弱性に対応</li>
                        </ol>
                    </div>

                    <div class="exercise-container">
                        <h4>実習3：リソース制限の設定</h4>
                        <p><strong>目的：</strong>コンテナにリソース制限を適用する</p>

                        <p><strong>手順：</strong></p>
                        <ol>
                            <li>docker-compose.ymlにリソース制限を追加</li>
                            <li>CPU: 0.5コア、メモリ: 512MBに制限</li>
                            <li>コンテナを起動</li>
                            <li><code>docker stats</code>でリソース使用状況を監視</li>
                            <li>負荷をかけて制限が機能することを確認</li>
                        </ol>
                    </div>
                </section>

                <!-- 理解度確認クイズ -->
                <section id="quiz">
                    <h2 class="section-title">理解度確認クイズ</h2>

                    <div class="quiz-container">
                        <h4>Q1: イメージ最適化</h4>
                        <p>イメージサイズを削減する方法として適切でないものはどれですか？</p>
                        <ol type="a">
                            <li>Alpine Linuxを使用する</li>
                            <li>マルチステージビルドを使用する</li>
                            <li>すべてのツールをインストールする</li>
                            <li>.dockerignoreで不要なファイルを除外する</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer1">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer1">
                            <div class="alert alert-info">
                                <strong>答え：c) すべてのツールをインストールする</strong><br>
                                不要なツールをインストールすると、イメージサイズが大きくなり、セキュリティリスクも増加します。必要最小限のコンポーネントのみをインストールすべきです。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q2: セキュリティ</h4>
                        <p>Dockerのセキュリティベストプラクティスとして正しいものはどれですか？</p>
                        <ol type="a">
                            <li>rootユーザーで実行する</li>
                            <li>非rootユーザーで実行する</li>
                            <li>パスワードをDockerfileにハードコードする</li>
                            <li><code>:latest</code>タグを常に使用する</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer2">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer2">
                            <div class="alert alert-info">
                                <strong>答え：b) 非rootユーザーで実行する</strong><br>
                                非rootユーザーで実行することで、コンテナが侵害された場合の影響を最小限に抑えることができます。これは最も重要なセキュリティベストプラクティスの1つです。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q3: 脆弱性スキャン</h4>
                        <p>コンテナイメージの脆弱性をスキャンするツールはどれですか？</p>
                        <ol type="a">
                            <li>Docker Compose</li>
                            <li>Trivy</li>
                            <li>Dockerfile</li>
                            <li>Docker Hub</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer3">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer3">
                            <div class="alert alert-info">
                                <strong>答え：b) Trivy</strong><br>
                                Trivyは、コンテナイメージの脆弱性をスキャンする人気のオープンソースツールです。Docker ScoutやSnykなども同様の機能を提供します。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q4: リソース制限</h4>
                        <p>コンテナのメモリを512MBに制限するコマンドはどれですか？</p>
                        <ol type="a">
                            <li><code>docker run --memory 512 myapp</code></li>
                            <li><code>docker run -m 512m myapp</code></li>
                            <li><code>docker run --mem-limit 512 myapp</code></li>
                            <li><code>docker run --memory-size 512 myapp</code></li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer4">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer4">
                            <div class="alert alert-info">
                                <strong>答え：b) <code>docker run -m 512m myapp</code></strong><br>
                                <code>-m</code>または<code>--memory</code>オプションでメモリ制限を指定します。単位は<code>m</code>（メガバイト）または<code>g</code>（ギガバイト）です。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q5: レイヤーキャッシュ</h4>
                        <p>Dockerfileでレイヤーキャッシュを効果的に活用するための原則はどれですか？</p>
                        <ol type="a">
                            <li>変更頻度の高いものを上に配置</li>
                            <li>変更頻度の低いものを上に配置</li>
                            <li>すべての命令を1つのRUNにまとめる</li>
                            <li>キャッシュは使わない</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer5">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer5">
                            <div class="alert alert-info">
                                <strong>答え：b) 変更頻度の低いものを上に配置</strong><br>
                                依存関係のインストール（package.json）など、変更頻度の低いものを先に配置し、アプリケーションコードなど変更頻度の高いものを後に配置することで、キャッシュを効果的に活用できます。
                            </div>
                        </div>
                    </div>
                </section>

                <!-- ナビゲーション -->
                <div class="chapter-nav">
                    <a href="docker-learning-material-08.html" class="btn btn-outline-primary">&larr; 前の章へ</a>
                    <a href="docker-learning-material-10.html" class="btn btn-primary">次の章へ &rarr;</a>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Highlight.js初期化 -->
    <script>
        hljs.highlightAll();
    </script>

    <!-- Mermaid初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>
