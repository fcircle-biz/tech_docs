<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker学習教材 第7章 - Dockerネットワークとコンテナ間通信</title>

    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Google Fonts - Noto Sans JP -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">

    <!-- Highlight.js CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>

    <style>
        /* ベースレイアウト */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            padding-top: 56px;
            line-height: 1.8;
        }

        /* ナビゲーション - Docker Blue */
        .navbar {
            background-color: #2496ED;
        }

        /* サイドバー */
        .sidebar {
            position: sticky;
            top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 1rem;
        }

        /* タイトル */
        .chapter-title {
            color: #2496ED;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 3px solid #2496ED;
            padding-bottom: 0.5rem;
            font-weight: bold;
        }

        .section-title {
            color: #1D63ED;
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        /* コンテンツボックス */
        .quiz-container {
            background-color: #e7f3ff;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #2496ED;
        }

        .exercise-container {
            background-color: #f3e5f5;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #9c27b0;
        }

        .highlight {
            background-color: #fff9e6;
            border-radius: 8px;
            padding: 1.2rem;
            margin: 1.5rem 0;
            border-left: 4px solid #ffc107;
        }

        .warning {
            background-color: #ffebee;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #f44336;
        }

        /* コードハイライト */
        .code-block {
            background-color: #1e1e1e;
            color: white;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
        }

        pre code.hljs {
            background-color: #1e1e1e;
            padding: 1rem;
            border-radius: 5px;
        }

        /* Mermaid図表 */
        .mermaid {
            text-align: center;
            margin: 2rem 0;
        }

        /* ナビゲーションボタン */
        .chapter-nav {
            margin: 2rem 0;
        }

        /* サイドバーリンク */
        .sidebar a {
            color: #2496ED;
            text-decoration: none;
        }

        .sidebar a:hover {
            text-decoration: underline;
        }

        /* 折りたたみコンテンツ */
        .collapse-trigger {
            cursor: pointer;
            color: #2496ED;
            user-select: none;
        }

        .collapse-trigger:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <!-- ナビゲーションバー -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">
                <i class="fab fa-docker"></i>
                <strong>Docker学習教材</strong>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- サイドバー -->
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky pt-3">
                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>学習章</span>
                    </h6>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-01.html">
                                第1章: Dockerとは何か
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-02.html">
                                第2章: 環境構築と基本操作
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-03.html">
                                第3章: イメージの理解と管理
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-04.html">
                                第4章: Dockerfileによるイメージ作成
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-05.html">
                                第5章: Docker Compose
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-06.html">
                                第6章: ボリュームとデータ永続化
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="docker-learning-material-07.html">
                                第7章: ネットワークとコンテナ間通信
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-08.html">
                                第8章: マルチコンテナアプリケーション
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-09.html">
                                第9章: ベストプラクティスとセキュリティ
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="docker-learning-material-10.html">
                                第10章: 本番環境へのデプロイ
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <!-- メインコンテンツ -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">第7章: Dockerネットワークとコンテナ間通信</h1>
                </div>

                <!-- 学習目標 -->
                <div class="highlight">
                    <h4>学習目標</h4>
                    <ul>
                        <li>Dockerネットワークの基本概念を理解する</li>
                        <li>デフォルトネットワーク（bridge、host、none）の違いを理解する</li>
                        <li>カスタムブリッジネットワークを作成・管理できる</li>
                        <li>コンテナ名によるDNS解決を活用できる</li>
                        <li>ネットワーク分離によるセキュリティ向上を実現できる</li>
                    </ul>
                </div>

                <!-- はじめに -->
                <section id="intro">
                    <h2 class="section-title">はじめに</h2>
                    <p>
                        マイクロサービスアーキテクチャやコンテナベースのアプリケーションでは、複数のコンテナが互いに通信する必要があります。例えば、Webアプリケーションコンテナがデータベースコンテナに接続する、フロントエンドがバックエンドAPIを呼び出す、などです。
                    </p>
                    <p>
                        この章では、Dockerの<strong>ネットワーク機能</strong>を学び、コンテナ間の通信を適切に設定する方法を習得します。また、セキュリティの観点から重要な<strong>ネットワーク分離</strong>についても学びます。
                    </p>
                </section>

                <!-- ネットワークの基本概念 -->
                <section id="network-basics">
                    <h2 class="section-title">Dockerネットワークの基本概念</h2>

                    <h3>Dockerネットワークとは</h3>
                    <p>
                        Dockerネットワークは、コンテナ間およびコンテナと外部との通信を可能にする仮想ネットワーク環境です。各コンテナは1つ以上のネットワークに接続でき、同じネットワーク内のコンテナ同士は互いに通信できます。
                    </p>

                    <div class="mermaid">
                        graph TD
                            A[Dockerホスト] --> B[ネットワーク1: frontend]
                            A --> C[ネットワーク2: backend]
                            B --> D[Webコンテナ]
                            B --> E[Nginxコンテナ]
                            C --> F[APIコンテナ]
                            C --> G[DBコンテナ]
                            D -.->|通信可能| E
                            F -.->|通信可能| G
                            style B fill:#e7f3ff
                            style C fill:#fff9e6
                    </div>

                    <h3>ネットワークの確認</h3>
                    <pre class="code-block"><code class="language-bash"># すべてのネットワークを一覧表示
docker network ls

# 出力例：
# NETWORK ID     NAME      DRIVER    SCOPE
# a1b2c3d4e5f6   bridge    bridge    local
# 1a2b3c4d5e6f   host      host      local
# 9f8e7d6c5b4a   none      null      local</code></pre>

                    <h3>ネットワークの詳細情報</h3>
                    <pre class="code-block"><code class="language-bash"># 特定のネットワークの詳細を確認
docker network inspect bridge

# 接続されているコンテナ、IPアドレス、設定などが表示される</code></pre>
                </section>

                <!-- デフォルトネットワーク -->
                <section id="default-networks">
                    <h2 class="section-title">デフォルトネットワーク</h2>

                    <p>Dockerには3つのデフォルトネットワークが用意されています：</p>

                    <h3>1. bridge（ブリッジ）ネットワーク</h3>
                    <p>
                        最も一般的なネットワークドライバーです。<code>docker run</code>でネットワークを指定しない場合、コンテナは自動的にbridgeネットワークに接続されます。
                    </p>

                    <h4>特徴</h4>
                    <ul>
                        <li>デフォルトで使用される</li>
                        <li>コンテナは独自のIPアドレスを取得</li>
                        <li>ポートマッピングで外部からアクセス可能</li>
                        <li>コンテナ間通信はIPアドレスで行う（コンテナ名では不可）</li>
                    </ul>

                    <pre class="code-block"><code class="language-bash"># デフォルトでbridgeネットワークに接続
docker run -d --name web nginx

# IPアドレスで通信（自動DNS解決なし）
docker run --rm alpine ping 172.17.0.2  # webコンテナのIP</code></pre>

                    <div class="warning">
                        <strong>制限：</strong>デフォルトのbridgeネットワークでは、コンテナ名によるDNS解決が使えません。カスタムブリッジネットワークの使用が推奨されます。
                    </div>

                    <h3>2. host ネットワーク</h3>
                    <p>
                        コンテナがホストのネットワークスタックを直接使用します。ネットワークの分離がなくなります。
                    </p>

                    <h4>特徴</h4>
                    <ul>
                        <li>ホストのネットワークインターフェースを直接使用</li>
                        <li>ポートマッピング不要</li>
                        <li>ネットワークパフォーマンスが最高</li>
                        <li>セキュリティ分離がない</li>
                    </ul>

                    <pre class="code-block"><code class="language-bash"># hostネットワークを使用
docker run -d --network host nginx

# コンテナはホストのポート80を直接使用（-pオプション不要）</code></pre>

                    <h3>3. none ネットワーク</h3>
                    <p>
                        ネットワーク機能を完全に無効化します。完全に隔離された環境が必要な場合に使用します。
                    </p>

                    <pre class="code-block"><code class="language-bash"># ネットワークなしでコンテナを起動
docker run -d --network none alpine

# コンテナは外部と通信できない</code></pre>

                    <h3>デフォルトネットワークの比較</h3>
                    <table class="table table-bordered">
                        <thead class="table-light">
                            <tr>
                                <th>ネットワーク</th>
                                <th>用途</th>
                                <th>DNS解決</th>
                                <th>分離</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>bridge</td>
                                <td>一般的な用途</td>
                                <td>×（IPのみ）</td>
                                <td>あり</td>
                            </tr>
                            <tr>
                                <td>host</td>
                                <td>最高性能が必要</td>
                                <td>N/A</td>
                                <td>なし</td>
                            </tr>
                            <tr>
                                <td>none</td>
                                <td>完全隔離</td>
                                <td>N/A</td>
                                <td>完全</td>
                            </tr>
                        </tbody>
                    </table>
                </section>

                <!-- カスタムネットワーク -->
                <section id="custom-networks">
                    <h2 class="section-title">カスタムブリッジネットワーク（推奨）</h2>

                    <h3>カスタムネットワークの利点</h3>
                    <p>
                        カスタムブリッジネットワークは、デフォルトのbridgeネットワークより多くの機能を提供します：
                    </p>
                    <ul>
                        <li><strong>自動DNS解決</strong>：コンテナ名で通信可能</li>
                        <li><strong>ネットワーク分離</strong>：異なるネットワーク間は通信できない</li>
                        <li><strong>動的な接続・切断</strong>：実行中のコンテナをネットワークに接続/切断可能</li>
                        <li><strong>設定可能</strong>：サブネット、IPレンジなどをカスタマイズ可能</li>
                    </ul>

                    <h3>カスタムネットワークの作成</h3>
                    <pre class="code-block"><code class="language-bash"># シンプルなネットワーク作成
docker network create my-network

# サブネットとゲートウェイを指定
docker network create \
  --driver bridge \
  --subnet 172.20.0.0/16 \
  --gateway 172.20.0.1 \
  my-custom-network

# ネットワーク一覧で確認
docker network ls</code></pre>

                    <h3>コンテナをカスタムネットワークに接続</h3>
                    <pre class="code-block"><code class="language-bash"># 起動時にネットワークを指定
docker run -d --name web --network my-network nginx
docker run -d --name api --network my-network python-app

# 実行中のコンテナをネットワークに接続
docker network connect my-network existing-container

# ネットワークから切断
docker network disconnect my-network existing-container</code></pre>

                    <h3>ネットワークの削除</h3>
                    <pre class="code-block"><code class="language-bash"># 特定のネットワークを削除
docker network rm my-network

# 使用されていないネットワークをすべて削除
docker network prune</code></pre>

                    <div class="warning">
                        <strong>注意：</strong>コンテナが接続されているネットワークは削除できません。先にコンテナを削除するか、ネットワークから切断する必要があります。
                    </div>
                </section>

                <!-- DNS解決 -->
                <section id="dns-resolution">
                    <h2 class="section-title">コンテナ名によるDNS解決</h2>

                    <h3>自動DNS解決の仕組み</h3>
                    <p>
                        カスタムブリッジネットワークでは、Dockerが内蔵DNSサーバーを提供し、<strong>コンテナ名</strong>を自動的にIPアドレスに解決します。これにより、IPアドレスを意識せずにコンテナ間通信ができます。
                    </p>

                    <div class="mermaid">
                        graph LR
                            A[Webコンテナ] -->|"db:5432 に接続"| B[Docker DNS]
                            B -->|IPアドレスを返す| A
                            A -->|実際の接続| C[DBコンテナ db]
                            style B fill:#e7f3ff
                    </div>

                    <h3>実践例</h3>
                    <pre class="code-block"><code class="language-bash"># カスタムネットワーク作成
docker network create app-network

# データベースコンテナを起動
docker run -d \
  --name postgres-db \
  --network app-network \
  -e POSTGRES_PASSWORD=secret \
  postgres

# Webアプリケーションコンテナを起動
docker run -d \
  --name web-app \
  --network app-network \
  -e DATABASE_URL=postgres://postgres:secret@postgres-db:5432/mydb \
  myapp

# webコンテナからDBコンテナにコンテナ名で接続できる！</code></pre>

                    <h3>DNS解決の確認</h3>
                    <pre class="code-block"><code class="language-bash"># webコンテナからpingを実行
docker exec web-app ping -c 2 postgres-db

# nslookupで名前解決を確認
docker exec web-app nslookup postgres-db</code></pre>

                    <h3>ネットワークエイリアス</h3>
                    <p>
                        1つのコンテナに複数の名前（エイリアス）を付けることができます。
                    </p>

                    <pre class="code-block"><code class="language-bash"># エイリアスを付けてコンテナを起動
docker run -d \
  --name postgres-db \
  --network app-network \
  --network-alias db \
  --network-alias database \
  postgres

# 'postgres-db', 'db', 'database' すべての名前で接続可能</code></pre>
                </section>

                <!-- ポートマッピング -->
                <section id="port-mapping">
                    <h2 class="section-title">ポートマッピングと外部公開</h2>

                    <h3>ポートマッピングの基本</h3>
                    <p>
                        コンテナのポートを外部（ホストマシン）に公開するには、<code>-p</code>オプションを使用します。
                    </p>

                    <pre class="code-block"><code class="language-bash"># 基本的なポートマッピング
docker run -d -p 8080:80 nginx
# ホストの8080番ポートをコンテナの80番ポートにマッピング

# 複数のポートをマッピング
docker run -d -p 8080:80 -p 8443:443 nginx

# ホストのIPを指定
docker run -d -p 127.0.0.1:8080:80 nginx

# ランダムなホストポートを割り当て
docker run -d -p 80 nginx
docker ps  # ホストポートを確認</code></pre>

                    <h3>ポートマッピングの確認</h3>
                    <pre class="code-block"><code class="language-bash"># コンテナのポートマッピングを確認
docker port container-name

# 出力例：
# 80/tcp -> 0.0.0.0:8080</code></pre>

                    <h3>EXPOSEとポートマッピングの違い</h3>
                    <div class="warning">
                        <strong>重要な違い：</strong>
                        <ul>
                            <li><code>EXPOSE</code>（Dockerfile）：ドキュメント目的、実際にポートは公開されない</li>
                            <li><code>-p</code>（docker run）：実際にホストのポートにマッピングして公開</li>
                        </ul>
                    </div>

                    <h3>ポート範囲のマッピング</h3>
                    <pre class="code-block"><code class="language-bash"># ポート範囲をマッピング
docker run -d -p 8000-8005:8000-8005 myapp</code></pre>
                </section>

                <!-- ネットワーク分離 -->
                <section id="network-isolation">
                    <h2 class="section-title">ネットワーク分離とセキュリティ</h2>

                    <h3>ネットワーク分離の重要性</h3>
                    <p>
                        異なるネットワークに接続されたコンテナは、デフォルトで互いに通信できません。これにより、セキュリティとアーキテクチャの明確化が実現できます。
                    </p>

                    <div class="mermaid">
                        graph TD
                            A[フロントエンドネットワーク] --> B[Webコンテナ]
                            A --> C[Nginxコンテナ]
                            D[バックエンドネットワーク] --> E[APIコンテナ]
                            D --> F[DBコンテナ]
                            B -.->|通信不可| E
                            B -.->|通信不可| F
                            C -.->|通信不可| F
                            style A fill:#e7f3ff
                            style D fill:#fff9e6
                    </div>

                    <h3>3層アーキテクチャでのネットワーク分離</h3>
                    <pre class="code-block"><code class="language-bash"># ネットワーク作成
docker network create frontend-net
docker network create backend-net

# フロントエンド（frontendネットワークのみ）
docker run -d --name web --network frontend-net nginx

# バックエンド（両方のネットワークに接続）
docker run -d --name api --network frontend-net python-app
docker network connect backend-net api

# データベース（backendネットワークのみ）
docker run -d --name db --network backend-net postgres

# 結果：
# - webはapiと通信可能
# - apiはdbと通信可能
# - webはdbと直接通信不可（セキュリティ向上）</code></pre>

                    <h3>ファイアウォールルール的なアプローチ</h3>
                    <p>
                        ネットワークを適切に分離することで、「必要最小限の通信のみを許可する」という最小権限の原則を実現できます。
                    </p>

                    <div class="highlight">
                        <h5>ベストプラクティス</h5>
                        <ul>
                            <li>公開されるサービス（Web）とデータベースを直接接続しない</li>
                            <li>APIレイヤーを中間に配置し、アクセス制御を行う</li>
                            <li>機密性の高いサービスは専用ネットワークに配置</li>
                            <li>必要な通信経路のみを明示的に設定</li>
                        </ul>
                    </div>
                </section>

                <!-- Docker Composeでのネットワーク -->
                <section id="compose-networks">
                    <h2 class="section-title">Docker Composeでのネットワーク管理</h2>

                    <h3>デフォルトネットワーク</h3>
                    <p>
                        Docker Composeは、デフォルトで1つのネットワークを作成し、すべてのサービスをそのネットワークに接続します。
                    </p>

                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  web:
    image: nginx
  api:
    image: myapi
  db:
    image: postgres

# 自動的に1つのネットワークが作成され、すべてのサービスが接続される
# web、api、db はすべて互いにコンテナ名で通信可能</code></pre>

                    <h3>カスタムネットワークの定義</h3>
                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  web:
    image: nginx
    networks:
      - frontend

  api:
    image: myapi
    networks:
      - frontend
      - backend

  db:
    image: postgres
    networks:
      - backend

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge</code></pre>

                    <h3>ネットワーク設定の詳細</h3>
                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  app:
    image: myapp
    networks:
      app-network:
        ipv4_address: 172.20.0.10  # 固定IPアドレス
        aliases:
          - app-server
          - application

networks:
  app-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
          gateway: 172.20.0.1</code></pre>

                    <h3>外部ネットワークの使用</h3>
                    <p>
                        既存のネットワーク（Docker Composeの外で作成されたもの）を使用する場合：
                    </p>

                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  app:
    image: myapp
    networks:
      - existing-network

networks:
  existing-network:
    external: true  # 外部で作成されたネットワークを使用</code></pre>

                    <pre class="code-block"><code class="language-bash"># 事前にネットワークを作成
docker network create existing-network

# Docker Composeを起動
docker compose up -d</code></pre>
                </section>

                <!-- 実践例 -->
                <section id="practical">
                    <h2 class="section-title">実践例：セキュアな3層アーキテクチャ</h2>

                    <h3>アーキテクチャ概要</h3>
                    <p>
                        フロントエンド、バックエンドAPI、データベースを適切にネットワーク分離した構成を構築します。
                    </p>

                    <pre class="code-block"><code class="language-yaml">version: '3.8'

services:
  # Nginx（リバースプロキシ）- 外部に公開
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    networks:
      - frontend
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro

  # Reactフロントエンド
  frontend:
    build: ./frontend
    networks:
      - frontend
    environment:
      - API_URL=http://api:8000

  # Node.js バックエンドAPI
  api:
    build: ./backend
    networks:
      - frontend  # nginxから接続を受ける
      - backend   # データベースに接続
    environment:
      - DATABASE_URL=postgres://user:pass@db:5432/mydb
      - REDIS_URL=redis://cache:6379

  # PostgreSQL データベース
  db:
    image: postgres:15-alpine
    networks:
      - backend  # バックエンドネットワークのみ
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: mydb
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # Redis キャッシュ
  cache:
    image: redis:7-alpine
    networks:
      - backend

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
    internal: true  # 外部からの接続を完全に遮断

volumes:
  postgres_data:</code></pre>

                    <div class="mermaid">
                        graph TD
                            A[インターネット] -->|:80,:443| B[Nginx]
                            B -->|frontend net| C[React Frontend]
                            B -->|frontend net| D[API Backend]
                            D -->|backend net| E[PostgreSQL]
                            D -->|backend net| F[Redis]
                            style B fill:#e7f3ff
                            style C fill:#e7f3ff
                            style D fill:#fff9e6
                            style E fill:#fff9e6
                            style F fill:#fff9e6
                    </div>

                    <h3>セキュリティのポイント</h3>
                    <ul>
                        <li><strong>外部公開の最小化</strong>：Nginxのみがポートを公開</li>
                        <li><strong>データベースの隔離</strong>：DBはbackendネットワークのみに接続</li>
                        <li><strong>内部ネットワーク</strong>：<code>internal: true</code>で外部からの接続を遮断</li>
                        <li><strong>明示的な通信経路</strong>：必要な接続のみを許可</li>
                    </ul>
                </section>

                <!-- 実習課題 -->
                <section id="exercises">
                    <h2 class="section-title">実習課題</h2>

                    <div class="exercise-container">
                        <h4>実習1：カスタムネットワークの作成と接続</h4>
                        <p><strong>目的：</strong>カスタムブリッジネットワークでコンテナ名によるDNS解決を体験する</p>

                        <p><strong>手順：</strong></p>
                        <ol>
                            <li>カスタムネットワーク<code>test-network</code>を作成</li>
                            <li>Nginxコンテナ（名前：web）を起動</li>
                            <li>Alpine Linuxコンテナを起動</li>
                            <li>AlpineコンテナからNginxコンテナに<code>ping web</code>で接続確認</li>
                            <li>コンテナ名でDNS解決されることを確認</li>
                        </ol>
                    </div>

                    <div class="exercise-container">
                        <h4>実習2：ネットワーク分離の実装</h4>
                        <p><strong>目的：</strong>複数のネットワークでコンテナを分離する</p>

                        <p><strong>手順：</strong></p>
                        <ol>
                            <li><code>frontend</code>と<code>backend</code>という2つのネットワークを作成</li>
                            <li>Webコンテナをfrontendネットワークに接続</li>
                            <li>APIコンテナを両方のネットワークに接続</li>
                            <li>DBコンテナをbackendネットワークのみに接続</li>
                            <li>Webコンテナから直接DBにアクセスできないことを確認</li>
                            <li>APIコンテナから両方にアクセスできることを確認</li>
                        </ol>
                    </div>

                    <div class="exercise-container">
                        <h4>実習3：Docker Composeでの複数ネットワーク構成</h4>
                        <p><strong>目的：</strong>docker-compose.ymlで複数ネットワークを定義する</p>

                        <p><strong>手順：</strong></p>
                        <ol>
                            <li>3層アーキテクチャ用のdocker-compose.ymlを作成</li>
                            <li>frontendとbackendの2つのネットワークを定義</li>
                            <li>各サービスを適切なネットワークに配置</li>
                            <li><code>docker compose up -d</code>で起動</li>
                            <li><code>docker network inspect</code>でネットワーク構成を確認</li>
                            <li>ログでサービス間の通信を確認</li>
                        </ol>
                    </div>
                </section>

                <!-- 理解度確認クイズ -->
                <section id="quiz">
                    <h2 class="section-title">理解度確認クイズ</h2>

                    <div class="quiz-container">
                        <h4>Q1: デフォルトネットワーク</h4>
                        <p><code>docker run</code>でネットワークを指定しない場合、どのネットワークに接続されますか？</p>
                        <ol type="a">
                            <li>host</li>
                            <li>none</li>
                            <li>bridge</li>
                            <li>custom</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer1">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer1">
                            <div class="alert alert-info">
                                <strong>答え：c) bridge</strong><br>
                                ネットワークを指定しない場合、コンテナはデフォルトの<code>bridge</code>ネットワークに接続されます。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q2: DNS解決</h4>
                        <p>コンテナ名でDNS解決ができるのはどのネットワークですか？</p>
                        <ol type="a">
                            <li>デフォルトのbridgeネットワーク</li>
                            <li>カスタムブリッジネットワーク</li>
                            <li>hostネットワーク</li>
                            <li>noneネットワーク</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer2">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer2">
                            <div class="alert alert-info">
                                <strong>答え：b) カスタムブリッジネットワーク</strong><br>
                                カスタムブリッジネットワークでは、Dockerが内蔵DNSサーバーを提供し、コンテナ名を自動的にIPアドレスに解決します。デフォルトのbridgeネットワークではこの機能は使えません。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q3: ポートマッピング</h4>
                        <p><code>docker run -p 8080:80 nginx</code>の意味として正しいものはどれですか？</p>
                        <ol type="a">
                            <li>コンテナの8080番ポートをホストの80番ポートにマッピング</li>
                            <li>ホストの8080番ポートをコンテナの80番ポートにマッピング</li>
                            <li>両方向に8080と80をマッピング</li>
                            <li>ポート80をブロック</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer3">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer3">
                            <div class="alert alert-info">
                                <strong>答え：b) ホストの8080番ポートをコンテナの80番ポートにマッピング</strong><br>
                                <code>-p</code>オプションの形式は<code>ホストポート:コンテナポート</code>です。この例では、ホストの8080にアクセスするとコンテナの80に転送されます。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q4: ネットワーク分離</h4>
                        <p>異なるネットワークに接続されたコンテナは、デフォルトで通信できますか？</p>
                        <ol type="a">
                            <li>はい、すべてのコンテナは通信可能</li>
                            <li>いいえ、通信できない</li>
                            <li>同じホスト上であれば通信可能</li>
                            <li>bridgeネットワークのみ通信可能</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer4">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer4">
                            <div class="alert alert-info">
                                <strong>答え：b) いいえ、通信できない</strong><br>
                                異なるネットワークに接続されたコンテナは、デフォルトで互いに通信できません。これがネットワーク分離の基本原則であり、セキュリティ向上に役立ちます。通信を許可するには、コンテナを両方のネットワークに接続する必要があります。
                            </div>
                        </div>
                    </div>

                    <div class="quiz-container">
                        <h4>Q5: Docker Composeのネットワーク</h4>
                        <p>Docker Composeでネットワークを明示的に定義しない場合、どうなりますか？</p>
                        <ol type="a">
                            <li>エラーになる</li>
                            <li>デフォルトのbridgeネットワークを使用</li>
                            <li>自動的に1つのカスタムネットワークが作成される</li>
                            <li>各サービスが独自のネットワークを持つ</li>
                        </ol>
                        <div class="collapse-trigger" data-bs-toggle="collapse" data-bs-target="#answer5">
                            <strong>解答を表示 ▼</strong>
                        </div>
                        <div class="collapse mt-2" id="answer5">
                            <div class="alert alert-info">
                                <strong>答え：c) 自動的に1つのカスタムネットワークが作成される</strong><br>
                                Docker Composeは、ネットワークを明示的に定義しない場合でも、自動的に1つのカスタムブリッジネットワーク（プロジェクト名_default）を作成し、すべてのサービスをそのネットワークに接続します。これにより、コンテナ名でDNS解決が使えます。
                            </div>
                        </div>
                    </div>
                </section>

                <!-- ナビゲーション -->
                <div class="chapter-nav">
                    <a href="docker-learning-material-06.html" class="btn btn-outline-primary">&larr; 前の章へ</a>
                    <a href="docker-learning-material-08.html" class="btn btn-primary">次の章へ &rarr;</a>
                </div>
            </main>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Highlight.js初期化 -->
    <script>
        hljs.highlightAll();
    </script>

    <!-- Mermaid初期化 -->
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>
